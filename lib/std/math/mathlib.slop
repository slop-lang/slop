;; ============================================================
;; Math Standard Library
;;
;; Common mathematical functions for SLOP.
;;
;; Provides:
;; - Integer operations (abs, sign, clamp, gcd, lcm)
;; - Float operations (abs-float, floor, ceil, round, trunc)
;; - Power and roots (sqrt, cbrt, pow, exp, log, log10, log2)
;; - Trigonometry (sin, cos, tan, asin, acos, atan, atan2)
;; - Hyperbolic (sinh, cosh, tanh)
;; - Constants (PI, E, TAU)
;; - Utilities (is-nan, is-inf, copysign)
;; ============================================================

(module mathlib
  (export
    ;; Constants
    PI E TAU
    ;; Integer operations
    abs sign clamp gcd lcm
    ;; Float operations
    abs-float floor ceil round trunc frac
    ;; Power and roots
    sqrt cbrt pow exp exp2 log log10 log2
    ;; Trigonometry
    sin cos tan asin acos atan atan2
    degrees-to-radians radians-to-degrees
    ;; Hyperbolic
    sinh cosh tanh
    ;; Utilities
    is-nan is-inf is-finite copysign
    lerp clamp-float)

  ;; ============================================================
  ;; FFI Declarations
  ;; ============================================================

  (ffi "math.h"
    ;; Basic operations
    (fabs ((x Float)) Float)
    (floor ((x Float)) Float)
    (ceil ((x Float)) Float)
    (round ((x Float)) Float)
    (trunc ((x Float)) Float)
    ;; Power and roots
    (sqrt ((x Float)) Float)
    (cbrt ((x Float)) Float)
    (pow ((x Float) (y Float)) Float)
    (exp ((x Float)) Float)
    (exp2 ((x Float)) Float)
    (log ((x Float)) Float)
    (log10 ((x Float)) Float)
    (log2 ((x Float)) Float)
    ;; Trigonometry
    (sin ((x Float)) Float)
    (cos ((x Float)) Float)
    (tan ((x Float)) Float)
    (asin ((x Float)) Float)
    (acos ((x Float)) Float)
    (atan ((x Float)) Float)
    (atan2 ((y Float) (x Float)) Float)
    ;; Hyperbolic
    (sinh ((x Float)) Float)
    (cosh ((x Float)) Float)
    (tanh ((x Float)) Float)
    ;; Utilities
    (isnan ((x Float)) Int)
    (isinf ((x Float)) Int)
    (isfinite ((x Float)) Int)
    (copysign ((x Float) (y Float)) Float)
    (fmod ((x Float) (y Float)) Float))

  ;; ============================================================
  ;; Constants
  ;; ============================================================

  (const PI Float 3.14159265358979323846)
  (const E Float 2.71828182845904523536)
  (const TAU Float 6.28318530717958647692)  ;; 2 * PI

  ;; ============================================================
  ;; Integer Operations
  ;; ============================================================

  (fn abs ((n Int))
    (@intent "Return absolute value of integer")
    (@spec ((Int) -> (Int 0 ..)))
    (@pure)
    (@post (>= $result 0))
    (@post (or (== $result n) (== $result (- 0 n))))
    (@example (5) -> 5)
    (@example (-5) -> 5)
    (@example (0) -> 0)
    (if (< n 0) (- 0 n) n))

  (fn sign ((n Int))
    (@intent "Return sign of integer: -1, 0, or 1")
    (@spec ((Int) -> (Int -1 .. 1)))
    (@pure)
    (@post (or (== $result -1) (== $result 0) (== $result 1)))
    (@example (42) -> 1)
    (@example (-42) -> -1)
    (@example (0) -> 0)
    (cond
      ((< n 0) -1)
      ((> n 0) 1)
      (else 0)))

  (fn clamp ((value Int) (min-val Int) (max-val Int))
    (@intent "Clamp integer to range [min-val, max-val]")
    (@spec ((Int Int Int) -> Int))
    (@pre (<= min-val max-val))
    (@post (>= $result min-val))
    (@post (<= $result max-val))
    (@pure)
    (@example (5 0 10) -> 5)
    (@example (-5 0 10) -> 0)
    (@example (15 0 10) -> 10)
    (cond
      ((< value min-val) min-val)
      ((> value max-val) max-val)
      (else value)))

  (fn gcd ((a Int) (b Int))
    (@intent "Compute greatest common divisor using Euclidean algorithm")
    (@spec ((Int Int) -> (Int 0 ..)))
    (@pure)
    (@post (>= $result 0))
    (@example (48 18) -> 6)
    (@example (17 13) -> 1)
    (@example (0 5) -> 5)
    (let ((x (abs a))
          (y (abs b)))
      (if (== y 0)
        x
        (let ((mut p x)
              (mut q y))
          (while (!= q 0)
            (let ((r (% p q)))
              (set! p q)
              (set! q r)))
          (cast (Int 0 ..) p)))))

  (fn lcm ((a Int) (b Int))
    (@intent "Compute least common multiple")
    (@spec ((Int Int) -> (Int 0 ..)))
    (@pure)
    (@post (>= $result 0))
    (@example (4 6) -> 12)
    (@example (3 5) -> 15)
    (@example (0 5) -> 0)
    (if (or (== a 0) (== b 0))
      0
      (let ((g (gcd a b)))
        (abs (* (/ a g) b)))))

  ;; ============================================================
  ;; Float Operations
  ;; ============================================================

  (fn abs-float ((x Float))
    (@intent "Return absolute value of float")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result 0.0))  ;; Trusted FFI behavior
    (@example (3.14) -> 3.14)
    (@example (-3.14) -> 3.14)
    (@example (0.0) -> 0.0)
    (fabs x))

  (fn floor ((x Float))
    (@intent "Round down to nearest integer")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (<= $result x))  ;; Trusted FFI behavior
    (@example (3.7) -> 3.0)
    (@example (-3.2) -> -4.0)
    (@example (5.0) -> 5.0)
    (floor x))

  (fn ceil ((x Float))
    (@intent "Round up to nearest integer")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result x))  ;; Trusted FFI behavior
    (@example (3.2) -> 4.0)
    (@example (-3.7) -> -3.0)
    (@example (5.0) -> 5.0)
    (ceil x))

  (fn round ((x Float))
    (@intent "Round to nearest integer (half away from zero)")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (3.5) -> 4.0)
    (@example (3.4) -> 3.0)
    (@example (-3.5) -> -4.0)
    (round x))

  (fn trunc ((x Float))
    (@intent "Truncate toward zero")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (3.7) -> 3.0)
    (@example (-3.7) -> -3.0)
    (trunc x))

  (fn frac ((x Float))
    (@intent "Return fractional part of float")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (3.14) -> 0.14)
    (@example (-3.14) -> -0.14)
    (- x (trunc x)))

  (fn clamp-float ((value Float) (min-val Float) (max-val Float))
    (@intent "Clamp float to range [min-val, max-val]")
    (@spec ((Float Float Float) -> Float))
    (@pre (<= min-val max-val))
    (@post (>= $result min-val))
    (@post (<= $result max-val))
    (@pure)
    (@example (0.5 0.0 1.0) -> 0.5)
    (@example (-0.5 0.0 1.0) -> 0.0)
    (@example (1.5 0.0 1.0) -> 1.0)
    (cond
      ((< value min-val) min-val)
      ((> value max-val) max-val)
      (else value)))

  ;; ============================================================
  ;; Power and Roots
  ;; ============================================================

  (fn sqrt ((x Float))
    (@intent "Compute square root")
    (@spec ((Float) -> Float))
    (@pre (>= x 0.0))
    (@assume (>= $result 0.0))  ;; Trusted FFI behavior
    (@pure)
    (@example (4.0) -> 2.0)
    (@example (9.0) -> 3.0)
    (@example (2.0) -> 1.41421356)
    (sqrt x))

  (fn cbrt ((x Float))
    (@intent "Compute cube root")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (8.0) -> 2.0)
    (@example (27.0) -> 3.0)
    (@example (-8.0) -> -2.0)
    (cbrt x))

  (fn pow ((base Float) (exponent Float))
    (@intent "Raise base to power of exponent")
    (@spec ((Float Float) -> Float))
    (@pure)
    (@example (2.0 3.0) -> 8.0)
    (@example (2.0 0.5) -> 1.41421356)
    (@example (10.0 -1.0) -> 0.1)
    (pow base exponent))

  (fn exp ((x Float))
    (@intent "Compute e^x (natural exponential)")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (> $result 0.0))  ;; Trusted FFI behavior
    (@example (0.0) -> 1.0)
    (@example (1.0) -> 2.71828182)
    (exp x))

  (fn exp2 ((x Float))
    (@intent "Compute 2^x")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (> $result 0.0))  ;; Trusted FFI behavior
    (@example (3.0) -> 8.0)
    (@example (0.0) -> 1.0)
    (exp2 x))

  (fn log ((x Float))
    (@intent "Compute natural logarithm (ln)")
    (@spec ((Float) -> Float))
    (@pre (> x 0.0))
    (@pure)
    (@example (1.0) -> 0.0)
    (@example (2.71828182) -> 1.0)
    (log x))

  (fn log10 ((x Float))
    (@intent "Compute base-10 logarithm")
    (@spec ((Float) -> Float))
    (@pre (> x 0.0))
    (@pure)
    (@example (10.0) -> 1.0)
    (@example (100.0) -> 2.0)
    (@example (1.0) -> 0.0)
    (log10 x))

  (fn log2 ((x Float))
    (@intent "Compute base-2 logarithm")
    (@spec ((Float) -> Float))
    (@pre (> x 0.0))
    (@pure)
    (@example (2.0) -> 1.0)
    (@example (8.0) -> 3.0)
    (@example (1.0) -> 0.0)
    (log2 x))

  ;; ============================================================
  ;; Trigonometry
  ;; ============================================================

  (fn sin ((x Float))
    (@intent "Compute sine (x in radians)")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result -1.0))  ;; Trusted FFI behavior
    (@assume (<= $result 1.0))
    (@example (0.0) -> 0.0)
    (sin x))

  (fn cos ((x Float))
    (@intent "Compute cosine (x in radians)")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result -1.0))  ;; Trusted FFI behavior
    (@assume (<= $result 1.0))
    (@example (0.0) -> 1.0)
    (cos x))

  (fn tan ((x Float))
    (@intent "Compute tangent (x in radians)")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (0.0) -> 0.0)
    (tan x))

  (fn asin ((x Float))
    (@intent "Compute arc sine, result in radians")
    (@spec ((Float) -> Float))
    (@pre (>= x -1.0))
    (@pre (<= x 1.0))
    (@pure)
    (@example (0.0) -> 0.0)
    (@example (1.0) -> 1.5707963)
    (asin x))

  (fn acos ((x Float))
    (@intent "Compute arc cosine, result in radians")
    (@spec ((Float) -> Float))
    (@pre (>= x -1.0))
    (@pre (<= x 1.0))
    (@assume (>= $result 0.0))  ;; Trusted FFI behavior
    (@pure)
    (@example (1.0) -> 0.0)
    (@example (0.0) -> 1.5707963)
    (acos x))

  (fn atan ((x Float))
    (@intent "Compute arc tangent, result in radians")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (0.0) -> 0.0)
    (@example (1.0) -> 0.7853981)
    (atan x))

  (fn atan2 ((y Float) (x Float))
    (@intent "Compute arc tangent of y/x using signs to determine quadrant")
    (@spec ((Float Float) -> Float))
    (@pure)
    (@example (1.0 1.0) -> 0.7853981)
    (@example (1.0 -1.0) -> 2.3561944)
    (atan2 y x))

  (fn degrees-to-radians ((degrees Float))
    (@intent "Convert degrees to radians")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (180.0) -> 3.14159265)
    (@example (90.0) -> 1.5707963)
    (@example (0.0) -> 0.0)
    (* degrees (/ PI 180.0)))

  (fn radians-to-degrees ((radians Float))
    (@intent "Convert radians to degrees")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (3.14159265) -> 180.0)
    (@example (1.5707963) -> 90.0)
    (@example (0.0) -> 0.0)
    (* radians (/ 180.0 PI)))

  ;; ============================================================
  ;; Hyperbolic Functions
  ;; ============================================================

  (fn sinh ((x Float))
    (@intent "Compute hyperbolic sine")
    (@spec ((Float) -> Float))
    (@pure)
    (@example (0.0) -> 0.0)
    (sinh x))

  (fn cosh ((x Float))
    (@intent "Compute hyperbolic cosine")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result 1.0))  ;; Trusted FFI behavior
    (@example (0.0) -> 1.0)
    (cosh x))

  (fn tanh ((x Float))
    (@intent "Compute hyperbolic tangent")
    (@spec ((Float) -> Float))
    (@pure)
    (@assume (>= $result -1.0))  ;; Trusted FFI behavior
    (@assume (<= $result 1.0))   ;; Trusted FFI behavior
    (@example (0.0) -> 0.0)
    (tanh x))

  ;; ============================================================
  ;; Utilities
  ;; ============================================================

  (fn is-nan ((x Float))
    (@intent "Check if float is NaN (not a number)")
    (@spec ((Float) -> Bool))
    (@pure)
    (!= (isnan x) 0))

  (fn is-inf ((x Float))
    (@intent "Check if float is infinite")
    (@spec ((Float) -> Bool))
    (@pure)
    (!= (isinf x) 0))

  (fn is-finite ((x Float))
    (@intent "Check if float is finite (not NaN or infinite)")
    (@spec ((Float) -> Bool))
    (@pure)
    (!= (isfinite x) 0))

  (fn copysign ((magnitude Float) (sign-val Float))
    (@intent "Return magnitude with sign of sign-val")
    (@spec ((Float Float) -> Float))
    (@pure)
    (@example (3.0 -1.0) -> -3.0)
    (@example (-3.0 1.0) -> 3.0)
    (copysign magnitude sign-val))

  (fn lerp ((a Float) (b Float) (t Float))
    (@intent "Linear interpolation between a and b by factor t")
    (@spec ((Float Float Float) -> Float))
    (@pre (>= t 0.0))
    (@pre (<= t 1.0))
    (@pure)
    (@example (0.0 10.0 0.5) -> 5.0)
    (@example (0.0 10.0 0.0) -> 0.0)
    (@example (0.0 10.0 1.0) -> 10.0)
    (+ a (* t (- b a))))
)
