;; ============================================================
;; SLOP Transpiler - Name Mangling
;;
;; Convert SLOP identifiers to valid C identifiers with proper
;; qualification and keyword escaping.
;; ============================================================

(module names
  (export
    to-c-name to-c-type-name
    to-qualified-name to-qualified-type-name
    make-type-c-name
    type-to-identifier
    is-c-keyword is-runtime-builtin)

  (import context (TranspileContext ctx-get-module ctx-lookup-import
                   ctx-get-prefixing))
  (import strlib (char-at))

  ;; ============================================================
  ;; Keyword and Builtin Checks
  ;;
  ;; NOTE: These use explicit cond chains because const (List String)
  ;; with list literals cannot be transpiled to C compile-time constants.
  ;; ============================================================

  ;; ============================================================
  ;; Basic Name Conversion
  ;; ============================================================

  (fn to-c-name ((arena Arena) (name String))
    (@intent "Convert SLOP identifier to valid C identifier")
    (@spec ((Arena String) -> String))
    (@pure)
    (@pre (> (string-len name) 0))
    (@post (> (string-len $result) 0))
    ;; Conversion rules:
    ;; - Replace '-' with '_'
    ;; - Replace '?' with '_p' (predicate suffix)
    ;; - Replace '!' with '_x' (mutation suffix)
    ;; - Replace '$' with '_'
    ;; - Replace '@' with '_at_'
    ;; - Prepend 'slop_' if result is a C keyword
    (let ((len (cast Int (string-len name)))
          (mut i 0)
          (buf (arena-alloc arena (* len 5)))
          (mut out-idx 0))
        (while (< i len)
          (let ((c (cast Int (@ (. name data) i))))
            (cond
              ;; Replace - with _
              ((== c 45)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Replace ? with _p
              ((== c 63)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 112))
                   (set! out-idx (+ out-idx 2))))
              ;; Replace ! with _x
              ((== c 33)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 120))
                   (set! out-idx (+ out-idx 2))))
              ;; Replace $ with _
              ((== c 36)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Replace @ with _at_
              ((== c 64)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 97))
                   (set! (@ buf (+ out-idx 2)) (cast U8 116))
                   (set! (@ buf (+ out-idx 3)) (cast U8 95))
                   (set! out-idx (+ out-idx 4))))
              ;; Keep other characters
              (else
               (do (set! (@ buf out-idx) (cast U8 c))
                   (set! out-idx (+ out-idx 1))))))
          (set! i (+ i 1)))
        (let ((mangled (String (cast (Ptr U8) buf) (cast U64 out-idx))))
          (if (is-c-keyword mangled)
            (string-concat arena "slop_" mangled)
            mangled))))

  (fn to-c-type-name ((arena Arena) (name String))
    (@intent "Convert SLOP type name to C type name")
    (@spec ((Arena String) -> String))
    (@pure)
    (@pre (> (string-len name) 0))
    ;; Same rules as to-c-name but for types
    (to-c-name arena name))

  ;; ============================================================
  ;; Qualified Name Conversion
  ;; ============================================================

  (fn to-qualified-name ((arena Arena) (ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert function name to qualified C name with module prefix")
    (@spec ((Arena (Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (@pre (> (string-len name) 0))
    (@pure)
    ;; Rules (in order):
    ;; 1. "main" is never prefixed
    ;; 2. Runtime builtins are never prefixed
    ;; 3. Check import map for explicit qualification
    ;; 4. If prefixing enabled and in module, prefix with module_
    ;; 5. Otherwise use base name
    (let ((base-name (to-c-name arena name)))
      (cond
        ;; 1. main is never prefixed
        ((string-eq name "main") base-name)
        ;; 2. Runtime builtins are never prefixed
        ((is-runtime-builtin name) base-name)
        ;; 3. Check import map for explicit qualification
        (else
         (match (ctx-lookup-import ctx name)
           ((some qualified) qualified)
           ((none)
            ;; 4. If prefixing enabled and in module, prefix with module_
            (if (ctx-get-prefixing ctx)
              (match (ctx-get-module ctx)
                ((some mod-name)
                 (string-concat arena (string-concat arena (to-c-name arena mod-name) "_") base-name))
                ((none) base-name))
              ;; 5. Otherwise use base name
              base-name)))))))

  (fn to-qualified-type-name ((arena Arena) (ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert type name to qualified C type name with module prefix")
    (@spec ((Arena (Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (@pre (> (string-len name) 0))
    (@pure)
    ;; Similar to to-qualified-name but for types
    ;; Built-in types (Int, Bool, String, etc.) are never prefixed
    (let ((base-name (to-c-type-name arena name)))
      ;; Built-in types are never prefixed
      (cond
        ((string-eq name "Int") base-name)
        ((string-eq name "Bool") base-name)
        ((string-eq name "String") base-name)
        ((string-eq name "Float") base-name)
        ((string-eq name "Char") base-name)
        ((string-eq name "Unit") base-name)
        ((string-eq name "U8") base-name)
        ((string-eq name "U16") base-name)
        ((string-eq name "U32") base-name)
        ((string-eq name "U64") base-name)
        ((string-eq name "I8") base-name)
        ((string-eq name "I16") base-name)
        ((string-eq name "I32") base-name)
        ((string-eq name "I64") base-name)
        ((string-eq name "Arena") base-name)
        ((string-eq name "Ptr") base-name)
        ((string-eq name "Void") base-name)
        (else
         ;; First check if this is an imported type - use its qualified name
         (match (ctx-lookup-import ctx name)
           ((some qualified) qualified)
           ((none)
             ;; If prefixing enabled and in module, prefix with current module_
             (if (ctx-get-prefixing ctx)
               (match (ctx-get-module ctx)
                 ((some mod-name)
                  (string-concat arena (string-concat arena (to-c-type-name arena mod-name) "_") base-name))
                 ((none) base-name))
               base-name)))))))

  (fn make-type-c-name ((arena Arena) (type-name String) (mod-name String))
    (@intent "Compute qualified C type name directly from module name (for type definitions)")
    (@spec ((Arena String String) -> String))
    (@pure)
    (@pre (> (string-len type-name) 0))
    (@pre (> (string-len mod-name) 0))
    ;; For defining a type, we compute mod_name directly without checking import map
    (let ((base-name (to-c-type-name arena type-name))
          (mod-c-name (to-c-type-name arena mod-name)))
      (string-concat arena mod-c-name (string-concat arena "_" base-name))))

  ;; ============================================================
  ;; Type to Identifier Conversion
  ;; ============================================================

  (fn type-to-identifier ((arena Arena) (c-type String))
    (@intent "Convert C type to valid identifier component for generated types")
    (@spec ((Arena String) -> String))
    (@pure)
    (@pre (> (string-len c-type) 0))
    ;; Examples that return string literals (normalized types):
    (@example "int64_t" -> "int")
    (@example "uint8_t" -> "u8")
    (@example "slop_string" -> "string")
    (@example "char*" -> "string")
    ;; Used for generating names like slop_option_string, slop_list_int
    ;; Rules:
    ;; - Replace '*' with '_ptr'
    ;; - Strip 'slop_' prefix if present
    ;; - Normalize: int64_t -> int, uint8_t -> u8, etc.
    ;; - Replace spaces with '_'
    (let ((len (cast Int (string-len c-type)))
          (buf (arena-alloc arena (* len 4)))
          (mut i 0)
          (mut out-idx 0))
        ;; First pass: character replacements
        (while (< i len)
          (let ((c (cast Int (@ (. c-type data) i))))
            (cond
              ;; Replace * with _ptr
              ((== c 42)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 112))
                   (set! (@ buf (+ out-idx 2)) (cast U8 116))
                   (set! (@ buf (+ out-idx 3)) (cast U8 114))
                   (set! out-idx (+ out-idx 4))))
              ;; Replace space with _
              ((== c 32)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Keep other chars
              (else
               (do (set! (@ buf out-idx) (cast U8 c))
                   (set! out-idx (+ out-idx 1))))))
          (set! i (+ i 1)))
        (let ((temp (String (cast (Ptr U8) buf) (cast U64 out-idx))))
          ;; Strip slop_ prefix if present (5 chars)
          (let ((result
                 (if (and (>= out-idx 5)
                          (== (@ buf 0) (cast U8 115))
                          (== (@ buf 1) (cast U8 108))
                          (== (@ buf 2) (cast U8 111))
                          (== (@ buf 3) (cast U8 112))
                          (== (@ buf 4) (cast U8 95)))
                   (String (cast (Ptr U8) (+ buf 5)) (cast U64 (- out-idx 5)))
                   temp)))
            ;; Check for C type normalizations
            (cond
              ((string-eq result "int64_t") "int")
              ((string-eq result "int32_t") "int")
              ((string-eq result "uint8_t") "u8")
              ((string-eq result "uint16_t") "u16")
              ((string-eq result "uint32_t") "u32")
              ((string-eq result "uint64_t") "u64")
              ((string-eq result "int8_t") "i8")
              ((string-eq result "int16_t") "i16")
              ((string-eq result "char_ptr") "string")
              (else result))))))

  (fn is-c-keyword ((name String))
    (@intent "Check if name is a C reserved keyword")
    (@spec ((String) -> Bool))
    (@pure)
    (@example "int" -> true)
    (@example "double" -> true)
    (@example "void" -> true)
    (@example "foo" -> false)
    (@example "my_var" -> false)
    ;; Explicit checks for C keywords (no list iteration)
    (cond
      ((string-eq name "auto") true)
      ((string-eq name "break") true)
      ((string-eq name "case") true)
      ((string-eq name "char") true)
      ((string-eq name "const") true)
      ((string-eq name "continue") true)
      ((string-eq name "default") true)
      ((string-eq name "do") true)
      ((string-eq name "double") true)
      ((string-eq name "else") true)
      ((string-eq name "enum") true)
      ((string-eq name "extern") true)
      ((string-eq name "float") true)
      ((string-eq name "for") true)
      ((string-eq name "goto") true)
      ((string-eq name "if") true)
      ((string-eq name "int") true)
      ((string-eq name "long") true)
      ((string-eq name "register") true)
      ((string-eq name "return") true)
      ((string-eq name "short") true)
      ((string-eq name "signed") true)
      ((string-eq name "sizeof") true)
      ((string-eq name "static") true)
      ((string-eq name "struct") true)
      ((string-eq name "switch") true)
      ((string-eq name "typedef") true)
      ((string-eq name "union") true)
      ((string-eq name "unsigned") true)
      ((string-eq name "void") true)
      ((string-eq name "volatile") true)
      ((string-eq name "while") true)
      ((string-eq name "inline") true)
      ((string-eq name "restrict") true)
      ((string-eq name "_Bool") true)
      ((string-eq name "_Complex") true)
      ((string-eq name "_Imaginary") true)
      (else false)))

  (fn is-runtime-builtin ((name String))
    (@intent "Check if name is a runtime builtin function")
    (@spec ((String) -> Bool))
    (@pure)
    (@example "print" -> true)
    (@example "println" -> true)
    (@example "string-len" -> true)
    (@example "list-push" -> true)
    (@example "my-func" -> false)
    (@example "foo" -> false)
    ;; Explicit checks for runtime builtins (no list iteration)
    (cond
      ((string-eq name "print") true)
      ((string-eq name "println") true)
      ((string-eq name "string-len") true)
      ((string-eq name "string-concat") true)
      ((string-eq name "string-eq") true)
      ((string-eq name "string-slice") true)
      ((string-eq name "int-to-string") true)
      ((string-eq name "float-to-string") true)
      ((string-eq name "arena-alloc") true)
      ((string-eq name "with-arena") true)
      ((string-eq name "list-new") true)
      ((string-eq name "list-push") true)
      ((string-eq name "list-pop") true)
      ((string-eq name "list-get") true)
      ((string-eq name "list-len") true)
      ((string-eq name "list-set") true)
      ((string-eq name "map-new") true)
      ((string-eq name "map-put") true)
      ((string-eq name "map-get") true)
      ((string-eq name "map-has") true)
      ((string-eq name "map-del") true)
      ((string-eq name "is-ok") true)
      ((string-eq name "is-err") true)
      ((string-eq name "unwrap") true)
      ((string-eq name "unwrap-err") true)
      ((string-eq name "is-some") true)
      ((string-eq name "is-none") true)
      ((string-eq name "now-ms") true)
      ((string-eq name "sleep-ms") true)
      ((string-eq name "assert") true)
      ((string-eq name "panic") true)
      (else false)))
)
