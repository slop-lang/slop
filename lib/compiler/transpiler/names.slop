;; ============================================================
;; SLOP Transpiler - Name Mangling
;;
;; Convert SLOP identifiers to valid C identifiers with proper
;; qualification and keyword escaping.
;; ============================================================

(module names
  (export
    to-c-name to-c-type-name
    to-qualified-name to-qualified-type-name
    type-to-identifier
    is-c-keyword is-runtime-builtin)

  (import context (TranspileContext ctx-get-module ctx-lookup-import
                   ctx-get-prefixing))
  (import strlib (string-eq string-concat string-char-at string-len))

  ;; ============================================================
  ;; C Reserved Keywords
  ;; ============================================================

  ;; Keywords that must be prefixed with slop_ to avoid conflicts
  (const C_KEYWORDS (List String)
    (list "auto" "break" "case" "char" "const" "continue" "default"
          "do" "double" "else" "enum" "extern" "float" "for" "goto"
          "if" "int" "long" "register" "return" "short" "signed"
          "sizeof" "static" "struct" "switch" "typedef" "union"
          "unsigned" "void" "volatile" "while" "inline" "restrict"
          "_Bool" "_Complex" "_Imaginary"))

  ;; ============================================================
  ;; Runtime Builtin Functions
  ;; ============================================================

  ;; Functions defined in slop_runtime.h - never prefixed
  (const RUNTIME_BUILTINS (List String)
    (list "print" "println" "string-len" "string-concat" "string-eq"
          "string-slice" "int-to-string" "float-to-string"
          "arena-alloc" "with-arena"
          "list-new" "list-push" "list-pop" "list-get" "list-len" "list-set"
          "map-new" "map-put" "map-get" "map-has" "map-del"
          "is-ok" "is-err" "unwrap" "unwrap-err"
          "is-some" "is-none"
          "now-ms" "sleep-ms"
          "assert" "panic"))

  ;; ============================================================
  ;; Basic Name Conversion
  ;; ============================================================

  (fn to-c-name ((name String))
    (@intent "Convert SLOP identifier to valid C identifier")
    (@spec ((String) -> String))
    (@pure)
    (@pre (> (string-len name) 0))
    (@post (> (string-len $result) 0))
    ;; Conversion rules:
    ;; - Replace '-' with '_'
    ;; - Replace '?' with '_p' (predicate suffix)
    ;; - Replace '!' with '_x' (mutation suffix)
    ;; - Replace '$' with '_'
    ;; - Replace '@' with '_at_'
    ;; - Prepend 'slop_' if result is a C keyword
    (with-arena 512
      (let ((len (cast Int (string-len name)))
            (mut i 0)
            (buf (arena-alloc arena (* len 5)))
            (mut out-idx 0))
        (while (< i len)
          (let ((c (cast Int (@ (. name data) i))))
            (cond
              ;; Replace - with _
              ((== c 45)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Replace ? with _p
              ((== c 63)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 112))
                   (set! out-idx (+ out-idx 2))))
              ;; Replace ! with _x
              ((== c 33)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 120))
                   (set! out-idx (+ out-idx 2))))
              ;; Replace $ with _
              ((== c 36)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Replace @ with _at_
              ((== c 64)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 97))
                   (set! (@ buf (+ out-idx 2)) (cast U8 116))
                   (set! (@ buf (+ out-idx 3)) (cast U8 95))
                   (set! out-idx (+ out-idx 4))))
              ;; Keep other characters
              (else
               (do (set! (@ buf out-idx) (cast U8 c))
                   (set! out-idx (+ out-idx 1))))))
          (set! i (+ i 1)))
        (let ((mangled (String (cast (Ptr U8) buf) (cast U64 out-idx))))
          (if (is-c-keyword mangled)
            (string-concat arena "slop_" mangled)
            mangled)))))

  (fn to-c-type-name ((name String))
    (@intent "Convert SLOP type name to C type name")
    (@spec ((String) -> String))
    (@pure)
    (@pre (> (string-len name) 0))
    ;; Same rules as to-c-name but for types
    (to-c-name name))

  ;; ============================================================
  ;; Qualified Name Conversion
  ;; ============================================================

  (fn to-qualified-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert function name to qualified C name with module prefix")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (@pre (> (string-len name) 0))
    (@pure)
    ;; Rules (in order):
    ;; 1. "main" is never prefixed
    ;; 2. Runtime builtins are never prefixed
    ;; 3. Check import map for explicit qualification
    ;; 4. If prefixing enabled and in module, prefix with module_
    ;; 5. Otherwise use base name
    (with-arena 256
      (let ((base-name (to-c-name name)))
        (cond
          ;; 1. main is never prefixed
          ((string-eq name "main") base-name)
          ;; 2. Runtime builtins are never prefixed
          ((is-runtime-builtin name) base-name)
          ;; 3. Check import map for explicit qualification
          (else
           (match (ctx-lookup-import ctx name)
             ((some qualified) qualified)
             ((none)
              ;; 4. If prefixing enabled and in module, prefix with module_
              (if (ctx-get-prefixing ctx)
                (match (ctx-get-module ctx)
                  ((some mod-name)
                   (string-concat arena (string-concat arena (to-c-name mod-name) "_") base-name))
                  ((none) base-name))
                ;; 5. Otherwise use base name
                base-name))))))))

  (fn to-qualified-type-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert type name to qualified C type name with module prefix")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (@pre (> (string-len name) 0))
    (@pure)
    ;; Similar to to-qualified-name but for types
    ;; Built-in types (Int, Bool, String, etc.) are never prefixed
    (with-arena 256
      (let ((base-name (to-c-type-name name)))
        ;; Built-in types are never prefixed
        (cond
          ((string-eq name "Int") base-name)
          ((string-eq name "Bool") base-name)
          ((string-eq name "String") base-name)
          ((string-eq name "Float") base-name)
          ((string-eq name "Char") base-name)
          ((string-eq name "Unit") base-name)
          ((string-eq name "U8") base-name)
          ((string-eq name "U16") base-name)
          ((string-eq name "U32") base-name)
          ((string-eq name "U64") base-name)
          ((string-eq name "I8") base-name)
          ((string-eq name "I16") base-name)
          ((string-eq name "I32") base-name)
          ((string-eq name "I64") base-name)
          ((string-eq name "Arena") base-name)
          ((string-eq name "Ptr") base-name)
          ((string-eq name "Void") base-name)
          (else
           ;; If prefixing enabled and in module, prefix with module_
           (if (ctx-get-prefixing ctx)
             (match (ctx-get-module ctx)
               ((some mod-name)
                (string-concat arena (string-concat arena (to-c-type-name mod-name) "_") base-name))
               ((none) base-name))
             base-name))))))

  ;; ============================================================
  ;; Type to Identifier Conversion
  ;; ============================================================

  (fn type-to-identifier ((c-type String))
    (@intent "Convert C type to valid identifier component for generated types")
    (@spec ((String) -> String))
    (@pure)
    (@pre (> (string-len c-type) 0))
    ;; Used for generating names like slop_option_string, slop_list_int
    ;; Rules:
    ;; - Replace '*' with '_ptr'
    ;; - Strip 'slop_' prefix if present
    ;; - Normalize: int64_t -> int, uint8_t -> u8, etc.
    ;; - Replace spaces with '_'
    (with-arena 256
      (let ((len (cast Int (string-len c-type)))
            (buf (arena-alloc arena (* len 4)))
            (mut i 0)
            (mut out-idx 0))
        ;; First pass: character replacements
        (while (< i len)
          (let ((c (cast Int (@ (. c-type data) i))))
            (cond
              ;; Replace * with _ptr
              ((== c 42)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! (@ buf (+ out-idx 1)) (cast U8 112))
                   (set! (@ buf (+ out-idx 2)) (cast U8 116))
                   (set! (@ buf (+ out-idx 3)) (cast U8 114))
                   (set! out-idx (+ out-idx 4))))
              ;; Replace space with _
              ((== c 32)
               (do (set! (@ buf out-idx) (cast U8 95))
                   (set! out-idx (+ out-idx 1))))
              ;; Keep other chars
              (else
               (do (set! (@ buf out-idx) (cast U8 c))
                   (set! out-idx (+ out-idx 1))))))
          (set! i (+ i 1)))
        (let ((temp (String (cast (Ptr U8) buf) (cast U64 out-idx))))
          ;; Strip slop_ prefix if present (5 chars)
          (let ((result
                 (if (and (>= out-idx 5)
                          (== (@ buf 0) (cast U8 115))
                          (== (@ buf 1) (cast U8 108))
                          (== (@ buf 2) (cast U8 111))
                          (== (@ buf 3) (cast U8 112))
                          (== (@ buf 4) (cast U8 95)))
                   (String (cast (Ptr U8) (+ buf 5)) (cast U64 (- out-idx 5)))
                   temp)))
            ;; Check for C type normalizations
            (cond
              ((string-eq result "int64_t") "int")
              ((string-eq result "int32_t") "int")
              ((string-eq result "uint8_t") "u8")
              ((string-eq result "uint16_t") "u16")
              ((string-eq result "uint32_t") "u32")
              ((string-eq result "uint64_t") "u64")
              ((string-eq result "int8_t") "i8")
              ((string-eq result "int16_t") "i16")
              ((string-eq result "char_ptr") "string")
              (else result)))))))

  ;; ============================================================
  ;; Keyword and Builtin Checks
  ;; ============================================================

  (fn is-c-keyword ((name String))
    (@intent "Check if name is a C reserved keyword")
    (@spec ((String) -> Bool))
    (@pure)
    (let ((mut i 0)
          (len (cast Int (list-len C_KEYWORDS))))
      (while (< i len)
        (match (list-get C_KEYWORDS i)
          ((some kw) (when (string-eq kw name) (return true)))
          ((none) ()))
        (set! i (+ i 1)))
      false))

  (fn is-runtime-builtin ((name String))
    (@intent "Check if name is a runtime builtin function")
    (@spec ((String) -> Bool))
    (@pure)
    (let ((mut i 0)
          (len (cast Int (list-len RUNTIME_BUILTINS))))
      (while (< i len)
        (match (list-get RUNTIME_BUILTINS i)
          ((some builtin) (when (string-eq builtin name) (return true)))
          ((none) ()))
        (set! i (+ i 1)))
      false))
)
