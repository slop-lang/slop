;; ============================================================
;; SLOP Native Transpiler - Expression Module
;;
;; Transpiles SLOP expressions to C code.
;; ============================================================

(module expr
  (export
    ;; Main entry point
    transpile-expr
    ;; Helpers
    transpile-literal transpile-symbol
    transpile-call transpile-binop
    ;; Operator helpers
    is-binop is-unop is-comparison-op
    ;; Type inference
    infer-expr-c-type infer-option-inner-slop-type infer-expr-slop-type
    ;; Collection/Result type inference helpers
    infer-collection-element-slop-type infer-result-ok-slop-type infer-result-err-slop-type
    c-type-to-option-type-name)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import context (TranspileContext ctx-lookup-var ctx-lookup-func ctx-lookup-type ctx-lookup-enum-variant
                   ctx-get-current-result-type ctx-get-current-return-type ctx-prefixing-enabled ctx-prefix-type ctx-get-module
                   ctx-str ctx-str3 ctx-str4 ctx-str5 VarEntry FuncEntry FuncParamType TypeEntry
                   to-c-type-prefixed ctx-push-scope ctx-pop-scope ctx-bind-var
                   ctx-lookup-field-type-by-index ctx-lookup-field-type ctx-lookup-field-slop-type ctx-register-option-type
                   ctx-register-struct-key-type ctx-has-struct-key-type ctx-lookup-type-alias
                   ctx-add-error-at ctx-sexpr-line ctx-sexpr-col ctx-list-first-line ctx-list-first-col
                   ctx-gensym ctx-add-deferred-lambda ctx-emit ctx-indent ctx-dedent ctx-get-output
                   LastLambdaInfo ctx-set-last-lambda-info ctx-get-last-lambda-info ctx-clear-last-lambda-info
                   ctx-warn-fallback
                   ctx-register-generic-instantiation ctx-has-generic-instantiation mangle-generic-fn-name))
  (import ctype (to-c-type to-c-name type-to-identifier sexpr-to-type-string
                 get-node-resolved-type resolved-type-to-c))
  (import strlib (replace starts-with ends-with substring char-at count-occurrences index-of contains))

  ;; ============================================================
  ;; String Escaping for C
  ;; ============================================================

  (fn escape-c-string ((ctx (Ptr TranspileContext)) (s String))
    (@intent "Escape string for C string literal")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (. s len)))
          (data (. s data)))
      ;; Calculate output size (worst case: every char needs escaping)
      (let ((buf (arena-alloc arena (+ (* len 2) 1)))
            (mut out-pos 0)
            (mut in-pos 0))
        (while (< in-pos len)
          (let ((c (cast Int (@ data in-pos))))
            (cond
              ((== c 10)  ;; \n
                (set! (@ buf out-pos) 92)       ;; backslash
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 110)      ;; n
                (set! out-pos (+ out-pos 1)))
              ((== c 13)  ;; \r
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 114)      ;; r
                (set! out-pos (+ out-pos 1)))
              ((== c 9)   ;; \t
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 116)      ;; t
                (set! out-pos (+ out-pos 1)))
              ((== c 92)  ;; backslash -> \\
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1)))
              ((== c 34)  ;; quote -> \"
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 34)
                (set! out-pos (+ out-pos 1)))
              (else
                (set! (@ buf out-pos) (cast U8 c))
                (set! out-pos (+ out-pos 1)))))
          (set! in-pos (+ in-pos 1)))
        (set! (@ buf out-pos) 0)  ;; null terminate
        (String buf (cast U64 out-pos)))))

  ;; ============================================================
  ;; Arena Alloc NULL Check Wrapper
  ;; ============================================================

  (fn wrap-arena-alloc-checked ((ctx (Ptr TranspileContext)) (alloc-expr String))
    (@intent "Wrap arena alloc expression with NULL check and abort")
    (@spec (((Ptr TranspileContext) String) -> String))
    (let ((prefix (ctx-str ctx "({ __auto_type _alloc = " alloc-expr))
          (suffix "; if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })"))
      (ctx-str ctx prefix suffix)))

  ;; ============================================================
  ;; Operator Classification
  ;; ============================================================

  (fn is-binop ((op String))
    (@intent "Check if operator is a binary operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "+")
        (string-eq op "-")
        (string-eq op "*")
        (string-eq op "/")
        (string-eq op "%")
        (string-eq op "and")
        (string-eq op "or")
        (string-eq op "bit-and")
        (string-eq op "bit-or")
        (string-eq op "bit-xor")
        (string-eq op "&")
        (string-eq op "|")
        (string-eq op "^")
        (string-eq op "<<")
        (string-eq op ">>")))

  (fn is-comparison-op ((op String))
    (@intent "Check if operator is a comparison operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "==")
        (string-eq op "=")
        (string-eq op "!=")
        (string-eq op "<")
        (string-eq op ">")
        (string-eq op "<=")
        (string-eq op ">=")))

  (fn is-unop ((op String))
    (@intent "Check if operator is a unary operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "not")
        (string-eq op "bit-not")
        (string-eq op "-")))

  ;; ============================================================
  ;; Symbol Name Extraction
  ;; ============================================================

  (fn extract-symbol-name ((expr (Ptr SExpr)))
    (@intent "Extract symbol name from either bare symbol or (quote symbol)")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {expr != nil})
    (match (deref expr)
      ;; Direct symbol: just return the name
      ((sym sym) (some (. sym name)))
      ;; List form: check for (quote symbol)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym head-sym)
                    (if (string-eq (. head-sym name) "quote")
                      ;; It's a quote form - extract the inner symbol
                      (match (list-get items 1)
                        ((some inner)
                          (match (deref inner)
                            ((sym inner-sym) (some (. inner-sym name)))
                            (else none)))
                        ((none) none))
                      none))
                  (else none)))
              ((none) none)))))
      (else none)))

  ;; ============================================================
  ;; Literal Transpilation
  ;; ============================================================

  (fn transpile-literal ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a literal expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((num num)
        (if (. num is-float)
          (. num raw)  ;; Use raw string representation
          (. num raw)))
      ((str str)
        ;; Wrap in SLOP_STR macro with escaped string
        (ctx-str3 ctx "SLOP_STR(\"" (escape-c-string ctx (. str value)) "\")"))
      ((sym sym)
        (transpile-symbol ctx (. sym name)))
      ((lst _)
        "/* error: list is not a literal */")))

  (fn transpile-symbol ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Transpile a symbol to C code")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ;; Boolean literals
        ((string-eq name "true") "1")
        ((string-eq name "false") "0")
        ;; Null pointer
        ((string-eq name "nil") "NULL")
        ;; None literal - use runtime macro
        ((string-eq name "none") "none")
        ;; Unit literal - used for Result Unit E types
        ((string-eq name "unit") "0")
        ;; Quoted symbols for enum values: 'read -> file_FileMode_read
        ((starts-with name "'")
          (let ((name-len (string-len name))
                (variant-name (substring arena name 1 (cast (Int 0 ..) (- name-len 1)))))
            (match (ctx-lookup-enum-variant ctx variant-name)
              ((some enum-name)
                ;; Return prefixed enum constant
                (get-prefixed-enum-value ctx enum-name variant-name))
              ((none)
                ;; Fallback - just strip quote and convert
                (to-c-name arena variant-name)))))
        ;; Dot notation: either field access (var.field) or enum (Type.variant)
        ((contains name ".")
          (match (index-of name ".")
            ((some dot-pos)
              (let ((base-name (substring arena name 0 dot-pos))
                    (rest-len (cast (Int 0 ..) (- (string-len name) (+ dot-pos 1))))
                    (rest-name (substring arena name (+ dot-pos 1) rest-len))
                    ;; Convert rest to C name (hyphen to underscore)
                    (c-rest (to-c-name arena rest-name)))
                ;; First check if base is a variable (field access)
                (match (ctx-lookup-var ctx base-name)
                  ((some var-entry)
                    ;; Field access: use -> if pointer, . otherwise
                    (let ((c-base (. var-entry c-name))
                          (is-ptr (. var-entry is-pointer))
                          (accessor (if is-ptr "->" ".")))
                      (ctx-str3 ctx c-base accessor c-rest)))
                  ((none)
                    ;; Not a variable - check if it's enum dot notation
                    (match (ctx-lookup-type ctx base-name)
                      ((some type-info)
                        (get-prefixed-enum-value ctx (. type-info c-name) rest-name))
                      ((none)
                        ;; Fallback: assume base_rest format
                        (ctx-str3 ctx base-name "_" c-rest)))))))
            ((none) (to-c-name arena name))))
        ;; Variable/constant lookup - check context first
        (else
          (match (ctx-lookup-var ctx name)
            ;; Found in context - use registered c-name
            ((some entry) (. entry c-name))
            ;; Not found - check if it's an enum variant
            ((none)
              (match (ctx-lookup-enum-variant ctx name)
                ((some enum-name)
                  (get-prefixed-enum-value ctx enum-name name))
                ((none)
                  ;; Check if it's a registered function (for function references)
                  (let ((c-name (to-c-name arena name)))
                    (match (ctx-lookup-func ctx name)
                      ((some func-entry)
                        ;; Use the registered c-name which includes module prefix
                        (. func-entry c-name))
                      ((none) c-name)))))))))))

  (fn get-prefixed-enum-value ((ctx (Ptr TranspileContext)) (enum-name String) (variant-name String))
    (@intent "Get fully qualified enum value - enum-name already has module prefix")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; enum-name already includes module prefix (e.g., "file_FileMode")
    ;; Convert variant-name to C format (hyphens to underscores) and append
    (let ((arena (. (deref ctx) arena)))
      (ctx-str3 ctx enum-name "_" (to-c-name arena variant-name))))

  ;; ============================================================
  ;; Binary Operation Transpilation
  ;; ============================================================

  (fn binop-to-c ((op String))
    (@intent "Convert SLOP binary operator to C operator")
    (@spec ((String) -> String))
    (cond
      ((string-eq op "+") "+")
      ((string-eq op "-") "-")
      ((string-eq op "*") "*")
      ((string-eq op "/") "/")
      ((string-eq op "%") "%")
      ((string-eq op "==") "==")
      ((string-eq op "=") "==")
      ((string-eq op "!=") "!=")
      ((string-eq op "<") "<")
      ((string-eq op ">") ">")
      ((string-eq op "<=") "<=")
      ((string-eq op ">=") ">=")
      ((string-eq op "and") "&&")
      ((string-eq op "or") "||")
      ((string-eq op "bit-and") "&")
      ((string-eq op "bit-or") "|")
      ((string-eq op "bit-xor") "^")
      ((string-eq op "&") "&")
      ((string-eq op "|") "|")
      ((string-eq op "^") "^")
      ((string-eq op "<<") "<<")
      ((string-eq op ">>") ">>")
      (else op)))

  (fn transpile-binop ((ctx (Ptr TranspileContext)) (op String) (left String) (right String))
    (@intent "Transpile a binary operation")
    (@spec (((Ptr TranspileContext) String String String) -> String))
    (@pre {ctx != nil})
    (let ((c-op (binop-to-c op)))
      (ctx-str5 ctx "(" left " " c-op (ctx-str3 ctx " " right ")"))))

  (fn transpile-variadic-binop ((ctx (Ptr TranspileContext)) (op String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Transpile a variadic binary operation (and/or) by chaining all arguments")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((c-op (binop-to-c op))
          (len (cast Int (list-len items))))
      (if (<= len (+ start-idx 1))
        (do
          (ctx-add-error-at ctx "not enough operands" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (let ((mut result "("))
          ;; Process first operand
          (match (list-get items start-idx)
            ((some first-arg)
              (set! result (ctx-str4 ctx result "(" (transpile-expr ctx first-arg) ")")))
            ((none) (set! result result)))
          ;; Process remaining operands
          (let ((mut i (+ start-idx 1)))
            (while (< i len)
              (match (list-get items i)
                ((some arg)
                  (let ((arg-str (ctx-str3 ctx " (" (transpile-expr ctx arg) ")")))
                    (set! result (ctx-str4 ctx result " " c-op arg-str))))
                ((none) (set! result result)))
              (set! i (+ i 1))))
          (ctx-str ctx result ")")))))

  ;; ============================================================
  ;; Built-in Type Detection
  ;; ============================================================

  (fn get-builtin-type-c-name ((type-name String))
    (@intent "Get C type name for built-in types, empty string if not a built-in")
    (@spec ((String) -> String))
    ;; Map SLOP built-in type names to their C equivalents
    ;; Returns empty string if not a built-in type
    (cond
      ((string-eq type-name "Bytes") "slop_bytes")
      ((string-eq type-name "String") "slop_string")
      (else "")))

  (fn is-pointer-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type like (Ptr X)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn is-string-literal ((expr (Ptr SExpr)))
    (@intent "Check if expression is a string literal")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((str _) true)
      (_ false)))

  (fn is-fn-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Fn ...) form")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((lst lst)
        (match (list-get (. lst items) 0)
          ((some head)
            (match (deref head)
              ((sym sym) (string-eq (. sym name) "Fn"))
              (_ false)))
          ((none) false)))
      (_ false)))

  (fn is-ptr-void-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Ptr Void)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (and (== (list-len items) 2)
               (match (list-get items 0)
                 ((some head)
                   (match (deref head)
                     ((sym s) (string-eq (. s name) "Ptr"))
                     (_ false)))
                 ((none) false))
               (match (list-get items 1)
                 ((some inner)
                   (match (deref inner)
                     ((sym s) (string-eq (. s name) "Void"))
                     (_ false)))
                 ((none) false)))))
      (_ false)))

  (fn is-closure-typed-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression has (Fn ...) type (is a closure)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Check if expr is a symbol bound with c-type = "slop_closure_t"
    (match (deref expr)
      ((sym sym)
        (match (ctx-lookup-var ctx (. sym name))
          ((some entry) (string-eq (. entry c-type) "slop_closure_t"))
          ((none) false)))
      (_ false)))

  (fn fn-type-to-c-fn-ptr ((ctx (Ptr TranspileContext)) (fn-expr (Ptr SExpr)))
    (@intent "Convert (Fn (arg-types) ret-type) AST to C function pointer type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {fn-expr != nil})
    ;; (Fn (ArgType1 ArgType2) RetType) -> "ret_c(*)(arg1_c, arg2_c)"
    ;; Extract items: [Fn, (args...), ret]
    (match (deref fn-expr)
      ((lst l)
        (let ((items (. l items)))
          (if (< (list-len items) 3)
            "void*"  ;; Malformed, fallback
            (let ((args-expr (match (list-get items 1) ((some e) e) ((none) fn-expr)))
                  (ret-expr (match (list-get items 2) ((some e) e) ((none) fn-expr)))
                  (ret-c (to-c-type-prefixed ctx ret-expr))
                  (args-c (build-fn-ptr-args-from-list ctx args-expr)))
              (if (string-eq args-c "")
                (ctx-str ctx ret-c "(*)(void)")
                (ctx-str ctx ret-c (ctx-str ctx "(*)(" (ctx-str ctx args-c ")"))))))))
      (_ "void*")))

  (fn build-fn-ptr-args-from-list ((ctx (Ptr TranspileContext)) (args-expr (Ptr SExpr)))
    (@intent "Build comma-separated C types from (ArgType1 ArgType2 ...)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {args-expr != nil})
    (match (deref args-expr)
      ((lst lst)
        (let ((items (. lst items))
              (count (list-len items))
              (mut result "")
              (mut i 0))
          (while (< i count)
            (match (list-get items i)
              ((some arg-type)
                (let ((c-type (to-c-type-prefixed ctx arg-type)))
                  (set! result (if (== i 0) c-type (ctx-str3 ctx result ", " c-type)))))
              ((none) (do)))
            (set! i (+ i 1)))
          result))
      (_ "")))

  (fn transpile-builtin-constructor ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile built-in type constructor with correct field order")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (cond
        ;; Bytes: (Bytes data len cap) -> (slop_bytes){.len = len, .cap = cap, .data = data}
        ((string-eq type-name "Bytes")
          (if (< len 4)
            "(slop_bytes){0}"
            (let ((data-c (match (list-get items 1) ((some e) (transpile-expr ctx e)) ((none) "NULL")))
                  (len-c (match (list-get items 2) ((some e) (transpile-expr ctx e)) ((none) "0")))
                  (cap-c (match (list-get items 3) ((some e) (transpile-expr ctx e)) ((none) "0"))))
              (ctx-str ctx "(slop_bytes){.len = " (ctx-str ctx len-c
                (ctx-str ctx ", .cap = " (ctx-str ctx cap-c
                  (ctx-str ctx ", .data = " (ctx-str ctx data-c "}")))))))))
        ;; String: (String data len) -> (slop_string){.len = len, .data = data}
        ((string-eq type-name "String")
          (if (< len 3)
            "(slop_string){0}"
            (let ((data-c (match (list-get items 1) ((some e) (transpile-expr ctx e)) ((none) "NULL")))
                  (len-c (match (list-get items 2) ((some e) (transpile-expr ctx e)) ((none) "0"))))
              (ctx-str ctx "(slop_string){.len = " (ctx-str ctx len-c
                (ctx-str ctx ", .data = " (ctx-str ctx data-c "}")))))))
        (else "(/* unknown builtin */)"))))

  ;; ============================================================
  ;; Function Call Transpilation
  ;; ============================================================

  (fn transpile-call ((ctx (Ptr TranspileContext)) (fn-name String) (args String))
    (@intent "Transpile a function call")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Check for runtime built-in functions first (no prefix)
      (let ((runtime-name (get-runtime-function-name fn-name)))
        (if (> (string-len runtime-name) 0)
          ;; Runtime function - use its name directly
          (ctx-str4 ctx runtime-name "(" args ")")
          ;; Handle qualified names like "file.open" or regular names like "open"
          (let ((base-name (get-base-function-name arena fn-name))
                (mod-name (get-module-from-qualified-name arena fn-name)))
            ;; First check if this is a local variable (function pointer or closure)
            (match (ctx-lookup-var ctx fn-name)
              ((some var-entry)
                ;; Check if this is a closure (captured lambda with env)
                (if (. var-entry is-closure)
                  (let ((lambda-name (. var-entry closure-lambda-name))
                        (env-type (. var-entry closure-env-type))
                        (var-c-name (. var-entry c-name))
                        (slop-type (. var-entry slop-type)))
                    ;; Check if specific closure (has lambda-name) or generic (Fn param)
                    (if (> (string-len lambda-name) 0)
                      ;; Specific closure call: lambda_name((env_type*)f.env, args...)
                      (if (> (string-len args) 0)
                        ;; Has arguments: lambda_name((env_type*)var.env, args)
                        (let ((s1 (ctx-str ctx lambda-name "(("))
                              (s2 (ctx-str ctx s1 env-type))
                              (s3 (ctx-str ctx s2 "*)"))
                              (s4 (ctx-str ctx s3 var-c-name))
                              (s5 (ctx-str ctx s4 ".env, "))
                              (s6 (ctx-str ctx s5 args)))
                          (ctx-str ctx s6 ")"))
                        ;; No arguments (just env): lambda_name((env_type*)var.env)
                        (let ((s1 (ctx-str ctx lambda-name "(("))
                              (s2 (ctx-str ctx s1 env-type))
                              (s3 (ctx-str ctx s2 "*)"))
                              (s4 (ctx-str ctx s3 var-c-name)))
                          (ctx-str ctx s4 ".env)")))
                      ;; Generic closure call for (Fn ...) params
                      (emit-generic-closure-call ctx var-c-name slop-type args)))
                  ;; Local function pointer variable - use its c-name directly
                  (ctx-str4 ctx (. var-entry c-name) "(" args ")")))
              ((none)
                ;; Look up registered function using base name
                (let ((c-name (match (ctx-lookup-func ctx base-name)
                                ((some func-entry)
                                  (. func-entry c-name))
                                ;; Not found - generate C name
                                ((none)
                                  (if (> (string-len mod-name) 0)
                                    ;; Cross-module call - convert qualified name to C name (mod_func)
                                    (to-c-name arena fn-name)
                                    ;; Same-module call - add current module prefix
                                    (ctx-prefix-type ctx (to-c-name arena fn-name)))))))
                  (ctx-str4 ctx c-name "(" args ")")))))))))

  ;; ============================================================
  ;; Generic Closure Invocation (for (Fn ...) parameters)
  ;; ============================================================

  (fn emit-generic-closure-call ((ctx (Ptr TranspileContext)) (var-c-name String) (slop-type String) (args String))
    (@intent "Emit generic closure call using cast-based invocation for (Fn ...) params")
    (@spec (((Ptr TranspileContext) String String String) -> String))
    (@pre {ctx != nil})
    ;; Generic pattern: ((ret_type(*)(void*, arg_types...))var.fn)(var.env, args...)
    (let ((arena (. (deref ctx) arena))
          (fn-cast (build-closure-fn-cast ctx slop-type))
          (fn-ptr (ctx-str ctx var-c-name ".fn"))
          (env-ptr (ctx-str ctx var-c-name ".env")))
      ;; Build: ((cast)fn)(env, args) or ((cast)fn)(env)
      (let ((cast-expr (ctx-str4 ctx "((" fn-cast ")" fn-ptr))
            (call-open (ctx-str ctx cast-expr ")(")))
        (if (> (string-len args) 0)
          ;; With args: ((cast)fn)(env, args)
          (ctx-str4 ctx call-open env-ptr ", " (ctx-str ctx args ")"))
          ;; No args: ((cast)fn)(env)
          (ctx-str ctx call-open (ctx-str ctx env-ptr ")"))))))

  (fn build-closure-fn-cast ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Build function pointer cast from SLOP type string like (Fn (Int) Int)")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Parse "(Fn (args...) ret)" and build "ret_c(*)(void*, arg_c_types...)"
    (let ((arena (. (deref ctx) arena))
          (ret-type (extract-fn-return-c-type ctx slop-type))
          (arg-types (extract-fn-arg-c-types ctx slop-type)))
      ;; Build: ret_type(*)(void*, arg_types...)
      ;; If no args, just void*. If args, void*, arg_types
      (if (string-eq arg-types "")
        (ctx-str ctx ret-type "(*)(void*)")
        (ctx-str ctx ret-type (ctx-str ctx "(*)(void*, " (ctx-str ctx arg-types ")"))))))

  (fn extract-fn-return-c-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Extract C return type from SLOP Fn type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Parse "(Fn (args...) RetType)" - return type is after last close paren of args
    ;; For simplicity, scan backwards from end to find the return type symbol
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (string-len slop-type))))
      ;; Find last space (after args list close paren)
      (let ((mut last-space -1)
            (mut paren-depth 0)
            (mut i 0))
        (while (< i len)
          (let ((c (char-at slop-type (cast (Int 0 ..) i))))
            (cond
              ((== c 40) (set! paren-depth (+ paren-depth 1)))  ;; (
              ((== c 41) (set! paren-depth (- paren-depth 1)))  ;; )
              ((and (== c 32) (== paren-depth 1))  ;; space at depth 1 (inside Fn)
                (set! last-space i))
              (else (do))))
          (set! i (+ i 1)))
        (if (< last-space 0)
          "int64_t"  ;; Default
          ;; Extract from last-space+1 to len-1 (skip closing paren)
          (let ((start (+ last-space 1))
                (end (- len 1))
                (sublen (- end start)))
            (if (<= sublen 0)
              "int64_t"
              (let ((ret-slop (substring arena slop-type (cast (Int 0 ..) start) (cast (Int 0 ..) sublen))))
                (closure-type-to-c ctx ret-slop))))))))

  (fn extract-fn-arg-c-types ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Extract C argument types from SLOP Fn type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Parse "(Fn (args...) RetType)" - args are in inner parens after "Fn "
    ;; Returns comma-separated C types, or empty string if no args
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (string-len slop-type))))
      ;; Find the args list: starts after "(Fn " (index 4), ends at matching )
      (let ((mut args-start -1)
            (mut args-end -1)
            (mut paren-depth 0)
            (mut i 0))
        (while (< i len)
          (let ((c (char-at slop-type (cast (Int 0 ..) i))))
            (cond
              ((== c 40)  ;; (
                (set! paren-depth (+ paren-depth 1))
                (when (== paren-depth 2)
                  (set! args-start (+ i 1))))
              ((== c 41)  ;; )
                (when (and (== paren-depth 2) (< args-end 0))
                  (set! args-end i))
                (set! paren-depth (- paren-depth 1)))
              (else (do))))
          (set! i (+ i 1)))
        (if (or (< args-start 0) (< args-end 0) (>= args-start args-end))
          ""  ;; No args or empty args
          ;; Extract args string and parse individual types
          (let ((args-str (substring arena slop-type (cast (Int 0 ..) args-start) (cast (Int 0 ..) (- args-end args-start)))))
            (parse-fn-args-to-c-types ctx args-str))))))

  (fn parse-fn-args-to-c-types ((ctx (Ptr TranspileContext)) (args-str String))
    (@intent "Parse SLOP arg types string and convert to comma-separated C types")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; args-str is like "Int" or "Int String" or "(Ptr Int)" or "(Ptr Int) String"
    ;; Split by space (but respect parens) and convert each to C type
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (string-len args-str))))
      (if (== len 0)
        ""
        (let ((mut result "")
               (mut token-start 0)
               (mut paren-depth 0)
               (mut i 0)
               (mut first true))
          (while (<= i len)
            (let ((c (if (< i len) (char-at args-str (cast (Int 0 ..) i)) 32)))  ;; space at end
              (cond
                ((== c 40) (set! paren-depth (+ paren-depth 1)))  ;; (
                ((== c 41) (set! paren-depth (- paren-depth 1)))  ;; )
                ((and (== c 32) (== paren-depth 0) (< token-start i))
                  ;; End of a token
                  (let ((token (substring arena args-str (cast (Int 0 ..) token-start) (cast (Int 0 ..) (- i token-start))))
                        (c-type (closure-type-to-c ctx token)))
                    (if first
                      (do
                        (set! result c-type)
                        (set! first false))
                      (set! result (ctx-str ctx result (ctx-str ctx ", " c-type)))))
                  (set! token-start (+ i 1)))
                ((and (== c 32) (== paren-depth 0))
                  ;; Skip leading/consecutive spaces
                  (set! token-start (+ i 1)))
                (else (do))))
            (set! i (+ i 1)))
          result))))

  (fn closure-type-to-c ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Convert SLOP type string to C type for closure cast generation")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Handle common types - for complex types, default to int64_t
    (cond
      ((string-eq slop-type "Int") "int64_t")
      ((string-eq slop-type "I8") "int8_t")
      ((string-eq slop-type "I16") "int16_t")
      ((string-eq slop-type "I32") "int32_t")
      ((string-eq slop-type "I64") "int64_t")
      ((string-eq slop-type "U8") "uint8_t")
      ((string-eq slop-type "U16") "uint16_t")
      ((string-eq slop-type "U32") "uint32_t")
      ((string-eq slop-type "U64") "uint64_t")
      ((string-eq slop-type "Float") "double")
      ((string-eq slop-type "F32") "float")
      ((string-eq slop-type "Bool") "uint8_t")
      ((string-eq slop-type "String") "slop_string")
      ((string-eq slop-type "Unit") "void")
      ((string-eq slop-type "Void") "void")
      ((starts-with slop-type "(Ptr ")
        ;; Pointer type - extract inner and add *
        (let ((arena (. (deref ctx) arena))
              (len (cast Int (string-len slop-type)))
              (inner-start 5)  ;; After "(Ptr "
              (inner-end (- len 1)))  ;; Before ")"
          (if (< inner-start inner-end)
            (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) (- inner-end inner-start)))))
              (ctx-str ctx (closure-type-to-c ctx inner) "*"))
            "void*")))
      ((starts-with slop-type "(Fn ")
        ;; Nested function type - use slop_closure_t
        "slop_closure_t")
      (else
        ;; Try looking up as a custom type in the type registry
        (match (ctx-lookup-type ctx slop-type)
          ((some type-entry) (. type-entry c-name))
          ((none) "int64_t")))))  ;; Default for truly unknown types

  (fn get-base-function-name ((arena Arena) (fn-name String))
    (@intent "Extract base function name from qualified name (file.open -> open)")
    (@spec ((Arena String) -> String))
    ;; Find the dot position
    (let ((len (cast Int (string-len fn-name)))
          (mut dot-pos -1)
          (mut i 0))
      (while (< i len)
        (if (= (char-at fn-name (cast (Int 0 ..) i)) 46)  ;; 46 = '.'
          (set! dot-pos i)
          (do))
        (set! i (+ i 1)))
      (if (< dot-pos 0)
        ;; No dot - return original name
        fn-name
        ;; Extract part after the dot
        (let ((start (+ dot-pos 1))
              (sublen (- len start)))
          (substring arena fn-name (cast (Int 0 ..) start) (cast (Int 0 ..) sublen))))))

  (fn get-module-from-qualified-name ((arena Arena) (fn-name String))
    (@intent "Extract module name from qualified name (file.open -> file)")
    (@spec ((Arena String) -> String))
    ;; Find the dot position
    (let ((len (cast Int (string-len fn-name)))
          (mut dot-pos -1)
          (mut i 0))
      (while (< i len)
        (if (= (char-at fn-name (cast (Int 0 ..) i)) 46)  ;; 46 = '.'
          (set! dot-pos i)
          (do))
        (set! i (+ i 1)))
      (if (< dot-pos 0)
        ;; No dot - return empty string (not qualified)
        ""
        ;; Extract part before the dot
        (substring arena fn-name 0 (cast (Int 0 ..) dot-pos)))))

  (fn get-runtime-function-name ((fn-name String))
    (@intent "Check if function is a runtime built-in and return its C name")
    (@spec ((String) -> String))
    (cond
      ;; String operations (from slop_runtime.h)
      ((string-eq fn-name "string-eq") "string_eq")
      ((string-eq fn-name "string-concat") "string_concat")
      ((string-eq fn-name "string-len") "string_len")
      ((string-eq fn-name "string-new") "string_new")
      ((string-eq fn-name "int-to-string") "int_to_string")
      ((string-eq fn-name "string-push-char") "slop_string_push_char")
      ((string-eq fn-name "float-to-string-short") "float_to_string_short")
      ;; Parsing operations (from strlib, but commonly used without explicit import)
      ((string-eq fn-name "parse-int") "strlib_parse_int")
      ((string-eq fn-name "parse-float") "strlib_parse_float")
      ;; List operations
      ((string-eq fn-name "list-len") "list_len")
      ((string-eq fn-name "list-new") "list_new")
      ((string-eq fn-name "list-push") "list_push")
      ((string-eq fn-name "list-get") "list_get")
      ;; Bytes operations
      ((string-eq fn-name "bytes-len") "bytes_len")
      ((string-eq fn-name "bytes-new") "bytes_new")
      ;; Option operations
      ((string-eq fn-name "unwrap") "unwrap")
      ;; C library functions (FFI)
      ((string-eq fn-name "printf") "printf")
      ((string-eq fn-name "fprintf") "fprintf")
      ((string-eq fn-name "sprintf") "sprintf")
      ((string-eq fn-name "snprintf") "snprintf")
      ((string-eq fn-name "malloc") "malloc")
      ((string-eq fn-name "free") "free")
      ((string-eq fn-name "memcpy") "memcpy")
      ((string-eq fn-name "memset") "memset")
      ((string-eq fn-name "strlen") "strlen")
      ((string-eq fn-name "strcmp") "strcmp")
      ((string-eq fn-name "exit") "exit")
      ((string-eq fn-name "abort") "abort")
      ;; Not a runtime function
      (else "")))

  ;; ============================================================
  ;; Type Inference Helpers
  ;; ============================================================

  (fn transpile-enum-variant ((ctx (Ptr TranspileContext)) (variant-name String))
    (@intent "Transpile an enum variant reference")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Look up the variant in registered enum types
      (match (ctx-lookup-enum-variant ctx variant-name)
        ((some enum-name)
          ;; Emit EnumType_variant
          (let ((enum-c (to-c-name arena enum-name))
                (variant-c (to-c-name arena variant-name)))
            (ctx-str3 ctx enum-c "_" variant-c)))
        ((none)
          ;; Fall back to just the variant name
          (to-c-name arena variant-name)))))

  (fn transpile-ok ((ctx (Ptr TranspileContext)) (value-c String))
    (@intent "Transpile ok result construction")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Get current function's result type
    (match (ctx-get-current-result-type ctx)
      ((some result-type)
        ;; (ResultType){ .is_ok = true, .data.ok = value }
        (ctx-str5 ctx "((" result-type "){ .is_ok = true, .data.ok = " value-c " })"))
      ((none)
        ;; No result type set - use generic
        (ctx-str3 ctx "(slop_result){ .is_ok = true, .data.ok = " value-c " }"))))

  (fn transpile-error ((ctx (Ptr TranspileContext)) (value-c String))
    (@intent "Transpile error result construction")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Get current function's result type
    (match (ctx-get-current-result-type ctx)
      ((some result-type)
        ;; (ResultType){ .is_ok = false, .data.err = value }
        (ctx-str5 ctx "((" result-type "){ .is_ok = false, .data.err = " value-c " })"))
      ((none)
        ;; No result type set - use generic
        (ctx-str3 ctx "(slop_result){ .is_ok = false, .data.err = " value-c " }"))))

  (fn infer-option-type ((ctx (Ptr TranspileContext)) (val-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a value expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {val-expr != nil})
    ;; Basic type inference for Option element type
    (match (deref val-expr)
      ((num num)
        ;; Numbers default to int option
        (if (. num is-float)
          "slop_option_double"
          "slop_option_int"))
      ((str _)
        "slop_option_string")
      ((sym sym)
        ;; First check if type checker annotated this node
        (match (get-node-resolved-type val-expr)
          ((some rt)
            ;; Use resolved type to build Option type
            (let ((c-type (resolved-type-to-c (. (deref ctx) arena) rt)))
              (c-type-to-option-type-name ctx c-type)))
          ((none)
            ;; Fall back to variable lookup
            (let ((name (. sym name)))
              (match (ctx-lookup-var ctx name)
                ((some var-entry)
                  (let ((c-type (. var-entry c-type))
                        (slop-type (. var-entry slop-type))
                        (arena (. (deref ctx) arena)))
                    (cond
                      ;; Handle auto type - try to derive from slop-type
                      ((string-eq c-type "auto")
                        (if (> (string-len slop-type) 0)
                          ;; Convert SLOP type to C type and build Option type
                          (let ((derived-c-type (slop-value-type-to-c-type ctx slop-type)))
                            (c-type-to-option-type-name ctx derived-c-type))
                          ;; No slop-type available - emit error
                          (do
                            (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for variable '" name "' - type is 'auto' with no SLOP type") (ctx-sexpr-line val-expr) (ctx-sexpr-col val-expr))
                            "__type_error__")))
                      ((string-eq c-type "int64_t") "slop_option_int")
                      ((string-eq c-type "double") "slop_option_double")
                      ((string-eq c-type "slop_string") "slop_option_string")
                      ((string-eq c-type "char") "slop_option_char")
                      ((string-eq c-type "uint8_t") "slop_option_u8")
                      ;; Check for pointer types (ends with *)
                      ((ends-with c-type "*")
                        (let ((base-type (strip-pointer-suffix arena c-type)))
                          (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                      ;; Other custom types: build slop_option_<typename>
                      (else (ctx-str3 ctx "slop_option_" c-type "")))))
                ;; Unknown variable - emit error
                ((none)
                  (do
                    (ctx-add-error-at ctx (ctx-str3 ctx "Unknown variable '" name "' for Option type inference") (ctx-sexpr-line val-expr) (ctx-sexpr-col val-expr))
                    "__type_error__")))))))
      ;; For complex expressions, try to infer type from the structure
      ((lst lst)
        (infer-list-expr-option-type ctx (. lst items)))))

  (fn c-type-to-option-type-name ((ctx (Ptr TranspileContext)) (c-type String))
    (@intent "Convert C type to corresponding Option type name")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ;; Pointer types (ends with *)
        ((ends-with c-type "*")
          (let ((base-type (strip-pointer-suffix arena c-type)))
            (ctx-str3 ctx "slop_option_" base-type "_ptr")))
        ;; All other types: use type-to-identifier for consistent naming
        (else (ctx-str3 ctx "slop_option_" (type-to-identifier arena c-type) "")))))

  (fn infer-field-c-type-from-items ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C type for a field access expression (. obj field) from items list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (line (ctx-list-first-line items))
          (col (ctx-list-first-col items)))
      (if (< len 3)
        "__auto_type"
        (match (list-get items 1)
          ((some obj-expr)
            (match (list-get items 2)
              ((some field-expr)
                (match (deref field-expr)
                  ((sym field-sym)
                    (let ((field-name (. field-sym name))
                          (obj-c-type (infer-expr-c-type ctx obj-expr)))
                      (match (ctx-lookup-field-type ctx obj-c-type field-name)
                        ((some c-type) c-type)
                        ((none)
                          ;; Try with SLOP type name
                          (match (ctx-lookup-var ctx (get-var-name-from-expr obj-expr))
                            ((some var-entry)
                              (let ((obj-slop-type (. var-entry slop-type)))
                                (match (ctx-lookup-field-type ctx obj-slop-type field-name)
                                  ((some c-type2) c-type2)
                                  ((none) "__auto_type"))))
                            ((none) "__auto_type"))))))
                  (else "__auto_type")))
              ((none) "__auto_type")))
          ((none) "__auto_type")))))

  (fn infer-list-expr-option-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer Option type for a list expression (field access, function call, etc.)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena))
          (line (ctx-list-first-line items))
          (col (ctx-list-first-col items)))
      (if (< len 1)
        (do
          (ctx-add-error-at ctx "Empty list in option type inference" line col)
          "__type_error__")
        (match (list-get items 0)
          ((some head-expr)
            (match (deref head-expr)
              ((sym sym)
                (let ((op (. sym name)))
                  (cond
                    ;; Field access: (. obj field) - try registry lookup, then hardcoded fallback
                    ((string-eq op ".")
                      (if (< len 3)
                        (do
                          (ctx-add-error-at ctx "Incomplete field access for option type inference" line col)
                          "__type_error__")
                        ;; Try registry-based field type lookup first
                        (let ((field-c-type (infer-field-c-type-from-items ctx items)))
                          (if (not (string-eq field-c-type "__auto_type"))
                            (c-type-to-option-type-name ctx field-c-type)
                            ;; Fallback: hardcoded known fields (for match-bound vars without type info)
                            (match (list-get items 2)
                              ((some field-expr)
                                (match (deref field-expr)
                                  ((sym field-sym)
                                    (let ((field-name (. field-sym name)))
                                      (cond
                                        ((string-eq field-name "name") "slop_option_string")
                                        ((string-eq field-name "value") "slop_option_string")
                                        ((string-eq field-name "message") "slop_option_string")
                                        ((string-eq field-name "c-name") "slop_option_string")
                                        ((string-eq field-name "c-type") "slop_option_string")
                                        ((string-eq field-name "slop-name") "slop_option_string")
                                        ((string-eq field-name "slop-type") "slop_option_string")
                                        ((string-eq field-name "return-type") "slop_option_string")
                                        ((string-eq field-name "slop-return-type") "slop_option_string")
                                        ((string-eq field-name "enum-name") "slop_option_string")
                                        ((string-eq field-name "variant-name") "slop_option_string")
                                        ((string-eq field-name "const-type") "slop_option_types_ResolvedType_ptr")
                                        ;; Unknown field - emit error
                                        (else
                                          (do
                                            (ctx-add-error-at ctx (ctx-str3 ctx "Unknown field '" field-name "' for option type inference") (ctx-sexpr-line field-expr) (ctx-sexpr-col field-expr))
                                            "__type_error__")))))
                                  (else
                                    (do
                                      (ctx-add-error-at ctx "Non-symbol field for option type inference" (ctx-sexpr-line field-expr) (ctx-sexpr-col field-expr))
                                      "__type_error__"))))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "Missing field for option type inference" line col)
                                  "__type_error__")))))))
                    ;; String functions that return strings
                    ((or (string-eq op "string-concat")
                         (or (string-eq op "string-copy")
                             (or (string-eq op "int-to-string")
                                 (string-eq op "substring"))))
                      "slop_option_string")
                    ;; Check function registry for return type
                    (else
                      (match (ctx-lookup-func ctx op)
                        ((some func-entry)
                          (let ((ret-type (. func-entry return-type)))
                            (cond
                              ;; Known string return
                              ((. func-entry returns-string) "slop_option_string")
                              ;; Has explicit return type
                              ((> (string-len ret-type) 0)
                                (cond
                                  ((string-eq ret-type "slop_string") "slop_option_string")
                                  ((string-eq ret-type "int64_t") "slop_option_int")
                                  ((string-eq ret-type "double") "slop_option_double")
                                  ;; Pointer type - generate slop_option_<base>_ptr
                                  ((ends-with ret-type "*")
                                    (let ((ctx-arena (. (deref ctx) arena))
                                          (base-type (strip-pointer-suffix ctx-arena ret-type)))
                                      (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                                  ;; Other types - generate slop_option_<type>
                                  (else (ctx-str3 ctx "slop_option_" ret-type ""))))
                              ;; No return type info - emit error
                              (else
                                (do
                                  (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for function '" op "' - no return type info") line col)
                                  "__type_error__")))))
                        ;; Unknown function - emit error
                        ((none)
                          (do
                            (ctx-add-error-at ctx (ctx-str3 ctx "Unknown function '" op "' for Option type inference") line col)
                            "__type_error__")))))))
              (else
                (do
                  (ctx-add-error-at ctx "Non-symbol head in option type inference" (ctx-sexpr-line head-expr) (ctx-sexpr-col head-expr))
                  "__type_error__"))))
          ((none)
            (do
              (ctx-add-error-at ctx "Missing list head in option type inference" line col)
              "__type_error__"))))))

  (fn strip-pointer-suffix ((arena Arena) (s String))
    (@intent "Strip trailing * from pointer type string")
    (@spec ((Arena String) -> String))
    (let ((len (string-len s)))
      (if (< len 1)
        ""
        (substring arena s (cast (Int 0 ..) 0) (cast (Int 0 ..) (- len 1))))))

  (fn extract-chan-elem-type ((ctx (Ptr TranspileContext)) (chan-type String))
    (@intent "Extract element type from channel type name (slop_chan_foo -> foo)")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (prefix-len 10))  ;; length of "slop_chan_"
      (let ((len (string-len chan-type)))
        (if (<= len prefix-len)
          "int64_t"  ;; fallback
          (substring arena chan-type (cast (Int 0 ..) prefix-len) (cast (Int 0 ..) len))))))

  (fn infer-list-element-option-type ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a list element (for list-get)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    ;; Return empty string to indicate "use anonymous struct fallback"
    (let ((arena (. (deref ctx) arena)))
      ;; Strategy 1: If the list expression has a resolved type from the checker, use it
      (match (get-node-resolved-type list-expr)
        ((some rt)
          (match (. (deref rt) inner-type)
            ((some elem-type)
              (let ((elem-c (resolved-type-to-c arena elem-type)))
                (string-concat arena "slop_option_" (type-to-identifier arena elem-c))))
            ((none) (infer-list-element-option-type-fallback ctx list-expr))))
        ((none)
          (do (ctx-warn-fallback ctx list-expr "infer-list-element-option-type")
              (infer-list-element-option-type-fallback ctx list-expr))))))

  (fn infer-list-element-option-type-fallback ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)))
    (@intent "Fallback: infer option type using infer-expr-c-type or string-based methods")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (list-c-type (infer-expr-c-type ctx list-expr)))
      ;; If infer-expr-c-type returns a list type, extract element and build option
      (if (starts-with list-c-type "slop_list_")
        (let ((elem-id (substring-after-prefix arena list-c-type "slop_list_"))
              (prefixed-elem (prefix-list-element-type ctx elem-id)))
          (string-concat arena "slop_option_" prefixed-elem))
        ;; Final fallback: old string-based path
        (match (deref list-expr)
          ((sym sym)
            (let ((name (. sym name)))
              (match (ctx-lookup-var ctx name)
                ((some var-entry)
                  (list-type-to-option-type ctx (. var-entry c-type)))
                ((none) ""))))
          ((lst lst)
            (let ((items (. lst items)))
              (if (< (list-len items) 3)
                ""
                (match (list-get items 0)
                  ((some head)
                    (match (deref head)
                      ((sym head-sym)
                        (if (string-eq (. head-sym name) ".")
                          (match (list-get items 2)
                            ((some field-expr)
                              (infer-field-access-list-type ctx field-expr))
                            ((none) ""))
                          ""))
                      (_ "")))
                  ((none) "")))))
          (_ "")))))

  (fn infer-field-access-list-type ((ctx (Ptr TranspileContext)) (field-expr (Ptr SExpr)))
    (@intent "Infer option type for list field access")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    ;; Get the field name and return appropriate option type
    ;; Only use named types that are guaranteed to exist (from types.slop imports)
    (match (deref field-expr)
      ((sym field-sym)
        (let ((field-name (. field-sym name)))
          ;; For common known field names from types module, return appropriate option types
          (cond
            ;; SExprList.items -> (List (Ptr SExpr)) -> slop_option_types_SExpr_ptr
            ((string-eq field-name "items") "slop_option_types_SExpr_ptr")
            ;; ResolvedType.variants -> (List ResolvedVariant) -> slop_option_types_ResolvedVariant
            ((string-eq field-name "variants") "slop_option_types_ResolvedVariant")
            ;; ResolvedType.fields -> (List ResolvedField) -> slop_option_types_ResolvedField
            ((string-eq field-name "fields") "slop_option_types_ResolvedField")
            ;; Default fallback - use empty string to trigger anonymous struct
            ;; (tokens etc. use anonymous struct since slop_option_parser_Token isn't defined)
            (else ""))))
      (_ "")))

  (fn list-type-to-option-type ((ctx (Ptr TranspileContext)) (c-type String))
    (@intent "Convert slop_list_X to slop_option_X")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ((string-eq c-type "slop_list_string") "slop_option_string")
        ((string-eq c-type "slop_list_int") "slop_option_int")
        ((string-eq c-type "slop_list_double") "slop_option_double")
        ((string-eq c-type "slop_list_char") "slop_option_char")
        ((string-eq c-type "slop_list_u8") "slop_option_u8")
        ;; For other list types, extract element and build option type
        ((starts-with c-type "slop_list_")
          (let ((elem-type (substring-after-prefix arena c-type "slop_list_")))
            ;; Check if elem-type needs module prefix
            ;; e.g. "SExpr_ptr" -> look up "SExpr" -> get "types_SExpr" -> "types_SExpr_ptr"
            (let ((prefixed-elem (prefix-list-element-type ctx elem-type)))
              (ctx-str3 ctx "slop_option_" prefixed-elem ""))))
        (else ""))))

  (fn prefix-list-element-type ((ctx (Ptr TranspileContext)) (elem-type String))
    (@intent "Add module prefix to list element type if needed")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (if (ends-with elem-type "_ptr")
        ;; Pointer element: strip _ptr, look up base, rebuild
        (let ((base (substring arena elem-type 0 (max 0 (- (cast Int (string-len elem-type)) 4)))))
          (match (ctx-lookup-type ctx base)
            ((some entry)
              (string-concat arena (. entry c-name) "_ptr"))
            ((none) elem-type)))
        ;; Non-pointer element: look up directly
        (match (ctx-lookup-type ctx elem-type)
          ((some entry)
            (. entry c-name))
          ((none) elem-type)))))

  (fn substring-after-prefix ((arena Arena) (s String) (prefix String))
    (@intent "Extract substring after a prefix")
    (@spec ((Arena String String) -> String))
    ;; Use strlib substring
    (let ((prefix-len (string-len prefix))
          (s-len (string-len s)))
      (if (<= s-len prefix-len)
        ""
        (let ((start (cast (Int 0 ..) prefix-len))
              (len (cast (Int 0 ..) (- s-len prefix-len))))
          (substring arena s start len)))))

  ;; ============================================================
  ;; Map Type Helpers (for map-get Option type inference)
  ;; ============================================================

  (fn extract-map-value-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract value type from '(Map K V)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Map String Int)" -> "Int" or "(Map Term (Set Term))" -> "(Set Term)"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 10)
        ""
        ;; Check for "(Map " prefix (5 chars)
        (if (not (starts-with slop-type "(Map "))
          ""
          ;; Find the space between K and V at nesting level 1
          ;; This handles compound value types like (Set Term)
          (let ((mut i 5)
                (mut nesting 1)
                (mut key-space 0)
                (mut found-key false)
                (end-idx (- len 1)))
            ;; Skip past key type to find space at level 1
            (while (and (< i end-idx) (not found-key))
              (let ((c (char-at slop-type (cast (Int 0 ..) i))))
                (cond
                  ((== c 40) (set! nesting (+ nesting 1)))
                  ((== c 41) (set! nesting (- nesting 1)))
                  ((and (== c 32) (== nesting 1))
                    (set! key-space i)
                    (set! found-key true))
                  (else (do))))
              (set! i (+ i 1)))
            (if (not found-key)
              ""
              (let ((value-start (+ key-space 1))
                    (value-len (- end-idx value-start)))
                (if (> value-len 0)
                  (substring arena slop-type (cast (Int 0 ..) value-start) (cast (Int 0 ..) value-len))
                  ""))))))))

  (fn slop-value-type-to-c-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Convert SLOP value type name to C type with proper module prefix")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (ctx-lookup-type ctx slop-type)
        ((some entry) (. entry c-name))
        ((none) (to-c-name arena slop-type)))))

  (fn get-var-name-from-expr ((expr (Ptr SExpr)))
    (@intent "Extract variable name from expression if it's a simple symbol")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym) (. sym name))
      (_ "")))

  (fn extract-map-key-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract key type from '(Map K V)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Map String Int)" -> "String"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 10)
        ""
        ;; Check for "(Map " prefix (5 chars)
        (if (not (starts-with slop-type "(Map "))
          ""
          ;; Find the space between K and V at nesting level 1
          (let ((mut i 5)
                (mut nesting 1)
                (mut key-space 0)
                (mut found-key false)
                (end-idx (- len 1)))
            ;; Skip past key type to find space at level 1
            (while (and (< i end-idx) (not found-key))
              (let ((c (char-at slop-type (cast (Int 0 ..) i))))
                (cond
                  ((== c 40) (set! nesting (+ nesting 1)))
                  ((== c 41) (set! nesting (- nesting 1)))
                  ((and (== c 32) (== nesting 1))
                    (set! key-space i)
                    (set! found-key true))
                  (else (do))))
              (set! i (+ i 1)))
            (if (not found-key)
              ""
              ;; Key starts at position 5 and ends at key-space
              (let ((key-start 5)
                    (key-len (- key-space key-start)))
                (if (> key-len 0)
                  (substring arena slop-type (cast (Int 0 ..) key-start) (cast (Int 0 ..) key-len))
                  ""))))))))

  (fn resolve-type-alias ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Resolve a type alias to its underlying type")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; If it already starts with (Map or (Set, return as-is
    (cond
      ((starts-with slop-type "(Map ") slop-type)
      ((starts-with slop-type "(Set ") slop-type)
      ((starts-with slop-type "(") slop-type)  ;; Some other compound type
      (else
        ;; It's a simple identifier - look up as type alias
        (match (ctx-lookup-type-alias ctx slop-type)
          ((some alias-def) alias-def)
          ((none) slop-type)))))

  ;; ============================================================
  ;; SLOP Type Inference for Expressions
  ;; ============================================================

  (fn infer-expr-slop-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer SLOP type of an expression for map/set key type propagation")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ;; Variable reference - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some entry) (. entry slop-type))
              ((none) ""))))
        ;; List expression - check for field access
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 1)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym head-sym)
                      (let ((op (. head-sym name)))
                        (cond
                          ;; Field access: (. obj field)
                          ((and (string-eq op ".") (>= len 3))
                            (match (list-get items 1)
                              ((some obj-expr)
                                (match (list-get items 2)
                                  ((some field-expr)
                                    (match (deref field-expr)
                                      ((sym field-sym)
                                        (let ((field-name (. field-sym name)))
                                          ;; Get object's type, then look up field's slop-type
                                          (let ((obj-c-type (infer-expr-c-type ctx obj-expr)))
                                            (match (ctx-lookup-field-slop-type ctx obj-c-type field-name)
                                              ((some slop-type) slop-type)
                                              ((none)
                                                ;; Try with SLOP type
                                                (let ((obj-slop-type (infer-expr-slop-type ctx obj-expr)))
                                                  (match (ctx-lookup-field-slop-type ctx obj-slop-type field-name)
                                                    ((some slop-type2) slop-type2)
                                                    ((none) ""))))))))
                                      (_ "")))
                                  ((none) "")))
                              ((none) "")))
                          ;; record-new: (record-new TypeName ...) -> TypeName
                          ((string-eq op "record-new")
                            (if (>= len 2)
                              (match (list-get items 1)
                                ((some type-expr)
                                  (match (deref type-expr)
                                    ((sym type-sym) (. type-sym name))
                                    (_ "")))
                                ((none) ""))
                              ""))
                          ;; map-new: (map-new arena KeyType ValueType) -> (Map KeyType ValueType)
                          ((string-eq op "map-new")
                            (if (>= len 4)
                              (match (list-get items 2)
                                ((some key-expr)
                                  (match (list-get items 3)
                                    ((some val-expr)
                                      (let ((key-str (sexpr-to-type-string arena key-expr))
                                            (val-str (sexpr-to-type-string arena val-expr)))
                                        (ctx-str5 ctx "(Map " key-str " " val-str ")")))
                                    ((none) "")))
                                ((none) ""))
                              ""))
                          ;; set-new: (set-new arena ElemType) -> (Set ElemType)
                          ((string-eq op "set-new")
                            (if (>= len 3)
                              (match (list-get items 2)
                                ((some elem-expr)
                                  (let ((elem-str (sexpr-to-type-string arena elem-expr)))
                                    (ctx-str3 ctx "(Set " elem-str ")")))
                                ((none) ""))
                              ""))
                          ;; list-new: (list-new arena ElemType) -> (List ElemType)
                          ((string-eq op "list-new")
                            (if (>= len 3)
                              (match (list-get items 2)
                                ((some elem-expr)
                                  (let ((elem-str (sexpr-to-type-string arena elem-expr)))
                                    (ctx-str3 ctx "(List " elem-str ")")))
                                ((none) ""))
                              ""))
                          ;; Default: check if it's a function call
                          (else
                            (match (ctx-lookup-func ctx op)
                              ((some func-entry) (. func-entry slop-return-type))
                              ((none) ""))))))
                    (_ "")))
                ((none) "")))))
        ;; Other forms - no type info
        (_ ""))))

  ;; ============================================================
  ;; Helper Functions for Type Inference from Inferred SLOP Types
  ;; ============================================================

  (fn infer-map-key-c-type-from-slop-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Infer C type of map key from a SLOP type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (if (== (string-len slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias ctx slop-type))
              (key-slop-type (extract-map-key-from-slop-type arena resolved-type)))
          (if (> (string-len key-slop-type) 0)
            (slop-value-type-to-c-type ctx key-slop-type)
            (let ((elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
              (if (> (string-len elem-slop-type) 0)
                (slop-value-type-to-c-type ctx elem-slop-type)
                "")))))))

  (fn infer-set-elem-c-type-from-slop-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Infer C type of set element from a SLOP type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (if (== (string-len slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias ctx slop-type))
              (elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
          (if (> (string-len elem-slop-type) 0)
            (slop-value-type-to-c-type ctx elem-slop-type)
            "")))))

  (fn extract-map-value-from-inferred ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Extract map value type by inferring the expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (inferred-slop-type (infer-expr-slop-type ctx map-expr)))
      (if (== (string-len inferred-slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias ctx inferred-slop-type)))
          (extract-map-value-from-slop-type arena resolved-type)))))

  (fn extract-list-elem-from-inferred ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)))
    (@intent "Extract list element type by inferring the expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (inferred-slop-type (infer-expr-slop-type ctx list-expr)))
      (if (== (string-len inferred-slop-type) 0)
        ""
        (if (starts-with inferred-slop-type "(List ")
          (let ((elem-len (- (- (string-len inferred-slop-type) 6) 1)))
            (if (> elem-len 0)
              (substring arena inferred-slop-type 6 (cast (Int 0 ..) elem-len))
              ""))
          ""))))

  (fn infer-map-key-c-type ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Infer the C type of a map's key type from variable lookup")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref map-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve type aliases and extract key type
                    (let ((resolved-type (resolve-type-alias ctx slop-type))
                          (key-slop-type (extract-map-key-from-slop-type arena resolved-type)))
                      (if (> (string-len key-slop-type) 0)
                        (slop-value-type-to-c-type ctx key-slop-type)
                        ;; Try set element type if not a map
                        (let ((elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
                          (if (> (string-len elem-slop-type) 0)
                            (slop-value-type-to-c-type ctx elem-slop-type)
                            ""))))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Non-symbol expression (field access, match binding, etc.) - use fallback inference
        (_ (infer-map-key-c-type-from-slop-type ctx (infer-expr-slop-type ctx map-expr))))))

  (fn extract-set-elem-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract element type from '(Set T)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Set Int)" -> "Int" or "(Set Term)" -> "Term"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 7)
        ""
        ;; Check for "(Set " prefix (5 chars)
        (if (not (starts-with slop-type "(Set "))
          ""
          ;; Element type starts at position 5 and goes to the closing paren
          (let ((elem-start 5)
                (elem-len (- (- len 1) elem-start)))  ;; len - 1 to skip closing paren
            (if (> elem-len 0)
              (substring arena slop-type (cast (Int 0 ..) elem-start) (cast (Int 0 ..) elem-len))
              ""))))))

  (fn infer-set-elem-c-type ((ctx (Ptr TranspileContext)) (set-expr (Ptr SExpr)))
    (@intent "Infer the C type of a set's element type from variable lookup")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {set-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref set-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve type aliases and extract element type
                    (let ((resolved-type (resolve-type-alias ctx slop-type))
                          (elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
                      (if (> (string-len elem-slop-type) 0)
                        (slop-value-type-to-c-type ctx elem-slop-type)
                        ""))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Non-symbol expression (field access, match binding, etc.) - use fallback inference
        (_ (infer-set-elem-c-type-from-slop-type ctx (infer-expr-slop-type ctx set-expr))))))

  (fn compound-slop-type-to-id ((arena Arena) (slop-type String))
    (@intent "Convert compound SLOP type string to C identifier for container naming")
    (@spec ((Arena String) -> String))
    ;; Handle compound types: (Set T), (Map K V), (List T), (Option T), (Ptr T)
    ;; Returns a valid C identifier component
    (cond
      ;; (Set T) -> set_<T-id>
      ((starts-with slop-type "(Set ")
        (let ((inner (extract-set-elem-from-slop-type arena slop-type)))
          (if (> (string-len inner) 0)
            (string-concat arena "set_" (slop-value-type-to-option-id arena inner))
            (to-c-name arena slop-type))))
      ;; (Map K V) -> map_<K-id>_<V-id>
      ((starts-with slop-type "(Map ")
        (let ((key-type (extract-map-key-from-slop-type arena slop-type))
              (val-type (extract-map-value-from-slop-type arena slop-type)))
          (if (and (> (string-len key-type) 0) (> (string-len val-type) 0))
            (string-concat arena "map_"
              (string-concat arena (slop-value-type-to-option-id arena key-type)
                (string-concat arena "_" (slop-value-type-to-option-id arena val-type))))
            (to-c-name arena slop-type))))
      ;; (List T) -> list_<T-id>
      ((starts-with slop-type "(List ")
        (let ((len (string-len slop-type)))
          (if (< len 8)
            (to-c-name arena slop-type)
            (let ((inner-start 6)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena "list_" (slop-value-type-to-option-id arena inner)))
                (to-c-name arena slop-type))))))
      ;; (Option T) -> option_<T-id>
      ((starts-with slop-type "(Option ")
        (let ((len (string-len slop-type)))
          (if (< len 10)
            (to-c-name arena slop-type)
            (let ((inner-start 8)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena "option_" (slop-value-type-to-option-id arena inner)))
                (to-c-name arena slop-type))))))
      ;; (Ptr T) -> <T-id>_ptr
      ((starts-with slop-type "(Ptr ")
        (let ((len (string-len slop-type)))
          (if (< len 7)
            (to-c-name arena slop-type)
            (let ((inner-start 5)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena (slop-value-type-to-option-id arena inner) "_ptr"))
                (to-c-name arena slop-type))))))
      ;; Unknown compound type - fall back to to-c-name
      (else (to-c-name arena slop-type))))

  (fn slop-value-type-to-option-id ((arena Arena) (slop-type String))
    (@intent "Convert SLOP value type name to option type identifier component")
    (@spec ((Arena String) -> String))
    ;; Map common SLOP types to option type identifiers
    (cond
      ((string-eq slop-type "Int") "int")
      ((string-eq slop-type "I8") "int8_t")
      ((string-eq slop-type "I16") "int16_t")
      ((string-eq slop-type "I32") "int32_t")
      ((string-eq slop-type "I64") "int64_t")
      ((string-eq slop-type "U8") "uint8_t")
      ((string-eq slop-type "U16") "uint16_t")
      ((string-eq slop-type "U32") "uint32_t")
      ((string-eq slop-type "U64") "uint64_t")
      ((string-eq slop-type "Char") "char")
      ((string-eq slop-type "Float") "double")
      ((string-eq slop-type "F32") "float")
      ((string-eq slop-type "Bool") "uint8_t")
      ((string-eq slop-type "String") "string")
      ((string-eq slop-type "Bytes") "bytes")
      ;; Compound types starting with ( need special handling
      ((starts-with slop-type "(")
        (compound-slop-type-to-id arena slop-type))
      ;; User-defined types - convert to C identifier format
      (else (to-c-name arena slop-type))))

  (fn infer-map-value-option-type ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a map value (for map-get)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref map-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve alias and extract value type
                    (let ((resolved-type (resolve-type-alias ctx slop-type))
                          (value-slop-type (extract-map-value-from-slop-type arena resolved-type)))
                      (if (> (string-len value-slop-type) 0)
                        ;; Got value type - check if it resolves to a container (pointer in C)
                        (let ((resolved-value (resolve-type-alias ctx value-slop-type)))
                          (if (or (starts-with resolved-value "(Map ")
                                  (or (starts-with resolved-value "(Set ")
                                      (starts-with resolved-value "(List ")))
                            ;; Container types are pointers in C
                            "slop_option_ptr"
                            ;; Convert to option type name
                            (let ((option-id (slop-value-type-to-option-id arena value-slop-type)))
                              (ctx-str ctx "slop_option_" option-id))))
                        ;; Couldn't extract value type
                        ""))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Other expressions (field access, deref, etc.) - use infer-expr-slop-type
        (_ (let ((slop-type (infer-expr-slop-type ctx map-expr)))
             (if (> (string-len slop-type) 0)
               ;; Resolve type alias before extracting map value type
               (let ((resolved-type (resolve-type-alias ctx slop-type))
                     (value-slop-type (extract-map-value-from-slop-type arena resolved-type)))
                 (if (> (string-len value-slop-type) 0)
                   ;; Check if value type resolves to a container (pointer in C)
                   (let ((resolved-value (resolve-type-alias ctx value-slop-type)))
                     (if (or (starts-with resolved-value "(Map ")
                             (or (starts-with resolved-value "(Set ")
                                 (starts-with resolved-value "(List ")))
                       ;; Container types are pointers in C
                       "slop_option_ptr"
                       (let ((option-id (slop-value-type-to-option-id arena value-slop-type)))
                         (ctx-str ctx "slop_option_" option-id))))
                   ""))
               ""))))))

  (fn option-type-to-value-c-type ((arena Arena) (option-type String))
    (@intent "Extract value C type from slop_option_<type> string")
    (@spec ((Arena String) -> String))
    (cond
      ((string-eq option-type "slop_option_int") "int64_t")
      ((string-eq option-type "slop_option_string") "slop_string")
      ((string-eq option-type "slop_option_bool") "uint8_t")
      ((string-eq option-type "slop_option_double") "double")
      ((string-eq option-type "slop_option_char") "char")
      ((string-eq option-type "slop_option_u8") "uint8_t")
      ((string-eq option-type "slop_option_ptr") "void*")
      ((starts-with option-type "slop_option_")
        (let ((extracted (substring-after-prefix arena option-type "slop_option_")))
          ;; Handle set_ types - sets are implemented as slop_map*
          (if (starts-with extracted "set_")
            "slop_map*"
            extracted)))
      (else "void")))

  (fn infer-option-inner-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Infer the inner SLOP type of an Option from the scrutinee expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; General approach: use infer-expr-slop-type, resolve aliases, extract inner from (Option T)
      (let ((expr-type (infer-expr-slop-type ctx scrutinee)))
        (let ((resolved (if (> (string-len expr-type) 0)
                          (resolve-type-alias ctx expr-type)
                          "")))
          (if (starts-with resolved "(Option ")
            (let ((len (string-len resolved)))
              (if (> len 9)
                (let ((inner-len (- (- (cast Int len) 8) 1)))
                  (if (> inner-len 0)
                    (substring arena resolved 8 (cast (Int 0 ..) inner-len))
                    ""))
                ""))
            ;; Fallback for map-get/list-get which return Option implicitly
            (match (deref scrutinee)
              ((lst lst)
                (let ((items (. lst items))
                      (len (list-len items)))
                  (if (< len 2)
                    ""
                    (match (list-get items 0)
                      ((some head-expr)
                        (match (deref head-expr)
                          ((sym sym)
                            (let ((op (. sym name)))
                              (cond
                                ((string-eq op "map-get")
                                  (if (< len 2)
                                    ""
                                    (match (list-get items 1)
                                      ((some map-expr)
                                        (match (deref map-expr)
                                          ((sym map-sym)
                                            (let ((map-name (. map-sym name)))
                                              (match (ctx-lookup-var ctx map-name)
                                                ((some var-entry)
                                                  (let ((slop-type (. var-entry slop-type)))
                                                    (if (> (string-len slop-type) 0)
                                                      (let ((resolved-type (resolve-type-alias ctx slop-type)))
                                                        (let ((value-type (extract-map-value-from-slop-type arena resolved-type)))
                                                          (resolve-type-alias ctx value-type)))
                                                      "")))
                                                ((none) ""))))
                                          (_ (extract-map-value-from-inferred ctx map-expr))))
                                      ((none) ""))))
                                ((string-eq op "list-get")
                                  (if (< len 2)
                                    ""
                                    (match (list-get items 1)
                                      ((some list-expr)
                                        (match (deref list-expr)
                                          ((sym list-sym)
                                            (let ((list-name (. list-sym name)))
                                              (match (ctx-lookup-var ctx list-name)
                                                ((some var-entry)
                                                  (let ((slop-type (. var-entry slop-type)))
                                                    (if (starts-with slop-type "(List ")
                                                      (let ((elem-len (- (- (string-len slop-type) 6) 1)))
                                                        (if (> elem-len 0)
                                                          (substring arena slop-type 6 (cast (Int 0 ..) elem-len))
                                                          ""))
                                                      "")))
                                                ((none) ""))))
                                          (_ (extract-list-elem-from-inferred ctx list-expr))))
                                      ((none) ""))))
                                (else ""))))
                          (_ "")))
                      ((none) "")))))
              (_ "")))))))

  ;; ============================================================
  ;; Ternary None Fix Helper
  ;; ============================================================

  (fn fix-ternary-none ((ctx (Ptr TranspileContext)) (other-branch String) (this-branch String))
    (@intent "Fix type mismatch when one ternary branch is 'none' and other is typed option")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; If this-branch is "none" and other-branch looks like a typed option,
    ;; return typed none
    (if (and (string-eq this-branch "none")
             (starts-with other-branch "(slop_option_"))
      ;; Extract option type from other-branch: "(slop_option_X){..."
      (let ((arena (. (deref ctx) arena)))
        (match (extract-option-type arena other-branch)
          ((some opt-type)
            (ctx-str3 ctx "(" opt-type "){.has_value = false}"))
          ((none) this-branch)))
      this-branch))

  (fn extract-option-type ((arena Arena) (s String))
    (@intent "Extract option type name from '(slop_option_X){...'")
    (@spec ((Arena String) -> (Option String)))
    ;; String format: (TYPE){...}
    ;; We want to extract TYPE without the ( and )
    (if (< (string-len s) 15)
      (none)
      (let ((mut i 1)  ;; skip leading (
            (len (string-len s))
            (mut found-brace false)
            (mut end-idx 0))
        ;; Find the { that ends the type name (ASCII 123)
        (while (and (< i len) (not found-brace))
          (if (== (char-at s (cast (Int 0 ..) i)) 123)  ;; '{' = 123
            (do
              (set! found-brace true)
              (set! end-idx (- i 2)))  ;; exclude both the ) before { and account for 0-index
            (set! i (+ i 1))))
        (if found-brace
          (some (substring arena s 1 (cast (Int 0 ..) end-idx)))
          (none)))))

  ;; ============================================================
  ;; Array Index Helper
  ;; ============================================================

  (fn transpile-array-index ((ctx (Ptr TranspileContext)) (arr-expr (Ptr SExpr)) (arr-c String) (idx-c String))
    (@intent "Transpile array indexing, handling struct types that need .data access")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String String) -> String))
    (@pre {ctx != nil})
    (@pre {arr-expr != nil})
    ;; Check if the array is a variable with a known type
    (match (deref arr-expr)
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type)))
                ;; Check for string/list types that have .data field
                (if (or (string-eq c-type "slop_string")
                        (string-eq c-type "string")
                        (starts-with c-type "slop_list_"))
                  (ctx-str5 ctx "(" arr-c ").data[" idx-c "]")
                  (ctx-str4 ctx arr-c "[" idx-c "]"))))
            ;; No type info - use simple indexing
            ((none) (ctx-str4 ctx arr-c "[" idx-c "]")))))
      ;; Non-symbol - just use simple indexing
      (_ (ctx-str4 ctx arr-c "[" idx-c "]"))))

  ;; ============================================================
  ;; Pointer Expression Detection
  ;; ============================================================

  (fn is-pointer-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression evaluates to a pointer type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Look up variable type in context
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type)))
                (ends-with c-type "*")))
            ((none) false))))
      ((lst lst)
        (let ((items (. lst items)))
          ;; Check for specific pointer-returning forms
          (if (>= (list-len items) 1)
            (match (list-get items 0)
              ((some head-ptr)
                (match (deref head-ptr)
                  ((sym head-sym)
                    (let ((op (. head-sym name)))
                      ;; deref returns value, addr returns pointer, cast to Ptr returns pointer
                      (cond
                        ((string-eq op "deref") false)
                        ((string-eq op "addr") true)
                        ((string-eq op "arena-alloc") true)
                        ;; cast to pointer type returns pointer
                        ((and (string-eq op "cast") (>= (list-len items) 2))
                          (match (list-get items 1)
                            ((some type-expr) (is-pointer-type-expr type-expr))
                            ((none) false)))
                        (else false))))
                  (_ false)))
              ((none) false))
            false)))
      (_ false)))

  ;; ============================================================
  ;; sizeof Type Extraction for arena-alloc
  ;; ============================================================

  (fn extract-sizeof-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract type from (sizeof Type) expression or nested within arithmetic, or return uint8_t")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (>= len 2)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((sym head-sym)
                      (let ((op (. head-sym name)))
                        (cond
                          ;; Direct sizeof - extract type
                          ((string-eq op "sizeof")
                            (match (list-get items 1)
                              ((some type-expr)
                                (to-c-type-prefixed ctx type-expr))
                              ((none) "uint8_t")))
                          ;; Arithmetic ops - search recursively for sizeof
                          ((or (string-eq op "*") (or (string-eq op "+") (or (string-eq op "-") (string-eq op "/"))))
                            ;; Search each operand for sizeof
                            (let ((mut i 1)
                                  (mut found "uint8_t"))
                              (while (< i len)
                                (match (list-get items i)
                                  ((some arg-expr)
                                    (let ((result (extract-sizeof-type ctx arg-expr)))
                                      (when (not (string-eq result "uint8_t"))
                                        (set! found result))))
                                  ((none) (do)))
                                (set! i (+ i 1)))
                              found))
                          (else "uint8_t"))))
                    (_ "uint8_t")))
                ((none) "uint8_t"))
              "uint8_t")))
        (_ "uint8_t"))))

  ;; ============================================================
  ;; Main Expression Transpilation
  ;; ============================================================

  (fn transpile-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a SLOP expression to C code")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ;; Literals
      ((num _) (transpile-literal ctx expr))
      ((str _) (transpile-literal ctx expr))
      ((sym _) (transpile-literal ctx expr))
      ;; List expressions (function calls, operators, etc.)
      ((lst lst)
        (transpile-list-expr ctx (. lst items)))))

  (fn transpile-list-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a list expression")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 1)
        (do
          (ctx-add-error-at ctx "empty list" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 0)
          ((some head-expr)
            (match (deref head-expr)
              ;; Symbol head - could be operator or function call
              ((sym head-sym)
                (let ((op (. head-sym name)))
                  (cond
                    ;; Binary operators with insufficient operands
                    ((and (is-binop op) (< len 3))
                      (do
                        (ctx-add-error-at ctx "binary operator needs at least 2 operands" (ctx-list-first-line items) (ctx-list-first-col items))
                        "0"))
                    ;; Binary operators (all are variadic - can chain: (- a b c) = a - b - c)
                    ((and (is-binop op) (>= len 3))
                      ;; More than 2 operands: chain all with same operator
                      (if (> len 3)
                        ;; Variadic: chain all operands
                        (transpile-variadic-binop ctx op items 1)
                        ;; Binary: just 2 operands
                        (match (list-get items 1)
                          ((some left)
                            (match (list-get items 2)
                              ((some right)
                                (let ((left-c (transpile-expr ctx left))
                                      (right-c (transpile-expr ctx right)))
                                  (transpile-binop ctx op left-c right-c)))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "missing right operand" (ctx-list-first-line items) (ctx-list-first-col items))
                                  "0"))))
                          ((none)
                            (do
                              (ctx-add-error-at ctx "missing left operand" (ctx-list-first-line items) (ctx-list-first-col items))
                              "0")))))
                    ;; Comparison operators with insufficient operands
                    ((and (is-comparison-op op) (< len 3))
                      (do
                        (ctx-add-error-at ctx "comparison operator needs 2 operands" (ctx-list-first-line items) (ctx-list-first-col items))
                        "0"))
                    ;; Comparison operators
                    ((and (is-comparison-op op) (>= len 3))
                      (match (list-get items 1)
                        ((some left)
                          (match (list-get items 2)
                            ((some right)
                              (let ((left-c (transpile-expr ctx left))
                                    (right-c (transpile-expr ctx right)))
                                (transpile-binop ctx op left-c right-c)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing right operand" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing left operand" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; not with no argument
                    ((and (string-eq op "not") (< len 2))
                      (do
                        (ctx-add-error-at ctx "not needs an argument" (ctx-list-first-line items) (ctx-list-first-col items))
                        "0"))
                    ;; not (unary)
                    ((and (string-eq op "not") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "!(" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; if expression with insufficient branches
                    ((and (string-eq op "if") (< len 4))
                      (do
                        (ctx-add-error-at ctx "if expression needs condition, then, and else branches" (ctx-list-first-line items) (ctx-list-first-col items))
                        "0"))
                    ;; if expression: (if cond then else) -> (cond) ? then : else
                    ((and (string-eq op "if") (>= len 4))
                      (match (list-get items 1)
                        ((some cond-expr)
                          (match (list-get items 2)
                            ((some then-expr)
                              (match (list-get items 3)
                                ((some else-expr)
                                  (let ((cond-c (transpile-expr ctx cond-expr))
                                        (then-c (transpile-expr ctx then-expr))
                                        (else-c (transpile-expr ctx else-expr)))
                                    ;; Fix type mismatch when one branch is typed option and other is none
                                    (let ((final-else (fix-ternary-none ctx then-c else-c))
                                          (final-then (fix-ternary-none ctx else-c then-c)))
                                      (ctx-str5 ctx "((" cond-c ") ? " (ctx-str3 ctx final-then " : " final-else) ")"))))
                                ((none)
                                  (do
                                    (ctx-add-error-at ctx "missing else" (ctx-list-first-line items) (ctx-list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing then" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing condition" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; let/let* as expression: use GCC statement expression
                    ((and (or (string-eq op "let") (string-eq op "let*")) (>= len 3))
                      (transpile-let-expr ctx items))
                    ;; while as expression (side effect only, returns 0)
                    ((and (string-eq op "while") (>= len 3))
                      (transpile-while-expr ctx items))
                    ;; Annotations (@loop-invariant, @property, etc.) - no-op, returns 0
                    ;; (bare "@" is array indexing, handled below)
                    ((and (starts-with op "@") (not (string-eq op "@")))
                      "0")
                    ;; do as expression: sequence, returns last value
                    ((and (string-eq op "do") (>= len 1))
                      (transpile-do-expr ctx items))
                    ;; when as expression: (when cond body) -> ((cond) ? ({ body; (void)0; }) : 0)
                    ((and (string-eq op "when") (>= len 2))
                      (transpile-when-expr ctx items))
                    ;; set! as expression (side effect, returns 0)
                    ((and (string-eq op "set!") (>= len 3))
                      (transpile-set-expr ctx items))
                    ;; match expression: use GCC statement expression
                    ((and (string-eq op "match") (>= len 3))
                      (transpile-match-expr ctx items))
                    ;; deref: (deref ptr) -> (*ptr)
                    ((and (string-eq op "deref") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "(*" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; Field access: (. obj field)
                    ((and (string-eq op ".") (>= len 3))
                      (match (list-get items 1)
                        ((some obj)
                          (match (list-get items 2)
                            ((some field-expr)
                              (match (deref field-expr)
                                ((sym field-sym)
                                  (let ((obj-c (transpile-expr ctx obj))
                                        (field-c (to-c-name arena (. field-sym name)))
                                        (is-ptr (is-pointer-expr ctx obj)))
                                    (if is-ptr
                                      (ctx-str3 ctx obj-c "->" field-c)
                                      (ctx-str3 ctx obj-c "." field-c))))
                                (_
                                  (do
                                    (ctx-add-error-at ctx "invalid field" (ctx-list-first-line items) (ctx-list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing field" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing object" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; cast: (cast Type expr)
                    ((and (string-eq op "cast") (>= len 3))
                      (match (list-get items 1)
                        ((some type-expr)
                          (match (list-get items 2)
                            ((some val-expr)
                              (let ((val-c (transpile-expr ctx val-expr)))
                                (cond
                                  ;; Direction 1: Cast TO (Fn ...) - use function pointer type
                                  ((is-fn-type-expr type-expr)
                                    (let ((fn-ptr-type (fn-type-to-c-fn-ptr ctx type-expr)))
                                      (ctx-str ctx "((" (ctx-str ctx fn-ptr-type (ctx-str ctx ")(" (ctx-str ctx val-c "))"))))))
                                  ;; Direction 2: Cast closure to (Ptr Void) - extract .fn
                                  ((and (is-ptr-void-type type-expr) (is-closure-typed-expr ctx val-expr))
                                    (ctx-str ctx "((void*)(" (ctx-str ctx val-c ".fn))")))
                                  ;; Normal cast (with string literal handling)
                                  (else
                                    (let ((c-type (to-c-type-prefixed ctx type-expr))
                                          (is-ptr-cast (is-pointer-type-expr type-expr))
                                          (is-str-literal (is-string-literal val-expr)))
                                      ;; When casting a string literal to pointer, use .data
                                      (if (and is-ptr-cast is-str-literal)
                                        (ctx-str ctx "((" (ctx-str ctx c-type (ctx-str ctx ")(" (ctx-str ctx val-c ".data))"))))
                                        (ctx-str5 ctx "((" c-type ")(" val-c "))")))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing cast value" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing cast type" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; c-inline: (c-inline "raw C code") -> raw C code
                    ((and (string-eq op "c-inline") (>= len 2))
                      (match (list-get items 1)
                        ((some str-expr)
                          (match (deref str-expr)
                            ((str str) (. str value))
                            (else
                              (do
                                (ctx-add-error-at ctx "c-inline requires string" (ctx-list-first-line items) (ctx-list-first-col items))
                                ""))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing c-inline string" (ctx-list-first-line items) (ctx-list-first-col items))
                            ""))))
                    ;; some: (some value) for Option
                    ((and (string-eq op "some") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr))
                                ;; Use infer-expr-c-type for more accurate type inference
                                (val-type (infer-expr-c-type ctx val-expr))
                                (option-type (cond
                                               ;; Check for type inference error marker
                                               ((string-eq val-type "__type_error__")
                                                 (do
                                                   (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "'") (ctx-sexpr-line val-expr) (ctx-sexpr-col val-expr))
                                                   "__type_error__"))
                                               ((string-eq val-type "slop_string") "slop_option_string")
                                               ((string-eq val-type "int64_t") "slop_option_int")
                                               ((string-eq val-type "double") "slop_option_double")
                                               ;; For auto/unknown type, emit error
                                               ((string-eq val-type "auto")
                                                 (do
                                                   (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "' - type is 'auto'") (ctx-sexpr-line val-expr) (ctx-sexpr-col val-expr))
                                                   "__type_error__"))
                                               (else (infer-option-type ctx val-expr)))))
                            ;; Check if option-type is an error
                            (if (or (string-eq option-type "__type_error__") (starts-with option-type "/*"))
                              ;; Error in type inference - return placeholder
                              (do
                                (when (starts-with option-type "/*")
                                  (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "'") (ctx-sexpr-line val-expr) (ctx-sexpr-col val-expr)))
                                "(slop_option_int){.has_value = 0}")
                              ;; Typed option construction
                              (ctx-str5 ctx "(" option-type "){.has_value = 1, .value = " val-c "}"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing some value" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; sizeof: (sizeof Type) -> sizeof(c_type)
                    ((and (string-eq op "sizeof") (>= len 2))
                      (match (list-get items 1)
                        ((some type-expr)
                          (let ((c-type (to-c-type-prefixed ctx type-expr)))
                            (ctx-str3 ctx "sizeof(" c-type ")")))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing sizeof type" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; addr: (addr x) -> (&x)
                    ((and (string-eq op "addr") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "(&" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing addr argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; @ array indexing: (@ arr i) -> arr[i]
                    ((and (string-eq op "@") (>= len 3))
                      (match (list-get items 1)
                        ((some arr-expr)
                          (match (list-get items 2)
                            ((some idx-expr)
                              (let ((arr-c (transpile-expr ctx arr-expr))
                                    (idx-c (transpile-expr ctx idx-expr)))
                                ;; Check if array is a struct type (string/list) needing .data
                                (transpile-array-index ctx arr-expr arr-c idx-c)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing index" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing array" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; arena-alloc: (arena-alloc arena size) -> (Type*)slop_arena_alloc(arena, size)
                    ;; Special case: (arena-alloc arena TypeName) -> (Type*)slop_arena_alloc(arena, sizeof(Type))
                    ((and (string-eq op "arena-alloc") (>= len 3))
                      (match (list-get items 1)
                        ((some arena-expr)
                          (match (list-get items 2)
                            ((some size-expr)
                              (let ((arena-c (transpile-expr ctx arena-expr)))
                                ;; Check if size-expr is a bare type symbol (known type)
                                (match (deref size-expr)
                                  ((sym sym)
                                    (let ((type-name (. sym name)))
                                      (match (ctx-lookup-type ctx type-name)
                                        ((some entry)
                                          ;; Known type - generate sizeof(prefixed_type)
                                          ;; Output: ((TYPE*)slop_arena_alloc(arena, sizeof(TYPE)))
                                          (let ((c-type (. entry c-name)))
                                            (wrap-arena-alloc-checked ctx (ctx-str ctx "((" (ctx-str ctx c-type (ctx-str ctx "*)slop_arena_alloc(" (ctx-str ctx arena-c (ctx-str ctx ", sizeof(" (ctx-str ctx c-type ")))")))))))))
                                        ((none)
                                          ;; Not a registered type - use normal transpilation
                                          (let ((size-c (transpile-expr ctx size-expr))
                                                (cast-type (extract-sizeof-type ctx size-expr)))
                                            (wrap-arena-alloc-checked ctx (ctx-str5 ctx "(" cast-type "*)slop_arena_alloc(" (ctx-str3 ctx arena-c ", " size-c) ")")))))))
                                  (else
                                    ;; Not a symbol - use normal transpilation
                                    (let ((size-c (transpile-expr ctx size-expr))
                                          (cast-type (extract-sizeof-type ctx size-expr)))
                                      (wrap-arena-alloc-checked ctx (ctx-str5 ctx "(" cast-type "*)slop_arena_alloc(" (ctx-str3 ctx arena-c ", " size-c) ")")))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing arena-alloc size" (ctx-list-first-line items) (ctx-list-first-col items))
                                "NULL"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing arena argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "NULL"))))
                    ;; quote: (quote variant) -> EnumType_variant
                    ((and (string-eq op "quote") (>= len 2))
                      (match (list-get items 1)
                        ((some variant-expr)
                          (match (deref variant-expr)
                            ((sym sym)
                              ;; Enum variant - look up the type and emit prefixed name
                              (let ((variant-name (. sym name)))
                                (transpile-enum-variant ctx variant-name)))
                            (else
                              (do
                                (ctx-add-error-at ctx "quote requires symbol" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing quote argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; record-new: (record-new Type (field1 val1) (field2 val2) ...) -> ((Type){.f1 = v1, ...})
                    ((and (string-eq op "record-new") (>= len 2))
                      (transpile-record-new ctx items))
                    ;; list: (list Type elem1 elem2 ...) -> inline list literal
                    ((and (string-eq op "list") (>= len 2))
                      (transpile-list-literal ctx items))
                    ;; map-new: (map-new arena KeyType ValueType) -> slop_map_new_ptr(arena, 16)
                    ((and (string-eq op "map-new") (>= len 2))
                      (transpile-map-new ctx items))
                    ;; map-put: (map-put map key val) -> slop_map_put(arena, map, key, &val)
                    ((and (string-eq op "map-put") (>= len 4))
                      (transpile-map-put ctx items))
                    ;; map-get: (map-get map key) -> slop_map_get(map, key)
                    ((and (string-eq op "map-get") (>= len 3))
                      (transpile-map-get ctx items))
                    ;; map-has: (map-has map key) -> (slop_map_get(map, key) != NULL)
                    ((and (string-eq op "map-has") (>= len 3))
                      (transpile-map-has ctx items))
                    ;; map-keys: (map-keys map) -> slop_map_keys(map)
                    ((and (string-eq op "map-keys") (>= len 2))
                      (transpile-map-keys ctx items))
                    ;; set: (set Type e1 e2...) -> set literal
                    ((and (string-eq op "set") (>= len 2))
                      (transpile-set-literal ctx items))
                    ;; set-new: (set-new arena ElementType) -> slop_map_new_ptr for Set
                    ((and (string-eq op "set-new") (>= len 3))
                      (transpile-set-new ctx items))
                    ;; set-put: (set-put set element) -> slop_map_put with dummy value
                    ((and (string-eq op "set-put") (>= len 3))
                      (transpile-set-put ctx items))
                    ;; set-has: (set-has set element) -> slop_map_has
                    ((and (string-eq op "set-has") (>= len 3))
                      (transpile-set-has ctx items))
                    ;; set-remove: (set-remove set element) -> slop_map_remove
                    ((and (string-eq op "set-remove") (>= len 3))
                      (transpile-set-remove ctx items))
                    ;; set-elements: (set-elements set) -> get elements as list
                    ((and (string-eq op "set-elements") (>= len 2))
                      (transpile-set-elements ctx items))
                    ;; union-new: (union-new Type tag value?) -> ((Type){ .tag = Type_tag, .data.tag = value })
                    ;; tag can be bare symbol or quoted symbol like 'literal
                    ((and (string-eq op "union-new") (>= len 3))
                      (match (list-get items 1)
                        ((some type-expr)
                          (match (list-get items 2)
                            ((some tag-expr)
                              (match (deref type-expr)
                                ((sym type-sym)
                                  ;; Extract tag name from either bare symbol or (quote symbol)
                                  (match (extract-symbol-name tag-expr)
                                    ((some tag-str)
                                      ;; Look up registered type to get proper c-name with module prefix
                                      (let ((raw-type-name (. type-sym name))
                                            (type-name (match (ctx-lookup-type ctx raw-type-name)
                                                         ((some entry) (. entry c-name))
                                                         ((none) (to-c-name arena raw-type-name))))
                                            (tag-name (to-c-name arena tag-str))
                                            ;; Build tag constant: Type_tag
                                            (tag-const (ctx-str ctx type-name (ctx-str ctx "_" tag-name))))
                                        ;; Check for optional value
                                        (if (>= len 4)
                                          (match (list-get items 3)
                                            ((some val-expr)
                                              (let ((val-c (transpile-expr ctx val-expr)))
                                                ;; ((Type){ .tag = Type_tag, .data.tag = value })
                                                (ctx-str3 ctx "((" type-name (ctx-str3 ctx "){ .tag = " tag-const (ctx-str5 ctx ", .data." tag-name " = " val-c " })")))))
                                            ((none)
                                              (do
                                                (ctx-add-error-at ctx "missing union value" (ctx-list-first-line items) (ctx-list-first-col items))
                                                "0")))
                                          ;; No value - just tag: ((Type){ .tag = Type_tag })
                                          (ctx-str3 ctx "((" type-name (ctx-str3 ctx "){ .tag = " tag-const " })")))))
                                    ((none)
                                      (do
                                        (ctx-add-error-at ctx "union-new tag must be symbol" (ctx-list-first-line items) (ctx-list-first-col items))
                                        "0"))))
                                (_
                                  (do
                                    (ctx-add-error-at ctx "union-new type must be symbol" (ctx-list-first-line items) (ctx-list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing union tag" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing union type" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; ok: (ok value) -> (ResultType){.tag = SLOP_OK, .ok = value}
                    ((and (string-eq op "ok") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr)))
                            (transpile-ok ctx val-c)))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing ok value" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; error: (error value) -> (ResultType){.tag = SLOP_ERR, .err = value}
                    ((and (string-eq op "error") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr)))
                            (transpile-error ctx val-c)))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing error value" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; ?: (? result-expr) -> propagation (returns early on error)
                    ((and (string-eq op "?") (>= len 2))
                      (match (list-get items 1)
                        ((some result-expr)
                          (let ((result-c (transpile-expr ctx result-expr)))
                            (match (ctx-get-current-result-type ctx)
                              ((some enclosing-type)
                                ;; Convert error to enclosing function's result type
                                (ctx-str5 ctx "({ __auto_type _tmp = " result-c "; if (!_tmp.is_ok) return ((" enclosing-type
                                          "){ .is_ok = false, .data.err = _tmp.data.err }); _tmp.data.ok; })"))
                              ((none)
                                ;; No enclosing result type - use direct return (fallback)
                                (ctx-str3 ctx "({ __auto_type _tmp = " result-c "; if (!_tmp.is_ok) return _tmp; _tmp.data.ok; })")))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing ? argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; list-len: (list-len list) -> ((int64_t)(list.len))
                    ((and (string-eq op "list-len") (>= len 2))
                      (match (list-get items 1)
                        ((some list-expr)
                          (let ((list-c (transpile-expr ctx list-expr)))
                            (ctx-str3 ctx "((int64_t)((" list-c ").len))")))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-len argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; list-get: (list-get list idx) -> inline option expression
                    ((and (string-eq op "list-get") (>= len 3))
                      (match (list-get items 1)
                        ((some list-expr)
                          (match (list-get items 2)
                            ((some idx-expr)
                              (let ((list-c (transpile-expr ctx list-expr))
                                    (idx-c (transpile-expr ctx idx-expr))
                                    ;; Try to get the proper named option type for this list's elements
                                    (option-type (infer-list-element-option-type ctx list-expr)))
                                ;; If we have a named option type, use it; otherwise use anonymous struct
                                (if (> (string-len option-type) 0)
                                  ;; Named option type available
                                  (ctx-str ctx "({ __auto_type _lst = " (ctx-str ctx list-c
                                    (ctx-str ctx "; size_t _idx = (size_t)" (ctx-str ctx idx-c
                                      (ctx-str ctx "; " (ctx-str ctx option-type
                                        " _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; })"))))))
                                  ;; Fallback to anonymous struct with __typeof__
                                  (ctx-str ctx "({ __auto_type _lst = " (ctx-str ctx list-c
                                    (ctx-str ctx "; size_t _idx = (size_t)" (ctx-str ctx idx-c
                                      "; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; })")))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-get index" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-get list argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; list-pop: (list-pop list) -> Option<T> (removes and returns last element)
                    ((and (string-eq op "list-pop") (>= len 2))
                      (match (list-get items 1)
                        ((some list-expr)
                          (let ((list-c (transpile-expr ctx list-expr))
                                ;; Try to get the proper named option type for this list's elements
                                (option-type (infer-list-element-option-type ctx list-expr)))
                            ;; If we have a named option type, use it; otherwise use anonymous struct
                            (if (> (string-len option-type) 0)
                              ;; Named option type available
                              (ctx-str ctx "({ __auto_type _lst_p = &(" (ctx-str ctx list-c
                                (ctx-str ctx "); " (ctx-str ctx option-type
                                  " _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; })"))))
                              ;; Fallback to anonymous struct with __typeof__
                              (ctx-str ctx "({ __auto_type _lst_p = &(" (ctx-str ctx list-c
                                "); struct { bool has_value; __typeof__(_lst_p->data[0]) value; } _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; })")))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-pop list argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; list-new: (list-new arena Type) -> compound literal
                    ((and (string-eq op "list-new") (>= len 3))
                      (match (list-get items 1)
                        ((some arena-expr)
                          (match (list-get items 2)
                            ((some type-expr)
                              (let ((arena-c (transpile-expr ctx arena-expr))
                                    (elem-c-type (to-c-type-prefixed ctx type-expr))
                                    (elem-id (type-to-identifier arena elem-c-type))
                                    (list-type (ctx-str ctx "slop_list_" elem-id)))
                                ;; ((slop_list_Type){ .data = (Type*)slop_arena_alloc(arena, 16 * sizeof(Type)), .len = 0, .cap = 16 })
                                (ctx-str ctx "(("
                                  (ctx-str ctx list-type
                                    (ctx-str ctx "){ .data = ("
                                      (ctx-str ctx elem-c-type
                                        (ctx-str ctx "*)slop_arena_alloc("
                                          (ctx-str ctx arena-c
                                            (ctx-str ctx ", 16 * sizeof("
                                              (ctx-str ctx elem-c-type ")), .len = 0, .cap = 16 })"))))))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-new type argument" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-new arena argument" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; list-push: (list-push list item) -> inline push
                    ((and (string-eq op "list-push") (>= len 3))
                      (match (list-get items 1)
                        ((some list-expr)
                          (match (list-get items 2)
                            ((some item-expr)
                              (let ((list-c (transpile-expr ctx list-expr))
                                    (item-c (transpile-expr ctx item-expr))
                                    ;; Determine arena source from the list expression
                                    ;; If it's a struct field access, use struct->arena
                                    (arena-c (get-arena-for-list-push-expr ctx list-expr list-c)))
                                ;; ({ __auto_type _lst_p = &(list); __auto_type _item = item;
                                ;;    if (_lst_p->len >= _lst_p->cap) { ... grow ... }
                                ;;    _lst_p->data[_lst_p->len++] = _item; })
                                (let ((s1 (ctx-str ctx "({ __auto_type _lst_p = &(" list-c))
                                      (s2 (ctx-str ctx s1 "); __auto_type _item = ("))
                                      (s3 (ctx-str ctx s2 item-c))
                                      (s4 (ctx-str ctx s3 "); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc("))
                                      (s5 (ctx-str ctx s4 arena-c))
                                      (s6 (ctx-str ctx s5 ", _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; })")))
                                  s6)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-push item" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-push list" (ctx-list-first-line items) (ctx-list-first-col items))
                            "0"))))
                    ;; none constructor: (none) -> typed none if return type is known
                    ((and (string-eq op "none") (= len 1))
                      ;; Try to use function's return type for typed none
                      (match (ctx-get-current-return-type ctx)
                        ((some ret-type)
                          (if (starts-with ret-type "slop_option_")
                            (ctx-str3 ctx "((" ret-type "){.has_value = false})")
                            "none"))
                        ((none) "none")))
                    ;; cond expression: (cond (test body) ... (else body)) -> nested ternary
                    ((string-eq op "cond")
                      (transpile-cond-expr ctx items))
                    ;; for as expression: (for (i start end) body...) -> ({ for (...) {...} 0; })
                    ((string-eq op "for")
                      (transpile-for-as-expr ctx items))
                    ;; for-each as expression: (for-each (item coll) body...) -> ({ for (...) {...} 0; })
                    ((string-eq op "for-each")
                      (transpile-for-each-as-expr ctx items))
                    ;; Lambda expression: (fn ((params...)) body) -> generate static fn, return name
                    ;; Distinguish from named fn by checking if items[1] is a list (params) not a symbol (name)
                    ((string-eq op "fn")
                      (transpile-lambda-expr ctx items))
                    ;; Default: function call
                    (else
                      (transpile-fn-call ctx op items)))))
              ;; Non-symbol head - could be a function pointer variable call
              (_
                ;; Transpile head expression and call it with arguments
                (let ((head-c (transpile-expr ctx head-expr))
                      (mut args "")
                      (mut i 1))
                  (while (< i len)
                    (match (list-get items i)
                      ((some arg)
                        (let ((arg-c (transpile-expr ctx arg)))
                          (if (string-eq args "")
                            (set! args arg-c)
                            (set! args (ctx-str3 ctx args ", " arg-c)))))
                      ((none) (do)))
                    (set! i (+ i 1)))
                  (ctx-str5 ctx head-c "(" args ")" "")))))
          ((none)
            (do
              (ctx-add-error-at ctx "empty list" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn transpile-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile a function call with arguments")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      ;; Check for print/println builtins first
      (cond
        ((string-eq fn-name "println")
          (if (< len 2)
            "printf(\"\\n\")"
            (match (list-get items 1)
              ((some arg)
                (transpile-print ctx arg true))
              ((none) "printf(\"\\n\")"))))
        ((string-eq fn-name "print")
          (if (< len 2)
            (do
              (ctx-add-error-at ctx "print: missing argument" (ctx-list-first-line items) (ctx-list-first-col items))
              "0")
            (match (list-get items 1)
              ((some arg)
                (transpile-print ctx arg false))
              ((none)
                (do
                  (ctx-add-error-at ctx "print: missing argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0")))))
        ;; printf: FFI call to C's printf - string literals become raw C strings
        ((string-eq fn-name "printf")
          (transpile-printf-call ctx items))
        ;; string-new: (string-new arena "literal") - string literal arg must be raw C string
        ((string-eq fn-name "string-new")
          (transpile-raw-string-fn-call ctx fn-name items))
        ;; min: (min a b) -> ((a) < (b) ? (a) : (b))
        ((string-eq fn-name "min")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "min: need 2 arguments" (ctx-list-first-line items) (ctx-list-first-col items))
              "0")
            (match (list-get items 1)
              ((some a-expr)
                (match (list-get items 2)
                  ((some b-expr)
                    (let ((a-c (transpile-expr ctx a-expr))
                          (b-c (transpile-expr ctx b-expr))
                          (s1 (string-concat arena "((" a-c))
                          (s2 (string-concat arena s1 ") < ("))
                          (s3 (string-concat arena s2 b-c))
                          (s4 (string-concat arena s3 ") ? ("))
                          (s5 (string-concat arena s4 a-c))
                          (s6 (string-concat arena s5 ") : ("))
                          (s7 (string-concat arena s6 b-c))
                          (s8 (string-concat arena s7 "))")))
                      s8))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "min: missing second argument" (ctx-list-first-line items) (ctx-list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "min: missing first argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0")))))
        ;; max: (max a b) -> ((a) > (b) ? (a) : (b))
        ((string-eq fn-name "max")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "max: need 2 arguments" (ctx-list-first-line items) (ctx-list-first-col items))
              "0")
            (match (list-get items 1)
              ((some a-expr)
                (match (list-get items 2)
                  ((some b-expr)
                    (let ((a-c (transpile-expr ctx a-expr))
                          (b-c (transpile-expr ctx b-expr))
                          (s1 (string-concat arena "((" a-c))
                          (s2 (string-concat arena s1 ") > ("))
                          (s3 (string-concat arena s2 b-c))
                          (s4 (string-concat arena s3 ") ? ("))
                          (s5 (string-concat arena s4 a-c))
                          (s6 (string-concat arena s5 ") : ("))
                          (s7 (string-concat arena s6 b-c))
                          (s8 (string-concat arena s7 "))")))
                      s8))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "max: missing second argument" (ctx-list-first-line items) (ctx-list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "max: missing first argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0")))))
        ;; spawn: special handling for closures
        ;; (spawn arena closure) -> inline thread creation with env
        ((string-eq fn-name "spawn")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "spawn: need arena and function arguments" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL")
            (match (list-get items 2)
              ((some fn-expr)
                (if (is-capturing-lambda fn-expr)
                  ;; Capturing lambda - inline the thread creation with env
                  (transpile-spawn-closure ctx items fn-expr)
                  ;; Non-capturing - use regular spawn call
                  (transpile-regular-fn-call ctx fn-name items)))
              ((none)
                (do
                  (ctx-add-error-at ctx "spawn: missing function argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL")))))
        ;; send: type-specific channel send
        ;; (send chan value) -> thread_send_<chan_type>(chan, value)
        ((string-eq fn-name "send")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "send: need channel and value arguments" (ctx-list-first-line items) (ctx-list-first-col items))
              "0")
            (match (list-get items 1)
              ((some chan-expr)
                (match (list-get items 2)
                  ((some value-expr)
                    (let ((chan-c (transpile-expr ctx chan-expr))
                          (value-c (transpile-expr ctx value-expr))
                          (chan-c-type (infer-expr-c-type ctx chan-expr)))
                      ;; Extract channel struct type from pointer type (remove trailing *)
                      (let ((chan-type (strip-pointer-suffix arena chan-c-type)))
                        (if (and (starts-with chan-type "slop_chan_")
                                 (not (string-eq chan-type "slop_chan_int")))
                          ;; Custom channel type - use specialized function
                          (let ((s1 (ctx-str3 ctx "thread_send_" chan-type "("))
                                (s2 (ctx-str ctx s1 chan-c))
                                (s3 (ctx-str ctx s2 ", ")))
                            (ctx-str ctx s3 (ctx-str ctx value-c ")")))
                          ;; Default int channel - use standard function
                          (ctx-str5 ctx "thread_send(" chan-c ", " value-c ")")))))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "send: missing value argument" (ctx-list-first-line items) (ctx-list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "send: missing channel argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0")))))
        ;; recv: type-specific channel receive
        ;; (recv chan) -> thread_recv(chan) which returns Result directly
        ((string-eq fn-name "recv")
          (if (< len 2)
            (do
              (ctx-add-error-at ctx "recv: need channel argument" (ctx-list-first-line items) (ctx-list-first-col items))
              "0")
            (match (list-get items 1)
              ((some chan-expr)
                (let ((chan-c (transpile-expr ctx chan-expr))
                      (chan-c-type (infer-expr-c-type ctx chan-expr)))
                  ;; Extract channel struct type from pointer type
                  (let ((chan-type (strip-pointer-suffix arena chan-c-type)))
                    (if (and (starts-with chan-type "slop_chan_")
                             (not (string-eq chan-type "slop_chan_int")))
                      ;; Custom channel type - use specialized function
                      (let ((s1 (ctx-str ctx "thread_recv_" chan-type))
                            (s2 (ctx-str ctx s1 "("))
                            (s3 (ctx-str ctx s2 chan-c)))
                        (ctx-str ctx s3 ")"))
                      ;; Default int channel - use standard function
                      (ctx-str3 ctx "thread_recv(" chan-c ")")))))
              ((none)
                (do
                  (ctx-add-error-at ctx "recv: missing channel argument" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0")))))
        (else
      ;; Check for built-in type constructors first (String, Bytes need special field ordering)
      (let ((builtin-c-name (get-builtin-type-c-name fn-name)))
        (if (> (string-len builtin-c-name) 0)
          ;; Built-in type constructor - use special handler for correct field order
          (transpile-builtin-constructor ctx fn-name items)
          ;; Check if this is a type constructor (record or union instantiation)
          (match (ctx-lookup-type ctx fn-name)
            ((some type-entry)
              (if (. type-entry is-union)
                ;; Union type: (UnionType (tag value)) -> ((UnionType){ .tag = UnionType_tag, .data.tag = value })
                (transpile-union-constructor ctx fn-name (. type-entry c-name) items)
                ;; Record type: emit compound literal
                ;; For none arguments, look up field type and generate typed compound literal
                (let ((c-name (. type-entry c-name))
                      (type-name fn-name)  ;; Use SLOP type name for field lookup
                      (mut args "")
                      (mut i 1)
                      (mut field-idx 0))
                  (while (< i len)
                    (match (list-get items i)
                      ((some arg)
                        (let ((arg-c (transpile-expr ctx arg))
                              ;; Look up field type for typed none handling
                              (field-type-opt (ctx-lookup-field-type-by-index ctx type-name field-idx))
                              (final-arg (match field-type-opt
                                           ((some field-type)
                                             (typed-none-arg ctx field-type arg-c))
                                           ((none) arg-c))))
                          (if (string-eq args "")
                            (set! args final-arg)
                            (set! args (ctx-str3 ctx args ", " final-arg)))
                          (set! field-idx (+ field-idx 1))))
                      ((none) (do)))
                    (set! i (+ i 1)))
                  (ctx-str5 ctx "(" c-name "){" args "}"))))
            ((none)
              ;; Check if fn-name is a union variant constructor (e.g., xsd-string-val)
              (match (ctx-lookup-enum-variant ctx fn-name)
                ((some type-name)
                  ;; Union variant constructor: (variant-name value) -> inline struct init
                  (let ((c-variant (to-c-name arena fn-name))
                        (c-tag-enum (ctx-str3 ctx type-name "_" c-variant)))
                    (if (>= len 2)
                      (match (list-get items 1)
                        ((some value-expr)
                          (let ((value-c (transpile-expr ctx value-expr)))
                            (ctx-str3 ctx "((" type-name
                              (ctx-str3 ctx "){ .tag = " c-tag-enum
                                (ctx-str5 ctx ", .data." c-variant " = " value-c " })")))))
                        ((none)
                          (ctx-str3 ctx "((" type-name
                            (ctx-str3 ctx "){ .tag = " c-tag-enum " })"))))
                      (ctx-str3 ctx "((" type-name
                        (ctx-str3 ctx "){ .tag = " c-tag-enum " })")))))
                ((none)
                  ;; Regular function call - look up param types for typed none handling
                  (let ((func-opt (ctx-lookup-func ctx fn-name))
                        (mut args "")
                        (mut i 1)
                        (mut param-idx 0))
                    ;; Check if function is defined or is a runtime built-in
                    (match func-opt
                      ((none)
                        ;; Not a user-defined function - check if it's a runtime built-in
                        (let ((runtime-name (get-runtime-function-name fn-name))
                              (var-opt (ctx-lookup-var ctx fn-name)))
                          (if (and (== (string-len runtime-name) 0)
                                   (match var-opt ((none) true) ((some _) false)))
                            ;; Not a runtime built-in or local variable - emit error
                            (do
                              (ctx-add-error-at ctx
                                (ctx-str3 ctx "undefined function '" fn-name "' - check imports")
                                (ctx-list-first-line items) (ctx-list-first-col items))
                              "0")
                            ;; Runtime built-in - proceed without type info
                            (do
                              (while (< i len)
                                (match (list-get items i)
                                  ((some arg)
                                    (let ((arg-c (transpile-expr ctx arg)))
                                      (if (string-eq args "")
                                        (set! args arg-c)
                                        (set! args (ctx-str3 ctx args ", " arg-c)))))
                                  ((none) (do)))
                                (set! i (+ i 1)))
                              (transpile-call ctx fn-name args)))))
                      ((some func-entry)
                        ;; User-defined function - process with typed none handling
                        (do
                          (while (< i len)
                            (match (list-get items i)
                              ((some arg)
                                (let ((arg-c (transpile-expr ctx arg))
                                      ;; Get expected type for this parameter
                                      (expected-type (match (list-get (. func-entry param-types) param-idx)
                                                       ((some p) (. (deref p) c-type))
                                                       ((none) "")))
                                      ;; Convert none to typed Option if needed
                                      (arg-c2 (typed-none-arg ctx expected-type arg-c))
                                      ;; Wrap function references in slop_closure_t if needed
                                      (final-arg (wrap-fn-ref-as-closure ctx expected-type arg-c2 arg)))
                                  (if (string-eq args "")
                                    (set! args final-arg)
                                    (set! args (ctx-str3 ctx args ", " final-arg)))
                                  (set! param-idx (+ param-idx 1))))
                              ((none) (do)))
                            (set! i (+ i 1)))
                          (transpile-call ctx fn-name args)))))))))))))))

  (fn transpile-print ((ctx (Ptr TranspileContext)) (arg (Ptr SExpr)) (newline Bool))
    (@intent "Transpile print/println with type-aware formatting")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> String))
    (@pre {ctx != nil})
    (@pre {arg != nil})
    (let ((arena (. (deref ctx) arena))
          (nl (if newline "\\n" "")))
      ;; Check argument type
      (match (deref arg)
        ;; String literal - direct printf
        ((str s)
          (ctx-str5 ctx "printf(\"%s" nl "\", \"" (. s value) "\")"))
        ;; Number literal
        ((num n)
          ;; Check if float
          (if (string-contains (. n raw) ".")
            (ctx-str5 ctx "printf(\"%f" nl "\", " (. n raw) ")")
            (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" (. n raw) "))")))
        ;; Other expression - check for known types
        (_
          (let ((arg-c (transpile-expr ctx arg)))
            ;; Try to infer type from variable lookup
            (match (get-expr-type-hint ctx arg)
              ((some type-hint)
                (cond
                  ((or (string-eq type-hint "String") (string-eq type-hint "slop_string"))
                    ;; String: use %.*s format since not null-terminated
                    ;; printf("%.*s\n", (int)(arg).len, (arg).data)
                    (transpile-print-string ctx arg-c nl))
                  ((or (string-eq type-hint "Bool") (string-eq type-hint "uint8_t"))
                    (ctx-str5 ctx "printf(\"%s" nl "\", (" arg-c ") ? \"true\" : \"false\")"))
                  ((or (string-eq type-hint "Float") (string-eq type-hint "double"))
                    (ctx-str5 ctx "printf(\"%f" nl "\", " arg-c ")"))
                  (else
                    ;; Default to integer
                    (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" arg-c "))"))))
              ;; No type hint - default to integer for now
              ((none)
                (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" arg-c "))"))))))))

  (fn transpile-print-string ((ctx (Ptr TranspileContext)) (arg-c String) (nl String))
    (@intent "Generate printf for string type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (let ((arena (. (deref ctx) arena)))
      ;; printf("%.*s\n", (int)(arg).len, (arg).data)
      (string-concat arena
        (string-concat arena
          (string-concat arena "printf(\"%.*s" nl)
          (string-concat arena "\", (int)(" arg-c))
        (string-concat arena ").len, ("
          (string-concat arena arg-c ").data)")))))

  (fn transpile-printf-call ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile printf call with raw C strings for string literals")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut args "")
          (mut i 1))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (match (deref arg)
                           ;; String literal - use raw C string, not SLOP_STR
                           ((str s)
                             (ctx-str3 ctx "\"" (escape-c-string ctx (. s value)) "\""))
                           ;; Other expressions - transpile normally
                           (_ (transpile-expr ctx arg)))))
              (if (string-eq args "")
                (set! args arg-c)
                (set! args (ctx-str3 ctx args ", " arg-c)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str3 ctx "printf(" args ")")))

  (fn transpile-raw-string-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile function call where string literal args should be raw C strings (not SLOP_STR)")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut args "")
          (mut i 1))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (match (deref arg)
                           ;; String literal - use raw C string, not SLOP_STR
                           ((str s)
                             (ctx-str3 ctx "\"" (escape-c-string ctx (. s value)) "\""))
                           ;; Other expressions - transpile normally
                           (_ (transpile-expr ctx arg)))))
              (if (string-eq args "")
                (set! args arg-c)
                (set! args (ctx-str3 ctx args ", " arg-c)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (transpile-call ctx fn-name args)))

  (fn string-contains ((s String) (substr String))
    (@intent "Check if string contains substring")
    (@spec ((String String) -> Bool))
    (> (count-occurrences s substr) 0))

  (fn get-expr-type-hint ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Try to determine expression type from context")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Use infer-expr-slop-type first, then map SLOP type to C type hint
    (let ((slop-type (infer-expr-slop-type ctx expr)))
      (cond
        ((string-eq slop-type "String") (some "slop_string"))
        ((string-eq slop-type "Bool") (some "uint8_t"))
        ((string-eq slop-type "Int") (some "int64_t"))
        ((string-eq slop-type "Float") (some "double"))
        (else
          ;; Fallback: check variable c-type and function lookups
          (match (deref expr)
            ((sym sym)
              (match (ctx-lookup-var ctx (. sym name))
                ((some entry)
                  (let ((ct (. entry c-type)))
                    (if (string-eq ct "auto")
                      (none)
                      (some ct))))
                ((none) (none))))
            ((lst lst)
              (let ((items (. lst items)))
                (if (>= (list-len items) 1)
                  (match (list-get items 0)
                    ((some head)
                      (match (deref head)
                        ((sym head-sym)
                          (let ((op (. head-sym name)))
                            (cond
                              ;; Field access fallback - use infer-expr-c-type, then hardcoded names
                              ((and (string-eq op ".") (>= (list-len items) 3))
                                (let ((c-type (infer-expr-c-type ctx expr)))
                                  (cond
                                    ((string-eq c-type "slop_string") (some "slop_string"))
                                    ((string-eq c-type "uint8_t") (some "uint8_t"))
                                    ((string-eq c-type "double") (some "double"))
                                    ((string-eq c-type "int64_t") (some "int64_t"))
                                    ;; Last resort: look up field slop-type from obj slop-type
                                    (else
                                      (match (list-get items 1)
                                        ((some obj-expr)
                                          (match (list-get items 2)
                                            ((some field-expr)
                                              (match (deref field-expr)
                                                ((sym field-sym)
                                                  (let ((field-name (. field-sym name))
                                                        (obj-slop-type (infer-expr-slop-type ctx obj-expr)))
                                                    (if (> (string-len obj-slop-type) 0)
                                                      (match (ctx-lookup-field-slop-type ctx obj-slop-type field-name)
                                                        ((some fst)
                                                          (cond
                                                            ((string-eq fst "String") (some "slop_string"))
                                                            ((string-eq fst "Bool") (some "uint8_t"))
                                                            ((string-eq fst "Int") (some "int64_t"))
                                                            ((string-eq fst "Float") (some "double"))
                                                            (else (none))))
                                                        ((none) (none)))
                                                      (none))))
                                                (_ (none))))
                                            ((none) (none))))
                                        ((none) (none)))))))
                              ;; Known string-returning builtins
                              ((or (string-eq op "int-to-string")
                                   (or (string-eq op "string-copy")
                                       (or (string-eq op "string-concat")
                                           (string-eq op "pretty-print"))))
                                (some "slop_string"))
                              ;; Function registry lookup
                              (else
                                (match (ctx-lookup-func ctx op)
                                  ((some func-entry)
                                    (if (. func-entry returns-string)
                                      (some "slop_string")
                                      (none)))
                                  ((none) (none)))))))
                        (_ (none))))
                    ((none) (none)))
                  (none))))
            (_ (none)))))))

  (fn transpile-union-constructor ((ctx (Ptr TranspileContext)) (type-name String) (c-type-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile a union constructor: (UnionType (tag value)) -> ((UnionType){ .tag = UnionType_tag, .data.tag = value })")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      ;; First argument should be (tag value) or just (tag)
      (if (< len 2)
        (ctx-str3 ctx "((" c-type-name "){})")
        (match (list-get items 1)
          ((some tag-expr)
            (match (deref tag-expr)
              ((lst tag-list)
                (let ((tag-items (. tag-list items)))
                  ;; Parse: (tag value) or (tag)
                  (if (< (list-len tag-items) 1)
                    (ctx-str3 ctx "((" c-type-name "){})")
                    (match (list-get tag-items 0)
                      ((some tag-name-expr)
                        (match (deref tag-name-expr)
                          ((sym tag-sym)
                            (let ((tag-name (. tag-sym name))
                                  (c-tag-name (to-c-name arena tag-name))
                                  (c-tag-enum (ctx-str ctx c-type-name (ctx-str ctx "_" c-tag-name))))
                              ;; Check if there's a value argument
                              (if (>= (list-len tag-items) 2)
                                (match (list-get tag-items 1)
                                  ((some value-expr)
                                    (let ((value-c (transpile-expr ctx value-expr)))
                                      (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum (ctx-str ctx ", .data." (ctx-str ctx c-tag-name (ctx-str ctx " = " (ctx-str ctx value-c " })"))))))))))
                                  ((none) (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })"))))))
                                ;; No value - just tag
                                (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })")))))))
                          (_ (ctx-str3 ctx "((" c-type-name "){})/* tag not symbol */"))))
                      ((none) (ctx-str3 ctx "((" c-type-name "){})/* no tag */"))))))
              ;; Not a list - might be bare symbol like (some x) or (none)
              ((sym sym)
                (let ((tag-name (. sym name))
                      (c-tag-name (to-c-name arena tag-name))
                      (c-tag-enum (ctx-str ctx c-type-name (ctx-str ctx "_" c-tag-name))))
                  (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })"))))))
              (_ (ctx-str3 ctx "((" c-type-name "){})/* unknown tag form */"))))
          ((none) (ctx-str3 ctx "((" c-type-name "){})/* no args */"))))))

  ;; ============================================================
  ;; Cond Expression (nested ternary)
  ;; ============================================================

  (fn transpile-cond-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a cond expression as nested ternary: (cond (t1 v1) (t2 v2) (else v3)) -> t1 ? v1 : t2 ? v2 : v3")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-cond-result-c-type ctx items))
          (mut result "")
          (mut i 1))
      ;; Process each clause (test body...) or (else body...)
      (while (< i len)
        (match (list-get items i)
          ((some clause-expr)
            (match (deref clause-expr)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (>= clause-len 2)
                    (match (list-get clause-items 0)
                      ((some test-expr)
                        (match (deref test-expr)
                          ;; else clause
                          ((sym sym)
                            (if (string-eq (. sym name) "else")
                              ;; else clause - get the body value (last expression)
                              (match (list-get clause-items (- clause-len 1))
                                ((some body-expr)
                                  (let ((body-c (transpile-expr ctx body-expr)))
                                    (set! result (ctx-str ctx result (typed-none ctx result-type body-c)))))
                                ((none) (set! result (ctx-str ctx result "0"))))
                              ;; Regular test - evaluate as condition
                              (let ((test-c (transpile-expr ctx test-expr)))
                                (match (list-get clause-items (- clause-len 1))
                                  ((some body-expr)
                                    (let ((body-c (typed-none ctx result-type (transpile-expr ctx body-expr))))
                                      (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c (ctx-str ctx " ? " (ctx-str ctx body-c " : "))))))))
                                  ((none) (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c " ? 0 : ")))))))))
                          ;; Non-symbol test
                          (_
                            (let ((test-c (transpile-expr ctx test-expr)))
                              (match (list-get clause-items (- clause-len 1))
                                ((some body-expr)
                                  (let ((body-c (typed-none ctx result-type (transpile-expr ctx body-expr))))
                                    (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c (ctx-str ctx " ? " (ctx-str ctx body-c " : "))))))))
                                ((none) (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c " ? 0 : "))))))))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Close any open ternaries with default 0
      (if (string-eq result "")
        "0"
        ;; Count open parens and close them
        (let ((mut open-count 0)
              (mut j 0)
              (rlen (string-len result)))
          (while (< j (cast Int rlen))
            (let ((c (char-at result (cast (Int 0 ..) j))))
              (cond
                ((== c 40) (set! open-count (+ open-count 1)))  ;; '('
                ((== c 41) (set! open-count (- open-count 1)))  ;; ')'
                (else (do))))
            (set! j (+ j 1)))
          ;; Add closing parens for unclosed ternaries
          (while (> open-count 0)
            (set! result (ctx-str ctx result ")"))
            (set! open-count (- open-count 1)))
          result))))

  ;; ============================================================
  ;; Match Expression (GCC statement expression)
  ;; ============================================================

  (fn transpile-match-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a match expression, returning a GCC statement expression string")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "invalid match expr" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some scrutinee)
            (let ((scrutinee-c (transpile-expr ctx scrutinee))
                  (patterns (collect-match-patterns ctx items)))
              (cond
                ((is-option-patterns patterns)
                  (build-option-match-expr ctx scrutinee scrutinee-c items))
                ((is-result-patterns patterns)
                  (build-result-match-expr ctx scrutinee scrutinee-c items))
                ((is-union-expr-patterns ctx patterns)
                  (build-union-match-expr ctx scrutinee scrutinee-c items))
                (else
                  (build-ternary-match-expr ctx scrutinee-c items)))))
          ((none)
            (do
              (ctx-add-error-at ctx "missing match scrutinee" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn collect-match-patterns ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Collect pattern expressions from match branches")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (list-new arena (Ptr SExpr)))
          (mut i 2))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 1)
                    (match (list-get branch-items 0)
                      ((some pattern) (list-push result pattern))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn get-expr-pattern-tag ((pat-expr (Ptr SExpr)))
    (@intent "Get the tag from a pattern expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            ""
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (. sym name))
                  (else "")))
              ((none) "")))))
      ((sym sym) (. sym name))
      (else "")))

  (fn is-option-patterns ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are option match")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut found false)
          (mut i 0))
      (while (and (< i len) (not found))
        (match (list-get patterns i)
          ((some pat)
            (let ((tag (get-expr-pattern-tag pat)))
              (when (or (string-eq tag "some") (string-eq tag "none"))
                (set! found true))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-result-patterns ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are result match")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut found false)
          (mut i 0))
      (while (and (< i len) (not found))
        (match (list-get patterns i)
          ((some pat)
            (let ((tag (get-expr-pattern-tag pat)))
              (when (or (string-eq tag "ok") (string-eq tag "error"))
                (set! found true))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-union-expr-patterns ((ctx (Ptr TranspileContext)) (patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are union match (tagged union variants)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Bool))
    (@pre {ctx != nil})
    ;; Union patterns are lists like (variant-name binding) where variant-name
    ;; is registered as an enum/union variant (and not one of special forms)
    (let ((len (list-len patterns))
          (mut has-union-variant false)
          (mut i 0))
      (while (and (< i len) (not has-union-variant))
        (match (list-get patterns i)
          ((some pat-expr)
            (let ((tag (get-expr-pattern-tag pat-expr)))
              ;; Check if it's a registered variant (not special forms)
              (when (and (not (string-eq tag ""))
                         (not (string-eq tag "some"))
                         (not (string-eq tag "none"))
                         (not (string-eq tag "ok"))
                         (not (string-eq tag "error"))
                         (not (string-eq tag "else"))
                         (not (string-eq tag "_")))
                (match (ctx-lookup-enum-variant ctx tag)
                  ((some _) (set! has-union-variant true))
                  ((none) (do))))))
          ((none) (do)))
        (set! i (+ i 1)))
      has-union-variant))

  (fn get-expr-binding-name ((pat-expr (Ptr SExpr)))
    (@intent "Extract binding name from pattern like (ok x)")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 1)
              ((some binding)
                (match (deref binding)
                  ((sym sym) (some (. sym name)))
                  (else none)))
              ((none) none)))))
      (else none)))

  (fn get-match-branch-body ((ctx (Ptr TranspileContext)) (branch-items (List (Ptr SExpr))))
    (@intent "Get the body expression from a match branch")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len branch-items)))
      (if (< len 2)
        "0"
        (match (list-get branch-items (- len 1))
          ((some body-expr)
            (transpile-expr ctx body-expr))
          ((none) "0")))))

  (fn transpile-branch-body-with-binding ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr))
                                          (branch-items (List (Ptr SExpr))) (binding-name String))
    (@intent "Transpile branch body with proper variable binding in scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    ;; Push scope to contain the binding
    (ctx-push-scope ctx)
    ;; Bind the variable if non-empty
    (when (not (string-eq binding-name ""))
      (let ((arena (. (deref ctx) arena))
            (c-name (to-c-name arena binding-name))
            ;; Infer the inner SLOP type from the scrutinee for proper map/set iteration
            (inner-slop-type (infer-option-inner-slop-type ctx scrutinee)))
        (ctx-bind-var ctx (VarEntry binding-name c-name "auto" inner-slop-type false false false "" ""))))
    ;; Transpile body expression
    (let ((result (get-match-branch-body ctx branch-items)))
      ;; Pop scope
      (ctx-pop-scope ctx)
      result))

  (fn build-option-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build Option match as GCC statement expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut some-body "0")
          (mut none-body "0")
          (mut some-binding "")
          (mut i 2))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-expr-pattern-tag pattern)))
                          (cond
                            ((string-eq tag "some")
                              (match (get-expr-binding-name pattern)
                                ((some name)
                                  (set! some-binding name)
                                  ;; Transpile body with binding in scope, passing scrutinee for type inference
                                  (set! some-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                ((none)
                                  ;; No binding - transpile normally
                                  (set! some-body (get-match-branch-body ctx branch-items)))))
                            ((string-eq tag "none")
                              (set! none-body (get-match-branch-body ctx branch-items)))
                            (else (do)))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Infer result type for proper none handling
      (let ((result-type (infer-match-result-c-type ctx items)))
        ;; Build the output string based on whether there's a binding
        (if (string-eq some-binding "")
          ;; No binding - use simple ternary
          (build-option-match-no-binding ctx scrutinee-c some-body none-body result-type)
          ;; Has binding - use if/else
          (build-option-match-with-binding ctx arena scrutinee-c some-binding some-body none-body result-type)))))

  (fn build-option-match-no-binding ((ctx (Ptr TranspileContext)) (scrutinee-c String) (some-body String) (none-body String) (result-type String))
    (@intent "Build Option match without binding using ternary or if/else for void")
    (@spec (((Ptr TranspileContext) String String String String) -> String))
    (@pre {ctx != nil})
    (if (string-eq result-type "void")
      ;; Void result - use if/else statement
      ;; ({ __auto_type _mv = scrutinee; if (_mv.has_value) { some_body; } else { none_body; } (void)0; })
      (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
            (s2 (ctx-str ctx s1 "; if (_mv.has_value) { "))
            (s3 (ctx-str ctx s2 some-body))
            (s4 (ctx-str ctx s3 "; } else { "))
            (s5 (ctx-str ctx s4 none-body))
            (s6 (ctx-str ctx s5 "; } (void)0; })")))
        s6)
      ;; Non-void - use ternary
      ;; ({ __auto_type _mv = scrutinee; _mv.has_value ? (some_body) : (none_body); })
      (let ((typed-none-body (typed-none ctx result-type none-body))
            (s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
            (s2 (ctx-str ctx s1 "; _mv.has_value ? ("))
            (s3 (ctx-str ctx s2 some-body))
            (s4 (ctx-str ctx s3 ") : ("))
            (s5 (ctx-str ctx s4 typed-none-body))
            (s6 (ctx-str ctx s5 "); })")))
        s6)))

  (fn build-option-match-with-binding ((ctx (Ptr TranspileContext)) (arena Arena) (scrutinee-c String)
                                       (binding String) (some-body String) (none-body String) (result-type String))
    (@intent "Build Option match with binding using ternary or if/else for void")
    (@spec (((Ptr TranspileContext) Arena String String String String String) -> String))
    (@pre {ctx != nil})
    (let ((var-c (to-c-name arena binding)))
      (if (string-eq result-type "void")
        ;; Void result - use if/else statement
        ;; ({ __auto_type _mv = scrutinee; if (_mv.has_value) { __auto_type v = _mv.value; some_body; } else { none_body; } (void)0; })
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; if (_mv.has_value) { __auto_type "))
              (s3 (ctx-str ctx s2 var-c))
              (s4 (ctx-str ctx s3 " = _mv.value; "))
              (s5 (ctx-str ctx s4 some-body))
              (s6 (ctx-str ctx s5 "; } else { "))
              (s7 (ctx-str ctx s6 none-body))
              (s8 (ctx-str ctx s7 "; } (void)0; })")))
          s8)
        ;; Non-void - use ternary
        ;; ({ __auto_type _mv = scrutinee; _mv.has_value ? ({ __auto_type v = _mv.value; some_body; }) : (none_body); })
        (let ((typed-none-body (typed-none ctx result-type none-body))
              (s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; _mv.has_value ? ({ __auto_type "))
              (s3 (ctx-str ctx s2 var-c))
              (s4 (ctx-str ctx s3 " = _mv.value; "))
              (s5 (ctx-str ctx s4 some-body))
              (s6 (ctx-str ctx s5 "; }) : ("))
              (s7 (ctx-str ctx s6 typed-none-body))
              (s8 (ctx-str ctx s7 "); })")))
          s8))))

  (fn infer-cond-result-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C result type for cond expression from first clause's body")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Look at first clause (index 1) to determine result type
    (let ((len (list-len items)))
      (if (< len 2)
        "int64_t"
        (match (list-get items 1)
          ((some first-clause)
            (match (deref first-clause)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (if (< clause-len 2)
                    "int64_t"
                    ;; Body is last element in clause
                    (match (list-get clause-items (- clause-len 1))
                      ((some body-expr)
                        (infer-expr-c-type ctx body-expr))
                      ((none) "int64_t")))))
              (else "int64_t")))
          ((none) "int64_t")))))

  (fn infer-match-branch-body-type ((ctx (Ptr TranspileContext)) (branch (Ptr SExpr)))
    (@intent "Infer C type from a single match branch body")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {branch != nil})
    (match (deref branch)
      ((lst branch-lst)
        (let ((branch-items (. branch-lst items))
              (branch-len (list-len branch-items)))
          (if (< branch-len 2)
            "__type_error__"
            (match (list-get branch-items (- branch-len 1))
              ((some body-expr) (infer-expr-c-type ctx body-expr))
              ((none) "__type_error__")))))
      (else "__type_error__")))

  (fn infer-match-result-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C result type for match expression, trying branches until one succeeds")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Try each branch starting from index 2 until we find a non-error type
    (let ((len (list-len items))
          (mut i 2)
          (mut result "__type_error__"))
      (if (< len 3)
        "int64_t"
        (do
          (while (and (< i len) (string-eq result "__type_error__"))
            (match (list-get items i)
              ((some branch) (set! result (infer-match-branch-body-type ctx branch)))
              ((none) (do)))
            (set! i (+ i 1)))
          (if (string-eq result "__type_error__")
            "int64_t"
            result)))))

  (fn slop-type-to-c-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Convert a SLOP type name to its C type equivalent")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; First check if it's a registered type (includes primitives)
      (match (ctx-lookup-type ctx slop-type)
        ((some entry) (. entry c-name))
        ((none)
          (cond
            ;; Pointer types like "(Ptr T)"
            ((starts-with slop-type "(Ptr ")
              (let ((inner (substring arena slop-type 5 (max 0 (- (cast Int (string-len slop-type)) 6)))))
                (ctx-str ctx (slop-type-to-c-type ctx inner) "*")))
            ;; Map/Set types -> slop_map*
            ((or (starts-with slop-type "(Map ") (starts-with slop-type "(Set "))
              "slop_map*")
            ;; List types -> need to generate list type name
            ((starts-with slop-type "(List ")
              (let ((inner (substring arena slop-type 6 (max 0 (- (cast Int (string-len slop-type)) 7)))))
                (ctx-str ctx "slop_list_" (slop-type-to-c-type ctx inner))))
            ;; Option types
            ((starts-with slop-type "(Option ")
              (let ((inner (substring arena slop-type 8 (max 0 (- (cast Int (string-len slop-type)) 9)))))
                (ctx-str ctx "slop_option_" (slop-type-to-c-type ctx inner))))
            ;; Default: use as-is (might be a C type already)
            (else slop-type))))))

  (fn infer-expr-c-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer C type of an expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; If the checker has annotated this node with a resolved type, use it
    (match (get-node-resolved-type expr)
      ((some rt)
        (resolved-type-to-c (. (deref ctx) arena) rt))
      ((none)
    (do (ctx-warn-fallback ctx expr "infer-expr-c-type")
    (match (deref expr)
      ;; String literal -> slop_string
      ((str _) "slop_string")
      ;; Number -> int64_t or double
      ((num num)
        (if (. num is-float) "double" "int64_t"))
      ;; Symbol -> look up type, handling "auto" from match bindings
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some entry)
              (let ((c-type (. entry c-type))
                    (slop-type (. entry slop-type)))
                (cond
                  ;; If c-type is "auto" or empty, try to convert slop-type
                  ((or (string-eq c-type "auto") (== (string-len c-type) 0))
                    (if (> (string-len slop-type) 0)
                      (slop-type-to-c-type ctx slop-type)
                      "int64_t"))
                  ;; Otherwise use the stored c-type
                  (else c-type))))
            ((none) "int64_t"))))
      ;; List -> check for known patterns
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "int64_t"
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; Check function registry for string-returning functions
                        ((match (ctx-lookup-func ctx op)
                           ((some func-entry) (. func-entry returns-string))
                           ((none) false))
                          "slop_string")
                        ;; Field access - delegate to shared helper
                        ((string-eq op ".")
                          (infer-field-c-type-from-items ctx items))
                        ;; Let expression - infer from body (last element after bindings)
                        ((or (string-eq op "let") (string-eq op "let*"))
                          (if (< (list-len items) 3)
                            "int64_t"
                            ;; Body is last element
                            (match (list-get items (- (list-len items) 1))
                              ((some body) (infer-expr-c-type ctx body))
                              ((none) "int64_t"))))
                        ;; do expression - infer from last subexpression
                        ((string-eq op "do")
                          (if (< (list-len items) 2)
                            "void"
                            (match (list-get items (- (list-len items) 1))
                              ((some last-expr) (infer-expr-c-type ctx last-expr))
                              ((none) "void"))))
                        ;; Cond expression - infer from first clause's body
                        ((string-eq op "cond")
                          (infer-cond-result-c-type ctx items))
                        ;; Match expression - infer from first branch's body
                        ((string-eq op "match")
                          (infer-match-result-c-type ctx items))
                        ;; If expression - infer from then branch
                        ((string-eq op "if")
                          (if (< (list-len items) 3)
                            "int64_t"
                            (match (list-get items 2)
                              ((some then-expr) (infer-expr-c-type ctx then-expr))
                              ((none) "int64_t"))))
                        ;; some constructor - infer Option type from value
                        ((string-eq op "some")
                          (if (< (list-len items) 2)
                            (do (ctx-add-error-at ctx "some constructor requires a value" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                              "__type_error__")
                            (match (list-get items 1)
                              ((some val-expr)
                                (let ((val-type (infer-expr-c-type ctx val-expr)))
                                  (cond
                                    ((string-eq val-type "slop_string") "slop_option_string")
                                    ((string-eq val-type "int64_t") "slop_option_int")
                                    ((string-eq val-type "double") "slop_option_double")
                                    ;; Pointer type - generate slop_option_<base>_ptr
                                    ((ends-with val-type "*")
                                      (let ((ctx-arena (. (deref ctx) arena))
                                            (base-type (strip-pointer-suffix ctx-arena val-type)))
                                        (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                                    ;; Other types - generate slop_option_<type>
                                    (else (ctx-str3 ctx "slop_option_" val-type "")))))
                              ((none)
                                (do (ctx-add-error-at ctx "some constructor: missing value expression" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                                  "__type_error__")))))
                        ;; none constructor - use return type context if available
                        ((string-eq op "none")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                ret-type
                                "slop_option_int"))
                            ((none) "slop_option_int")))
                        ;; list-push returns void
                        ((string-eq op "list-push")
                          "void")
                        ;; set! returns void
                        ((string-eq op "set!")
                          "void")
                        ;; cast - return the target type
                        ((string-eq op "cast")
                          (if (< (list-len items) 2)
                            "void*"
                            (match (list-get items 1)
                              ((some type-expr)
                                (to-c-type-prefixed ctx type-expr))
                              ((none) "void*"))))
                        ;; deref - dereference pointer, strip one level of pointer
                        ((string-eq op "deref")
                          (if (< (list-len items) 2)
                            "int64_t"
                            (match (list-get items 1)
                              ((some inner)
                                (let ((inner-type (infer-expr-c-type ctx inner)))
                                  (if (ends-with inner-type "*")
                                    (strip-pointer-suffix (. (deref ctx) arena) inner-type)
                                    inner-type)))
                              ((none) "int64_t"))))
                        ;; string-concat returns slop_string
                        ((string-eq op "string-concat") "slop_string")
                        ;; list-len returns int64_t
                        ((string-eq op "list-len") "int64_t")
                        ;; string-len returns int64_t
                        ((string-eq op "string-len") "int64_t")
                        ;; string-eq returns uint8_t (Bool)
                        ((string-eq op "string-eq") "uint8_t")
                        ;; addr returns pointer - infer inner type and add *
                        ((string-eq op "addr")
                          (if (< (list-len items) 2)
                            "void*"
                            (match (list-get items 1)
                              ((some inner)
                                (ctx-str3 ctx (infer-expr-c-type ctx inner) "*" ""))
                              ((none) "void*"))))
                        ;; send returns Result(Void, ChanError)
                        ((or (string-eq op "send") (ends-with op ":send"))
                          "slop_result_void_thread_ChanError")
                        ;; recv returns Result(<inner>, ChanError) - infer inner from channel type
                        ((or (string-eq op "recv") (ends-with op ":recv"))
                          (if (< (list-len items) 2)
                            "slop_result_int64_t_thread_ChanError"
                            (match (list-get items 1)
                              ((some chan-arg)
                                (let ((chan-c-type (infer-expr-c-type ctx chan-arg))
                                      (chan-type (strip-pointer-suffix (. (deref ctx) arena) chan-c-type)))
                                  (if (starts-with chan-type "slop_chan_")
                                    (let ((inner-id (substring-after-prefix (. (deref ctx) arena) chan-type "slop_chan_")))
                                      (ctx-str3 ctx "slop_result_" inner-id "_thread_ChanError"))
                                    "slop_result_int64_t_thread_ChanError")))
                              ((none) "slop_result_int64_t_thread_ChanError"))))
                        ;; join returns the thread's result type
                        ((or (string-eq op "join") (ends-with op ":join"))
                          "int64_t")
                        ;; spawn returns a thread pointer
                        ((or (string-eq op "spawn") (ends-with op ":spawn"))
                          "slop_thread*")
                        ;; chan-buffered returns a channel pointer
                        ((or (string-eq op "chan-buffered") (ends-with op ":chan-buffered"))
                          "slop_chan_int*")
                        ;; arena-alloc returns void*
                        ((string-eq op "arena-alloc") "void*")
                        ;; list-new returns a list struct - need element type from 2nd arg
                        ((string-eq op "list-new")
                          (if (< (list-len items) 3)
                            (do
                              (ctx-add-error-at ctx "Cannot infer list-new type: missing element type argument" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                              "__type_error__")
                            (match (list-get items 2)
                              ((some type-expr)
                                (let ((elem-c (to-c-type (. (deref ctx) arena) type-expr)))
                                  (ctx-str3 ctx "slop_list_" (type-to-identifier (. (deref ctx) arena) elem-c) "")))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "Cannot infer list-new element type" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                                  "__type_error__")))))
                        ;; list-get returns option type - infer from list argument
                        ((string-eq op "list-get")
                          (if (< (list-len items) 2)
                            (do
                              (ctx-add-error-at ctx "Cannot infer list-get type: missing list argument" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                              "__type_error__")
                            (match (list-get items 1)
                              ((some list-arg)
                                (let ((list-c-type (infer-expr-c-type ctx list-arg)))
                                  (if (starts-with list-c-type "slop_list_")
                                    (let ((elem-id (substring-after-prefix (. (deref ctx) arena) list-c-type "slop_list_")))
                                      (ctx-str3 ctx "slop_option_" elem-id ""))
                                    (do
                                      (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer list-get element type from '" list-c-type "'") (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                                      "__type_error__"))))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "Cannot infer list-get type: missing argument" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                                  "__type_error__")))))
                        ;; int-to-string returns slop_string
                        ((string-eq op "int-to-string") "slop_string")
                        ;; when returns void
                        ((string-eq op "when")
                          "void")
                        ;; Arithmetic operators return int64_t
                        ((or (string-eq op "+") (or (string-eq op "-") (or (string-eq op "*") (or (string-eq op "/") (string-eq op "%")))))
                          "int64_t")
                        ;; Comparison operators return uint8_t (Bool)
                        ((or (string-eq op ">") (or (string-eq op "<") (or (string-eq op ">=") (or (string-eq op "<=") (or (string-eq op "==") (string-eq op "!="))))))
                          "uint8_t")
                        ;; Logical operators return uint8_t (Bool)
                        ((or (string-eq op "and") (or (string-eq op "or") (string-eq op "not")))
                          "uint8_t")
                        ;; Function call or struct constructor - check type registry first
                        (else
                          ;; First check if it's a struct/union constructor
                          (match (ctx-lookup-type ctx op)
                            ((some type-entry)
                              ;; It's a type! Return its C name
                              (. type-entry c-name))
                            ((none)
                              ;; Not a type, check function registry
                              (match (ctx-lookup-func ctx op)
                                ((some func-entry)
                                  (let ((ret-type (. func-entry return-type)))
                                    (cond
                                      ((. func-entry returns-string) "slop_string")
                                      ((string-eq ret-type "void") "void")
                                      ((> (string-len ret-type) 0) ret-type)
                                      ;; Empty return type = incomplete info
                                      (else (do (ctx-add-error-at ctx (ctx-str3 ctx "function '" op "' has no return type information") (ctx-sexpr-line expr) (ctx-sexpr-col expr)) "__type_error__")))))
                                ;; Function not found in registry
                                ((none) (do (ctx-add-error-at ctx (ctx-str3 ctx "unknown function or type '" op "'") (ctx-sexpr-line expr) (ctx-sexpr-col expr)) "__type_error__")))))))))
                  (else (do (ctx-add-error-at ctx "cannot infer type: list head is not a symbol" (ctx-sexpr-line expr) (ctx-sexpr-col expr)) "__type_error__"))))
              ((none) (do (ctx-add-error-at ctx "cannot infer type of empty list" (ctx-sexpr-line expr) (ctx-sexpr-col expr)) "__type_error__"))))))
      (else (do (ctx-add-error-at ctx "cannot infer type of expression" (ctx-sexpr-line expr) (ctx-sexpr-col expr)) "__type_error__")))))))

  (fn build-result-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build Result match as GCC statement expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-match-result-c-type ctx items))
          (mut ok-body "0")
          (mut err-body "0")
          (mut ok-binding "")
          (mut err-binding "")
          (mut i 2))
      (do (while (< i len)
            (match (list-get items i)
              ((some branch)
                (match (deref branch)
                  ((lst branch-lst)
                    (let ((branch-items (. branch-lst items)))
                      (when (>= (list-len branch-items) 2)
                        (match (list-get branch-items 0)
                          ((some pattern)
                            (let ((tag (get-expr-pattern-tag pattern)))
                              (cond
                                ((string-eq tag "ok")
                                  (match (get-expr-binding-name pattern)
                                    ((some name)
                                      (set! ok-binding name)
                                      ;; Transpile body with binding in scope
                                      (set! ok-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                    ((none)
                                      ;; No binding - transpile normally
                                      (set! ok-body (get-match-branch-body ctx branch-items)))))
                                ((string-eq tag "error")
                                  (match (get-expr-binding-name pattern)
                                    ((some name)
                                      (set! err-binding name)
                                      ;; Transpile body with binding in scope
                                      (set! err-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                    ((none)
                                      ;; No binding - transpile normally
                                      (set! err-body (get-match-branch-body ctx branch-items)))))
                                (else (do)))))
                          ((none) (do))))))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          ;; Build GCC statement expression with if/else
      ;; ({ __auto_type _mv = scrutinee; <type> _mr;
      ;;    if (_mv.is_ok) { ok_bind _mr = ok_body; } else { err_bind _mr = err_body; } _mr; })
      (let ((ok-bind (if (string-eq ok-binding "")
                        ""
                        (ctx-str3 ctx "__auto_type " (to-c-name arena ok-binding) " = _mv.data.ok; ")))
            (err-bind (if (string-eq err-binding "")
                         ""
                         (ctx-str3 ctx "__auto_type " (to-c-name arena err-binding) " = _mv.data.err; "))))
        (if (string-eq result-type "void")
          ;; Void match - execute branches for side effects only
          (ctx-str ctx
            (ctx-str ctx "({ __auto_type _mv = " scrutinee-c)
            (ctx-str ctx "; if (_mv.is_ok) { "
              (ctx-str ctx ok-bind
                (ctx-str ctx ok-body
                  (ctx-str ctx "; } else { "
                    (ctx-str ctx err-bind
                      (ctx-str ctx err-body "; } (void)0; })"))))))))
          ;; Normal match with result variable using inferred type
          (ctx-str ctx
            (ctx-str ctx "({ __auto_type _mv = " scrutinee-c)
            (ctx-str ctx (ctx-str3 ctx "; " result-type " _mr; if (_mv.is_ok) { ")
              (ctx-str ctx ok-bind
                (ctx-str ctx "_mr = "
                  (ctx-str ctx ok-body
                    (ctx-str ctx "; } else { "
                      (ctx-str ctx err-bind
                        (ctx-str ctx "_mr = "
                          (ctx-str ctx err-body "; } _mr; })")))))))))))))

  (fn build-union-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build union (tagged union) match as GCC statement expression with switch")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Generate: ({ __auto_type _mv = scrutinee; <type> _mr = {0};
    ;;              switch (_mv.tag) { case T_v: { __auto_type b = _mv.data.v; _mr = body; break; } ... } _mr; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-match-result-c-type ctx items))
          (mut cases "")
          (mut i 2))
      ;; Build switch cases
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (set! cases (build-union-case-expr ctx arena cases scrutinee pattern branch-items result-type)))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Build the full expression with inferred result type
      (if (string-eq result-type "void")
        ;; Void match - no result variable, execute for side effects only
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; switch (_mv.tag) { "))
              (s3 (ctx-str ctx s2 cases))
              (s4 (ctx-str ctx s3 " } (void)0; })")))
          s4)
        ;; Non-void match with result variable
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 (ctx-str ctx "; " (ctx-str ctx result-type " _mr = {0}; switch (_mv.tag) { "))))
              (s3 (ctx-str ctx s2 cases))
              (s4 (ctx-str ctx s3 " } _mr; })")))
          s4))))

  (fn typed-none ((ctx (Ptr TranspileContext)) (result-type String) (body String))
    (@intent "Convert 'none' to typed none if result type is an Option type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    (if (and (string-eq body "none")
             (starts-with result-type "slop_option_"))
      (ctx-str3 ctx "(" result-type "){.has_value = false}")
      body))

  (fn typed-none-arg ((ctx (Ptr TranspileContext)) (expected-type String) (arg-c String))
    (@intent "Convert 'none' to typed Option compound literal if expected type is Option")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; If arg is "none" and expected type starts with "slop_option_",
    ;; generate: ((slop_option_T){.has_value = false})
    (if (and (string-eq arg-c "none")
             (starts-with expected-type "slop_option_"))
      (ctx-str3 ctx "((" expected-type "){.has_value = false})")
      arg-c))

  (fn wrap-fn-ref-as-closure ((ctx (Ptr TranspileContext)) (expected-type String) (arg-c String) (arg-expr (Ptr SExpr)))
    (@intent "Wrap function reference in slop_closure_t if expected type requires it")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    ;; If expected type is slop_closure_t and arg is a function name (symbol),
    ;; wrap it: (slop_closure_t){(void*)fn_name, NULL}
    (if (string-eq expected-type "slop_closure_t")
      ;; Check if original expression is a symbol (function reference)
      (match (deref arg-expr)
        ((sym sym)
          ;; Look up using SLOP name, wrap with C name
          (let ((slop-name (. sym name)))
            (match (ctx-lookup-func ctx slop-name)
              ((some _)
                (ctx-str5 ctx "(slop_closure_t){(void*)" arg-c ", NULL}" "" ""))
              ((none) arg-c))))
        (else arg-c))
      arg-c))

  (fn build-union-case-expr ((ctx (Ptr TranspileContext)) (arena Arena) (cases String)
                             (scrutinee (Ptr SExpr)) (pattern (Ptr SExpr)) (branch-items (List (Ptr SExpr))) (result-type String))
    (@intent "Build a single union case for expression-level match")
    (@spec (((Ptr TranspileContext) Arena String (Ptr SExpr) (Ptr SExpr) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (let ((tag (get-expr-pattern-tag pattern))
          (is-void (string-eq result-type "void")))
      (cond
        ((or (string-eq tag "else") (string-eq tag "_"))
          ;; Default case
          (let ((body (typed-none ctx result-type (get-match-branch-body ctx branch-items))))
            (if is-void
              (ctx-str ctx cases (ctx-str3 ctx "default: { " body "; break; } "))
              (ctx-str ctx cases (ctx-str3 ctx "default: { _mr = " body "; break; } ")))))
        (else
          ;; Regular variant case
          (match (ctx-lookup-enum-variant ctx tag)
            ((some type-name)
              (let ((c-tag (to-c-name arena tag))
                    (case-label (ctx-str4 ctx type-name "_" c-tag ""))
                    (binding-opt (get-expr-binding-name pattern)))
                (match binding-opt
                  ((some binding-name)
                    ;; Has binding - need to bind variable and transpile body with scope
                    (let ((c-binding (to-c-name arena binding-name))
                          (body (typed-none ctx result-type (transpile-branch-body-with-binding ctx scrutinee branch-items binding-name)))
                          (s1 (ctx-str ctx cases "case "))
                          (s2 (ctx-str ctx s1 case-label))
                          (s3 (ctx-str ctx s2 ": { __auto_type "))
                          (s4 (ctx-str ctx s3 c-binding))
                          (s5 (ctx-str ctx s4 " = _mv.data."))
                          (s6 (ctx-str ctx s5 c-tag))
                          (s7 (if is-void
                                (ctx-str ctx s6 "; ")
                                (ctx-str ctx s6 "; _mr = ")))
                          (s8 (ctx-str ctx s7 body))
                          (s9 (ctx-str ctx s8 "; break; } ")))
                      s9))
                  ((none)
                    ;; No binding
                    (let ((body (typed-none ctx result-type (get-match-branch-body ctx branch-items)))
                          (s1 (ctx-str ctx cases "case "))
                          (s2 (ctx-str ctx s1 case-label))
                          (s3 (if is-void
                                (ctx-str ctx s2 ": { ")
                                (ctx-str ctx s2 ": { _mr = ")))
                          (s4 (ctx-str ctx s3 body))
                          (s5 (ctx-str ctx s4 "; break; } ")))
                      s5)))))
            ((none) cases))))))

  (fn build-ternary-match-expr ((ctx (Ptr TranspileContext)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build match as ternary chain for literals/enums")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; For exhaustive matches (no else), use last branch as default to avoid type mismatch
    ;; Build chain in reverse: last branch becomes innermost fallback
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result "")
          (mut has-else false)
          (mut first-branch true)
          (mut i (- len 1)))
      (while (>= i 2)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-expr-pattern-tag pattern))
                              (body (get-match-branch-body ctx branch-items)))
                          (cond
                            ;; else/_ clause - use as default
                            ((or (string-eq tag "else") (string-eq tag "_"))
                              (set! result body)
                              (set! has-else true)
                              (set! first-branch false))
                            ;; First non-else branch in reverse order - use as default for exhaustive matches
                            (first-branch
                              (set! result body)
                              (set! first-branch false))
                            ;; Subsequent branches - wrap in ternary
                            (else
                              (let ((pattern-c (transpile-expr ctx pattern)))
                                ;; Build: ((scrutinee == pattern) ? body : result)
                                (set! result (ctx-str ctx
                                  (ctx-str ctx "((" scrutinee-c)
                                  (ctx-str ctx " == "
                                    (ctx-str ctx pattern-c
                                      (ctx-str ctx ") ? "
                                        (ctx-str ctx body
                                          (ctx-str ctx " : " (ctx-str ctx result ")")))))))))))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (- i 1)))
      ;; If no branches at all, return 0
      (if (string-eq result "")
        "0"
        result)))

  ;; ============================================================
  ;; Expression-position statement forms (GCC statement expressions)
  ;; ============================================================

  (fn transpile-let-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile let as expression using GCC statement expression")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (let ((bindings...)) body...) -> ({ binding1; binding2; ...; result; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some bindings-expr)
            (match (deref bindings-expr)
              ((lst bindings-lst)
                ;; Push scope for let bindings
                (ctx-push-scope ctx)
                (let ((mut result "({ ")
                      (bindings-items (. bindings-lst items))
                      (bindings-len (list-len bindings-items))
                      (mut bi 0))
                  ;; First pass: register all binding names in context
                  ;; (so nested lambdas can find them during free var analysis)
                  (while (< bi bindings-len)
                    (match (list-get bindings-items bi)
                      ((some binding)
                        (register-let-binding-in-context ctx binding))
                      ((none) (do)))
                    (set! bi (+ bi 1)))
                  ;; Second pass: emit bindings
                  (set! bi 0)
                  (while (< bi bindings-len)
                    (match (list-get bindings-items bi)
                      ((some binding)
                        (let ((binding-c (transpile-binding-expr ctx binding)))
                          (set! result (ctx-str3 ctx result binding-c " "))))
                      ((none) (do)))
                    (set! bi (+ bi 1)))
                  ;; Emit body expressions (all but last as statements)
                  (let ((mut i 2))
                    (while (< i (- len 1))
                      (match (list-get items i)
                        ((some body-expr)
                          (let ((body-c (transpile-expr ctx body-expr)))
                            (set! result (ctx-str3 ctx result body-c "; "))))
                        ((none) (do)))
                      (set! i (+ i 1)))
                    ;; Last body expression is the result
                    (let ((final-result
                           (match (list-get items (- len 1))
                             ((some last-expr)
                               (let ((last-c (transpile-expr ctx last-expr)))
                                 (ctx-str3 ctx result last-c "; })")))
                             ((none) (ctx-str ctx result "0; })")))))
                      ;; Pop scope before returning
                      (ctx-pop-scope ctx)
                      final-result))))
              (else "({ (void)0; })")))
          ((none) "({ (void)0; })")))))

  (fn register-let-binding-in-context ((ctx (Ptr TranspileContext)) (binding (Ptr SExpr)))
    (@intent "Register a let binding's variable name in context for free var analysis")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {binding != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref binding)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 2)
              ;; Check for mut: (mut name init) or (mut name Type init)
              (let ((has-mut (binding-has-mut items))
                    (name-idx (if has-mut 1 0))
                    (has-type (if has-mut (>= len 4) (>= len 3)))
                    (type-idx (+ name-idx 1))
                    (init-idx (if has-mut (if has-type 3 2) (if has-type 2 1))))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((sym name-sym)
                        (let ((var-name (. name-sym name))
                              (c-name (to-c-name arena var-name))
                              ;; Get C type: prefer explicit type annotation, else infer from init
                              (c-type (if has-type
                                        ;; Use explicit type annotation
                                        (match (list-get items type-idx)
                                          ((some type-expr) (to-c-type-prefixed ctx type-expr))
                                          ((none) "int64_t"))
                                        ;; No explicit type - infer from init expr
                                        (match (list-get items init-idx)
                                          ((some init-expr)
                                            (match (get-node-resolved-type init-expr)
                                              ((some rt) (resolved-type-to-c arena rt))
                                              ((none) "int64_t")))
                                          ((none) "int64_t")))))
                          ;; Register in context so nested lambdas can find it
                          (ctx-bind-var ctx (VarEntry var-name c-name c-type "" false false false "" ""))))
                      (else (do))))
                  ((none) (do)))))))
        (else (do)))))

  (fn transpile-binding-expr ((ctx (Ptr TranspileContext)) (binding (Ptr SExpr)))
    (@intent "Transpile a single let binding for expression context")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {binding != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref binding)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              ""
              ;; Check for mut: (mut name init) or (mut name Type init)
              (let ((has-mut (binding-has-mut items))
                    (name-idx (if has-mut 1 0)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((sym name-sym)
                        (let ((var-name (to-c-name arena (. name-sym name)))
                              ;; Determine init index: (name init) or (name Type init) or (mut name init) or (mut name Type init)
                              (has-type (if has-mut (>= len 4) (>= len 3)))
                              (type-idx (+ name-idx 1))
                              (init-idx (if has-mut (if has-type 3 2) (if has-type 2 1))))
                          ;; Use explicit type if provided, otherwise __auto_type
                          (if has-type
                            (match (list-get items type-idx)
                              ((some type-expr)
                                (let ((c-type (to-c-type-prefixed ctx type-expr)))
                                  (match (list-get items init-idx)
                                    ((some init-expr)
                                      ;; Check if init is (some ...) and use annotated type
                                      (let ((init-c (transpile-typed-init ctx init-expr c-type)))
                                        (ctx-str5 ctx c-type " " (ctx-str3 ctx var-name " = " init-c) ";" "")))
                                    ((none) (ctx-str5 ctx c-type " " var-name " = {0};" "")))))
                              ((none)
                                (match (list-get items init-idx)
                                  ((some init-expr)
                                    (let ((init-c (transpile-expr ctx init-expr)))
                                      (ctx-str5 ctx "__auto_type " var-name " = " init-c ";")))
                                  ((none) (ctx-str3 ctx "__auto_type " var-name " = 0;")))))
                            ;; No explicit type - use __auto_type
                            (match (list-get items init-idx)
                              ((some init-expr)
                                (let ((init-c (transpile-expr ctx init-expr)))
                                  (ctx-str5 ctx "__auto_type " var-name " = " init-c ";")))
                              ((none) (ctx-str3 ctx "__auto_type " var-name " = 0;"))))))
                      (else "")))
                  ((none) ""))))))
        (else ""))))

  (fn binding-has-mut ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with mut keyword")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym) (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn transpile-typed-init ((ctx (Ptr TranspileContext)) (init-expr (Ptr SExpr)) (target-type String))
    (@intent "Transpile init expression with known target type (handles some/none)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (@pre {init-expr != nil})
    ;; Check if init is (some ...) or (none) and target is an Option type
    (match (deref init-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            (transpile-expr ctx init-expr)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; (some value) with known Option type
                        ((string-eq op "some")
                          (if (< (list-len items) 2)
                            (transpile-expr ctx init-expr)
                            (match (list-get items 1)
                              ((some val-expr)
                                (let ((val-c (transpile-expr ctx val-expr)))
                                  ;; Use target type for Option construction
                                  (ctx-str5 ctx "(" target-type "){.has_value = 1, .value = " val-c "}")))
                              ((none) (transpile-expr ctx init-expr)))))
                        ;; (none) with known Option type
                        ((string-eq op "none")
                          (ctx-str3 ctx "(" target-type "){.has_value = false}"))
                        ;; Other expressions - default transpilation
                        (else (transpile-expr ctx init-expr)))))
                  (else (transpile-expr ctx init-expr))))
              ((none) (transpile-expr ctx init-expr))))))
      (else (transpile-expr ctx init-expr))))

  (fn transpile-while-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile while as expression (side effect only, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (while cond body) -> ({ while (cond) { body; } 0; })
    (let ((len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some cond-expr)
            (let ((cond-c (transpile-expr ctx cond-expr))
                  (mut body-str ""))
              ;; Emit body statements
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some body-expr)
                      (let ((body-c (transpile-expr ctx body-expr)))
                        (set! body-str (ctx-str3 ctx body-str body-c "; "))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              ;; Build result string
              (let ((part1 (ctx-str3 ctx "({ while (" cond-c ") { "))
                    (part2 (ctx-str ctx body-str "} 0; })")))
                (ctx-str ctx part1 part2))))
          ((none) "({ (void)0; })")))))

  (fn transpile-do-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile do as expression (sequence, returns last value)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (do e1 e2 ... en) -> ({ e1; e2; ...; en; })
    (let ((len (list-len items)))
      (if (<= len 1)
        "({ (void)0; })"
        (let ((mut result "({ ")
              (mut i 1))
          (while (< i len)
            (match (list-get items i)
              ((some expr)
                (let ((expr-c (transpile-expr ctx expr))
                      (is-last (== i (- len 1))))
                  (set! result (ctx-str3 ctx result expr-c "; "))))
              ((none) (do)))
            (set! i (+ i 1)))
          (ctx-str ctx result "})")))))

  (fn transpile-when-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile when as expression (side effect, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (when cond body...) -> ((cond) ? ({ body...; (void)0; }) : ({ (void)0; }))
    (let ((len (list-len items)))
      (if (< len 2)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some cond-expr)
            (let ((cond-c (transpile-expr ctx cond-expr))
                  (mut body-c "({ "))
              ;; Transpile body expressions (items 2..n)
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some body-expr)
                      (set! body-c (ctx-str3 ctx body-c (transpile-expr ctx body-expr) "; ")))
                    ((none) (do)))
                  (set! i (+ i 1))))
              (set! body-c (ctx-str ctx body-c "0; })"))
              (ctx-str5 ctx "((" cond-c ") ? " body-c " : ({ (void)0; }))")))
          ((none) "({ (void)0; })")))))

  (fn transpile-set-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set! as expression (side effect, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (set! target value) -> ({ target = value; (void)0; })
    ;; or (set! (@ arr idx) value) -> ({ arr[idx] = value; (void)0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some target-expr)
            (match (list-get items 2)
              ((some val-expr)
                (let ((val-c (transpile-expr ctx val-expr)))
                  ;; Check if target is array indexing (@ arr idx)
                  (match (deref target-expr)
                    ((lst target-lst)
                      (let ((target-items (. target-lst items)))
                        (if (< (list-len target-items) 1)
                          (ctx-str5 ctx "({ " (transpile-expr ctx target-expr) " = " val-c "; (void)0; })")
                          (match (list-get target-items 0)
                            ((some head)
                              (match (deref head)
                                ((sym sym)
                                  (let ((op (. sym name)))
                                    (cond
                                      ;; Array indexing: (@ arr idx) = value
                                      ((string-eq op "@")
                                        (if (< (list-len target-items) 3)
                                          "({ (void)0; })"
                                          (match (list-get target-items 1)
                                            ((some arr-expr)
                                              (match (list-get target-items 2)
                                                ((some idx-expr)
                                                  (let ((arr-c (transpile-expr ctx arr-expr))
                                                        (idx-c (transpile-expr ctx idx-expr)))
                                                    (ctx-str ctx "({ " (ctx-str ctx arr-c (ctx-str ctx "[" (ctx-str ctx idx-c (ctx-str ctx "] = " (ctx-str ctx val-c "; (void)0; })"))))))))
                                                ((none) "({ (void)0; })")))
                                            ((none) "({ (void)0; })"))))
                                      ;; Field assignment: (. obj field) = value
                                      ((string-eq op ".")
                                        (let ((target-c (transpile-expr ctx target-expr)))
                                          (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))
                                      (else
                                        (let ((target-c (transpile-expr ctx target-expr)))
                                          (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })"))))))
                                (_ (let ((target-c (transpile-expr ctx target-expr)))
                                     (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))))
                            ((none) "({ (void)0; })")))))
                    ;; Simple variable assignment - look up in context for captured vars
                    ((sym sym)
                      (let ((var-name (. sym name))
                            (target-c (match (ctx-lookup-var ctx var-name)
                                        ((some entry) (. entry c-name))
                                        ((none) (to-c-name arena var-name)))))
                        (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))
                    (else
                      (let ((target-c (transpile-expr ctx target-expr)))
                        (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })"))))))
              ((none) "({ (void)0; })")))
          ((none) "({ (void)0; })")))))

  ;; ============================================================
  ;; Arena Detection for list-push
  ;; ============================================================

  (fn get-arena-for-list-push-expr ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)) (list-c String))
    (@intent "Get arena source for list-push by analyzing list expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    ;; First priority: check if "arena" variable is in scope (most functions have arena param)
    (match (ctx-lookup-var ctx "arena")
      ((some arena-var)
        ;; arena is in scope - use it directly
        (. arena-var c-name))
      ((none)
        ;; Second priority: check for "ctx" variable which has arena field
        (match (ctx-lookup-var ctx "ctx")
          ((some ctx-var)
            ;; ctx is in scope - use ctx->arena
            (ctx-str ctx (. ctx-var c-name) "->arena"))
          ((none)
            ;; Third priority: check if list-expr is a field access pattern (. BASE FIELD)
            ;; Extract arena from BASE (e.g., (. (deref env) types) -> env->arena)
            (let ((arena-from-field (get-arena-from-field-access ctx list-expr)))
              (if (> (string-len arena-from-field) 0)
                arena-from-field
                ;; Fallback to "arena" - will error if not available
                "arena")))))))

  (fn get-arena-from-field-access ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract arena from base struct if expr is field access (. BASE FIELD)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Match pattern: (. BASE FIELD) where BASE might be (deref VAR) or VAR
    ;; Returns arena from BASE, or empty string if not a field access
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 3)
            "" ;; Not enough elements for field access
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (if (string-eq (. sym name) ".")
                      ;; This is a field access: (. BASE FIELD)
                      (match (list-get items 1)
                        ((some base-expr)
                          ;; Get arena from the base expression
                          (get-arena-from-base ctx base-expr))
                        ((none) ""))
                      "")) ;; Not a field access
                  (else ""))) ;; Head is not a symbol
              ((none) ""))))) ;; Missing head
      (else ""))) ;; Not a list

  (fn get-arena-from-base ((ctx (Ptr TranspileContext)) (base-expr (Ptr SExpr)))
    (@intent "Extract arena from a base expression - return base->arena or base.arena")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {base-expr != nil})
    (match (deref base-expr)
      ;; Simple symbol - check if it's a pointer variable
      ((sym sym)
        (let ((var-name (. sym name)))
          (match (ctx-lookup-var ctx var-name)
            ((some entry)
              ;; Check if it's a pointer variable
              (if (. entry is-pointer)
                (ctx-str ctx (. entry c-name) "->arena")
                (ctx-str ctx (. entry c-name) ".arena")))
            ((none)
              ;; Unknown variable - assume pointer access
              (let ((arena (. (deref ctx) arena))
                    (c-name (to-c-name arena var-name)))
                (ctx-str ctx c-name "->arena"))))))
      ;; Deref expression: (deref ptr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            "arena"
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (if (string-eq (. sym name) "deref")
                      ;; (deref ptr) -> ptr->arena
                      (match (list-get items 1)
                        ((some ptr-expr)
                          (let ((ptr-c (transpile-expr ctx ptr-expr)))
                            (ctx-str ctx ptr-c "->arena")))
                        ((none) "arena"))
                      ;; Not a deref
                      "arena"))
                  (else "arena")))
              ((none) "arena")))))
      (else "arena")))

  ;; Keep old function for compatibility
  (fn get-arena-for-list-push ((ctx (Ptr TranspileContext)) (list-c String))
    (@intent "Get arena source for list-push - use arena from scope")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Fallback - use arena from scope
    "arena")

  ;; ============================================================
  ;; Map Type Helpers
  ;; ============================================================

  (fn is-ptr-to-ptr-map ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression is a pointer-to-pointer map (Ptr (Map ...)) -> slop_map**")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Check if expr is a symbol with type ending in **
    (match (deref expr)
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some entry)
              (let ((c-type (. entry c-type)))
                (ends-with c-type "**")))
            ((none) false))))
      (else false)))

  ;; ============================================================
  ;; Record-new, List Literal, and Map Operations
  ;; ============================================================

  (fn transpile-record-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile record-new expression to C compound literal")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "record-new: missing type" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some type-expr)
            (match (deref type-expr)
              ;; Named type: (record-new TypeName (field1 val1) ...)
              ((sym type-sym)
                (let ((raw-type-name (. type-sym name))
                      (type-name (match (ctx-lookup-type ctx raw-type-name)
                                   ((some entry) (. entry c-name))
                                   ((none) (ctx-prefix-type ctx (to-c-name arena raw-type-name))))))
                  (transpile-record-fields ctx type-name items 2)))
              ;; Inline record type: (record-new (record (f1 T1) (f2 T2)) (f1 v1) (f2 v2))
              ((lst type-lst)
                (let ((type-items (. type-lst items)))
                  (if (< (list-len type-items) 1)
                    (do
                      (ctx-add-error-at ctx "record-new: invalid inline type" (ctx-list-first-line items) (ctx-list-first-col items))
                      "0")
                    (match (list-get type-items 0)
                      ((some head)
                        (match (deref head)
                          ((sym head-sym)
                            (if (string-eq (. head-sym name) "record")
                              ;; Use to-c-type-prefixed to get the registered typedef name
                              (let ((type-name (to-c-type-prefixed ctx type-expr)))
                                (transpile-record-fields ctx type-name items 2))
                              (do
                                (ctx-add-error-at ctx "record-new: expected record keyword" (ctx-list-first-line items) (ctx-list-first-col items))
                                "0")))
                          (else
                            (do
                              (ctx-add-error-at ctx "record-new: invalid type head" (ctx-list-first-line items) (ctx-list-first-col items))
                              "0"))))
                      ((none)
                        (do
                          (ctx-add-error-at ctx "record-new: empty type" (ctx-list-first-line items) (ctx-list-first-col items))
                          "0"))))))
              (else
                (do
                  (ctx-add-error-at ctx "record-new: invalid type" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "record-new: missing type" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn transpile-record-fields ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Build field assignments for record compound literal")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (ctx-str ctx "((" (ctx-str ctx type-name "){")))
          (mut i start-idx)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some val-expr)
                                (let ((raw-field-name (. name-sym name))
                                      (field-name (to-c-name arena raw-field-name))
                                      (field-type-opt (ctx-lookup-field-type ctx type-name raw-field-name))
                                      (field-val (match field-type-opt
                                                   ((some field-type) (transpile-typed-init ctx val-expr field-type))
                                                   ((none) (transpile-expr ctx val-expr)))))
                                  (if first
                                    (set! result (ctx-str ctx result (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " field-val)))))
                                    (set! result (ctx-str ctx result (ctx-str ctx ", ." (ctx-str ctx field-name (ctx-str ctx " = " field-val))))))
                                  (set! first false)))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "})")))

  (fn build-inline-struct-type ((ctx (Ptr TranspileContext)) (type-items (List (Ptr SExpr))))
    (@intent "Build anonymous struct type definition from inline record")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len type-items))
          (mut result "struct { ")
          (mut i 1))  ;; Skip 'record' keyword
      (while (< i len)
        (match (list-get type-items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some type-expr)
                                (let ((field-name (to-c-name arena (. name-sym name)))
                                      (field-type (to-c-type-prefixed ctx type-expr)))
                                  (set! result (ctx-str ctx result (ctx-str ctx field-type (ctx-str ctx " " (ctx-str ctx field-name "; ")))))))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "}")))

  (fn transpile-inline-record-fields ((ctx (Ptr TranspileContext)) (struct-def String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Build field assignments for inline record compound literal")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (ctx-str ctx "((" (ctx-str ctx struct-def "){")))
          (mut i start-idx)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some val-expr)
                                (let ((field-name (to-c-name arena (. name-sym name)))
                                      (field-val (transpile-expr ctx val-expr)))
                                  (if first
                                    (set! result (ctx-str ctx result (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " field-val)))))
                                    (set! result (ctx-str ctx result (ctx-str ctx ", ." (ctx-str ctx field-name (ctx-str ctx " = " field-val))))))
                                  (set! first false)))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "})")))

  (fn transpile-list-literal ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile list literal to inline array")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "list: missing type" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some type-expr)
            (let ((elem-type (to-c-type-prefixed ctx type-expr))
                  (elem-count (- len 2)))
              ;; Generate: (slop_list_TYPE){.len = N, .cap = N, .data = (TYPE[]){e1, e2, ...}}
              (let ((type-id (type-to-identifier arena elem-type))
                    (count-str (int-to-string arena elem-count))
                    (mut result (ctx-str ctx "((slop_list_" (ctx-str ctx type-id "){")))
                    (mut data-part (ctx-str ctx ".len = " (ctx-str ctx count-str (ctx-str ctx ", .cap = " (ctx-str ctx count-str (ctx-str ctx ", .data = (" (ctx-str ctx elem-type "[]){")))))))
                    (mut i 2)
                    (mut first true))
                (while (< i len)
                  (match (list-get items i)
                    ((some elem-expr)
                      (let ((elem-c (transpile-expr ctx elem-expr)))
                        (if first
                          (set! data-part (ctx-str ctx data-part elem-c))
                          (set! data-part (ctx-str ctx data-part (ctx-str ctx ", " elem-c))))
                        (set! first false)))
                    ((none) (do)))
                  (set! i (+ i 1)))
                (ctx-str ctx result (ctx-str ctx data-part "}})")))))
          ((none)
            (do
              (ctx-add-error-at ctx "list: missing type" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  ;; ============================================================
  ;; Map Key Type Info
  ;;
  ;; Returns C code suffix with sizeof, hash function, and eq function
  ;; for the given key type expression: "sizeof(...), hash_fn, eq_fn"
  ;; ============================================================

  (fn build-struct-key-info ((ctx (Ptr TranspileContext)) (c-name String))
    (@intent "Build sizeof/hash/eq info string for a struct key type")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Generate: sizeof(TypeName), slop_hash_TypeName, slop_eq_TypeName
    (ctx-str ctx "sizeof("
      (ctx-str ctx c-name
        (ctx-str ctx "), slop_hash_"
          (ctx-str ctx c-name
            (ctx-str ctx ", slop_eq_" c-name))))))

  (fn get-map-key-c-info ((ctx (Ptr TranspileContext)) (key-type-expr (Ptr SExpr)))
    (@intent "Get sizeof, hash fn, eq fn suffix for map key type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {key-type-expr != nil})
    (match (deref key-type-expr)
      ;; Symbol: check for builtin types
      ((sym sym)
        (let ((name (. sym name)))
          (cond
            ;; String -> slop_string
            ((string-eq name "String")
              "sizeof(slop_string), slop_hash_string, slop_eq_string")
            ;; Int, I64 -> int64_t
            ((or (string-eq name "Int") (string-eq name "I64"))
              "sizeof(int64_t), slop_hash_int, slop_eq_int")
            ;; I32 -> int32_t (use int hash)
            ((string-eq name "I32")
              "sizeof(int32_t), slop_hash_int, slop_eq_int")
            ;; Uint, U64 -> uint64_t
            ((or (string-eq name "Uint") (string-eq name "U64"))
              "sizeof(uint64_t), slop_hash_uint, slop_eq_uint")
            ;; U32 -> uint32_t (use uint hash)
            ((string-eq name "U32")
              "sizeof(uint32_t), slop_hash_uint, slop_eq_uint")
            ;; Symbol -> int64_t (symbols are interned as integers)
            ((string-eq name "Symbol")
              "sizeof(int64_t), slop_hash_symbol, slop_eq_symbol")
            ;; User-defined type: look up and generate struct hash/eq
            (else
              (let ((arena (. (deref ctx) arena))
                    (result (get-struct-key-info-by-name ctx name)))
                (if (> (string-len result) 0)
                  result
                  ;; Fall back to direct name conversion
                  (let ((c-name (to-c-name arena name)))
                    (ctx-register-struct-key-type ctx c-name)
                    (build-struct-key-info ctx c-name))))))))
      ;; List: check for (Ptr T)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "sizeof(void*), slop_hash_ptr, slop_eq_ptr"
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((head-name (. sym name)))
                      (if (string-eq head-name "Ptr")
                        "sizeof(void*), slop_hash_ptr, slop_eq_ptr"
                        ;; Default to string for unknown compound types
                        "sizeof(slop_string), slop_hash_string, slop_eq_string")))
                  (_ "sizeof(slop_string), slop_hash_string, slop_eq_string")))
              ((none) "sizeof(void*), slop_hash_ptr, slop_eq_ptr")))))
      ;; Default fallback
      (_ "sizeof(slop_string), slop_hash_string, slop_eq_string")))

  (fn get-struct-key-info-by-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Look up a type by name and return struct key info if found")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Try direct lookup first
    (match (ctx-lookup-type ctx name)
      ((some type-entry)
        (let ((c-name (. type-entry c-name)))
          (ctx-register-struct-key-type ctx c-name)
          (build-struct-key-info ctx c-name)))
      ((none)
        ;; Try with module prefix
        (match (ctx-get-module ctx)
          ((some mod)
            (let ((prefixed (ctx-str3 ctx mod "_" name)))
              (match (ctx-lookup-type ctx prefixed)
                ((some type-entry)
                  (let ((c-name (. type-entry c-name)))
                    (ctx-register-struct-key-type ctx c-name)
                    (build-struct-key-info ctx c-name)))
                ((none) ""))))
          ((none) "")))))

  (fn transpile-map-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-new to slop_map_new_ptr with key type info")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        ;; Backward compat: if only arena, default to string keys
        (if (< len 2)
          (do
            (ctx-add-error-at ctx "map-new: missing arena" (ctx-list-first-line items) (ctx-list-first-col items))
            "NULL")
          (match (list-get items 1)
            ((some arena-expr)
              (let ((arena-c (transpile-expr ctx arena-expr)))
                ;; Default to string keys for backward compatibility
                (ctx-str ctx "slop_map_new_ptr(" (ctx-str ctx arena-c ", 16, sizeof(slop_string), slop_hash_string, slop_eq_string)"))))
            ((none)
              (do
                (ctx-add-error-at ctx "map-new: missing arena" (ctx-list-first-line items) (ctx-list-first-col items))
                "NULL"))))
        ;; Full form: (map-new arena KeyType ValueType)
        (match (list-get items 1)
          ((some arena-expr)
            (match (list-get items 2)
              ((some key-type-expr)
                (let ((arena-c (transpile-expr ctx arena-expr))
                      (key-info (get-map-key-c-info ctx key-type-expr)))
                  ;; Generate: slop_map_new_ptr(arena, 16, sizeof_expr, hash_fn, eq_fn)
                  ;; key-info is already the formatted string "sizeof(...), hash_fn, eq_fn"
                  (ctx-str ctx "slop_map_new_ptr("
                    (ctx-str ctx arena-c
                      (ctx-str ctx ", 16, "
                        (ctx-str ctx key-info ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-new: missing KeyType" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-new: missing arena" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; Map Key Wrapping
  ;;
  ;; The generic map API expects keys as const void*.
  ;; For structs (slop_string), pass &key.
  ;; For primitives, use compound literal: &(type){key}
  ;; ============================================================

  (fn is-c-primitive-type ((t String))
    (@intent "Check if type is a C primitive that works with compound literals")
    (@spec ((String) -> Bool))
    (cond
      ((string-eq t "int64_t") true)
      ((string-eq t "int32_t") true)
      ((string-eq t "int16_t") true)
      ((string-eq t "int8_t") true)
      ((string-eq t "uint64_t") true)
      ((string-eq t "uint32_t") true)
      ((string-eq t "uint16_t") true)
      ((string-eq t "uint8_t") true)
      ((string-eq t "double") true)
      ((string-eq t "float") true)
      ((string-eq t "bool") true)
      (else false)))

  (fn wrap-map-key-as-ptr ((ctx (Ptr TranspileContext)) (key-c String) (key-expr (Ptr SExpr)) (container-expr (Ptr SExpr)))
    (@intent "Wrap transpiled key expression as pointer for map/set operations")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {key-expr != nil})
    ;; container-expr may be nil (e.g., for set literals where type is explicit)
    (let ((container-key-type
            (if (!= container-expr nil)
              ;; Try map key type first, then set element type
              (let ((map-type (infer-map-key-c-type ctx container-expr)))
                (if (> (string-len map-type) 0)
                  map-type
                  (infer-set-elem-c-type ctx container-expr)))
              ""))
          (key-type (if (> (string-len container-key-type) 0)
                      container-key-type
                      (infer-expr-c-type ctx key-expr))))
      (cond
        ;; slop_string is a struct, just take address
        ((string-eq key-type "slop_string")
          (ctx-str ctx "&(" (ctx-str ctx key-c ")")))
        ;; Pointer types - cast and take address
        ((ends-with key-type "*")
          (ctx-str ctx "&(void*){" (ctx-str ctx key-c "}")))
        ;; Primitives - use compound literal (works for scalars)
        ((is-c-primitive-type key-type)
          (ctx-str ctx "&(" (ctx-str ctx key-type (ctx-str ctx "){" (ctx-str ctx key-c "}")))))
        ;; Struct/union types - just take address (compound literal doesn't work)
        (else
          (ctx-str ctx "&(" (ctx-str ctx key-c ")"))))))

  (fn transpile-map-put ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-put to slop_map_put with proper key pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 4)
        (do
          (ctx-add-error-at ctx "map-put: needs map, key, val" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (match (list-get items 3)
                  ((some val-expr)
                    (let ((map-c (transpile-expr ctx map-expr))
                          (key-c (transpile-expr ctx key-expr))
                          (val-c (transpile-expr ctx val-expr))
                          ;; Wrap key as pointer for generic map API
                          (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr))
                          ;; Check if map is a pointer-to-pointer (Ptr Map -> slop_map**)
                          (needs-deref (is-ptr-to-ptr-map ctx map-expr)))
                      ;; slop_map_put expects arena, slop_map* and key as const void*
                      ;; Arena is assumed to be in scope from with-arena
                      ;; Allocate value on arena so it persists beyond the statement
                      ;; If we have slop_map**, dereference once
                      (if needs-deref
                        (let ((s1 (ctx-str ctx "({ __auto_type _val = " val-c))
                              (s2 (ctx-str ctx s1 "; void* _vptr = slop_arena_alloc(arena, sizeof(_val)); memcpy(_vptr, &_val, sizeof(_val)); slop_map_put(arena, (*"))
                              (s3 (ctx-str ctx s2 map-c))
                              (s4 (ctx-str ctx s3 "), "))
                              (s5 (ctx-str ctx s4 key-ptr))
                              (s6 (ctx-str ctx s5 ", _vptr); })")))
                          s6)
                        (let ((s1 (ctx-str ctx "({ __auto_type _val = " val-c))
                              (s2 (ctx-str ctx s1 "; void* _vptr = slop_arena_alloc(arena, sizeof(_val)); memcpy(_vptr, &_val, sizeof(_val)); slop_map_put(arena, "))
                              (s3 (ctx-str ctx s2 map-c))
                              (s4 (ctx-str ctx s3 ", "))
                              (s5 (ctx-str ctx s4 key-ptr))
                              (s6 (ctx-str ctx s5 ", _vptr); })")))
                          s6))))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "map-put: missing val" (ctx-list-first-line items) (ctx-list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-put: missing key" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-put: missing map" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn transpile-map-get ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-get to slop_map_get with proper key pointer wrapping and inferred value type")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "map-get: needs map, key" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (let ((map-c (transpile-expr ctx map-expr))
                      (key-c (transpile-expr ctx key-expr))
                      ;; Wrap key as pointer for generic map API
                      (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr))
                      ;; Infer option type from map's value type
                      (option-type (infer-map-value-option-type ctx map-expr)))
                  ;; If we have a named option type, use it; otherwise use anonymous struct
                  (if (> (string-len option-type) 0)
                    ;; Named option type available - register it and generate proper code
                    (let ((inner-type-name (substring-after-prefix arena option-type "slop_option_"))
                          (value-c-type (option-type-to-value-c-type arena option-type)))
                      ;; Register the option type using inner-type-name so set_* types are properly detected
                      (ctx-register-option-type ctx inner-type-name option-type)
                      (ctx-str ctx "({ void* _ptr = slop_map_get("
                        (ctx-str ctx map-c
                          (ctx-str ctx ", "
                            (ctx-str ctx key-ptr
                              (ctx-str ctx "); _ptr ? ("
                                (ctx-str ctx option-type
                                  (ctx-str ctx "){ .has_value = true, .value = *("
                                    (ctx-str ctx value-c-type
                                      (ctx-str ctx "*)_ptr } : ("
                                        (ctx-str ctx option-type
                                          "){ .has_value = false }; })")))))))))))
                    ;; Fallback to anonymous struct
                    (ctx-str ctx "({ void* _ptr = slop_map_get("
                      (ctx-str ctx map-c
                        (ctx-str ctx ", "
                          (ctx-str ctx key-ptr
                            "); struct { bool has_value; void* value; } _r; if (_ptr) { _r.has_value = true; _r.value = _ptr; } else { _r.has_value = false; } _r; })")))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-get: missing key" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-get: missing map" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  (fn transpile-map-has ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-has to check for non-NULL with proper key pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "map-has: needs map, key" (ctx-list-first-line items) (ctx-list-first-col items))
          "false")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (let ((map-c (transpile-expr ctx map-expr))
                      (key-c (transpile-expr ctx key-expr))
                      ;; Wrap key as pointer for generic map API
                      (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr)))
                  ;; Generate: (slop_map_get(MAP, KEY_PTR) != NULL)
                  (ctx-str ctx "(slop_map_get(" (ctx-str ctx map-c (ctx-str ctx ", " (ctx-str ctx key-ptr ") != NULL)"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-has: missing key" (ctx-list-first-line items) (ctx-list-first-col items))
                  "false"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-has: missing map" (ctx-list-first-line items) (ctx-list-first-col items))
              "false"))))))

  (fn transpile-map-keys ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-keys to properly typed list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "map-keys: needs map" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some map-expr)
            (let ((map-c (transpile-expr ctx map-expr))
                  (key-c-type (infer-map-key-c-type ctx map-expr))
                  ;; Debug: get variable name and slop-type
                  (debug-var-name (get-var-name-from-expr map-expr))
                  (debug-slop-type (match (ctx-lookup-var ctx debug-var-name)
                                     ((some entry) (. entry slop-type))
                                     ((none) "VAR_NOT_FOUND"))))
              ;; Check if key type is string - use legacy slop_map_keys
              (if (or (string-eq key-c-type "slop_string") (== (string-len key-c-type) 0))
                ;; Generate: slop_map_keys(arena, MAP) with debug info
                (ctx-str ctx "/* DEBUG: var=" (ctx-str ctx debug-var-name (ctx-str ctx " slop=" (ctx-str ctx debug-slop-type (ctx-str ctx " key=" (ctx-str ctx key-c-type (ctx-str ctx " */ slop_map_keys(arena, " (ctx-str ctx map-c ")"))))))))
                ;; Generate typed list from raw elements:
                ;; ({ slop_set_elements_result _r = slop_set_elements_raw(arena, MAP);
                ;;    (slop_list_KeyType){.data = (KeyType*)_r.data, .len = _r.len, .cap = _r.cap}; })
                (let ((list-type (ctx-str ctx "slop_list_" key-c-type)))
                  (ctx-str ctx "({ slop_set_elements_result _r = slop_set_elements_raw(arena, "
                    (ctx-str ctx map-c
                      (ctx-str ctx "); ("
                        (ctx-str ctx list-type
                          (ctx-str ctx "){.data = ("
                            (ctx-str ctx key-c-type
                              (ctx-str ctx "*)_r.data, .len = _r.len, .cap = _r.cap}; })" "")))))))))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-keys: missing map" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; Set Operations
  ;; ============================================================

  (fn transpile-set-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-new to slop_map_new_ptr with element type info")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-new: needs arena and ElementType" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some arena-expr)
            (match (list-get items 2)
              ((some elem-type-expr)
                (let ((arena-c (transpile-expr ctx arena-expr))
                      (elem-info (get-map-key-c-info ctx elem-type-expr)))
                  ;; Generate: slop_map_new_ptr(arena, 16, sizeof_expr, hash_fn, eq_fn)
                  (ctx-str ctx "slop_map_new_ptr("
                    (ctx-str ctx arena-c
                      (ctx-str ctx ", 16, "
                        (ctx-str ctx elem-info ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-new: missing ElementType" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-new: missing arena" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  (fn transpile-set-put ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-put to slop_map_put with dummy value")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-put: needs set, element" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  ;; Use a dummy 1-byte value for set membership
                  (ctx-str ctx "({ uint8_t _dummy = 1; slop_map_put(arena, "
                    (ctx-str ctx set-c
                      (ctx-str ctx ", "
                        (ctx-str ctx elem-ptr ", &_dummy); })"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-put: missing element" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-put: missing set" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn transpile-set-has ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-has to check for non-NULL with proper element pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-has: needs set, element" (ctx-list-first-line items) (ctx-list-first-col items))
          "false")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  (ctx-str ctx "(slop_map_get(" (ctx-str ctx set-c (ctx-str ctx ", " (ctx-str ctx elem-ptr ") != NULL)"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-has: missing element" (ctx-list-first-line items) (ctx-list-first-col items))
                  "false"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-has: missing set" (ctx-list-first-line items) (ctx-list-first-col items))
              "false"))))))

  (fn transpile-set-remove ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-remove to slop_map_remove with proper element pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-remove: needs set, element" (ctx-list-first-line items) (ctx-list-first-col items))
          "0")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  (ctx-str ctx "slop_map_remove(" (ctx-str ctx set-c (ctx-str ctx ", " (ctx-str ctx elem-ptr ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-remove: missing element" (ctx-list-first-line items) (ctx-list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-remove: missing set" (ctx-list-first-line items) (ctx-list-first-col items))
              "0"))))))

  (fn transpile-set-elements ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-elements to properly typed list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "set-elements: needs set" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some set-expr)
            (let ((set-c (transpile-expr ctx set-expr))
                  (elem-c-type (infer-set-elem-c-type ctx set-expr)))
              ;; Check if element type is string - use legacy slop_map_keys
              (if (or (string-eq elem-c-type "slop_string") (== (string-len elem-c-type) 0))
                ;; Generate: slop_map_keys(arena, SET)
                (ctx-str ctx "slop_map_keys(arena, " (ctx-str ctx set-c ")"))
                ;; Generate typed list from raw elements:
                ;; ({ slop_set_elements_result _r = slop_set_elements_raw(arena, SET);
                ;;    (slop_list_ElemType){.data = (ElemType*)_r.data, .len = _r.len, .cap = _r.cap}; })
                (let ((list-type (ctx-str ctx "slop_list_" elem-c-type)))
                  (ctx-str ctx "({ slop_set_elements_result _r = slop_set_elements_raw(arena, "
                    (ctx-str ctx set-c
                      (ctx-str ctx "); ("
                        (ctx-str ctx list-type
                          (ctx-str ctx "){.data = ("
                            (ctx-str ctx elem-c-type
                              (ctx-str ctx "*)_r.data, .len = _r.len, .cap = _r.cap}; })" "")))))))))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-elements: missing set" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  (fn transpile-set-literal ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set literal (set Type e1 e2...) to inline set construction")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "set: needs at least Type" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some type-expr)
            (let ((elem-info (get-map-key-c-info ctx type-expr))
                  ;; Build: ({ slop_map* _s = slop_map_new_ptr(arena, N, elem_info);
                  (num-elems (- len 2))
                  (init-cap (if (> num-elems 16) num-elems 16))
                  (mut result (ctx-str ctx "({ slop_map* _s = slop_map_new_ptr(arena, "
                                (ctx-str ctx (int-to-string arena init-cap)
                                  (ctx-str ctx ", "
                                    (ctx-str ctx elem-info "); "))))))
              ;; Add each element: slop_map_put(arena, _s, &elem, &(uint8_t){1});
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some elem-expr)
                      (let ((elem-c (transpile-expr ctx elem-expr))
                            (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr nil)))
                        (set! result (ctx-str ctx result
                          (ctx-str ctx "slop_map_put(arena, _s, "
                            (ctx-str ctx elem-ptr ", &(uint8_t){1}); "))))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              ;; Close: _s; })
              (ctx-str ctx result "_s; })")))
          ((none)
            (do
              (ctx-add-error-at ctx "set: missing type" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; For Loop as Expression
  ;; ============================================================

  (fn transpile-for-as-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile for loop as expression returning 0")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (for (var start end) body...) -> ({ for (int64_t var = start; var < end; var++) { body... } 0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        "({ /* for: need binding */ 0; })"
        (match (list-get items 1)
          ((some binding-expr)
            (match (deref binding-expr)
              ((lst binding-lst)
                (let ((binding-items (. binding-lst items))
                      (binding-len (list-len binding-items)))
                  (if (< binding-len 3)
                    "({ /* for: binding needs (var start end) */ 0; })"
                    (match (list-get binding-items 0)
                      ((some var-expr)
                        (match (deref var-expr)
                          ((sym var-sym)
                            (let ((var-name (to-c-name arena (. var-sym name))))
                              (match (list-get binding-items 1)
                                ((some start-expr)
                                  (match (list-get binding-items 2)
                                    ((some end-expr)
                                      (let ((start-c (transpile-expr ctx start-expr))
                                            (end-c (transpile-expr ctx end-expr))
                                            ;; Build: ({ for (int64_t var = start; var < end; var++) {
                                            (mut result (ctx-str5 ctx "({ for (int64_t " var-name " = " start-c
                                                          (ctx-str5 ctx "; " var-name " < " end-c
                                                            (ctx-str3 ctx "; " var-name "++) { ")))))
                                        ;; Bind loop variable for body expressions
                                        (ctx-push-scope ctx)
                                        (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "int64_t" "" false false false "" ""))
                                        ;; Process body expressions
                                        (let ((mut i 2))
                                          (while (< i len)
                                            (match (list-get items i)
                                              ((some body-expr)
                                                (let ((body-c (transpile-expr ctx body-expr)))
                                                  (set! result (ctx-str3 ctx result body-c "; "))))
                                              ((none) (do)))
                                            (set! i (+ i 1))))
                                        (ctx-pop-scope ctx)
                                        ;; Close: } 0; })
                                        (ctx-str ctx result "} 0; })")))
                                    ((none) "({ /* for: missing end */ 0; })")))
                                ((none) "({ /* for: missing start */ 0; })"))))
                          (else "({ /* for: var must be symbol */ 0; })")))
                      ((none) "({ /* for: missing var */ 0; })")))))
              (else "({ /* for: binding must be list */ 0; })")))
          ((none) "({ /* for: missing binding */ 0; })")))))

  ;; ============================================================
  ;; For-Each Loop as Expression
  ;; ============================================================

  (fn transpile-for-each-as-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile for-each loop as expression returning 0")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (for-each (item coll) body...) -> ({ for (size_t _i = 0; _i < coll.len; _i++) { __auto_type item = coll.data[_i]; body... } 0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        "({ /* for-each: need binding */ 0; })"
        (match (list-get items 1)
          ((some binding-expr)
            (match (deref binding-expr)
              ((lst binding-lst)
                (let ((binding-items (. binding-lst items))
                      (binding-len (list-len binding-items)))
                  (if (< binding-len 2)
                    "({ /* for-each: binding needs (var coll) */ 0; })"
                    (match (list-get binding-items 0)
                      ((some var-expr)
                        (match (deref var-expr)
                          ((sym var-sym)
                            (let ((var-name (to-c-name arena (. var-sym name))))
                              (match (list-get binding-items 1)
                                ((some coll-expr)
                                  (let ((coll-c (transpile-expr ctx coll-expr))
                                        ;; Infer element type from collection for proper type propagation
                                        (elem-slop-type (infer-collection-element-slop-type ctx coll-expr))
                                        ;; Build: ({ for (size_t _i = 0; _i < coll.len; _i++) { __auto_type item = coll.data[_i];
                                        (mut result (ctx-str3 ctx "({ for (size_t _i = 0; _i < " coll-c
                                                      (ctx-str5 ctx ".len; _i++) { __auto_type " var-name " = " coll-c ".data[_i]; "))))
                                    ;; Bind loop variable for body expressions with inferred element type
                                    (ctx-push-scope ctx)
                                    (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "auto" elem-slop-type false false false "" ""))
                                    ;; Process body expressions
                                    (let ((mut i 2))
                                      (while (< i len)
                                        (match (list-get items i)
                                          ((some body-expr)
                                            (let ((body-c (transpile-expr ctx body-expr)))
                                              (set! result (ctx-str3 ctx result body-c "; "))))
                                          ((none) (do)))
                                        (set! i (+ i 1))))
                                    (ctx-pop-scope ctx)
                                    ;; Close: } 0; })
                                    (ctx-str ctx result "} 0; })")))
                                ((none) "({ /* for-each: missing collection */ 0; })"))))
                          (else "({ /* for-each: var must be symbol */ 0; })")))
                      ((none) "({ /* for-each: missing var */ 0; })")))))
              (else "({ /* for-each: binding must be list */ 0; })")))
          ((none) "({ /* for-each: missing binding */ 0; })")))))

  ;; ============================================================
  ;; Lambda Expression Transpilation
  ;; ============================================================

  (fn transpile-lambda-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile lambda expression to static function, return function name")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Lambda: (fn ((param Type)...) body...)
    ;; items[0] = "fn", items[1] = params list, items[2..] = body
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "lambda needs params" (ctx-list-first-line items) (ctx-list-first-col items))
          "NULL")
        ;; Check if items[1] is a list (lambda) or symbol (named fn - error in expr context)
        (match (list-get items 1)
          ((some second)
            (match (deref second)
              ;; Lambda: params list is second element
              ((lst params-lst)
                (transpile-lambda-with-params ctx items (. params-lst items)))
              ;; Named function definition in expression context - error
              ((sym _)
                (do
                  (ctx-add-error-at ctx "named function not allowed in expression context" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL"))
              (else
                (do
                  (ctx-add-error-at ctx "invalid lambda form" (ctx-list-first-line items) (ctx-list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "lambda missing params" (ctx-list-first-line items) (ctx-list-first-col items))
              "NULL"))))))

  (fn transpile-lambda-with-params ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))))
    (@intent "Transpile lambda with extracted parameter list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          ;; Extract param names for free variable analysis
          (param-names (extract-param-names arena params))
          ;; Empty pending list for top-level lambda analysis
          (empty-pending (list-new arena String))
          ;; Find free variables BEFORE pushing scope
          ;; (so we can see what's captured from enclosing scope)
          (free-vars (find-free-vars ctx param-names items 2 empty-pending)))
      ;; Generate unique lambda name with module prefix
      (let ((base-name (ctx-gensym ctx "_lambda"))
            (lambda-name (match (ctx-get-module ctx)
                           ((some mod) (ctx-str3 ctx (to-c-name arena mod) "_" base-name))
                           ((none) base-name))))
        ;; Check if we have captures
        (if (> (list-len free-vars) 0)
          ;; Closure: generate struct and modified lambda
          (transpile-closure ctx items params param-names free-vars lambda-name)
          ;; Simple lambda: no captures
          (transpile-simple-lambda ctx items params lambda-name)))))

  (fn extract-param-names ((arena Arena) (params (List (Ptr SExpr))))
    (@intent "Extract parameter names from params list")
    (@spec ((Arena (List (Ptr SExpr))) -> (List String)))
    (let ((names (list-new arena String))
          (count (list-len params))
          (mut i 0))
      (while (< i count)
        (match (list-get params i)
          ((some param-expr)
            (match (deref param-expr)
              ((lst param-lst)
                (let ((param-items (. param-lst items)))
                  (when (>= (list-len param-items) 1)
                    (match (list-get param-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (list-push names (. name-sym name)))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      names))

  (fn infer-lambda-return-type ((ctx (Ptr TranspileContext)) (body (Ptr SExpr)))
    (@intent "Infer the C return type from a lambda body expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    ;; Get the C type from the body expression
    ;; If body is nil or inference fails, fall back to int64_t
    (if (== body nil)
      "int64_t"
      (let ((c-type (infer-expr-c-type ctx body)))
        (if (string-eq c-type "")
          "int64_t"
          c-type))))

  (fn transpile-simple-lambda ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))) (lambda-name String))
    (@intent "Transpile non-capturing lambda")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    ;; Get body expression (last item after params) for type inference
    (let ((body-expr (match (list-get items (- (list-len items) 1))
                       ((some e) e)
                       ((none) nil)))
          (param-str (build-lambda-params ctx params))
          ;; Infer return type from lambda body
          (return-type (infer-lambda-return-type ctx body-expr)))
      ;; Push scope for lambda body
      (ctx-push-scope ctx)
      ;; Bind parameter names in scope
      (bind-lambda-params ctx params)
      ;; Transpile body expressions
      (let ((body-start 2)
            (body-code (transpile-lambda-body ctx items body-start return-type)))
        (ctx-pop-scope ctx)
        ;; Build complete function definition
        (let ((fn-def (build-lambda-function ctx lambda-name return-type param-str body-code)))
          ;; Add to deferred lambdas
          (ctx-add-deferred-lambda ctx fn-def)
          ;; Return closure struct with NULL env (non-capturing lambda)
          (ctx-str5 ctx "(slop_closure_t){(void*)" lambda-name ", NULL}" "" "")))))

  (fn transpile-closure ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))) (param-names (List String)) (free-vars (List String)) (lambda-name String))
    (@intent "Transpile capturing lambda (closure)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr)) (List String) (List String) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          ;; Get body expression for type inference
          (body-expr (match (list-get items (- (list-len items) 1))
                       ((some e) e)
                       ((none) nil)))
          ;; Generate closure struct name
          (env-name (ctx-str ctx lambda-name "_env"))
          (env-type (ctx-str ctx env-name "_t")))
      ;; Build closure environment struct
      (let ((struct-def (build-closure-struct ctx env-type free-vars)))
        ;; Add struct to deferred lambdas (before the function)
        (ctx-add-deferred-lambda ctx struct-def)
        ;; Build lambda with env parameter
        (let ((param-str (build-closure-params ctx params))
              ;; Infer return type from lambda body
              (return-type (infer-lambda-return-type ctx body-expr)))
          ;; Push scope for lambda body
          (ctx-push-scope ctx)
          ;; Bind env-accessed variables (they come from _env)
          (bind-closure-captures ctx free-vars)
          ;; Bind regular parameters
          (bind-lambda-params ctx params)
          ;; Transpile body expressions
          (let ((body-start 2)
                (body-code (transpile-lambda-body ctx items body-start return-type)))
            (ctx-pop-scope ctx)
            ;; Build closure function (takes void* env as first param)
            (let ((fn-def (build-closure-function ctx lambda-name env-type return-type param-str body-code free-vars)))
              (ctx-add-deferred-lambda ctx fn-def)
              ;; Set last lambda info for closure variable binding
              (ctx-set-last-lambda-info ctx true env-type lambda-name)
              ;; Generate closure instantiation expression
              ;; This creates the env struct and returns a packaged closure
              (build-closure-instance ctx lambda-name env-name env-type free-vars)))))))

  (fn build-closure-struct ((ctx (Ptr TranspileContext)) (env-type String) (free-vars (List String)))
    (@intent "Build typedef for closure environment struct")
    (@spec (((Ptr TranspileContext) String (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut fields "")
          (mut i 0))
      ;; Build fields for each captured variable
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            ;; Look up variable type from context (checker should have resolved it)
            (let ((var-type (match (ctx-lookup-var ctx var-name)
                              ((some entry)
                                (let ((slop-type (. entry slop-type)))
                                  (if (> (string-len slop-type) 0)
                                    (slop-type-to-c-type ctx slop-type)
                                    (. entry c-type))))
                              ((none) "int64_t")))
                  (c-name (to-c-name arena var-name)))
              (set! fields (ctx-str ctx fields (ctx-str4 ctx var-type " " c-name "; ")))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; typedef struct { fields } env_type;
      (ctx-str ctx "typedef struct { " (ctx-str3 ctx fields "} " (ctx-str ctx env-type ";")))))

  (fn build-closure-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Build C parameter string for closure (without env, added separately)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Same as build-lambda-params but we prepend void* _env in the function def
    (build-lambda-params ctx params))

  (fn bind-closure-captures ((ctx (Ptr TranspileContext)) (free-vars (List String)))
    (@intent "Bind captured variables to access via _env pointer")
    (@spec (((Ptr TranspileContext) (List String)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut i 0))
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            ;; The variable access will be translated to _env->var_name
            ;; We bind it with a special marker that the transpiler recognizes
            (let ((c-name (to-c-name arena var-name))
                  (access-expr (ctx-str3 ctx "_env->" c-name ""))
                  (var-info (ctx-lookup-var ctx var-name))
                  (var-type (match var-info ((some entry) (. entry c-type)) ((none) "int64_t")))
                  (slop-type (match var-info ((some entry) (. entry slop-type)) ((none) ""))))
              ;; Bind with the access expression as the C name
              (ctx-bind-var ctx (VarEntry var-name access-expr var-type slop-type false false false "" ""))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn build-closure-function ((ctx (Ptr TranspileContext)) (name String) (env-type String) (ret-type String) (params String) (body String) (free-vars (List String)))
    (@intent "Build static closure function with env parameter")
    (@spec (((Ptr TranspileContext) String String String String String (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; static ret_type name(env_type* _env, params) { body }
      (let ((env-param (ctx-str3 ctx env-type "* _env" ""))
            (full-params (if (string-eq params "(void)")
                           (ctx-str3 ctx "(" env-param ")")
                           (ctx-str5 ctx "(" env-param ", " (trim-parens arena params) ")"))))
        (ctx-str ctx "static " (ctx-str ctx ret-type (ctx-str ctx " " (ctx-str ctx name (ctx-str ctx full-params (ctx-str ctx " { " (ctx-str ctx body " }"))))))))))

  (fn trim-parens ((arena Arena) (s String))
    (@intent "Remove leading ( and trailing ) from string")
    (@spec ((Arena String) -> String))
    (let ((len (cast Int (string-len s))))
      (if (< len 2)
        s
        (substring arena s (cast (Int 0 ..) 1) (cast (Int 0 ..) (- len 2))))))

  (fn build-closure-instance ((ctx (Ptr TranspileContext)) (lambda-name String) (env-name String) (env-type String) (free-vars (List String)))
    (@intent "Build expression that creates closure instance")
    (@spec (((Ptr TranspileContext) String String String (List String)) -> String))
    (@pre {ctx != nil})
    ;; Return a compound statement expression that declares the env and creates the closure
    ;; This ensures the env declaration is included when the closure is used in nested contexts
    ;; ({ env_type env_name = { .var1 = var1, ... }; (slop_closure_t){ (void*)fn, (void*)&env_name }; })
    (let ((arena (. (deref ctx) arena)))
      (let ((initializer (build-env-initializer ctx free-vars)))
        (let ((env-decl (ctx-str ctx env-type
                          (ctx-str ctx " "
                            (ctx-str ctx env-name
                              (ctx-str ctx " = "
                                (ctx-str ctx initializer ";")))))))
          ;; Return compound statement expression with declaration and closure
          (ctx-str ctx "({ "
            (ctx-str ctx env-decl
              (ctx-str ctx " (slop_closure_t){ (void*)"
                (ctx-str ctx lambda-name
                  (ctx-str ctx ", (void*)&"
                    (ctx-str ctx env-name " }; })"))))))))))

  (fn build-env-initializer ((ctx (Ptr TranspileContext)) (free-vars (List String)))
    (@intent "Build initializer for closure environment struct")
    (@spec (((Ptr TranspileContext) (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut result "{ ")
          (mut i 0))
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            (let ((c-name (to-c-name arena var-name))
                  ;; Look up the actual access expression from context
                  ;; For captured vars, this will be "_env->var", for locals just "var"
                  (access-expr (match (ctx-lookup-var ctx var-name)
                                 ((some entry) (. entry c-name))
                                 ((none) c-name))))
              (if (> i 0)
                (set! result (ctx-str ctx result (ctx-str5 ctx ", ." c-name " = " access-expr "")))
                (set! result (ctx-str ctx result (ctx-str5 ctx "." c-name " = " access-expr ""))))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result " }")))

  (fn build-lambda-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Build C parameter string from lambda params list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (param-count (list-len params)))
      (if (== param-count 0)
        "(void)"
        (let ((mut result "(")
              (mut i 0))
          (while (< i param-count)
            (match (list-get params i)
              ((some param-expr)
                (match (deref param-expr)
                  ((lst param-lst)
                    (let ((param-items (. param-lst items)))
                      (when (>= (list-len param-items) 2)
                        (match (list-get param-items 0)
                          ((some name-expr)
                            (match (deref name-expr)
                              ((sym name-sym)
                                (match (list-get param-items 1)
                                  ((some type-expr)
                                    (let ((param-name (to-c-name arena (. name-sym name)))
                                          (param-type (to-c-type-prefixed ctx type-expr)))
                                      (if (> i 0)
                                        (set! result (ctx-str ctx result (ctx-str5 ctx ", " param-type " " param-name "")))
                                        (set! result (ctx-str ctx result (ctx-str4 ctx param-type " " param-name ""))))))
                                  ((none) (do))))
                              (else (do))))
                          ((none) (do))))))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          (ctx-str ctx result ")")))))

  (fn bind-lambda-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Bind lambda parameters in current scope")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (param-count (list-len params))
          (mut i 0))
      (while (< i param-count)
        (match (list-get params i)
          ((some param-expr)
            (match (deref param-expr)
              ((lst param-lst)
                (let ((param-items (. param-lst items)))
                  (when (>= (list-len param-items) 2)
                    (match (list-get param-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get param-items 1)
                              ((some type-expr)
                                (let ((param-name (. name-sym name))
                                      (c-name (to-c-name arena param-name))
                                      (c-type (to-c-type-prefixed ctx type-expr))
                                      (is-ptr (is-pointer-type-sexpr type-expr)))
                                  (ctx-bind-var ctx (VarEntry param-name c-name c-type "" is-ptr false false "" ""))))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-pointer-type-sexpr ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn transpile-lambda-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int) (return-type String))
    (@intent "Transpile lambda body expressions, return last as value")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int String) -> String))
    (@pre {ctx != nil})
    ;; Return the value of the last expression (unless void)
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (is-void (string-eq return-type "void"))
          (mut result "")
          (mut i start))
      (if (<= len start)
        ;; No body - return 0 or nothing for void
        (if is-void "(void)0;" "return 0;")
        (do
          (while (< i len)
            (match (list-get items i)
              ((some expr)
                (let ((expr-c (transpile-expr ctx expr))
                      (is-last (== i (- len 1))))
                  (if is-last
                    ;; Last expression: return its value (or just evaluate for void)
                    (if is-void
                      (set! result (ctx-str ctx result (ctx-str ctx expr-c ";")))
                      (set! result (ctx-str ctx result (ctx-str ctx "return " (ctx-str ctx expr-c ";")))))
                    ;; Not last: just evaluate for side effects
                    (set! result (ctx-str ctx result (ctx-str3 ctx expr-c "; " ""))))))
              ((none) (do)))
            (set! i (+ i 1)))
          result))))

  (fn build-lambda-function ((ctx (Ptr TranspileContext)) (name String) (ret-type String) (params String) (body String))
    (@intent "Build complete static function definition for lambda with env parameter")
    (@spec (((Ptr TranspileContext) String String String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; static ret_type name(void* _env, params) { body }
      ;; _env is unused for non-capturing lambdas but required for uniform closure calling convention
      (let ((full-params (if (string-eq params "(void)")
                           "(void* _env)"
                           (ctx-str5 ctx "(void* _env, " (trim-parens arena params) ")" "" ""))))
        (ctx-str ctx "static " (ctx-str ctx ret-type (ctx-str ctx " " (ctx-str ctx name (ctx-str ctx full-params (ctx-str ctx " { " (ctx-str ctx body " }"))))))))))

  ;; ============================================================
  ;; spawn + Closure Support
  ;; ============================================================

  (fn is-capturing-lambda ((expr (Ptr SExpr)))
    (@intent "Check if expression is a lambda form (fn ((params...)) body)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    ;; Check if expr is (fn ((params...)) body) form
    ;; Note: This only checks the structure, not whether it actually captures
    ;; The actual capture detection happens in transpile-spawn-closure
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (if (not (string-eq (. sym name) "fn"))
                      false
                      ;; It's a fn form - check if it has params list (lambda vs named fn)
                      (match (list-get items 1)
                        ((some second)
                          (match (deref second)
                            ((lst _) true)  ;; Lambda form
                            (_ false)))
                        ((none) false))))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn transpile-spawn-closure ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (fn-expr (Ptr SExpr)))
    (@intent "Transpile spawn call with lambda - inline thread creation, handles both capturing and non-capturing")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {fn-expr != nil})
    ;; First check if the lambda actually captures anything
    (let ((arena (. (deref ctx) arena)))
      (match (list-get items 1)
        ((some arena-expr)
          (let ((arena-c (transpile-expr ctx arena-expr))
                (has-captures (lambda-has-captures ctx fn-expr)))
            (if has-captures
              ;; Capturing lambda - transpile returns slop_closure_t
              (let ((closure-c (transpile-expr ctx fn-expr)))
                (ctx-str ctx "({ slop_closure_t _spawn_cl = " (ctx-str ctx closure-c
                  (ctx-str ctx "; slop_thread_int* _spawn_th = slop_arena_alloc(" (ctx-str ctx arena-c
                    (ctx-str ctx ", sizeof(slop_thread_int));"
                      (ctx-str ctx " _spawn_th->func = _spawn_cl.fn;"
                        (ctx-str ctx " _spawn_th->env = _spawn_cl.env;"
                          (ctx-str ctx " _spawn_th->done = false;"
                            (ctx-str ctx " pthread_create(&_spawn_th->id, NULL, (void*)slop_thread_int_entry, (void*)_spawn_th);"
                              " _spawn_th; })"))))))))))
              ;; Non-capturing lambda - use regular spawn call
              (transpile-regular-fn-call ctx "spawn" items))))
        ((none)
          (do
            (ctx-add-error-at ctx "spawn: missing arena argument" (ctx-list-first-line items) (ctx-list-first-col items))
            "NULL")))))

  (fn lambda-has-captures ((ctx (Ptr TranspileContext)) (fn-expr (Ptr SExpr)))
    (@intent "Check if lambda expression has free variables that need capturing")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {fn-expr != nil})
    ;; Extract params and body from lambda, then check for free vars
    (match (deref fn-expr)
      ((lst lst)
        (let ((items (. lst items))
              (arena (. (deref ctx) arena)))
          (if (< (list-len items) 2)
            false
            (match (list-get items 1)
              ((some params-expr)
                (match (deref params-expr)
                  ((lst params-lst)
                    (let ((params (. params-lst items))
                          (param-names (extract-param-names arena params))
                          (empty-pending (list-new arena String))
                          (free-vars (find-free-vars ctx param-names items 2 empty-pending)))
                      (> (list-len free-vars) 0)))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn transpile-regular-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile regular function call (non-special cases)")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Build argument list and call transpile-call
    ;; Look up function to get parameter types for typed none handling
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (func-opt (ctx-lookup-func ctx fn-name))
          (mut args "")
          (mut i 1)
          (mut param-idx 0))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (transpile-expr ctx arg))
                  ;; Get expected type for this parameter if available
                  (expected-type (match func-opt
                                   ((some func-entry)
                                     (match (list-get (. func-entry param-types) param-idx)
                                       ((some p) (. (deref p) c-type))
                                       ((none) "")))
                                   ((none) "")))
                  ;; Convert none to typed Option if needed
                  (final-arg (typed-none-arg ctx expected-type arg-c)))
              (if (string-eq args "")
                (set! args final-arg)
                (set! args (ctx-str3 ctx args ", " final-arg)))
              (set! param-idx (+ param-idx 1))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; No name mangling for generic functions - type params are for checking only
      (transpile-call ctx fn-name args)))

  (fn infer-generic-type-binding ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer type binding for generic function from first argument type")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; For thread functions: first arg is (Ptr (Chan T)) or value T
    ;; Extract T from channel type or from value type
    (let ((arena (. (deref ctx) arena)))
      (if (< (list-len items) 2)
        ""  ;; No arguments
        (match (list-get items 1)
          ((some first-arg)
            ;; Get SLOP type of first argument
            (let ((slop-type (infer-expr-slop-type ctx first-arg)))
              (if (string-eq slop-type "")
                ;; Try to infer C type and convert
                (let ((c-type (infer-expr-c-type ctx first-arg)))
                  (extract-type-binding-from-c-type arena c-type))
                ;; Extract type binding from SLOP type
                (extract-type-binding-from-slop-type arena slop-type))))
          ((none) "")))))

  (fn extract-type-binding-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract type binding T from SLOP type like (Ptr (Chan Int)) -> int")
    (@spec ((Arena String) -> String))
    ;; Look for patterns like (Ptr (Chan X)) or (Ptr (Thread X))
    ;; Extract X and convert to C type identifier
    (cond
      ;; (Ptr (Chan X)) pattern - extract X
      ((starts-with slop-type "(Ptr (Chan ")
        (let ((inner-start 11)  ;; len("(Ptr (Chan ")
              (inner-end (find-matching-paren slop-type inner-start)))
          (if (> inner-end inner-start)
            (let ((inner-type (substring arena slop-type (cast (Int 0 ..) inner-start)
                                         (cast (Int 0 ..) (- inner-end inner-start)))))
              (slop-type-to-c-identifier arena inner-type))
            "int")))
      ;; (Ptr (Thread X)) pattern
      ((starts-with slop-type "(Ptr (Thread ")
        (let ((inner-start 13)  ;; len("(Ptr (Thread ")
              (inner-end (find-matching-paren slop-type inner-start)))
          (if (> inner-end inner-start)
            (let ((inner-type (substring arena slop-type (cast (Int 0 ..) inner-start)
                                         (cast (Int 0 ..) (- inner-end inner-start)))))
              (slop-type-to-c-identifier arena inner-type))
            "int")))
      ;; Simple type - convert directly
      (else (slop-type-to-c-identifier arena slop-type))))

  (fn extract-type-binding-from-c-type ((arena Arena) (c-type String))
    (@intent "Extract type binding from C type like slop_chan_int* -> int")
    (@spec ((Arena String) -> String))
    ;; Look for patterns like slop_chan_X* or slop_thread_X*
    (cond
      ((starts-with c-type "slop_chan_")
        ;; Extract X from slop_chan_X* (strip slop_chan_ prefix and * suffix)
        (let ((start 10)  ;; len("slop_chan_")
              (end-offset (if (ends-with c-type "*") 1 0))
              (len (string-len c-type)))
          (if (> len start)
            (substring arena c-type (cast (Int 0 ..) start)
                      (cast (Int 0 ..) (- (- (cast Int len) start) end-offset)))
            "int")))
      ((starts-with c-type "slop_thread_")
        (let ((start 12)  ;; len("slop_thread_")
              (end-offset (if (ends-with c-type "*") 1 0))
              (len (string-len c-type)))
          (if (> len start)
            (substring arena c-type (cast (Int 0 ..) start)
                      (cast (Int 0 ..) (- (- (cast Int len) start) end-offset)))
            "int")))
      ;; Default to int for unknown patterns
      (else "int")))

  (fn slop-type-to-c-identifier ((arena Arena) (slop-type String))
    (@intent "Convert SLOP type name to C identifier for mangling")
    (@spec ((Arena String) -> String))
    ;; Map common SLOP types to C identifiers
    (cond
      ((string-eq slop-type "Int") "int")
      ((string-eq slop-type "I64") "int")
      ((string-eq slop-type "I32") "i32")
      ((string-eq slop-type "I16") "i16")
      ((string-eq slop-type "I8") "i8")
      ((string-eq slop-type "U64") "u64")
      ((string-eq slop-type "U32") "u32")
      ((string-eq slop-type "U16") "u16")
      ((string-eq slop-type "U8") "u8")
      ((string-eq slop-type "String") "string")
      ((string-eq slop-type "Bool") "bool")
      ((string-eq slop-type "Float") "double")
      ((string-eq slop-type "Unit") "unit")
      ;; Default: convert to lowercase C name
      (else (to-c-name arena slop-type))))

  (fn find-matching-paren ((s String) (start Int))
    (@intent "Find position of closing paren, accounting for nesting")
    (@spec ((String Int) -> Int))
    (let ((len (cast Int (string-len s)))
          (mut depth 0)
          (mut i start)
          (mut found -1))
      (while (and (< i len) (< found 0))
        (let ((c (char-at s (cast (Int 0 ..) i))))
          (cond
            ((== c 40)  ;; '('
              (set! depth (+ depth 1)))
            ((== c 41)  ;; ')'
              (if (== depth 0)
                (set! found i)
                (set! depth (- depth 1))))
            (else (do))))
        (set! i (+ i 1)))
      (if (< found 0) len found)))

  ;; ============================================================
  ;; Free Variable Analysis for Closures
  ;; ============================================================

  (fn find-free-vars ((ctx (Ptr TranspileContext)) (param-names (List String)) (body-items (List (Ptr SExpr))) (start Int) (pending (List String)))
    (@intent "Find variables in lambda body that are captured from enclosing scope")
    (@spec (((Ptr TranspileContext) (List String) (List (Ptr SExpr)) Int (List String)) -> (List String)))
    (@pre {ctx != nil})
    ;; Collect all symbol references in the body
    ;; Filter out: params, known functions, builtins, type names
    ;; What remains are captured variables
    (let ((arena (. (deref ctx) arena))
          (all-symbols (list-new arena String))
          (free-vars (list-new arena String))
          (len (list-len body-items))
          (mut i start))
      ;; Collect all symbols from body expressions
      (while (< i len)
        (match (list-get body-items i)
          ((some expr)
            (collect-symbols-in-expr ctx (addr all-symbols) pending expr))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Filter to find truly free variables
      (let ((sym-count (list-len all-symbols))
            (mut j 0))
        (while (< j sym-count)
          (match (list-get all-symbols j)
            ((some sym-name)
              (when (is-free-var ctx param-names pending sym-name)
                ;; Check not already in free-vars
                (when (not (list-contains-string free-vars sym-name))
                  (list-push free-vars sym-name))))
            ((none) (do)))
          (set! j (+ j 1))))
      free-vars))

  (fn collect-symbols-in-expr ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (expr (Ptr SExpr)))
    (@intent "Recursively collect all symbol references in an expression")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Add symbol name if not a special keyword and not in pending (local binding)
        (let ((name (. sym name)))
          (when (and (not (is-special-keyword name))
                     (not (list-contains-string pending name)))
            (list-push (deref symbols) name))))
      ((lst lst)
        ;; Recursively collect from list items
        ;; But be smart about special forms that introduce bindings
        (let ((items (. lst items))
              (len (list-len items)))
          (when (> len 0)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym head-sym)
                    (let ((op (. head-sym name)))
                      (cond
                        ;; let: skip binding names, recurse into values and body
                        ((string-eq op "let")
                          (collect-symbols-in-let ctx symbols pending items))
                        ;; fn: collect free vars from nested lambda (they need to be captured by us too)
                        ((string-eq op "fn")
                          (collect-nested-lambda-free-vars ctx symbols pending items))
                        ;; match: recurse into scrutinee and bodies (pattern vars are local)
                        ((string-eq op "match")
                          (collect-symbols-in-match ctx symbols pending items))
                        ;; for/for-each: skip loop var, recurse into range/collection and body
                        ((or (string-eq op "for") (string-eq op "for-each"))
                          (collect-symbols-in-for ctx symbols pending items))
                        ;; Default: recurse into all items
                        (else
                          (collect-symbols-in-list ctx symbols pending items 0)))))
                  (else
                    ;; Non-symbol head, recurse into all
                    (collect-symbols-in-list ctx symbols pending items 0))))
              ((none) (do))))))
      (else (do))))

  (fn collect-symbols-in-list ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Collect symbols from list items starting at index")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (collect-symbols-in-expr ctx symbols pending item))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn collect-symbols-in-let ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from let form, excluding bound names")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (let ((name val) ...) body...)
    ;; Recurse into values and body, but not binding names
    ;; Add binding names to pending for the body
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        (match (list-get items 1)
          ((some bindings-expr)
            (let ((new-names (extract-let-binding-names arena bindings-expr))
                  (updated-pending (list-concat arena pending new-names)))
              (match (deref bindings-expr)
                ((lst bindings-lst)
                  ;; For each binding, only collect from the value (with original pending)
                  (let ((bindings (. bindings-lst items))
                        (binding-count (list-len bindings))
                        (mut i 0))
                    (while (< i binding-count)
                      (match (list-get bindings i)
                        ((some binding)
                          (match (deref binding)
                            ((lst bind-lst)
                              (let ((bind-items (. bind-lst items)))
                                ;; binding is (name value) or (mut name value)
                                ;; Collect from value only
                                (when (>= (list-len bind-items) 2)
                                  (let ((val-idx (if (is-mut-binding bind-items) 2 1)))
                                    (match (list-get bind-items val-idx)
                                      ((some val-expr)
                                        (collect-symbols-in-expr ctx symbols pending val-expr))
                                      ((none) (do)))))))
                            (else (do))))
                        ((none) (do)))
                      (set! i (+ i 1)))))
                (else (do)))
              ;; Collect from body expressions with updated pending
              (collect-symbols-in-list ctx symbols updated-pending items 2)))
          ((none) (do))))))

  (fn is-mut-binding ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with mut keyword")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym) (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn extract-let-binding-names ((arena Arena) (bindings-expr (Ptr SExpr)))
    (@intent "Extract variable names from let bindings list")
    (@spec ((Arena (Ptr SExpr)) -> (List String)))
    (@pre {bindings-expr != nil})
    (let ((names (list-new arena String)))
      (match (deref bindings-expr)
        ((lst bindings-lst)
          (let ((bindings (. bindings-lst items))
                (binding-count (list-len bindings))
                (mut i 0))
            (while (< i binding-count)
              (match (list-get bindings i)
                ((some binding)
                  (match (deref binding)
                    ((lst bind-lst)
                      (let ((bind-items (. bind-lst items)))
                        (when (>= (list-len bind-items) 1)
                          (let ((name-idx (if (is-mut-binding bind-items) 1 0)))
                            (match (list-get bind-items name-idx)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((sym sym) (list-push names (. sym name)))
                                  (else (do))))
                              ((none) (do)))))))
                    (else (do))))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))
      names))

  (fn collect-symbols-in-match ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from match form")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (match scrutinee (pattern body)...)
    ;; Collect from scrutinee and bodies (pattern vars are local)
    (let ((len (list-len items)))
      (when (>= len 2)
        ;; Collect from scrutinee
        (match (list-get items 1)
          ((some scrutinee)
            (collect-symbols-in-expr ctx symbols pending scrutinee))
          ((none) (do)))
        ;; Collect from clause bodies (skip patterns)
        (let ((mut i 2))
          (while (< i len)
            (match (list-get items i)
              ((some clause)
                (match (deref clause)
                  ((lst clause-lst)
                    (let ((clause-items (. clause-lst items)))
                      ;; Clause is (pattern body...), collect from body only
                      (collect-symbols-in-list ctx symbols pending clause-items 1)))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))))))

  (fn collect-symbols-in-for ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from for/for-each form")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (for (i start end) body...) or (for-each (item coll) body...)
    ;; Skip loop variable, collect from range/collection and body
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        (match (list-get items 1)
          ((some binding)
            (match (deref binding)
              ((lst bind-lst)
                (let ((bind-items (. bind-lst items)))
                  ;; Collect from start/end or collection (items after first)
                  (collect-symbols-in-list ctx symbols pending bind-items 1)
                  ;; Extract loop var name and add to pending for body
                  (let ((loop-var-pending (extract-for-loop-var-pending arena pending bind-items)))
                    ;; Collect from body with loop var in pending
                    (collect-symbols-in-list ctx symbols loop-var-pending items 2))))
              (else (do))))
          ((none) (do))))))

  (fn extract-for-loop-var-pending ((arena Arena) (pending (List String)) (bind-items (List (Ptr SExpr))))
    (@intent "Extract loop variable and add to pending list")
    (@spec ((Arena (List String) (List (Ptr SExpr))) -> (List String)))
    (if (< (list-len bind-items) 1)
      pending
      (match (list-get bind-items 0)
        ((some var-expr)
          (match (deref var-expr)
            ((sym var-sym)
              (let ((result (list-new arena String))
                    (var-name (. var-sym name))
                    (plen (list-len pending))
                    (mut i 0))
                ;; Copy existing pending
                (while (< i plen)
                  (match (list-get pending i)
                    ((some s) (list-push result s))
                    ((none) (do)))
                  (set! i (+ i 1)))
                ;; Add loop var
                (list-push result var-name)
                result))
            (else pending)))
        ((none) pending))))

  (fn collect-nested-lambda-free-vars ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (pending (List String)) (items (List (Ptr SExpr))))
    (@intent "Collect free variables from nested lambda that outer lambda must capture")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List String) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; A nested lambda (fn ((params...)) body...) has free vars that we also need
    ;; Extract param names to exclude them, then find free vars of nested lambda body
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        ;; items[1] is params list
        (match (list-get items 1)
          ((some params-expr)
            (match (deref params-expr)
              ((lst params-lst)
                (let ((params (. params-lst items))
                      (param-names (extract-param-names arena params))
                      ;; Combine pending with nested lambda params for recursive analysis
                      (nested-pending (list-concat arena pending param-names)))
                  ;; Recursively collect from nested lambda body
                  ;; The nested lambda's params shadow outer vars, so use nested-pending
                  (collect-symbols-in-list ctx symbols nested-pending items 2)))
              (else (do))))
          ((none) (do))))))

  (fn is-special-keyword ((name String))
    (@intent "Check if name is a special keyword that shouldn't be collected")
    (@spec ((String) -> Bool))
    ;; Special forms, operators, and type names
    (or (string-eq name "let")
        (string-eq name "if")
        (string-eq name "cond")
        (string-eq name "match")
        (string-eq name "when")
        (string-eq name "while")
        (string-eq name "for")
        (string-eq name "for-each")
        (string-eq name "do")
        (string-eq name "set!")
        (string-eq name "deref")
        (string-eq name "cast")
        (string-eq name "fn")
        (string-eq name "true")
        (string-eq name "false")
        (string-eq name "nil")
        (string-eq name "none")
        (string-eq name "some")
        (string-eq name "ok")
        (string-eq name "error")
        (string-eq name "mut")
        (string-eq name "else")
        (string-eq name "and")
        (string-eq name "or")
        (string-eq name "not")))

  (fn is-free-var ((ctx (Ptr TranspileContext)) (param-names (List String)) (pending (List String)) (sym-name String))
    (@intent "Check if symbol is a free variable (captured from enclosing scope)")
    (@spec (((Ptr TranspileContext) (List String) (List String) String) -> Bool))
    (@pre {ctx != nil})
    ;; A symbol is free if:
    ;; - Not a lambda parameter
    ;; - Not a known function
    ;; - Not a type name
    ;; - Not a builtin operator
    ;; - IS a variable in the current scope OR in pending let bindings
    (if (list-contains-string param-names sym-name)
      false  ;; Lambda parameter, not free
      (if (list-contains-string pending sym-name)
        true  ;; Variable will be bound by enclosing let - it's capturable
        (if (is-builtin-op sym-name)
          false  ;; Builtin operator
          (match (ctx-lookup-func ctx sym-name)
            ((some _) false)  ;; Known function
            ((none)
              (match (ctx-lookup-type ctx sym-name)
                ((some _) false)  ;; Type name
                ((none)
                  ;; Check if it's a variable in scope
                  (match (ctx-lookup-var ctx sym-name)
                    ((some _) true)  ;; It's a captured variable!
                    ((none) false))))))))))  ;; Unknown symbol

  (fn is-builtin-op ((name String))
    (@intent "Check if name is a builtin operator")
    (@spec ((String) -> Bool))
    (or (string-eq name "+")
        (string-eq name "-")
        (string-eq name "*")
        (string-eq name "/")
        (string-eq name "%")
        (string-eq name "==")
        (string-eq name "!=")
        (string-eq name "<")
        (string-eq name ">")
        (string-eq name "<=")
        (string-eq name ">=")
        (string-eq name "@")))

  (fn list-contains-string ((lst (List String)) (needle String))
    (@intent "Check if string list contains the given string")
    (@spec (((List String) String) -> Bool))
    (let ((len (list-len lst))
          (mut i 0)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get lst i)
          ((some s)
            (when (string-eq s needle)
              (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn list-concat ((arena Arena) (a (List String)) (b (List String)))
    (@intent "Concatenate two string lists, returning a new list")
    (@spec ((Arena (List String) (List String)) -> (List String)))
    (let ((result (list-new arena String))
          (len-a (list-len a))
          (len-b (list-len b))
          (mut i 0))
      (while (< i len-a)
        (match (list-get a i)
          ((some s) (list-push result s))
          ((none) (do)))
        (set! i (+ i 1)))
      (set! i 0)
      (while (< i len-b)
        (match (list-get b i)
          ((some s) (list-push result s))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  ;; ============================================================
  ;; Type Argument Extraction Helpers
  ;; ============================================================

  (fn extract-first-type-arg ((arena Arena) (slop-type String) (start Int))
    (@intent "Extract first type arg, handling nested parens")
    (@spec ((Arena String Int) -> String))
    (let ((len (cast Int (string-len slop-type)))
          (mut depth 0)
          (mut end-pos start)
          (mut found false))
      (while (and (< end-pos len) (not found))
        (let ((c (char-at slop-type (cast (Int 0 ..) end-pos))))
          (cond
            ((== c 40)
              (set! depth (+ depth 1))
              (set! end-pos (+ end-pos 1)))
            ((== c 41)
              (if (== depth 0)
                (set! found true)
                (do
                  (set! depth (- depth 1))
                  (set! end-pos (+ end-pos 1)))))
            ((and (== c 32) (== depth 0))
              (set! found true))
            (else
              (set! end-pos (+ end-pos 1))))))
      (if (> end-pos start)
        (substring arena slop-type (cast (Int 0 ..) start) (cast (Int 0 ..) (- end-pos start)))
        "")))

  (fn extract-second-type-arg ((arena Arena) (slop-type String) (start Int))
    (@intent "Extract second type arg from compound type")
    (@spec ((Arena String Int) -> String))
    (let ((first-arg (extract-first-type-arg arena slop-type start))
          (first-len (string-len first-arg)))
      (if (== first-len 0)
        ""
        (extract-first-type-arg arena slop-type (+ start (+ (cast Int first-len) 1))))))

  ;; ============================================================
  ;; Result Type Inference Helpers
  ;; ============================================================

  (fn infer-result-ok-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Extract OK type T from (Result T E) scrutinee")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena))
          (expr-type (infer-expr-slop-type ctx scrutinee)))
      (let ((resolved (if (> (string-len expr-type) 0)
                        (resolve-type-alias ctx expr-type)
                        "")))
        (if (starts-with resolved "(Result ")
          (extract-first-type-arg arena resolved 8)
          ""))))

  (fn infer-result-err-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Extract Error type E from (Result T E) scrutinee")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena))
          (expr-type (infer-expr-slop-type ctx scrutinee)))
      (let ((resolved (if (> (string-len expr-type) 0)
                        (resolve-type-alias ctx expr-type)
                        "")))
        (if (starts-with resolved "(Result ")
          (extract-second-type-arg arena resolved 8)
          ""))))

  ;; ============================================================
  ;; Collection Element Type Inference
  ;; ============================================================

  (fn infer-collection-element-slop-type ((ctx (Ptr TranspileContext)) (coll-expr (Ptr SExpr)))
    (@intent "Infer the SLOP element type from a collection expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {coll-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref coll-expr)
        ((lst lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (let ((op (. sym name)))
                        (cond
                          ((string-eq op "map-keys")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-slop-type (infer-expr-slop-type ctx map-expr)))
                                    (if (> (string-len map-slop-type) 0)
                                      (let ((resolved (resolve-type-alias ctx map-slop-type)))
                                        (extract-map-key-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          ((string-eq op "set-elements")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some set-expr)
                                  (let ((set-slop-type (infer-expr-slop-type ctx set-expr)))
                                    (if (> (string-len set-slop-type) 0)
                                      (let ((resolved (resolve-type-alias ctx set-slop-type)))
                                        (extract-set-elem-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          ((string-eq op "map-values")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-slop-type (infer-expr-slop-type ctx map-expr)))
                                    (if (> (string-len map-slop-type) 0)
                                      (let ((resolved (resolve-type-alias ctx map-slop-type)))
                                        (extract-map-value-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          (else (infer-elem-from-type ctx coll-expr)))))
                    (_ (infer-elem-from-type ctx coll-expr))))
                ((none) "")))))
        (_ (infer-elem-from-type ctx coll-expr)))))

  (fn infer-elem-from-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer element type from expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena))
          (slop-type (infer-expr-slop-type ctx expr)))
      (if (== (string-len slop-type) 0)
        ""
        ;; Resolve type alias before pattern matching (e.g., TermSet -> (Set Term))
        (let ((resolved-type (resolve-type-alias ctx slop-type)))
          (cond
            ((starts-with resolved-type "(List ")
              (let ((elem-len (- (- (string-len resolved-type) 6) 1)))
                (if (> elem-len 0)
                  (substring arena resolved-type 6 (cast (Int 0 ..) elem-len))
                  "")))
            ((starts-with resolved-type "(Set ")
              (extract-set-elem-from-slop-type arena resolved-type))
            ((starts-with resolved-type "(Map ")
              ;; For maps, return the key type (used for iteration)
              (extract-map-key-from-slop-type arena resolved-type))
            (else ""))))))

) ;; end module
