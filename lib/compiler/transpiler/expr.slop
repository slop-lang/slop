;; ============================================================
;; SLOP Native Transpiler - Expression Module
;;
;; Transpiles SLOP expressions to C code.
;; ============================================================

(module expr
  (export
    ;; Main entry point
    transpile-expr
    ;; Helpers
    transpile-literal transpile-symbol
    transpile-call transpile-binop
    ;; Operator helpers
    is-binop is-unop is-comparison-op
    ;; Type inference
    infer-expr-c-type infer-option-inner-slop-type infer-expr-slop-type
    ;; Collection/Result type inference helpers
    infer-collection-element-slop-type infer-result-ok-slop-type infer-result-err-slop-type)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import context (TranspileContext ctx-lookup-var ctx-lookup-func ctx-lookup-type ctx-lookup-enum-variant
                   ctx-get-current-result-type ctx-get-current-return-type ctx-prefixing-enabled ctx-prefix-type ctx-get-module
                   ctx-str ctx-str3 ctx-str4 ctx-str5 VarEntry FuncEntry FuncParamType TypeEntry
                   to-c-type-prefixed ctx-push-scope ctx-pop-scope ctx-bind-var
                   ctx-lookup-field-type-by-index ctx-lookup-field-type ctx-lookup-field-slop-type ctx-register-option-type
                   ctx-register-struct-key-type ctx-has-struct-key-type ctx-lookup-type-alias
                   ctx-add-error-at sexpr-line sexpr-col list-first-line list-first-col
                   ctx-gensym ctx-add-deferred-lambda ctx-emit ctx-indent ctx-dedent ctx-get-output
                   LastLambdaInfo ctx-set-last-lambda-info ctx-get-last-lambda-info ctx-clear-last-lambda-info))
  (import ctype (to-c-type to-c-name type-to-identifier sexpr-to-type-string))
  (import strlib (replace starts-with ends-with substring char-at count-occurrences index-of contains))

  ;; ============================================================
  ;; String Escaping for C
  ;; ============================================================

  (fn escape-c-string ((ctx (Ptr TranspileContext)) (s String))
    (@intent "Escape string for C string literal")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (. s len)))
          (data (. s data)))
      ;; Calculate output size (worst case: every char needs escaping)
      (let ((buf (arena-alloc arena (+ (* len 2) 1)))
            (mut out-pos 0)
            (mut in-pos 0))
        (while (< in-pos len)
          (let ((c (cast Int (@ data in-pos))))
            (cond
              ((== c 10)  ;; \n
                (set! (@ buf out-pos) 92)       ;; backslash
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 110)      ;; n
                (set! out-pos (+ out-pos 1)))
              ((== c 13)  ;; \r
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 114)      ;; r
                (set! out-pos (+ out-pos 1)))
              ((== c 9)   ;; \t
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 116)      ;; t
                (set! out-pos (+ out-pos 1)))
              ((== c 92)  ;; backslash -> \\
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1)))
              ((== c 34)  ;; quote -> \"
                (set! (@ buf out-pos) 92)
                (set! out-pos (+ out-pos 1))
                (set! (@ buf out-pos) 34)
                (set! out-pos (+ out-pos 1)))
              (else
                (set! (@ buf out-pos) (cast U8 c))
                (set! out-pos (+ out-pos 1)))))
          (set! in-pos (+ in-pos 1)))
        (set! (@ buf out-pos) 0)  ;; null terminate
        (String buf (cast U64 out-pos)))))

  ;; ============================================================
  ;; Operator Classification
  ;; ============================================================

  (fn is-binop ((op String))
    (@intent "Check if operator is a binary operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "+")
        (string-eq op "-")
        (string-eq op "*")
        (string-eq op "/")
        (string-eq op "%")
        (string-eq op "and")
        (string-eq op "or")
        (string-eq op "bit-and")
        (string-eq op "bit-or")
        (string-eq op "bit-xor")
        (string-eq op "&")
        (string-eq op "|")
        (string-eq op "^")
        (string-eq op "<<")
        (string-eq op ">>")))

  (fn is-comparison-op ((op String))
    (@intent "Check if operator is a comparison operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "==")
        (string-eq op "=")
        (string-eq op "!=")
        (string-eq op "<")
        (string-eq op ">")
        (string-eq op "<=")
        (string-eq op ">=")))

  (fn is-unop ((op String))
    (@intent "Check if operator is a unary operator")
    (@spec ((String) -> Bool))
    (or (string-eq op "not")
        (string-eq op "bit-not")
        (string-eq op "-")))

  ;; ============================================================
  ;; Symbol Name Extraction
  ;; ============================================================

  (fn extract-symbol-name ((expr (Ptr SExpr)))
    (@intent "Extract symbol name from either bare symbol or (quote symbol)")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {expr != nil})
    (match (deref expr)
      ;; Direct symbol: just return the name
      ((sym sym) (some (. sym name)))
      ;; List form: check for (quote symbol)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym head-sym)
                    (if (string-eq (. head-sym name) "quote")
                      ;; It's a quote form - extract the inner symbol
                      (match (list-get items 1)
                        ((some inner)
                          (match (deref inner)
                            ((sym inner-sym) (some (. inner-sym name)))
                            (else none)))
                        ((none) none))
                      none))
                  (else none)))
              ((none) none)))))
      (else none)))

  ;; ============================================================
  ;; Literal Transpilation
  ;; ============================================================

  (fn transpile-literal ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a literal expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((num num)
        (if (. num is-float)
          (. num raw)  ;; Use raw string representation
          (. num raw)))
      ((str str)
        ;; Wrap in SLOP_STR macro with escaped string
        (ctx-str3 ctx "SLOP_STR(\"" (escape-c-string ctx (. str value)) "\")"))
      ((sym sym)
        (transpile-symbol ctx (. sym name)))
      ((lst _)
        "/* error: list is not a literal */")))

  (fn transpile-symbol ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Transpile a symbol to C code")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ;; Boolean literals
        ((string-eq name "true") "1")
        ((string-eq name "false") "0")
        ;; Null pointer
        ((string-eq name "nil") "NULL")
        ;; None literal - use runtime macro
        ((string-eq name "none") "none")
        ;; Unit literal - used for Result Unit E types
        ((string-eq name "unit") "0")
        ;; Quoted symbols for enum values: 'read -> file_FileMode_read
        ((starts-with name "'")
          (let ((name-len (string-len name))
                (variant-name (substring arena name 1 (cast (Int 0 ..) (- name-len 1)))))
            (match (ctx-lookup-enum-variant ctx variant-name)
              ((some enum-name)
                ;; Return prefixed enum constant
                (get-prefixed-enum-value ctx enum-name variant-name))
              ((none)
                ;; Fallback - just strip quote and convert
                (to-c-name arena variant-name)))))
        ;; Dot notation: either field access (var.field) or enum (Type.variant)
        ((contains name ".")
          (match (index-of name ".")
            ((some dot-pos)
              (let ((base-name (substring arena name 0 dot-pos))
                    (rest-len (cast (Int 0 ..) (- (string-len name) (+ dot-pos 1))))
                    (rest-name (substring arena name (+ dot-pos 1) rest-len))
                    ;; Convert rest to C name (hyphen to underscore)
                    (c-rest (to-c-name arena rest-name)))
                ;; First check if base is a variable (field access)
                (match (ctx-lookup-var ctx base-name)
                  ((some var-entry)
                    ;; Field access: use -> if pointer, . otherwise
                    (let ((c-base (. var-entry c-name))
                          (is-ptr (. var-entry is-pointer))
                          (accessor (if is-ptr "->" ".")))
                      (ctx-str3 ctx c-base accessor c-rest)))
                  ((none)
                    ;; Not a variable - check if it's enum dot notation
                    (match (ctx-lookup-type ctx base-name)
                      ((some type-info)
                        (get-prefixed-enum-value ctx (. type-info c-name) rest-name))
                      ((none)
                        ;; Fallback: assume base_rest format
                        (ctx-str3 ctx base-name "_" c-rest)))))))
            ((none) (to-c-name arena name))))
        ;; Variable/constant lookup - check context first
        (else
          (match (ctx-lookup-var ctx name)
            ;; Found in context - use registered c-name
            ((some entry) (. entry c-name))
            ;; Not found - check if it's an enum variant
            ((none)
              (match (ctx-lookup-enum-variant ctx name)
                ((some enum-name)
                  (get-prefixed-enum-value ctx enum-name name))
                ((none)
                  ;; Check if it's a registered function (for function references)
                  (let ((c-name (to-c-name arena name)))
                    (match (ctx-lookup-func ctx name)
                      ((some func-entry)
                        ;; Use the registered c-name which includes module prefix
                        (. func-entry c-name))
                      ((none) c-name)))))))))))

  (fn get-prefixed-enum-value ((ctx (Ptr TranspileContext)) (enum-name String) (variant-name String))
    (@intent "Get fully qualified enum value - enum-name already has module prefix")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; enum-name already includes module prefix (e.g., "file_FileMode")
    ;; Convert variant-name to C format (hyphens to underscores) and append
    (let ((arena (. (deref ctx) arena)))
      (ctx-str3 ctx enum-name "_" (to-c-name arena variant-name))))

  ;; ============================================================
  ;; Binary Operation Transpilation
  ;; ============================================================

  (fn binop-to-c ((op String))
    (@intent "Convert SLOP binary operator to C operator")
    (@spec ((String) -> String))
    (cond
      ((string-eq op "+") "+")
      ((string-eq op "-") "-")
      ((string-eq op "*") "*")
      ((string-eq op "/") "/")
      ((string-eq op "%") "%")
      ((string-eq op "==") "==")
      ((string-eq op "=") "==")
      ((string-eq op "!=") "!=")
      ((string-eq op "<") "<")
      ((string-eq op ">") ">")
      ((string-eq op "<=") "<=")
      ((string-eq op ">=") ">=")
      ((string-eq op "and") "&&")
      ((string-eq op "or") "||")
      ((string-eq op "bit-and") "&")
      ((string-eq op "bit-or") "|")
      ((string-eq op "bit-xor") "^")
      ((string-eq op "&") "&")
      ((string-eq op "|") "|")
      ((string-eq op "^") "^")
      ((string-eq op "<<") "<<")
      ((string-eq op ">>") ">>")
      (else op)))

  (fn transpile-binop ((ctx (Ptr TranspileContext)) (op String) (left String) (right String))
    (@intent "Transpile a binary operation")
    (@spec (((Ptr TranspileContext) String String String) -> String))
    (@pre {ctx != nil})
    (let ((c-op (binop-to-c op)))
      (ctx-str5 ctx "(" left " " c-op (ctx-str3 ctx " " right ")"))))

  (fn transpile-variadic-binop ((ctx (Ptr TranspileContext)) (op String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Transpile a variadic binary operation (and/or) by chaining all arguments")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((c-op (binop-to-c op))
          (len (cast Int (list-len items))))
      (if (<= len (+ start-idx 1))
        (do
          (ctx-add-error-at ctx "not enough operands" (list-first-line items) (list-first-col items))
          "0")
        (let ((mut result "("))
          ;; Process first operand
          (match (list-get items start-idx)
            ((some first-arg)
              (set! result (ctx-str4 ctx result "(" (transpile-expr ctx first-arg) ")")))
            ((none) (set! result result)))
          ;; Process remaining operands
          (let ((mut i (+ start-idx 1)))
            (while (< i len)
              (match (list-get items i)
                ((some arg)
                  (let ((arg-str (ctx-str3 ctx " (" (transpile-expr ctx arg) ")")))
                    (set! result (ctx-str4 ctx result " " c-op arg-str))))
                ((none) (set! result result)))
              (set! i (+ i 1))))
          (ctx-str ctx result ")")))))

  ;; ============================================================
  ;; Built-in Type Detection
  ;; ============================================================

  (fn get-builtin-type-c-name ((type-name String))
    (@intent "Get C type name for built-in types, empty string if not a built-in")
    (@spec ((String) -> String))
    ;; Map SLOP built-in type names to their C equivalents
    ;; Returns empty string if not a built-in type
    (cond
      ((string-eq type-name "Bytes") "slop_bytes")
      ((string-eq type-name "String") "slop_string")
      (else "")))

  (fn is-pointer-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type like (Ptr X)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn is-string-literal ((expr (Ptr SExpr)))
    (@intent "Check if expression is a string literal")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((str _) true)
      (_ false)))

  (fn transpile-builtin-constructor ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile built-in type constructor with correct field order")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (cond
        ;; Bytes: (Bytes data len cap) -> (slop_bytes){.len = len, .cap = cap, .data = data}
        ((string-eq type-name "Bytes")
          (if (< len 4)
            "(slop_bytes){0}"
            (let ((data-c (match (list-get items 1) ((some e) (transpile-expr ctx e)) ((none) "NULL")))
                  (len-c (match (list-get items 2) ((some e) (transpile-expr ctx e)) ((none) "0")))
                  (cap-c (match (list-get items 3) ((some e) (transpile-expr ctx e)) ((none) "0"))))
              (ctx-str ctx "(slop_bytes){.len = " (ctx-str ctx len-c
                (ctx-str ctx ", .cap = " (ctx-str ctx cap-c
                  (ctx-str ctx ", .data = " (ctx-str ctx data-c "}")))))))))
        ;; String: (String data len) -> (slop_string){.len = len, .data = data}
        ((string-eq type-name "String")
          (if (< len 3)
            "(slop_string){0}"
            (let ((data-c (match (list-get items 1) ((some e) (transpile-expr ctx e)) ((none) "NULL")))
                  (len-c (match (list-get items 2) ((some e) (transpile-expr ctx e)) ((none) "0"))))
              (ctx-str ctx "(slop_string){.len = " (ctx-str ctx len-c
                (ctx-str ctx ", .data = " (ctx-str ctx data-c "}")))))))
        (else "(/* unknown builtin */)"))))

  ;; ============================================================
  ;; Function Call Transpilation
  ;; ============================================================

  (fn transpile-call ((ctx (Ptr TranspileContext)) (fn-name String) (args String))
    (@intent "Transpile a function call")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Check for runtime built-in functions first (no prefix)
      (let ((runtime-name (get-runtime-function-name fn-name)))
        (if (> (string-len runtime-name) 0)
          ;; Runtime function - use its name directly
          (ctx-str4 ctx runtime-name "(" args ")")
          ;; Handle qualified names like "file.open" or regular names like "open"
          (let ((base-name (get-base-function-name arena fn-name))
                (mod-name (get-module-from-qualified-name arena fn-name)))
            ;; First check if this is a local variable (function pointer or closure)
            (match (ctx-lookup-var ctx fn-name)
              ((some var-entry)
                ;; Check if this is a closure (captured lambda)
                (if (. var-entry is-closure)
                  ;; Closure call: lambda_name((env_type*)f.env, args...)
                  (let ((lambda-name (. var-entry closure-lambda-name))
                        (env-type (. var-entry closure-env-type))
                        (var-c-name (. var-entry c-name)))
                    (if (> (string-len args) 0)
                      ;; Has arguments: lambda_name((env_type*)var.env, args)
                      (let ((s1 (ctx-str ctx lambda-name "(("))
                            (s2 (ctx-str ctx s1 env-type))
                            (s3 (ctx-str ctx s2 "*)"))
                            (s4 (ctx-str ctx s3 var-c-name))
                            (s5 (ctx-str ctx s4 ".env, "))
                            (s6 (ctx-str ctx s5 args)))
                        (ctx-str ctx s6 ")"))
                      ;; No arguments (just env): lambda_name((env_type*)var.env)
                      (let ((s1 (ctx-str ctx lambda-name "(("))
                            (s2 (ctx-str ctx s1 env-type))
                            (s3 (ctx-str ctx s2 "*)"))
                            (s4 (ctx-str ctx s3 var-c-name)))
                        (ctx-str ctx s4 ".env)"))))
                  ;; Local function pointer variable - use its c-name directly
                  (ctx-str4 ctx (. var-entry c-name) "(" args ")")))
              ((none)
                ;; Look up registered function using base name
                (let ((c-name (match (ctx-lookup-func ctx base-name)
                                ((some func-entry)
                                  (. func-entry c-name))
                                ;; Not found - generate C name
                                ((none)
                                  (if (> (string-len mod-name) 0)
                                    ;; Cross-module call - convert qualified name to C name (mod_func)
                                    (to-c-name arena fn-name)
                                    ;; Same-module call - add current module prefix
                                    (ctx-prefix-type ctx (to-c-name arena fn-name)))))))
                  (ctx-str4 ctx c-name "(" args ")")))))))))

  (fn get-base-function-name ((arena Arena) (fn-name String))
    (@intent "Extract base function name from qualified name (file.open -> open)")
    (@spec ((Arena String) -> String))
    ;; Find the dot position
    (let ((len (cast Int (string-len fn-name)))
          (mut dot-pos -1)
          (mut i 0))
      (while (< i len)
        (if (= (char-at fn-name (cast (Int 0 ..) i)) 46)  ;; 46 = '.'
          (set! dot-pos i)
          (do))
        (set! i (+ i 1)))
      (if (< dot-pos 0)
        ;; No dot - return original name
        fn-name
        ;; Extract part after the dot
        (let ((start (+ dot-pos 1))
              (sublen (- len start)))
          (substring arena fn-name (cast (Int 0 ..) start) (cast (Int 0 ..) sublen))))))

  (fn get-module-from-qualified-name ((arena Arena) (fn-name String))
    (@intent "Extract module name from qualified name (file.open -> file)")
    (@spec ((Arena String) -> String))
    ;; Find the dot position
    (let ((len (cast Int (string-len fn-name)))
          (mut dot-pos -1)
          (mut i 0))
      (while (< i len)
        (if (= (char-at fn-name (cast (Int 0 ..) i)) 46)  ;; 46 = '.'
          (set! dot-pos i)
          (do))
        (set! i (+ i 1)))
      (if (< dot-pos 0)
        ;; No dot - return empty string (not qualified)
        ""
        ;; Extract part before the dot
        (substring arena fn-name 0 (cast (Int 0 ..) dot-pos)))))

  (fn get-runtime-function-name ((fn-name String))
    (@intent "Check if function is a runtime built-in and return its C name")
    (@spec ((String) -> String))
    (cond
      ;; String operations (from slop_runtime.h)
      ((string-eq fn-name "string-eq") "string_eq")
      ((string-eq fn-name "string-concat") "string_concat")
      ((string-eq fn-name "string-len") "string_len")
      ((string-eq fn-name "string-new") "string_new")
      ((string-eq fn-name "int-to-string") "int_to_string")
      ((string-eq fn-name "float-to-string-short") "float_to_string_short")
      ;; Parsing operations (from strlib, but commonly used without explicit import)
      ((string-eq fn-name "parse-int") "strlib_parse_int")
      ((string-eq fn-name "parse-float") "strlib_parse_float")
      ;; List operations
      ((string-eq fn-name "list-len") "list_len")
      ((string-eq fn-name "list-new") "list_new")
      ((string-eq fn-name "list-push") "list_push")
      ((string-eq fn-name "list-get") "list_get")
      ;; Bytes operations
      ((string-eq fn-name "bytes-len") "bytes_len")
      ((string-eq fn-name "bytes-new") "bytes_new")
      ;; Option operations
      ((string-eq fn-name "unwrap") "unwrap")
      ;; C library functions (FFI)
      ((string-eq fn-name "printf") "printf")
      ((string-eq fn-name "fprintf") "fprintf")
      ((string-eq fn-name "sprintf") "sprintf")
      ((string-eq fn-name "snprintf") "snprintf")
      ((string-eq fn-name "malloc") "malloc")
      ((string-eq fn-name "free") "free")
      ((string-eq fn-name "memcpy") "memcpy")
      ((string-eq fn-name "memset") "memset")
      ((string-eq fn-name "strlen") "strlen")
      ((string-eq fn-name "strcmp") "strcmp")
      ((string-eq fn-name "exit") "exit")
      ((string-eq fn-name "abort") "abort")
      ;; Not a runtime function
      (else "")))

  ;; ============================================================
  ;; Type Inference Helpers
  ;; ============================================================

  (fn transpile-enum-variant ((ctx (Ptr TranspileContext)) (variant-name String))
    (@intent "Transpile an enum variant reference")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Look up the variant in registered enum types
      (match (ctx-lookup-enum-variant ctx variant-name)
        ((some enum-name)
          ;; Emit EnumType_variant
          (let ((enum-c (to-c-name arena enum-name))
                (variant-c (to-c-name arena variant-name)))
            (ctx-str3 ctx enum-c "_" variant-c)))
        ((none)
          ;; Fall back to just the variant name
          (to-c-name arena variant-name)))))

  (fn transpile-ok ((ctx (Ptr TranspileContext)) (value-c String))
    (@intent "Transpile ok result construction")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Get current function's result type
    (match (ctx-get-current-result-type ctx)
      ((some result-type)
        ;; (ResultType){ .is_ok = true, .data.ok = value }
        (ctx-str5 ctx "((" result-type "){ .is_ok = true, .data.ok = " value-c " })"))
      ((none)
        ;; No result type set - use generic
        (ctx-str3 ctx "(slop_result){ .is_ok = true, .data.ok = " value-c " }"))))

  (fn transpile-error ((ctx (Ptr TranspileContext)) (value-c String))
    (@intent "Transpile error result construction")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Get current function's result type
    (match (ctx-get-current-result-type ctx)
      ((some result-type)
        ;; (ResultType){ .is_ok = false, .data.err = value }
        (ctx-str5 ctx "((" result-type "){ .is_ok = false, .data.err = " value-c " })"))
      ((none)
        ;; No result type set - use generic
        (ctx-str3 ctx "(slop_result){ .is_ok = false, .data.err = " value-c " }"))))

  (fn infer-option-type ((ctx (Ptr TranspileContext)) (val-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a value expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {val-expr != nil})
    ;; Basic type inference for Option element type
    (match (deref val-expr)
      ((num num)
        ;; Numbers default to int option
        (if (. num is-float)
          "slop_option_double"
          "slop_option_int"))
      ((str _)
        "slop_option_string")
      ((sym sym)
        ;; Try to look up variable type
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type))
                    (slop-type (. var-entry slop-type))
                    (arena (. (deref ctx) arena)))
                (cond
                  ;; Handle auto type - try to derive from slop-type
                  ((string-eq c-type "auto")
                    (if (> (string-len slop-type) 0)
                      ;; Convert SLOP type to C type and build Option type
                      (let ((derived-c-type (slop-value-type-to-c-type ctx slop-type)))
                        (c-type-to-option-type-name ctx derived-c-type))
                      ;; No slop-type available - emit error
                      (do
                        (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for variable '" name "' - type is 'auto' with no SLOP type") (sexpr-line val-expr) (sexpr-col val-expr))
                        "__type_error__")))
                  ((string-eq c-type "int64_t") "slop_option_int")
                  ((string-eq c-type "double") "slop_option_double")
                  ((string-eq c-type "slop_string") "slop_option_string")
                  ((string-eq c-type "char") "slop_option_char")
                  ((string-eq c-type "uint8_t") "slop_option_u8")
                  ;; Check for pointer types (ends with *)
                  ((ends-with c-type "*")
                    (let ((base-type (strip-pointer-suffix arena c-type)))
                      (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                  ;; Other custom types: build slop_option_<typename>
                  (else (ctx-str3 ctx "slop_option_" c-type "")))))
            ;; Unknown variable - emit error
            ((none)
              (do
                (ctx-add-error-at ctx (ctx-str3 ctx "Unknown variable '" name "' for Option type inference") (sexpr-line val-expr) (sexpr-col val-expr))
                "__type_error__")))))
      ;; For complex expressions, try to infer type from the structure
      ((lst lst)
        (infer-list-expr-option-type ctx (. lst items)))))

  (fn c-type-to-option-type-name ((ctx (Ptr TranspileContext)) (c-type String))
    (@intent "Convert C type to corresponding Option type name")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ((string-eq c-type "int64_t") "slop_option_int")
        ((string-eq c-type "double") "slop_option_double")
        ((string-eq c-type "slop_string") "slop_option_string")
        ((string-eq c-type "char") "slop_option_char")
        ((string-eq c-type "uint8_t") "slop_option_u8")
        ((string-eq c-type "int8_t") "slop_option_i8")
        ((string-eq c-type "uint16_t") "slop_option_u16")
        ((string-eq c-type "int16_t") "slop_option_i16")
        ((string-eq c-type "uint32_t") "slop_option_u32")
        ((string-eq c-type "int32_t") "slop_option_i32")
        ((string-eq c-type "float") "slop_option_float")
        ;; Check for pointer types (ends with *)
        ((ends-with c-type "*")
          (let ((base-type (strip-pointer-suffix arena c-type)))
            (ctx-str3 ctx "slop_option_" base-type "_ptr")))
        ;; Other custom types: build slop_option_<typename>
        (else (ctx-str3 ctx "slop_option_" c-type "")))))

  (fn infer-field-c-type-from-items ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C type for a field access expression (. obj field) from items list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        "/* TRANSPILER ERROR: malformed field access */"
        (match (list-get items 1)
          ((some obj-expr)
            (match (list-get items 2)
              ((some field-expr)
                (match (deref field-expr)
                  ((sym field-sym)
                    (let ((field-name (. field-sym name))
                          (obj-c-type (infer-expr-c-type ctx obj-expr)))
                      (match (ctx-lookup-field-type ctx obj-c-type field-name)
                        ((some c-type) c-type)
                        ((none)
                          ;; Try with SLOP type name
                          (match (ctx-lookup-var ctx (get-var-name-from-expr obj-expr))
                            ((some var-entry)
                              (let ((obj-slop-type (. var-entry slop-type)))
                                (match (ctx-lookup-field-type ctx obj-slop-type field-name)
                                  ((some c-type2) c-type2)
                                  ((none) "/* TRANSPILER ERROR: unknown field type */"))))
                            ((none) "/* TRANSPILER ERROR: unknown object type */"))))))
                  (else "/* TRANSPILER ERROR: field name must be symbol */")))
              ((none) "/* TRANSPILER ERROR: missing field expression */")))
          ((none) "/* TRANSPILER ERROR: missing object expression */")))))

  (fn infer-list-expr-option-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer Option type for a list expression (field access, function call, etc.)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena))
          (line (list-first-line items))
          (col (list-first-col items)))
      (if (< len 1)
        (do
          (ctx-add-error-at ctx "Empty list in option type inference" line col)
          "__type_error__")
        (match (list-get items 0)
          ((some head-expr)
            (match (deref head-expr)
              ((sym sym)
                (let ((op (. sym name)))
                  (cond
                    ;; Field access: (. obj field) - try registry lookup, then hardcoded fallback
                    ((string-eq op ".")
                      (if (< len 3)
                        (do
                          (ctx-add-error-at ctx "Incomplete field access for option type inference" line col)
                          "__type_error__")
                        ;; Try registry-based field type lookup first
                        (let ((field-c-type (infer-field-c-type-from-items ctx items)))
                          (if (not (starts-with field-c-type "/*"))
                            (c-type-to-option-type-name ctx field-c-type)
                            ;; Fallback: hardcoded known fields (for match-bound vars with __auto_type)
                            (match (list-get items 2)
                              ((some field-expr)
                                (match (deref field-expr)
                                  ((sym field-sym)
                                    (let ((field-name (. field-sym name)))
                                      (cond
                                        ((string-eq field-name "name") "slop_option_string")
                                        ((string-eq field-name "value") "slop_option_string")
                                        ((string-eq field-name "message") "slop_option_string")
                                        ((string-eq field-name "c-name") "slop_option_string")
                                        ((string-eq field-name "c-type") "slop_option_string")
                                        ((string-eq field-name "slop-name") "slop_option_string")
                                        ((string-eq field-name "slop-type") "slop_option_string")
                                        ((string-eq field-name "return-type") "slop_option_string")
                                        ((string-eq field-name "slop-return-type") "slop_option_string")
                                        ((string-eq field-name "enum-name") "slop_option_string")
                                        ((string-eq field-name "variant-name") "slop_option_string")
                                        ((string-eq field-name "const-type") "slop_option_types_ResolvedType_ptr")
                                        ;; Unknown field - emit error
                                        (else
                                          (do
                                            (ctx-add-error-at ctx (ctx-str3 ctx "Unknown field '" field-name "' for option type inference") (sexpr-line field-expr) (sexpr-col field-expr))
                                            "__type_error__")))))
                                  (else
                                    (do
                                      (ctx-add-error-at ctx "Non-symbol field for option type inference" (sexpr-line field-expr) (sexpr-col field-expr))
                                      "__type_error__"))))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "Missing field for option type inference" line col)
                                  "__type_error__")))))))
                    ;; String functions that return strings
                    ((or (string-eq op "string-concat")
                         (or (string-eq op "string-copy")
                             (or (string-eq op "int-to-string")
                                 (string-eq op "substring"))))
                      "slop_option_string")
                    ;; Check function registry for return type
                    (else
                      (match (ctx-lookup-func ctx op)
                        ((some func-entry)
                          (let ((ret-type (. func-entry return-type)))
                            (cond
                              ;; Known string return
                              ((. func-entry returns-string) "slop_option_string")
                              ;; Has explicit return type
                              ((> (string-len ret-type) 0)
                                (cond
                                  ((string-eq ret-type "slop_string") "slop_option_string")
                                  ((string-eq ret-type "int64_t") "slop_option_int")
                                  ((string-eq ret-type "double") "slop_option_double")
                                  ;; Pointer type - generate slop_option_<base>_ptr
                                  ((ends-with ret-type "*")
                                    (let ((ctx-arena (. (deref ctx) arena))
                                          (base-type (strip-pointer-suffix ctx-arena ret-type)))
                                      (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                                  ;; Other types - generate slop_option_<type>
                                  (else (ctx-str3 ctx "slop_option_" ret-type ""))))
                              ;; No return type info - emit error
                              (else
                                (do
                                  (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for function '" op "' - no return type info") line col)
                                  "__type_error__")))))
                        ;; Unknown function - emit error
                        ((none)
                          (do
                            (ctx-add-error-at ctx (ctx-str3 ctx "Unknown function '" op "' for Option type inference") line col)
                            "__type_error__")))))))
              (else
                (do
                  (ctx-add-error-at ctx "Non-symbol head in option type inference" (sexpr-line head-expr) (sexpr-col head-expr))
                  "__type_error__"))))
          ((none)
            (do
              (ctx-add-error-at ctx "Missing list head in option type inference" line col)
              "__type_error__"))))))

  (fn strip-pointer-suffix ((arena Arena) (s String))
    (@intent "Strip trailing * from pointer type string")
    (@spec ((Arena String) -> String))
    (let ((len (string-len s)))
      (if (< len 1)
        ""
        (substring arena s (cast (Int 0 ..) 0) (cast (Int 0 ..) (- len 1))))))

  (fn extract-chan-elem-type ((ctx (Ptr TranspileContext)) (chan-type String))
    (@intent "Extract element type from channel type name (slop_chan_foo -> foo)")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (prefix-len 10))  ;; length of "slop_chan_"
      (let ((len (string-len chan-type)))
        (if (<= len prefix-len)
          "int64_t"  ;; fallback
          (substring arena chan-type (cast (Int 0 ..) prefix-len) (cast (Int 0 ..) len))))))

  (fn infer-list-element-option-type ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a list element (for list-get)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    ;; Return empty string to indicate "use anonymous struct fallback"
    (let ((arena (. (deref ctx) arena)))
      (match (deref list-expr)
        ;; Simple variable name
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (list-type-to-option-type ctx (. var-entry c-type)))
              ((none) ""))))  ;; fallback
        ;; Field access: (. var field) - check for known fields
        ((lst lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 3)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym head-sym)
                      (if (string-eq (. head-sym name) ".")
                        ;; This is a field access (. obj field)
                        (match (list-get items 2)
                          ((some field-expr)
                            (infer-field-access-list-type ctx field-expr))
                          ((none) ""))
                        ""))
                    (_ "")))
                ((none) "")))))
        (_ ""))))

  (fn infer-field-access-list-type ((ctx (Ptr TranspileContext)) (field-expr (Ptr SExpr)))
    (@intent "Infer option type for list field access")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    ;; Get the field name and return appropriate option type
    ;; Only use named types that are guaranteed to exist (from types.slop imports)
    (match (deref field-expr)
      ((sym field-sym)
        (let ((field-name (. field-sym name)))
          ;; For common known field names from types module, return appropriate option types
          (cond
            ;; SExprList.items -> (List (Ptr SExpr)) -> slop_option_types_SExpr_ptr
            ((string-eq field-name "items") "slop_option_types_SExpr_ptr")
            ;; ResolvedType.variants -> (List ResolvedVariant) -> slop_option_types_ResolvedVariant
            ((string-eq field-name "variants") "slop_option_types_ResolvedVariant")
            ;; ResolvedType.fields -> (List ResolvedField) -> slop_option_types_ResolvedField
            ((string-eq field-name "fields") "slop_option_types_ResolvedField")
            ;; Default fallback - use empty string to trigger anonymous struct
            ;; (tokens etc. use anonymous struct since slop_option_parser_Token isn't defined)
            (else ""))))
      (_ "")))

  (fn list-type-to-option-type ((ctx (Ptr TranspileContext)) (c-type String))
    (@intent "Convert slop_list_X to slop_option_X")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ((string-eq c-type "slop_list_string") "slop_option_string")
        ((string-eq c-type "slop_list_int") "slop_option_int")
        ((string-eq c-type "slop_list_double") "slop_option_double")
        ((string-eq c-type "slop_list_char") "slop_option_char")
        ((string-eq c-type "slop_list_u8") "slop_option_u8")
        ;; For other list types, extract element and build option type
        ((starts-with c-type "slop_list_")
          (let ((elem-type (substring-after-prefix arena c-type "slop_list_")))
            (ctx-str3 ctx "slop_option_" elem-type "")))
        (else ""))))

  (fn substring-after-prefix ((arena Arena) (s String) (prefix String))
    (@intent "Extract substring after a prefix")
    (@spec ((Arena String String) -> String))
    ;; Use strlib substring
    (let ((prefix-len (string-len prefix))
          (s-len (string-len s)))
      (if (<= s-len prefix-len)
        ""
        (let ((start (cast (Int 0 ..) prefix-len))
              (len (cast (Int 0 ..) (- s-len prefix-len))))
          (substring arena s start len)))))

  ;; ============================================================
  ;; Map Type Helpers (for map-get Option type inference)
  ;; ============================================================

  (fn extract-map-value-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract value type from '(Map K V)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Map String Int)" -> "Int" or "(Map Term (Set Term))" -> "(Set Term)"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 10)
        ""
        ;; Check for "(Map " prefix (5 chars)
        (if (not (starts-with slop-type "(Map "))
          ""
          ;; Find the space between K and V at nesting level 1
          ;; This handles compound value types like (Set Term)
          (let ((mut i 5)
                (mut nesting 1)
                (mut key-space 0)
                (mut found-key false)
                (end-idx (- len 1)))
            ;; Skip past key type to find space at level 1
            (while (and (< i end-idx) (not found-key))
              (let ((c (char-at slop-type (cast (Int 0 ..) i))))
                (cond
                  ((== c 40) (set! nesting (+ nesting 1)))
                  ((== c 41) (set! nesting (- nesting 1)))
                  ((and (== c 32) (== nesting 1))
                    (set! key-space i)
                    (set! found-key true))
                  (else (do))))
              (set! i (+ i 1)))
            (if (not found-key)
              ""
              (let ((value-start (+ key-space 1))
                    (value-len (- end-idx value-start)))
                (if (> value-len 0)
                  (substring arena slop-type (cast (Int 0 ..) value-start) (cast (Int 0 ..) value-len))
                  ""))))))))

  (fn slop-value-type-to-c-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Convert SLOP value type name to C type with proper module prefix")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Map common SLOP types to C types
    (cond
      ((string-eq slop-type "Int") "int64_t")
      ((string-eq slop-type "I8") "int8_t")
      ((string-eq slop-type "I16") "int16_t")
      ((string-eq slop-type "I32") "int32_t")
      ((string-eq slop-type "I64") "int64_t")
      ((string-eq slop-type "U8") "uint8_t")
      ((string-eq slop-type "U16") "uint16_t")
      ((string-eq slop-type "U32") "uint32_t")
      ((string-eq slop-type "U64") "uint64_t")
      ((string-eq slop-type "Char") "char")
      ((string-eq slop-type "Float") "double")
      ((string-eq slop-type "F32") "float")
      ((string-eq slop-type "Bool") "uint8_t")
      ((string-eq slop-type "String") "slop_string")
      ((string-eq slop-type "Bytes") "slop_bytes")
      ;; User-defined types - look up in context for proper prefixed name
      (else
        (let ((arena (. (deref ctx) arena)))
          (match (ctx-lookup-type ctx slop-type)
            ((some entry) (. entry c-name))
            ((none) (to-c-name arena slop-type)))))))

  (fn get-var-name-from-expr ((expr (Ptr SExpr)))
    (@intent "Extract variable name from expression if it's a simple symbol")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym) (. sym name))
      (_ "")))

  (fn extract-map-key-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract key type from '(Map K V)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Map String Int)" -> "String"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 10)
        ""
        ;; Check for "(Map " prefix (5 chars)
        (if (not (starts-with slop-type "(Map "))
          ""
          ;; Find the space between K and V at nesting level 1
          (let ((mut i 5)
                (mut nesting 1)
                (mut key-space 0)
                (mut found-key false)
                (end-idx (- len 1)))
            ;; Skip past key type to find space at level 1
            (while (and (< i end-idx) (not found-key))
              (let ((c (char-at slop-type (cast (Int 0 ..) i))))
                (cond
                  ((== c 40) (set! nesting (+ nesting 1)))
                  ((== c 41) (set! nesting (- nesting 1)))
                  ((and (== c 32) (== nesting 1))
                    (set! key-space i)
                    (set! found-key true))
                  (else (do))))
              (set! i (+ i 1)))
            (if (not found-key)
              ""
              ;; Key starts at position 5 and ends at key-space
              (let ((key-start 5)
                    (key-len (- key-space key-start)))
                (if (> key-len 0)
                  (substring arena slop-type (cast (Int 0 ..) key-start) (cast (Int 0 ..) key-len))
                  ""))))))))

  (fn resolve-type-alias-for-map ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Resolve a type alias to get the underlying (Map K V) or (Set T) type")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; If it already starts with (Map or (Set, return as-is
    (cond
      ((starts-with slop-type "(Map ") slop-type)
      ((starts-with slop-type "(Set ") slop-type)
      ((starts-with slop-type "(") slop-type)  ;; Some other compound type
      (else
        ;; It's a simple identifier - look up as type alias
        (match (ctx-lookup-type-alias ctx slop-type)
          ((some alias-def) alias-def)
          ((none) slop-type)))))

  ;; ============================================================
  ;; SLOP Type Inference for Expressions
  ;; ============================================================

  (fn infer-expr-slop-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer SLOP type of an expression for map/set key type propagation")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ;; Variable reference - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some entry) (. entry slop-type))
              ((none) ""))))
        ;; List expression - check for field access
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 1)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym head-sym)
                      (let ((op (. head-sym name)))
                        (cond
                          ;; Field access: (. obj field)
                          ((and (string-eq op ".") (>= len 3))
                            (match (list-get items 1)
                              ((some obj-expr)
                                (match (list-get items 2)
                                  ((some field-expr)
                                    (match (deref field-expr)
                                      ((sym field-sym)
                                        (let ((field-name (. field-sym name)))
                                          ;; Get object's type, then look up field's slop-type
                                          (let ((obj-c-type (infer-expr-c-type ctx obj-expr)))
                                            (match (ctx-lookup-field-slop-type ctx obj-c-type field-name)
                                              ((some slop-type) slop-type)
                                              ((none)
                                                ;; Try with SLOP type
                                                (let ((obj-slop-type (infer-expr-slop-type ctx obj-expr)))
                                                  (match (ctx-lookup-field-slop-type ctx obj-slop-type field-name)
                                                    ((some slop-type2) slop-type2)
                                                    ((none) ""))))))))
                                      (_ "")))
                                  ((none) "")))
                              ((none) "")))
                          ;; record-new: (record-new TypeName ...) -> TypeName
                          ((string-eq op "record-new")
                            (if (>= len 2)
                              (match (list-get items 1)
                                ((some type-expr)
                                  (match (deref type-expr)
                                    ((sym type-sym) (. type-sym name))
                                    (_ "")))
                                ((none) ""))
                              ""))
                          ;; map-new: (map-new arena KeyType ValueType) -> (Map KeyType ValueType)
                          ((string-eq op "map-new")
                            (if (>= len 4)
                              (match (list-get items 2)
                                ((some key-expr)
                                  (match (list-get items 3)
                                    ((some val-expr)
                                      (let ((key-str (sexpr-to-type-string arena key-expr))
                                            (val-str (sexpr-to-type-string arena val-expr)))
                                        (ctx-str5 ctx "(Map " key-str " " val-str ")")))
                                    ((none) "")))
                                ((none) ""))
                              ""))
                          ;; set-new: (set-new arena ElemType) -> (Set ElemType)
                          ((string-eq op "set-new")
                            (if (>= len 3)
                              (match (list-get items 2)
                                ((some elem-expr)
                                  (let ((elem-str (sexpr-to-type-string arena elem-expr)))
                                    (ctx-str3 ctx "(Set " elem-str ")")))
                                ((none) ""))
                              ""))
                          ;; list-new: (list-new arena ElemType) -> (List ElemType)
                          ((string-eq op "list-new")
                            (if (>= len 3)
                              (match (list-get items 2)
                                ((some elem-expr)
                                  (let ((elem-str (sexpr-to-type-string arena elem-expr)))
                                    (ctx-str3 ctx "(List " elem-str ")")))
                                ((none) ""))
                              ""))
                          ;; Default: check if it's a function call
                          (else
                            (match (ctx-lookup-func ctx op)
                              ((some func-entry) (. func-entry slop-return-type))
                              ((none) ""))))))
                    (_ "")))
                ((none) "")))))
        ;; Other forms - no type info
        (_ ""))))

  ;; ============================================================
  ;; Helper Functions for Type Inference from Inferred SLOP Types
  ;; ============================================================

  (fn infer-map-key-c-type-from-slop-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Infer C type of map key from a SLOP type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (if (== (string-len slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
              (key-slop-type (extract-map-key-from-slop-type arena resolved-type)))
          (if (> (string-len key-slop-type) 0)
            (slop-value-type-to-c-type ctx key-slop-type)
            (let ((elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
              (if (> (string-len elem-slop-type) 0)
                (slop-value-type-to-c-type ctx elem-slop-type)
                "")))))))

  (fn infer-set-elem-c-type-from-slop-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Infer C type of set element from a SLOP type string")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (if (== (string-len slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
              (elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
          (if (> (string-len elem-slop-type) 0)
            (slop-value-type-to-c-type ctx elem-slop-type)
            "")))))

  (fn extract-map-value-from-inferred ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Extract map value type by inferring the expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (inferred-slop-type (infer-expr-slop-type ctx map-expr)))
      (if (== (string-len inferred-slop-type) 0)
        ""
        (let ((resolved-type (resolve-type-alias-for-map ctx inferred-slop-type)))
          (extract-map-value-from-slop-type arena resolved-type)))))

  (fn extract-list-elem-from-inferred ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)))
    (@intent "Extract list element type by inferring the expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (inferred-slop-type (infer-expr-slop-type ctx list-expr)))
      (if (== (string-len inferred-slop-type) 0)
        ""
        (if (starts-with inferred-slop-type "(List ")
          (let ((elem-len (- (- (string-len inferred-slop-type) 6) 1)))
            (if (> elem-len 0)
              (substring arena inferred-slop-type 6 (cast (Int 0 ..) elem-len))
              ""))
          ""))))

  (fn infer-map-key-c-type ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Infer the C type of a map's key type from variable lookup")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref map-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve type aliases and extract key type
                    (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
                          (key-slop-type (extract-map-key-from-slop-type arena resolved-type)))
                      (if (> (string-len key-slop-type) 0)
                        (slop-value-type-to-c-type ctx key-slop-type)
                        ;; Try set element type if not a map
                        (let ((elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
                          (if (> (string-len elem-slop-type) 0)
                            (slop-value-type-to-c-type ctx elem-slop-type)
                            ""))))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Non-symbol expression (field access, match binding, etc.) - use fallback inference
        (_ (infer-map-key-c-type-from-slop-type ctx (infer-expr-slop-type ctx map-expr))))))

  (fn extract-set-elem-from-slop-type ((arena Arena) (slop-type String))
    (@intent "Extract element type from '(Set T)' SLOP type string")
    (@spec ((Arena String) -> String))
    ;; Handle cases like "(Set Int)" -> "Int" or "(Set Term)" -> "Term"
    ;; Returns "" if cannot parse
    (let ((len (string-len slop-type)))
      (if (< len 7)
        ""
        ;; Check for "(Set " prefix (5 chars)
        (if (not (starts-with slop-type "(Set "))
          ""
          ;; Element type starts at position 5 and goes to the closing paren
          (let ((elem-start 5)
                (elem-len (- (- len 1) elem-start)))  ;; len - 1 to skip closing paren
            (if (> elem-len 0)
              (substring arena slop-type (cast (Int 0 ..) elem-start) (cast (Int 0 ..) elem-len))
              ""))))))

  (fn infer-set-elem-c-type ((ctx (Ptr TranspileContext)) (set-expr (Ptr SExpr)))
    (@intent "Infer the C type of a set's element type from variable lookup")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {set-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref set-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve type aliases and extract element type
                    (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
                          (elem-slop-type (extract-set-elem-from-slop-type arena resolved-type)))
                      (if (> (string-len elem-slop-type) 0)
                        (slop-value-type-to-c-type ctx elem-slop-type)
                        ""))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Non-symbol expression (field access, match binding, etc.) - use fallback inference
        (_ (infer-set-elem-c-type-from-slop-type ctx (infer-expr-slop-type ctx set-expr))))))

  (fn compound-slop-type-to-id ((arena Arena) (slop-type String))
    (@intent "Convert compound SLOP type string to C identifier for container naming")
    (@spec ((Arena String) -> String))
    ;; Handle compound types: (Set T), (Map K V), (List T), (Option T), (Ptr T)
    ;; Returns a valid C identifier component
    (cond
      ;; (Set T) -> set_<T-id>
      ((starts-with slop-type "(Set ")
        (let ((inner (extract-set-elem-from-slop-type arena slop-type)))
          (if (> (string-len inner) 0)
            (string-concat arena "set_" (slop-value-type-to-option-id arena inner))
            (to-c-name arena slop-type))))
      ;; (Map K V) -> map_<K-id>_<V-id>
      ((starts-with slop-type "(Map ")
        (let ((key-type (extract-map-key-from-slop-type arena slop-type))
              (val-type (extract-map-value-from-slop-type arena slop-type)))
          (if (and (> (string-len key-type) 0) (> (string-len val-type) 0))
            (string-concat arena "map_"
              (string-concat arena (slop-value-type-to-option-id arena key-type)
                (string-concat arena "_" (slop-value-type-to-option-id arena val-type))))
            (to-c-name arena slop-type))))
      ;; (List T) -> list_<T-id>
      ((starts-with slop-type "(List ")
        (let ((len (string-len slop-type)))
          (if (< len 8)
            (to-c-name arena slop-type)
            (let ((inner-start 6)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena "list_" (slop-value-type-to-option-id arena inner)))
                (to-c-name arena slop-type))))))
      ;; (Option T) -> option_<T-id>
      ((starts-with slop-type "(Option ")
        (let ((len (string-len slop-type)))
          (if (< len 10)
            (to-c-name arena slop-type)
            (let ((inner-start 8)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena "option_" (slop-value-type-to-option-id arena inner)))
                (to-c-name arena slop-type))))))
      ;; (Ptr T) -> <T-id>_ptr
      ((starts-with slop-type "(Ptr ")
        (let ((len (string-len slop-type)))
          (if (< len 7)
            (to-c-name arena slop-type)
            (let ((inner-start 5)
                  (inner-len (- (- len 1) inner-start)))
              (if (> inner-len 0)
                (let ((inner (substring arena slop-type (cast (Int 0 ..) inner-start) (cast (Int 0 ..) inner-len))))
                  (string-concat arena (slop-value-type-to-option-id arena inner) "_ptr"))
                (to-c-name arena slop-type))))))
      ;; Unknown compound type - fall back to to-c-name
      (else (to-c-name arena slop-type))))

  (fn slop-value-type-to-option-id ((arena Arena) (slop-type String))
    (@intent "Convert SLOP value type name to option type identifier component")
    (@spec ((Arena String) -> String))
    ;; Map common SLOP types to option type identifiers
    (cond
      ((string-eq slop-type "Int") "int")
      ((string-eq slop-type "I8") "int8_t")
      ((string-eq slop-type "I16") "int16_t")
      ((string-eq slop-type "I32") "int32_t")
      ((string-eq slop-type "I64") "int64_t")
      ((string-eq slop-type "U8") "uint8_t")
      ((string-eq slop-type "U16") "uint16_t")
      ((string-eq slop-type "U32") "uint32_t")
      ((string-eq slop-type "U64") "uint64_t")
      ((string-eq slop-type "Char") "char")
      ((string-eq slop-type "Float") "double")
      ((string-eq slop-type "F32") "float")
      ((string-eq slop-type "Bool") "uint8_t")
      ((string-eq slop-type "String") "string")
      ((string-eq slop-type "Bytes") "bytes")
      ;; Compound types starting with ( need special handling
      ((starts-with slop-type "(")
        (compound-slop-type-to-id arena slop-type))
      ;; User-defined types - convert to C identifier format
      (else (to-c-name arena slop-type))))

  (fn infer-map-value-option-type ((ctx (Ptr TranspileContext)) (map-expr (Ptr SExpr)))
    (@intent "Infer the slop_option_* type for a map value (for map-get)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {map-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref map-expr)
        ;; Simple variable name - look up its slop-type
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (> (string-len slop-type) 0)
                    ;; We have a SLOP type string - resolve alias and extract value type
                    (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
                          (value-slop-type (extract-map-value-from-slop-type arena resolved-type)))
                      (if (> (string-len value-slop-type) 0)
                        ;; Got value type - check if it resolves to a container (pointer in C)
                        (let ((resolved-value (resolve-type-alias-for-map ctx value-slop-type)))
                          (if (or (starts-with resolved-value "(Map ")
                                  (or (starts-with resolved-value "(Set ")
                                      (starts-with resolved-value "(List ")))
                            ;; Container types are pointers in C
                            "slop_option_ptr"
                            ;; Convert to option type name
                            (let ((option-id (slop-value-type-to-option-id arena value-slop-type)))
                              (ctx-str ctx "slop_option_" option-id))))
                        ;; Couldn't extract value type
                        ""))
                    ;; No slop-type stored
                    "")))
              ((none) ""))))
        ;; Other expressions (field access, deref, etc.) - use infer-expr-slop-type
        (_ (let ((slop-type (infer-expr-slop-type ctx map-expr)))
             (if (> (string-len slop-type) 0)
               ;; Resolve type alias before extracting map value type
               (let ((resolved-type (resolve-type-alias-for-map ctx slop-type))
                     (value-slop-type (extract-map-value-from-slop-type arena resolved-type)))
                 (if (> (string-len value-slop-type) 0)
                   ;; Check if value type resolves to a container (pointer in C)
                   (let ((resolved-value (resolve-type-alias-for-map ctx value-slop-type)))
                     (if (or (starts-with resolved-value "(Map ")
                             (or (starts-with resolved-value "(Set ")
                                 (starts-with resolved-value "(List ")))
                       ;; Container types are pointers in C
                       "slop_option_ptr"
                       (let ((option-id (slop-value-type-to-option-id arena value-slop-type)))
                         (ctx-str ctx "slop_option_" option-id))))
                   ""))
               ""))))))

  (fn option-type-to-value-c-type ((arena Arena) (option-type String))
    (@intent "Extract value C type from slop_option_<type> string")
    (@spec ((Arena String) -> String))
    (cond
      ((string-eq option-type "slop_option_int") "int64_t")
      ((string-eq option-type "slop_option_string") "slop_string")
      ((string-eq option-type "slop_option_bool") "uint8_t")
      ((string-eq option-type "slop_option_double") "double")
      ((string-eq option-type "slop_option_char") "char")
      ((string-eq option-type "slop_option_u8") "uint8_t")
      ((string-eq option-type "slop_option_ptr") "void*")
      ((starts-with option-type "slop_option_")
        (let ((extracted (substring-after-prefix arena option-type "slop_option_")))
          ;; Handle set_ types - sets are implemented as slop_map*
          (if (starts-with extracted "set_")
            "slop_map*"
            extracted)))
      (else "void")))

  (fn infer-option-inner-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Infer the inner SLOP type of an Option from the scrutinee expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    ;; For a variable of type (Option T), return "T"
    ;; For (map-get M k), if M has type (Map K V), return "V"
    ;; For (list-get L i), if L has type (List T), return "T"
    (let ((arena (. (deref ctx) arena)))
      (match (deref scrutinee)
        ;; Variable reference - look up its slop-type and extract inner type from (Option T)
        ((sym sym)
          (let ((name (. sym name)))
            (match (ctx-lookup-var ctx name)
              ((some var-entry)
                (let ((slop-type (. var-entry slop-type)))
                  (if (starts-with slop-type "(Option ")
                    ;; Extract T from "(Option T)" - starts at position 8, ends before last paren
                    (let ((len (string-len slop-type)))
                      (if (> len 9)
                        (let ((inner-len (- (- (cast Int len) 8) 1)))
                          (if (> inner-len 0)
                            (substring arena slop-type 8 (cast (Int 0 ..) inner-len))
                            ""))
                        ""))
                    "")))
              ((none) ""))))
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              ""
              (match (list-get items 0)
                ((some head-expr)
                  (match (deref head-expr)
                    ((sym sym)
                      (let ((op (. sym name)))
                        (cond
                          ((string-eq op "map-get")
                            ;; (map-get MAP KEY) - get value type from MAP's type
                            (if (< len 2)
                              ""
                              (match (list-get items 1)
                                ((some map-expr)
                                  (match (deref map-expr)
                                    ((sym map-sym)
                                      (let ((map-name (. map-sym name)))
                                        (match (ctx-lookup-var ctx map-name)
                                          ((some var-entry)
                                            (let ((slop-type (. var-entry slop-type)))
                                              (if (> (string-len slop-type) 0)
                                                ;; Resolve type aliases before extracting value type
                                                (let ((resolved-type (resolve-type-alias-for-map ctx slop-type)))
                                                  (let ((value-type (extract-map-value-from-slop-type arena resolved-type)))
                                                    ;; Also resolve value type if it's a type alias (e.g., TermSet -> (Set Term))
                                                    (resolve-type-alias-for-map ctx value-type)))
                                                "")))
                                          ((none) ""))))
                                    ;; Non-symbol map expression - use fallback inference
                                    (_ (extract-map-value-from-inferred ctx map-expr))))
                                ((none) ""))))
                          ((string-eq op "list-get")
                            ;; (list-get LIST IDX) - get element type from LIST's type
                            (if (< len 2)
                              ""
                              (match (list-get items 1)
                                ((some list-expr)
                                  (match (deref list-expr)
                                    ((sym list-sym)
                                      (let ((list-name (. list-sym name)))
                                        (match (ctx-lookup-var ctx list-name)
                                          ((some var-entry)
                                            (let ((slop-type (. var-entry slop-type)))
                                              (if (starts-with slop-type "(List ")
                                                (let ((elem-len (- (- (string-len slop-type) 6) 1)))
                                                  (if (> elem-len 0)
                                                    (substring arena slop-type 6 (cast (Int 0 ..) elem-len))
                                                    ""))
                                                "")))
                                          ((none) ""))))
                                    ;; Non-symbol list expression - use fallback inference
                                    (_ (extract-list-elem-from-inferred ctx list-expr))))
                                ((none) ""))))
                          (else ""))))
                    (_ "")))
                ((none) "")))))
        (_ ""))))

  ;; ============================================================
  ;; Ternary None Fix Helper
  ;; ============================================================

  (fn fix-ternary-none ((ctx (Ptr TranspileContext)) (other-branch String) (this-branch String))
    (@intent "Fix type mismatch when one ternary branch is 'none' and other is typed option")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; If this-branch is "none" and other-branch looks like a typed option,
    ;; return typed none
    (if (and (string-eq this-branch "none")
             (starts-with other-branch "(slop_option_"))
      ;; Extract option type from other-branch: "(slop_option_X){..."
      (let ((arena (. (deref ctx) arena)))
        (match (extract-option-type arena other-branch)
          ((some opt-type)
            (ctx-str3 ctx "(" opt-type "){.has_value = false}"))
          ((none) this-branch)))
      this-branch))

  (fn extract-option-type ((arena Arena) (s String))
    (@intent "Extract option type name from '(slop_option_X){...'")
    (@spec ((Arena String) -> (Option String)))
    ;; String format: (TYPE){...}
    ;; We want to extract TYPE without the ( and )
    (if (< (string-len s) 15)
      (none)
      (let ((mut i 1)  ;; skip leading (
            (len (string-len s))
            (mut found-brace false)
            (mut end-idx 0))
        ;; Find the { that ends the type name (ASCII 123)
        (while (and (< i len) (not found-brace))
          (if (== (char-at s (cast (Int 0 ..) i)) 123)  ;; '{' = 123
            (do
              (set! found-brace true)
              (set! end-idx (- i 2)))  ;; exclude both the ) before { and account for 0-index
            (set! i (+ i 1))))
        (if found-brace
          (some (substring arena s 1 (cast (Int 0 ..) end-idx)))
          (none)))))

  ;; ============================================================
  ;; Array Index Helper
  ;; ============================================================

  (fn transpile-array-index ((ctx (Ptr TranspileContext)) (arr-expr (Ptr SExpr)) (arr-c String) (idx-c String))
    (@intent "Transpile array indexing, handling struct types that need .data access")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String String) -> String))
    (@pre {ctx != nil})
    (@pre {arr-expr != nil})
    ;; Check if the array is a variable with a known type
    (match (deref arr-expr)
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type)))
                ;; Check for string/list types that have .data field
                (if (or (string-eq c-type "slop_string")
                        (string-eq c-type "string")
                        (starts-with c-type "slop_list_"))
                  (ctx-str5 ctx "(" arr-c ").data[" idx-c "]")
                  (ctx-str4 ctx arr-c "[" idx-c "]"))))
            ;; No type info - use simple indexing
            ((none) (ctx-str4 ctx arr-c "[" idx-c "]")))))
      ;; Non-symbol - just use simple indexing
      (_ (ctx-str4 ctx arr-c "[" idx-c "]"))))

  ;; ============================================================
  ;; Pointer Expression Detection
  ;; ============================================================

  (fn is-pointer-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression evaluates to a pointer type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Look up variable type in context
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type)))
                (ends-with c-type "*")))
            ((none) false))))
      ((lst lst)
        (let ((items (. lst items)))
          ;; Check for specific pointer-returning forms
          (if (>= (list-len items) 1)
            (match (list-get items 0)
              ((some head-ptr)
                (match (deref head-ptr)
                  ((sym head-sym)
                    (let ((op (. head-sym name)))
                      ;; deref returns value, addr returns pointer, cast to Ptr returns pointer
                      (cond
                        ((string-eq op "deref") false)
                        ((string-eq op "addr") true)
                        ((string-eq op "arena-alloc") true)
                        ;; cast to pointer type returns pointer
                        ((and (string-eq op "cast") (>= (list-len items) 2))
                          (match (list-get items 1)
                            ((some type-expr) (is-pointer-type-expr type-expr))
                            ((none) false)))
                        (else false))))
                  (_ false)))
              ((none) false))
            false)))
      (_ false)))

  ;; ============================================================
  ;; sizeof Type Extraction for arena-alloc
  ;; ============================================================

  (fn extract-sizeof-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract type from (sizeof Type) expression or nested within arithmetic, or return uint8_t")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (>= len 2)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((sym head-sym)
                      (let ((op (. head-sym name)))
                        (cond
                          ;; Direct sizeof - extract type
                          ((string-eq op "sizeof")
                            (match (list-get items 1)
                              ((some type-expr)
                                (to-c-type-prefixed ctx type-expr))
                              ((none) "uint8_t")))
                          ;; Arithmetic ops - search recursively for sizeof
                          ((or (string-eq op "*") (or (string-eq op "+") (or (string-eq op "-") (string-eq op "/"))))
                            ;; Search each operand for sizeof
                            (let ((mut i 1)
                                  (mut found "uint8_t"))
                              (while (< i len)
                                (match (list-get items i)
                                  ((some arg-expr)
                                    (let ((result (extract-sizeof-type ctx arg-expr)))
                                      (when (not (string-eq result "uint8_t"))
                                        (set! found result))))
                                  ((none) (do)))
                                (set! i (+ i 1)))
                              found))
                          (else "uint8_t"))))
                    (_ "uint8_t")))
                ((none) "uint8_t"))
              "uint8_t")))
        (_ "uint8_t"))))

  ;; ============================================================
  ;; Main Expression Transpilation
  ;; ============================================================

  (fn transpile-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a SLOP expression to C code")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ;; Literals
      ((num _) (transpile-literal ctx expr))
      ((str _) (transpile-literal ctx expr))
      ((sym _) (transpile-literal ctx expr))
      ;; List expressions (function calls, operators, etc.)
      ((lst lst)
        (transpile-list-expr ctx (. lst items)))))

  (fn transpile-list-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a list expression")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 1)
        (do
          (ctx-add-error-at ctx "empty list" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 0)
          ((some head-expr)
            (match (deref head-expr)
              ;; Symbol head - could be operator or function call
              ((sym head-sym)
                (let ((op (. head-sym name)))
                  (cond
                    ;; Binary operators with insufficient operands
                    ((and (is-binop op) (< len 3))
                      (do
                        (ctx-add-error-at ctx "binary operator needs at least 2 operands" (list-first-line items) (list-first-col items))
                        "0"))
                    ;; Binary operators (all are variadic - can chain: (- a b c) = a - b - c)
                    ((and (is-binop op) (>= len 3))
                      ;; More than 2 operands: chain all with same operator
                      (if (> len 3)
                        ;; Variadic: chain all operands
                        (transpile-variadic-binop ctx op items 1)
                        ;; Binary: just 2 operands
                        (match (list-get items 1)
                          ((some left)
                            (match (list-get items 2)
                              ((some right)
                                (let ((left-c (transpile-expr ctx left))
                                      (right-c (transpile-expr ctx right)))
                                  (transpile-binop ctx op left-c right-c)))
                              ((none)
                                (do
                                  (ctx-add-error-at ctx "missing right operand" (list-first-line items) (list-first-col items))
                                  "0"))))
                          ((none)
                            (do
                              (ctx-add-error-at ctx "missing left operand" (list-first-line items) (list-first-col items))
                              "0")))))
                    ;; Comparison operators with insufficient operands
                    ((and (is-comparison-op op) (< len 3))
                      (do
                        (ctx-add-error-at ctx "comparison operator needs 2 operands" (list-first-line items) (list-first-col items))
                        "0"))
                    ;; Comparison operators
                    ((and (is-comparison-op op) (>= len 3))
                      (match (list-get items 1)
                        ((some left)
                          (match (list-get items 2)
                            ((some right)
                              (let ((left-c (transpile-expr ctx left))
                                    (right-c (transpile-expr ctx right)))
                                (transpile-binop ctx op left-c right-c)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing right operand" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing left operand" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; not with no argument
                    ((and (string-eq op "not") (< len 2))
                      (do
                        (ctx-add-error-at ctx "not needs an argument" (list-first-line items) (list-first-col items))
                        "0"))
                    ;; not (unary)
                    ((and (string-eq op "not") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "!(" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; if expression with insufficient branches
                    ((and (string-eq op "if") (< len 4))
                      (do
                        (ctx-add-error-at ctx "if expression needs condition, then, and else branches" (list-first-line items) (list-first-col items))
                        "0"))
                    ;; if expression: (if cond then else) -> (cond) ? then : else
                    ((and (string-eq op "if") (>= len 4))
                      (match (list-get items 1)
                        ((some cond-expr)
                          (match (list-get items 2)
                            ((some then-expr)
                              (match (list-get items 3)
                                ((some else-expr)
                                  (let ((cond-c (transpile-expr ctx cond-expr))
                                        (then-c (transpile-expr ctx then-expr))
                                        (else-c (transpile-expr ctx else-expr)))
                                    ;; Fix type mismatch when one branch is typed option and other is none
                                    (let ((final-else (fix-ternary-none ctx then-c else-c))
                                          (final-then (fix-ternary-none ctx else-c then-c)))
                                      (ctx-str5 ctx "((" cond-c ") ? " (ctx-str3 ctx final-then " : " final-else) ")"))))
                                ((none)
                                  (do
                                    (ctx-add-error-at ctx "missing else" (list-first-line items) (list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing then" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing condition" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; let/let* as expression: use GCC statement expression
                    ((and (or (string-eq op "let") (string-eq op "let*")) (>= len 3))
                      (transpile-let-expr ctx items))
                    ;; while as expression (side effect only, returns 0)
                    ((and (string-eq op "while") (>= len 3))
                      (transpile-while-expr ctx items))
                    ;; Annotations (@loop-invariant, @property, etc.) - no-op, returns 0
                    ;; (bare "@" is array indexing, handled below)
                    ((and (starts-with op "@") (not (string-eq op "@")))
                      "0")
                    ;; do as expression: sequence, returns last value
                    ((and (string-eq op "do") (>= len 1))
                      (transpile-do-expr ctx items))
                    ;; when as expression: (when cond body) -> ((cond) ? ({ body; (void)0; }) : 0)
                    ((and (string-eq op "when") (>= len 2))
                      (transpile-when-expr ctx items))
                    ;; set! as expression (side effect, returns 0)
                    ((and (string-eq op "set!") (>= len 3))
                      (transpile-set-expr ctx items))
                    ;; match expression: use GCC statement expression
                    ((and (string-eq op "match") (>= len 3))
                      (transpile-match-expr ctx items))
                    ;; deref: (deref ptr) -> (*ptr)
                    ((and (string-eq op "deref") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "(*" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; Field access: (. obj field)
                    ((and (string-eq op ".") (>= len 3))
                      (match (list-get items 1)
                        ((some obj)
                          (match (list-get items 2)
                            ((some field-expr)
                              (match (deref field-expr)
                                ((sym field-sym)
                                  (let ((obj-c (transpile-expr ctx obj))
                                        (field-c (to-c-name arena (. field-sym name)))
                                        (is-ptr (is-pointer-expr ctx obj)))
                                    (if is-ptr
                                      (ctx-str3 ctx obj-c "->" field-c)
                                      (ctx-str3 ctx obj-c "." field-c))))
                                (_
                                  (do
                                    (ctx-add-error-at ctx "invalid field" (list-first-line items) (list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing field" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing object" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; cast: (cast Type expr)
                    ((and (string-eq op "cast") (>= len 3))
                      (match (list-get items 1)
                        ((some type-expr)
                          (match (list-get items 2)
                            ((some val-expr)
                              (let ((c-type (to-c-type-prefixed ctx type-expr))
                                    (val-c (transpile-expr ctx val-expr))
                                    (is-ptr-cast (is-pointer-type-expr type-expr))
                                    (is-str-literal (is-string-literal val-expr)))
                                ;; When casting a string literal to pointer, use .data
                                (if (and is-ptr-cast is-str-literal)
                                  (ctx-str ctx "((" (ctx-str ctx c-type (ctx-str ctx ")(" (ctx-str ctx val-c ".data))"))))
                                  (ctx-str5 ctx "((" c-type ")(" val-c "))"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing cast value" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing cast type" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; c-inline: (c-inline "raw C code") -> raw C code
                    ((and (string-eq op "c-inline") (>= len 2))
                      (match (list-get items 1)
                        ((some str-expr)
                          (match (deref str-expr)
                            ((str str) (. str value))
                            (else
                              (do
                                (ctx-add-error-at ctx "c-inline requires string" (list-first-line items) (list-first-col items))
                                ""))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing c-inline string" (list-first-line items) (list-first-col items))
                            ""))))
                    ;; some: (some value) for Option
                    ((and (string-eq op "some") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr))
                                ;; Use infer-expr-c-type for more accurate type inference
                                (val-type (infer-expr-c-type ctx val-expr))
                                (option-type (cond
                                               ;; Check for type inference error marker
                                               ((string-eq val-type "__type_error__")
                                                 (do
                                                   (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "'") (sexpr-line val-expr) (sexpr-col val-expr))
                                                   "__type_error__"))
                                               ((string-eq val-type "slop_string") "slop_option_string")
                                               ((string-eq val-type "int64_t") "slop_option_int")
                                               ((string-eq val-type "double") "slop_option_double")
                                               ;; For auto/unknown type, emit error - don't guess
                                               ((string-eq val-type "auto")
                                                 (do
                                                   (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "' - type is 'auto'") (sexpr-line val-expr) (sexpr-col val-expr))
                                                   "__type_error__"))
                                               (else (infer-option-type ctx val-expr)))))
                            ;; Check if option-type is an error
                            (if (or (string-eq option-type "__type_error__") (starts-with option-type "/*"))
                              ;; Error in type inference - return placeholder
                              (do
                                (when (starts-with option-type "/*")
                                  (ctx-add-error-at ctx (ctx-str3 ctx "Cannot infer Option type for value '" val-c "'") (sexpr-line val-expr) (sexpr-col val-expr)))
                                "(slop_option_int){.has_value = 0}")
                              ;; Typed option construction
                              (ctx-str5 ctx "(" option-type "){.has_value = 1, .value = " val-c "}"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing some value" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; sizeof: (sizeof Type) -> sizeof(c_type)
                    ((and (string-eq op "sizeof") (>= len 2))
                      (match (list-get items 1)
                        ((some type-expr)
                          (let ((c-type (to-c-type-prefixed ctx type-expr)))
                            (ctx-str3 ctx "sizeof(" c-type ")")))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing sizeof type" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; addr: (addr x) -> (&x)
                    ((and (string-eq op "addr") (>= len 2))
                      (match (list-get items 1)
                        ((some arg)
                          (ctx-str3 ctx "(&" (transpile-expr ctx arg) ")"))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing addr argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; @ array indexing: (@ arr i) -> arr[i]
                    ((and (string-eq op "@") (>= len 3))
                      (match (list-get items 1)
                        ((some arr-expr)
                          (match (list-get items 2)
                            ((some idx-expr)
                              (let ((arr-c (transpile-expr ctx arr-expr))
                                    (idx-c (transpile-expr ctx idx-expr)))
                                ;; Check if array is a struct type (string/list) needing .data
                                (transpile-array-index ctx arr-expr arr-c idx-c)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing index" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing array" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; arena-alloc: (arena-alloc arena size) -> (Type*)slop_arena_alloc(arena, size)
                    ;; Special case: (arena-alloc arena TypeName) -> (Type*)slop_arena_alloc(arena, sizeof(Type))
                    ((and (string-eq op "arena-alloc") (>= len 3))
                      (match (list-get items 1)
                        ((some arena-expr)
                          (match (list-get items 2)
                            ((some size-expr)
                              (let ((arena-c (transpile-expr ctx arena-expr)))
                                ;; Check if size-expr is a bare type symbol (known type)
                                (match (deref size-expr)
                                  ((sym sym)
                                    (let ((type-name (. sym name)))
                                      (match (ctx-lookup-type ctx type-name)
                                        ((some entry)
                                          ;; Known type - generate sizeof(prefixed_type)
                                          ;; Output: ((TYPE*)slop_arena_alloc(arena, sizeof(TYPE)))
                                          (let ((c-type (. entry c-name)))
                                            (ctx-str ctx "((" (ctx-str ctx c-type (ctx-str ctx "*)slop_arena_alloc(" (ctx-str ctx arena-c (ctx-str ctx ", sizeof(" (ctx-str ctx c-type ")))"))))))))
                                        ((none)
                                          ;; Not a registered type - use normal transpilation
                                          (let ((size-c (transpile-expr ctx size-expr))
                                                (cast-type (extract-sizeof-type ctx size-expr)))
                                            (ctx-str5 ctx "(" cast-type "*)slop_arena_alloc(" (ctx-str3 ctx arena-c ", " size-c) ")"))))))
                                  (else
                                    ;; Not a symbol - use normal transpilation
                                    (let ((size-c (transpile-expr ctx size-expr))
                                          (cast-type (extract-sizeof-type ctx size-expr)))
                                      (ctx-str5 ctx "(" cast-type "*)slop_arena_alloc(" (ctx-str3 ctx arena-c ", " size-c) ")"))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing arena-alloc size" (list-first-line items) (list-first-col items))
                                "NULL"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing arena argument" (list-first-line items) (list-first-col items))
                            "NULL"))))
                    ;; quote: (quote variant) -> EnumType_variant
                    ((and (string-eq op "quote") (>= len 2))
                      (match (list-get items 1)
                        ((some variant-expr)
                          (match (deref variant-expr)
                            ((sym sym)
                              ;; Enum variant - look up the type and emit prefixed name
                              (let ((variant-name (. sym name)))
                                (transpile-enum-variant ctx variant-name)))
                            (else
                              (do
                                (ctx-add-error-at ctx "quote requires symbol" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing quote argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; record-new: (record-new Type (field1 val1) (field2 val2) ...) -> ((Type){.f1 = v1, ...})
                    ((and (string-eq op "record-new") (>= len 2))
                      (transpile-record-new ctx items))
                    ;; list: (list Type elem1 elem2 ...) -> inline list literal
                    ((and (string-eq op "list") (>= len 2))
                      (transpile-list-literal ctx items))
                    ;; map-new: (map-new arena KeyType ValueType) -> slop_map_new_ptr(arena, 16)
                    ((and (string-eq op "map-new") (>= len 2))
                      (transpile-map-new ctx items))
                    ;; map-put: (map-put map key val) -> slop_map_put(arena, map, key, &val)
                    ((and (string-eq op "map-put") (>= len 4))
                      (transpile-map-put ctx items))
                    ;; map-get: (map-get map key) -> slop_map_get(map, key)
                    ((and (string-eq op "map-get") (>= len 3))
                      (transpile-map-get ctx items))
                    ;; map-has: (map-has map key) -> (slop_map_get(map, key) != NULL)
                    ((and (string-eq op "map-has") (>= len 3))
                      (transpile-map-has ctx items))
                    ;; map-keys: (map-keys map) -> slop_map_keys(map)
                    ((and (string-eq op "map-keys") (>= len 2))
                      (transpile-map-keys ctx items))
                    ;; set: (set Type e1 e2...) -> set literal
                    ((and (string-eq op "set") (>= len 2))
                      (transpile-set-literal ctx items))
                    ;; set-new: (set-new arena ElementType) -> slop_map_new_ptr for Set
                    ((and (string-eq op "set-new") (>= len 3))
                      (transpile-set-new ctx items))
                    ;; set-put: (set-put set element) -> slop_map_put with dummy value
                    ((and (string-eq op "set-put") (>= len 3))
                      (transpile-set-put ctx items))
                    ;; set-has: (set-has set element) -> slop_map_has
                    ((and (string-eq op "set-has") (>= len 3))
                      (transpile-set-has ctx items))
                    ;; set-remove: (set-remove set element) -> slop_map_remove
                    ((and (string-eq op "set-remove") (>= len 3))
                      (transpile-set-remove ctx items))
                    ;; set-elements: (set-elements set) -> get elements as list
                    ((and (string-eq op "set-elements") (>= len 2))
                      (transpile-set-elements ctx items))
                    ;; union-new: (union-new Type tag value?) -> ((Type){ .tag = Type_tag, .data.tag = value })
                    ;; tag can be bare symbol or quoted symbol like 'literal
                    ((and (string-eq op "union-new") (>= len 3))
                      (match (list-get items 1)
                        ((some type-expr)
                          (match (list-get items 2)
                            ((some tag-expr)
                              (match (deref type-expr)
                                ((sym type-sym)
                                  ;; Extract tag name from either bare symbol or (quote symbol)
                                  (match (extract-symbol-name tag-expr)
                                    ((some tag-str)
                                      ;; Look up registered type to get proper c-name with module prefix
                                      (let ((raw-type-name (. type-sym name))
                                            (type-name (match (ctx-lookup-type ctx raw-type-name)
                                                         ((some entry) (. entry c-name))
                                                         ((none) (to-c-name arena raw-type-name))))
                                            (tag-name (to-c-name arena tag-str))
                                            ;; Build tag constant: Type_tag
                                            (tag-const (ctx-str ctx type-name (ctx-str ctx "_" tag-name))))
                                        ;; Check for optional value
                                        (if (>= len 4)
                                          (match (list-get items 3)
                                            ((some val-expr)
                                              (let ((val-c (transpile-expr ctx val-expr)))
                                                ;; ((Type){ .tag = Type_tag, .data.tag = value })
                                                (ctx-str3 ctx "((" type-name (ctx-str3 ctx "){ .tag = " tag-const (ctx-str5 ctx ", .data." tag-name " = " val-c " })")))))
                                            ((none)
                                              (do
                                                (ctx-add-error-at ctx "missing union value" (list-first-line items) (list-first-col items))
                                                "0")))
                                          ;; No value - just tag: ((Type){ .tag = Type_tag })
                                          (ctx-str3 ctx "((" type-name (ctx-str3 ctx "){ .tag = " tag-const " })")))))
                                    ((none)
                                      (do
                                        (ctx-add-error-at ctx "union-new tag must be symbol" (list-first-line items) (list-first-col items))
                                        "0"))))
                                (_
                                  (do
                                    (ctx-add-error-at ctx "union-new type must be symbol" (list-first-line items) (list-first-col items))
                                    "0"))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing union tag" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing union type" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; ok: (ok value) -> (ResultType){.tag = SLOP_OK, .ok = value}
                    ((and (string-eq op "ok") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr)))
                            (transpile-ok ctx val-c)))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing ok value" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; error: (error value) -> (ResultType){.tag = SLOP_ERR, .err = value}
                    ((and (string-eq op "error") (>= len 2))
                      (match (list-get items 1)
                        ((some val-expr)
                          (let ((val-c (transpile-expr ctx val-expr)))
                            (transpile-error ctx val-c)))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing error value" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; ?: (? result-expr) -> propagation (returns early on error)
                    ((and (string-eq op "?") (>= len 2))
                      (match (list-get items 1)
                        ((some result-expr)
                          (let ((result-c (transpile-expr ctx result-expr)))
                            (match (ctx-get-current-result-type ctx)
                              ((some enclosing-type)
                                ;; Convert error to enclosing function's result type
                                (ctx-str5 ctx "({ __auto_type _tmp = " result-c "; if (!_tmp.is_ok) return ((" enclosing-type
                                          "){ .is_ok = false, .data.err = _tmp.data.err }); _tmp.data.ok; })"))
                              ((none)
                                ;; No enclosing result type - use direct return (fallback)
                                (ctx-str3 ctx "({ __auto_type _tmp = " result-c "; if (!_tmp.is_ok) return _tmp; _tmp.data.ok; })")))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing ? argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; list-len: (list-len list) -> ((int64_t)(list.len))
                    ((and (string-eq op "list-len") (>= len 2))
                      (match (list-get items 1)
                        ((some list-expr)
                          (let ((list-c (transpile-expr ctx list-expr)))
                            (ctx-str3 ctx "((int64_t)((" list-c ").len))")))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-len argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; list-get: (list-get list idx) -> inline option expression
                    ((and (string-eq op "list-get") (>= len 3))
                      (match (list-get items 1)
                        ((some list-expr)
                          (match (list-get items 2)
                            ((some idx-expr)
                              (let ((list-c (transpile-expr ctx list-expr))
                                    (idx-c (transpile-expr ctx idx-expr))
                                    ;; Try to get the proper named option type for this list's elements
                                    (option-type (infer-list-element-option-type ctx list-expr)))
                                ;; If we have a named option type, use it; otherwise use anonymous struct
                                (if (> (string-len option-type) 0)
                                  ;; Named option type available
                                  (ctx-str ctx "({ __auto_type _lst = " (ctx-str ctx list-c
                                    (ctx-str ctx "; size_t _idx = (size_t)" (ctx-str ctx idx-c
                                      (ctx-str ctx "; " (ctx-str ctx option-type
                                        " _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; })"))))))
                                  ;; Fallback to anonymous struct with __typeof__
                                  (ctx-str ctx "({ __auto_type _lst = " (ctx-str ctx list-c
                                    (ctx-str ctx "; size_t _idx = (size_t)" (ctx-str ctx idx-c
                                      "; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; })")))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-get index" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-get list argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; list-pop: (list-pop list) -> Option<T> (removes and returns last element)
                    ((and (string-eq op "list-pop") (>= len 2))
                      (match (list-get items 1)
                        ((some list-expr)
                          (let ((list-c (transpile-expr ctx list-expr))
                                ;; Try to get the proper named option type for this list's elements
                                (option-type (infer-list-element-option-type ctx list-expr)))
                            ;; If we have a named option type, use it; otherwise use anonymous struct
                            (if (> (string-len option-type) 0)
                              ;; Named option type available
                              (ctx-str ctx "({ __auto_type _lst_p = &(" (ctx-str ctx list-c
                                (ctx-str ctx "); " (ctx-str ctx option-type
                                  " _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; })"))))
                              ;; Fallback to anonymous struct with __typeof__
                              (ctx-str ctx "({ __auto_type _lst_p = &(" (ctx-str ctx list-c
                                "); struct { bool has_value; __typeof__(_lst_p->data[0]) value; } _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; })")))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-pop list argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; list-new: (list-new arena Type) -> compound literal
                    ((and (string-eq op "list-new") (>= len 3))
                      (match (list-get items 1)
                        ((some arena-expr)
                          (match (list-get items 2)
                            ((some type-expr)
                              (let ((arena-c (transpile-expr ctx arena-expr))
                                    (elem-c-type (to-c-type-prefixed ctx type-expr))
                                    (elem-id (type-to-identifier arena elem-c-type))
                                    (list-type (ctx-str ctx "slop_list_" elem-id)))
                                ;; ((slop_list_Type){ .data = (Type*)slop_arena_alloc(arena, 16 * sizeof(Type)), .len = 0, .cap = 16 })
                                (ctx-str ctx "(("
                                  (ctx-str ctx list-type
                                    (ctx-str ctx "){ .data = ("
                                      (ctx-str ctx elem-c-type
                                        (ctx-str ctx "*)slop_arena_alloc("
                                          (ctx-str ctx arena-c
                                            (ctx-str ctx ", 16 * sizeof("
                                              (ctx-str ctx elem-c-type ")), .len = 0, .cap = 16 })"))))))))))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-new type argument" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-new arena argument" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; list-push: (list-push list item) -> inline push
                    ((and (string-eq op "list-push") (>= len 3))
                      (match (list-get items 1)
                        ((some list-expr)
                          (match (list-get items 2)
                            ((some item-expr)
                              (let ((list-c (transpile-expr ctx list-expr))
                                    (item-c (transpile-expr ctx item-expr))
                                    ;; Determine arena source from the list expression
                                    ;; If it's a struct field access, use struct->arena
                                    (arena-c (get-arena-for-list-push-expr ctx list-expr list-c)))
                                ;; ({ __auto_type _lst_p = &(list); __auto_type _item = item;
                                ;;    if (_lst_p->len >= _lst_p->cap) { ... grow ... }
                                ;;    _lst_p->data[_lst_p->len++] = _item; })
                                (let ((s1 (ctx-str ctx "({ __auto_type _lst_p = &(" list-c))
                                      (s2 (ctx-str ctx s1 "); __auto_type _item = ("))
                                      (s3 (ctx-str ctx s2 item-c))
                                      (s4 (ctx-str ctx s3 "); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc("))
                                      (s5 (ctx-str ctx s4 arena-c))
                                      (s6 (ctx-str ctx s5 ", _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; })")))
                                  s6)))
                            ((none)
                              (do
                                (ctx-add-error-at ctx "missing list-push item" (list-first-line items) (list-first-col items))
                                "0"))))
                        ((none)
                          (do
                            (ctx-add-error-at ctx "missing list-push list" (list-first-line items) (list-first-col items))
                            "0"))))
                    ;; none constructor: (none) -> typed none if return type is known
                    ((and (string-eq op "none") (= len 1))
                      ;; Try to use function's return type for typed none
                      (match (ctx-get-current-return-type ctx)
                        ((some ret-type)
                          (if (starts-with ret-type "slop_option_")
                            (ctx-str3 ctx "((" ret-type "){.has_value = false})")
                            "none"))
                        ((none) "none")))
                    ;; cond expression: (cond (test body) ... (else body)) -> nested ternary
                    ((string-eq op "cond")
                      (transpile-cond-expr ctx items))
                    ;; for as expression: (for (i start end) body...) -> ({ for (...) {...} 0; })
                    ((string-eq op "for")
                      (transpile-for-as-expr ctx items))
                    ;; for-each as expression: (for-each (item coll) body...) -> ({ for (...) {...} 0; })
                    ((string-eq op "for-each")
                      (transpile-for-each-as-expr ctx items))
                    ;; Lambda expression: (fn ((params...)) body) -> generate static fn, return name
                    ;; Distinguish from named fn by checking if items[1] is a list (params) not a symbol (name)
                    ((string-eq op "fn")
                      (transpile-lambda-expr ctx items))
                    ;; Default: function call
                    (else
                      (transpile-fn-call ctx op items)))))
              ;; Non-symbol head - could be a function pointer variable call
              (_
                ;; Transpile head expression and call it with arguments
                (let ((head-c (transpile-expr ctx head-expr))
                      (mut args "")
                      (mut i 1))
                  (while (< i len)
                    (match (list-get items i)
                      ((some arg)
                        (let ((arg-c (transpile-expr ctx arg)))
                          (if (string-eq args "")
                            (set! args arg-c)
                            (set! args (ctx-str3 ctx args ", " arg-c)))))
                      ((none) (do)))
                    (set! i (+ i 1)))
                  (ctx-str5 ctx head-c "(" args ")" "")))))
          ((none)
            (do
              (ctx-add-error-at ctx "empty list" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn transpile-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile a function call with arguments")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      ;; Check for print/println builtins first
      (cond
        ((string-eq fn-name "println")
          (if (< len 2)
            "printf(\"\\n\")"
            (match (list-get items 1)
              ((some arg)
                (transpile-print ctx arg true))
              ((none) "printf(\"\\n\")"))))
        ((string-eq fn-name "print")
          (if (< len 2)
            (do
              (ctx-add-error-at ctx "print: missing argument" (list-first-line items) (list-first-col items))
              "0")
            (match (list-get items 1)
              ((some arg)
                (transpile-print ctx arg false))
              ((none)
                (do
                  (ctx-add-error-at ctx "print: missing argument" (list-first-line items) (list-first-col items))
                  "0")))))
        ;; printf: FFI call to C's printf - string literals become raw C strings
        ((string-eq fn-name "printf")
          (transpile-printf-call ctx items))
        ;; string-new: (string-new arena "literal") - string literal arg must be raw C string
        ((string-eq fn-name "string-new")
          (transpile-raw-string-fn-call ctx fn-name items))
        ;; min: (min a b) -> ((a) < (b) ? (a) : (b))
        ((string-eq fn-name "min")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "min: need 2 arguments" (list-first-line items) (list-first-col items))
              "0")
            (match (list-get items 1)
              ((some a-expr)
                (match (list-get items 2)
                  ((some b-expr)
                    (let ((a-c (transpile-expr ctx a-expr))
                          (b-c (transpile-expr ctx b-expr))
                          (s1 (string-concat arena "((" a-c))
                          (s2 (string-concat arena s1 ") < ("))
                          (s3 (string-concat arena s2 b-c))
                          (s4 (string-concat arena s3 ") ? ("))
                          (s5 (string-concat arena s4 a-c))
                          (s6 (string-concat arena s5 ") : ("))
                          (s7 (string-concat arena s6 b-c))
                          (s8 (string-concat arena s7 "))")))
                      s8))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "min: missing second argument" (list-first-line items) (list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "min: missing first argument" (list-first-line items) (list-first-col items))
                  "0")))))
        ;; max: (max a b) -> ((a) > (b) ? (a) : (b))
        ((string-eq fn-name "max")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "max: need 2 arguments" (list-first-line items) (list-first-col items))
              "0")
            (match (list-get items 1)
              ((some a-expr)
                (match (list-get items 2)
                  ((some b-expr)
                    (let ((a-c (transpile-expr ctx a-expr))
                          (b-c (transpile-expr ctx b-expr))
                          (s1 (string-concat arena "((" a-c))
                          (s2 (string-concat arena s1 ") > ("))
                          (s3 (string-concat arena s2 b-c))
                          (s4 (string-concat arena s3 ") ? ("))
                          (s5 (string-concat arena s4 a-c))
                          (s6 (string-concat arena s5 ") : ("))
                          (s7 (string-concat arena s6 b-c))
                          (s8 (string-concat arena s7 "))")))
                      s8))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "max: missing second argument" (list-first-line items) (list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "max: missing first argument" (list-first-line items) (list-first-col items))
                  "0")))))
        ;; spawn: special handling for closures
        ;; (spawn arena closure) -> inline thread creation with env
        ((string-eq fn-name "spawn")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "spawn: need arena and function arguments" (list-first-line items) (list-first-col items))
              "NULL")
            (match (list-get items 2)
              ((some fn-expr)
                (if (is-capturing-lambda fn-expr)
                  ;; Capturing lambda - inline the thread creation with env
                  (transpile-spawn-closure ctx items fn-expr)
                  ;; Non-capturing - use regular spawn call
                  (transpile-regular-fn-call ctx fn-name items)))
              ((none)
                (do
                  (ctx-add-error-at ctx "spawn: missing function argument" (list-first-line items) (list-first-col items))
                  "NULL")))))
        ;; send: type-specific channel send
        ;; (send chan value) -> thread_send_<chan_type>(chan, value)
        ((string-eq fn-name "send")
          (if (< len 3)
            (do
              (ctx-add-error-at ctx "send: need channel and value arguments" (list-first-line items) (list-first-col items))
              "0")
            (match (list-get items 1)
              ((some chan-expr)
                (match (list-get items 2)
                  ((some value-expr)
                    (let ((chan-c (transpile-expr ctx chan-expr))
                          (value-c (transpile-expr ctx value-expr))
                          (chan-c-type (infer-expr-c-type ctx chan-expr)))
                      ;; Extract channel struct type from pointer type (remove trailing *)
                      (let ((chan-type (strip-pointer-suffix arena chan-c-type)))
                        (if (and (starts-with chan-type "slop_chan_")
                                 (not (string-eq chan-type "slop_chan_int")))
                          ;; Custom channel type - use specialized function
                          (let ((s1 (ctx-str3 ctx "thread_send_" chan-type "("))
                                (s2 (ctx-str ctx s1 chan-c))
                                (s3 (ctx-str ctx s2 ", ")))
                            (ctx-str ctx s3 (ctx-str ctx value-c ")")))
                          ;; Default int channel - use standard function
                          (ctx-str5 ctx "thread_send(" chan-c ", " value-c ")")))))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "send: missing value argument" (list-first-line items) (list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "send: missing channel argument" (list-first-line items) (list-first-col items))
                  "0")))))
        ;; recv: type-specific channel receive
        ;; (recv chan) -> thread_recv(chan) which returns Result directly
        ((string-eq fn-name "recv")
          (if (< len 2)
            (do
              (ctx-add-error-at ctx "recv: need channel argument" (list-first-line items) (list-first-col items))
              "0")
            (match (list-get items 1)
              ((some chan-expr)
                (let ((chan-c (transpile-expr ctx chan-expr))
                      (chan-c-type (infer-expr-c-type ctx chan-expr)))
                  ;; Extract channel struct type from pointer type
                  (let ((chan-type (strip-pointer-suffix arena chan-c-type)))
                    (if (and (starts-with chan-type "slop_chan_")
                             (not (string-eq chan-type "slop_chan_int")))
                      ;; Custom channel type - use specialized function
                      (let ((s1 (ctx-str ctx "thread_recv_" chan-type))
                            (s2 (ctx-str ctx s1 "("))
                            (s3 (ctx-str ctx s2 chan-c)))
                        (ctx-str ctx s3 ")"))
                      ;; Default int channel - use standard function
                      (ctx-str3 ctx "thread_recv(" chan-c ")")))))
              ((none)
                (do
                  (ctx-add-error-at ctx "recv: missing channel argument" (list-first-line items) (list-first-col items))
                  "0")))))
        (else
      ;; Check if this is a type constructor (record or union instantiation)
      (match (ctx-lookup-type ctx fn-name)
        ((some type-entry)
          (if (. type-entry is-union)
            ;; Union type: (UnionType (tag value)) -> ((UnionType){ .tag = UnionType_tag, .data.tag = value })
            (transpile-union-constructor ctx fn-name (. type-entry c-name) items)
            ;; Record type: emit compound literal
            ;; For none arguments, look up field type and generate typed compound literal
            (let ((c-name (. type-entry c-name))
                  (type-name fn-name)  ;; Use SLOP type name for field lookup
                  (mut args "")
                  (mut i 1)
                  (mut field-idx 0))
              (while (< i len)
                (match (list-get items i)
                  ((some arg)
                    (let ((arg-c (transpile-expr ctx arg))
                          ;; Look up field type for typed none handling
                          (field-type-opt (ctx-lookup-field-type-by-index ctx type-name field-idx))
                          (final-arg (match field-type-opt
                                       ((some field-type)
                                         (typed-none-arg ctx field-type arg-c))
                                       ((none) arg-c))))
                      (if (string-eq args "")
                        (set! args final-arg)
                        (set! args (ctx-str3 ctx args ", " final-arg)))
                      (set! field-idx (+ field-idx 1))))
                  ((none) (do)))
                (set! i (+ i 1)))
              (ctx-str5 ctx "(" c-name "){" args "}"))))
        ((none)
          ;; Check for built-in type constructors
          (let ((builtin-c-name (get-builtin-type-c-name fn-name)))
            (if (> (string-len builtin-c-name) 0)
              ;; Built-in type constructor - use special handler for correct field order
              (transpile-builtin-constructor ctx fn-name items)
              ;; Check if fn-name is a union variant constructor (e.g., xsd-string-val)
              (match (ctx-lookup-enum-variant ctx fn-name)
                ((some type-name)
                  ;; Union variant constructor: (variant-name value) -> inline struct init
                  (let ((c-variant (to-c-name arena fn-name))
                        (c-tag-enum (ctx-str3 ctx type-name "_" c-variant)))
                    (if (>= len 2)
                      (match (list-get items 1)
                        ((some value-expr)
                          (let ((value-c (transpile-expr ctx value-expr)))
                            (ctx-str3 ctx "((" type-name
                              (ctx-str3 ctx "){ .tag = " c-tag-enum
                                (ctx-str5 ctx ", .data." c-variant " = " value-c " })")))))
                        ((none)
                          (ctx-str3 ctx "((" type-name
                            (ctx-str3 ctx "){ .tag = " c-tag-enum " })"))))
                      (ctx-str3 ctx "((" type-name
                        (ctx-str3 ctx "){ .tag = " c-tag-enum " })")))))
                ((none)
                  ;; Regular function call - look up param types for typed none handling
                  (let ((func-opt (ctx-lookup-func ctx fn-name))
                        (mut args "")
                        (mut i 1)
                        (mut param-idx 0))
                    ;; Check if function is defined or is a runtime built-in
                    (match func-opt
                      ((none)
                        ;; Not a user-defined function - check if it's a runtime built-in
                        (let ((runtime-name (get-runtime-function-name fn-name))
                              (var-opt (ctx-lookup-var ctx fn-name)))
                          (if (and (== (string-len runtime-name) 0)
                                   (match var-opt ((none) true) ((some _) false)))
                            ;; Not a runtime built-in or local variable - emit error
                            (do
                              (ctx-add-error-at ctx
                                (ctx-str3 ctx "undefined function '" fn-name "' - check imports")
                                (list-first-line items) (list-first-col items))
                              "0")
                            ;; Runtime built-in - proceed without type info
                            (do
                              (while (< i len)
                                (match (list-get items i)
                                  ((some arg)
                                    (let ((arg-c (transpile-expr ctx arg)))
                                      (if (string-eq args "")
                                        (set! args arg-c)
                                        (set! args (ctx-str3 ctx args ", " arg-c)))))
                                  ((none) (do)))
                                (set! i (+ i 1)))
                              (transpile-call ctx fn-name args)))))
                      ((some func-entry)
                        ;; User-defined function - process with typed none handling
                        (do
                          (while (< i len)
                            (match (list-get items i)
                              ((some arg)
                                (let ((arg-c (transpile-expr ctx arg))
                                      ;; Get expected type for this parameter
                                      (expected-type (match (list-get (. func-entry param-types) param-idx)
                                                       ((some p) (. (deref p) c-type))
                                                       ((none) "")))
                                      ;; Convert none to typed Option if needed
                                      (final-arg (typed-none-arg ctx expected-type arg-c)))
                                  (if (string-eq args "")
                                    (set! args final-arg)
                                    (set! args (ctx-str3 ctx args ", " final-arg)))
                                  (set! param-idx (+ param-idx 1))))
                              ((none) (do)))
                            (set! i (+ i 1)))
                          (transpile-call ctx fn-name args)))))))))))))))

  (fn transpile-print ((ctx (Ptr TranspileContext)) (arg (Ptr SExpr)) (newline Bool))
    (@intent "Transpile print/println with type-aware formatting")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> String))
    (@pre {ctx != nil})
    (@pre {arg != nil})
    (let ((arena (. (deref ctx) arena))
          (nl (if newline "\\n" "")))
      ;; Check argument type
      (match (deref arg)
        ;; String literal - direct printf
        ((str s)
          (ctx-str5 ctx "printf(\"%s" nl "\", \"" (. s value) "\")"))
        ;; Number literal
        ((num n)
          ;; Check if float
          (if (string-contains (. n raw) ".")
            (ctx-str5 ctx "printf(\"%f" nl "\", " (. n raw) ")")
            (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" (. n raw) "))")))
        ;; Other expression - check for known types
        (_
          (let ((arg-c (transpile-expr ctx arg)))
            ;; Try to infer type from variable lookup
            (match (get-expr-type-hint ctx arg)
              ((some type-hint)
                (cond
                  ((or (string-eq type-hint "String") (string-eq type-hint "slop_string"))
                    ;; String: use %.*s format since not null-terminated
                    ;; printf("%.*s\n", (int)(arg).len, (arg).data)
                    (transpile-print-string ctx arg-c nl))
                  ((or (string-eq type-hint "Bool") (string-eq type-hint "uint8_t"))
                    (ctx-str5 ctx "printf(\"%s" nl "\", (" arg-c ") ? \"true\" : \"false\")"))
                  ((or (string-eq type-hint "Float") (string-eq type-hint "double"))
                    (ctx-str5 ctx "printf(\"%f" nl "\", " arg-c ")"))
                  (else
                    ;; Default to integer
                    (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" arg-c "))"))))
              ;; No type hint - default to integer for now
              ((none)
                (ctx-str5 ctx "printf(\"%lld" nl "\", (long long)(" arg-c "))"))))))))

  (fn transpile-print-string ((ctx (Ptr TranspileContext)) (arg-c String) (nl String))
    (@intent "Generate printf for string type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (let ((arena (. (deref ctx) arena)))
      ;; printf("%.*s\n", (int)(arg).len, (arg).data)
      (string-concat arena
        (string-concat arena
          (string-concat arena "printf(\"%.*s" nl)
          (string-concat arena "\", (int)(" arg-c))
        (string-concat arena ").len, ("
          (string-concat arena arg-c ").data)")))))

  (fn transpile-printf-call ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile printf call with raw C strings for string literals")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut args "")
          (mut i 1))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (match (deref arg)
                           ;; String literal - use raw C string, not SLOP_STR
                           ((str s)
                             (ctx-str3 ctx "\"" (escape-c-string ctx (. s value)) "\""))
                           ;; Other expressions - transpile normally
                           (_ (transpile-expr ctx arg)))))
              (if (string-eq args "")
                (set! args arg-c)
                (set! args (ctx-str3 ctx args ", " arg-c)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str3 ctx "printf(" args ")")))

  (fn transpile-raw-string-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile function call where string literal args should be raw C strings (not SLOP_STR)")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut args "")
          (mut i 1))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (match (deref arg)
                           ;; String literal - use raw C string, not SLOP_STR
                           ((str s)
                             (ctx-str3 ctx "\"" (escape-c-string ctx (. s value)) "\""))
                           ;; Other expressions - transpile normally
                           (_ (transpile-expr ctx arg)))))
              (if (string-eq args "")
                (set! args arg-c)
                (set! args (ctx-str3 ctx args ", " arg-c)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (transpile-call ctx fn-name args)))

  (fn string-contains ((s String) (substr String))
    (@intent "Check if string contains substring")
    (@spec ((String String) -> Bool))
    (> (count-occurrences s substr) 0))

  (fn get-expr-type-hint ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Try to determine expression type from context")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (match (deref expr)
      ((sym sym)
        (match (ctx-lookup-var ctx (. sym name))
          ((some entry) (some (. entry c-type)))
          ((none) (none))))
      ;; For list expressions - could be field access or function call
      ((lst lst)
        (let ((items (. lst items)))
          (if (>= (list-len items) 1)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym head-sym)
                    (let ((op (. head-sym name)))
                      (cond
                        ;; Field access
                        ((and (string-eq op ".") (>= (list-len items) 3))
                          (match (list-get items 2)
                            ((some field-expr)
                              (match (deref field-expr)
                                ((sym field-sym)
                                  (let ((field-name (. field-sym name)))
                                    (cond
                                      ((string-eq field-name "message") (some "slop_string"))
                                      ((string-eq field-name "name") (some "slop_string"))
                                      ((string-eq field-name "value") (some "slop_string"))
                                      ((string-eq field-name "line") (some "int64_t"))
                                      ((string-eq field-name "col") (some "int64_t"))
                                      (else (none)))))
                                (_ (none))))
                            ((none) (none))))
                        ;; Function call - check known functions first, then lookup
                        (else
                          ;; Check for known string-returning functions first
                          (cond
                            ((string-eq op "pretty-print") (some "slop_string"))
                            ((string-eq op "string-copy") (some "slop_string"))
                            ((string-eq op "string-concat") (some "slop_string"))
                            ((string-eq op "int-to-string") (some "slop_string"))
                            (else
                              (match (ctx-lookup-func ctx op)
                                ((some func-entry)
                                  (if (. func-entry returns-string)
                                    (some "slop_string")
                                    (none)))
                                ((none) (none)))))))))
                  (_ (none))))
              ((none) (none)))
            (none))))
      (_ (none))))

  (fn transpile-union-constructor ((ctx (Ptr TranspileContext)) (type-name String) (c-type-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile a union constructor: (UnionType (tag value)) -> ((UnionType){ .tag = UnionType_tag, .data.tag = value })")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      ;; First argument should be (tag value) or just (tag)
      (if (< len 2)
        (ctx-str3 ctx "((" c-type-name "){})")
        (match (list-get items 1)
          ((some tag-expr)
            (match (deref tag-expr)
              ((lst tag-list)
                (let ((tag-items (. tag-list items)))
                  ;; Parse: (tag value) or (tag)
                  (if (< (list-len tag-items) 1)
                    (ctx-str3 ctx "((" c-type-name "){})")
                    (match (list-get tag-items 0)
                      ((some tag-name-expr)
                        (match (deref tag-name-expr)
                          ((sym tag-sym)
                            (let ((tag-name (. tag-sym name))
                                  (c-tag-name (to-c-name arena tag-name))
                                  (c-tag-enum (ctx-str ctx c-type-name (ctx-str ctx "_" c-tag-name))))
                              ;; Check if there's a value argument
                              (if (>= (list-len tag-items) 2)
                                (match (list-get tag-items 1)
                                  ((some value-expr)
                                    (let ((value-c (transpile-expr ctx value-expr)))
                                      (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum (ctx-str ctx ", .data." (ctx-str ctx c-tag-name (ctx-str ctx " = " (ctx-str ctx value-c " })"))))))))))
                                  ((none) (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })"))))))
                                ;; No value - just tag
                                (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })")))))))
                          (_ (ctx-str3 ctx "((" c-type-name "){})/* tag not symbol */"))))
                      ((none) (ctx-str3 ctx "((" c-type-name "){})/* no tag */"))))))
              ;; Not a list - might be bare symbol like (some x) or (none)
              ((sym sym)
                (let ((tag-name (. sym name))
                      (c-tag-name (to-c-name arena tag-name))
                      (c-tag-enum (ctx-str ctx c-type-name (ctx-str ctx "_" c-tag-name))))
                  (ctx-str ctx "((" (ctx-str ctx c-type-name (ctx-str ctx "){ .tag = " (ctx-str ctx c-tag-enum " })"))))))
              (_ (ctx-str3 ctx "((" c-type-name "){})/* unknown tag form */"))))
          ((none) (ctx-str3 ctx "((" c-type-name "){})/* no args */"))))))

  ;; ============================================================
  ;; Cond Expression (nested ternary)
  ;; ============================================================

  (fn transpile-cond-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a cond expression as nested ternary: (cond (t1 v1) (t2 v2) (else v3)) -> t1 ? v1 : t2 ? v2 : v3")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-cond-result-c-type ctx items))
          (mut result "")
          (mut i 1))
      ;; Process each clause (test body...) or (else body...)
      (while (< i len)
        (match (list-get items i)
          ((some clause-expr)
            (match (deref clause-expr)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (>= clause-len 2)
                    (match (list-get clause-items 0)
                      ((some test-expr)
                        (match (deref test-expr)
                          ;; else clause
                          ((sym sym)
                            (if (string-eq (. sym name) "else")
                              ;; else clause - get the body value (last expression)
                              (match (list-get clause-items (- clause-len 1))
                                ((some body-expr)
                                  (let ((body-c (transpile-expr ctx body-expr)))
                                    (set! result (ctx-str ctx result (typed-none ctx result-type body-c)))))
                                ((none) (set! result (ctx-str ctx result "0"))))
                              ;; Regular test - evaluate as condition
                              (let ((test-c (transpile-expr ctx test-expr)))
                                (match (list-get clause-items (- clause-len 1))
                                  ((some body-expr)
                                    (let ((body-c (typed-none ctx result-type (transpile-expr ctx body-expr))))
                                      (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c (ctx-str ctx " ? " (ctx-str ctx body-c " : "))))))))
                                  ((none) (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c " ? 0 : ")))))))))
                          ;; Non-symbol test
                          (_
                            (let ((test-c (transpile-expr ctx test-expr)))
                              (match (list-get clause-items (- clause-len 1))
                                ((some body-expr)
                                  (let ((body-c (typed-none ctx result-type (transpile-expr ctx body-expr))))
                                    (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c (ctx-str ctx " ? " (ctx-str ctx body-c " : "))))))))
                                ((none) (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx test-c " ? 0 : "))))))))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Close any open ternaries with default 0
      (if (string-eq result "")
        "0"
        ;; Count open parens and close them
        (let ((mut open-count 0)
              (mut j 0)
              (rlen (string-len result)))
          (while (< j (cast Int rlen))
            (let ((c (char-at result (cast (Int 0 ..) j))))
              (cond
                ((== c 40) (set! open-count (+ open-count 1)))  ;; '('
                ((== c 41) (set! open-count (- open-count 1)))  ;; ')'
                (else (do))))
            (set! j (+ j 1)))
          ;; Add closing parens for unclosed ternaries
          (while (> open-count 0)
            (set! result (ctx-str ctx result ")"))
            (set! open-count (- open-count 1)))
          result))))

  ;; ============================================================
  ;; Match Expression (GCC statement expression)
  ;; ============================================================

  (fn transpile-match-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile a match expression, returning a GCC statement expression string")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "invalid match expr" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some scrutinee)
            (let ((scrutinee-c (transpile-expr ctx scrutinee))
                  (patterns (collect-match-patterns ctx items)))
              (cond
                ((is-option-patterns patterns)
                  (build-option-match-expr ctx scrutinee scrutinee-c items))
                ((is-result-patterns patterns)
                  (build-result-match-expr ctx scrutinee scrutinee-c items))
                ((is-union-expr-patterns ctx patterns)
                  (build-union-match-expr ctx scrutinee scrutinee-c items))
                (else
                  (build-ternary-match-expr ctx scrutinee-c items)))))
          ((none)
            (do
              (ctx-add-error-at ctx "missing match scrutinee" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn collect-match-patterns ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Collect pattern expressions from match branches")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (list-new arena (Ptr SExpr)))
          (mut i 2))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 1)
                    (match (list-get branch-items 0)
                      ((some pattern) (list-push result pattern))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn get-expr-pattern-tag ((pat-expr (Ptr SExpr)))
    (@intent "Get the tag from a pattern expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            ""
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (. sym name))
                  (else "")))
              ((none) "")))))
      ((sym sym) (. sym name))
      (else "")))

  (fn is-option-patterns ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are option match")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut found false)
          (mut i 0))
      (while (and (< i len) (not found))
        (match (list-get patterns i)
          ((some pat)
            (let ((tag (get-expr-pattern-tag pat)))
              (when (or (string-eq tag "some") (string-eq tag "none"))
                (set! found true))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-result-patterns ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are result match")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut found false)
          (mut i 0))
      (while (and (< i len) (not found))
        (match (list-get patterns i)
          ((some pat)
            (let ((tag (get-expr-pattern-tag pat)))
              (when (or (string-eq tag "ok") (string-eq tag "error"))
                (set! found true))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-union-expr-patterns ((ctx (Ptr TranspileContext)) (patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are union match (tagged union variants)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Bool))
    (@pre {ctx != nil})
    ;; Union patterns are lists like (variant-name binding) where variant-name
    ;; is registered as an enum/union variant (and not one of special forms)
    (let ((len (list-len patterns))
          (mut has-union-variant false)
          (mut i 0))
      (while (and (< i len) (not has-union-variant))
        (match (list-get patterns i)
          ((some pat-expr)
            (let ((tag (get-expr-pattern-tag pat-expr)))
              ;; Check if it's a registered variant (not special forms)
              (when (and (not (string-eq tag ""))
                         (not (string-eq tag "some"))
                         (not (string-eq tag "none"))
                         (not (string-eq tag "ok"))
                         (not (string-eq tag "error"))
                         (not (string-eq tag "else"))
                         (not (string-eq tag "_")))
                (match (ctx-lookup-enum-variant ctx tag)
                  ((some _) (set! has-union-variant true))
                  ((none) (do))))))
          ((none) (do)))
        (set! i (+ i 1)))
      has-union-variant))

  (fn get-expr-binding-name ((pat-expr (Ptr SExpr)))
    (@intent "Extract binding name from pattern like (ok x)")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 1)
              ((some binding)
                (match (deref binding)
                  ((sym sym) (some (. sym name)))
                  (else none)))
              ((none) none)))))
      (else none)))

  (fn get-match-branch-body ((ctx (Ptr TranspileContext)) (branch-items (List (Ptr SExpr))))
    (@intent "Get the body expression from a match branch")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len branch-items)))
      (if (< len 2)
        "0"
        (match (list-get branch-items (- len 1))
          ((some body-expr)
            (transpile-expr ctx body-expr))
          ((none) "0")))))

  (fn transpile-branch-body-with-binding ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr))
                                          (branch-items (List (Ptr SExpr))) (binding-name String))
    (@intent "Transpile branch body with proper variable binding in scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    ;; Push scope to contain the binding
    (ctx-push-scope ctx)
    ;; Bind the variable if non-empty
    (when (not (string-eq binding-name ""))
      (let ((arena (. (deref ctx) arena))
            (c-name (to-c-name arena binding-name))
            ;; Infer the inner SLOP type from the scrutinee for proper map/set iteration
            (inner-slop-type (infer-option-inner-slop-type ctx scrutinee)))
        (ctx-bind-var ctx (VarEntry binding-name c-name "auto" inner-slop-type false false false "" ""))))
    ;; Transpile body expression
    (let ((result (get-match-branch-body ctx branch-items)))
      ;; Pop scope
      (ctx-pop-scope ctx)
      result))

  (fn build-option-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build Option match as GCC statement expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut some-body "0")
          (mut none-body "0")
          (mut some-binding "")
          (mut i 2))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-expr-pattern-tag pattern)))
                          (cond
                            ((string-eq tag "some")
                              (match (get-expr-binding-name pattern)
                                ((some name)
                                  (set! some-binding name)
                                  ;; Transpile body with binding in scope, passing scrutinee for type inference
                                  (set! some-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                ((none)
                                  ;; No binding - transpile normally
                                  (set! some-body (get-match-branch-body ctx branch-items)))))
                            ((string-eq tag "none")
                              (set! none-body (get-match-branch-body ctx branch-items)))
                            (else (do)))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Infer result type for proper none handling
      (let ((result-type (infer-match-result-c-type ctx items)))
        ;; Build the output string based on whether there's a binding
        (if (string-eq some-binding "")
          ;; No binding - use simple ternary
          (build-option-match-no-binding ctx scrutinee-c some-body none-body result-type)
          ;; Has binding - use if/else
          (build-option-match-with-binding ctx arena scrutinee-c some-binding some-body none-body result-type)))))

  (fn build-option-match-no-binding ((ctx (Ptr TranspileContext)) (scrutinee-c String) (some-body String) (none-body String) (result-type String))
    (@intent "Build Option match without binding using ternary or if/else for void")
    (@spec (((Ptr TranspileContext) String String String String) -> String))
    (@pre {ctx != nil})
    (if (string-eq result-type "void")
      ;; Void result - use if/else statement
      ;; ({ __auto_type _mv = scrutinee; if (_mv.has_value) { some_body; } else { none_body; } (void)0; })
      (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
            (s2 (ctx-str ctx s1 "; if (_mv.has_value) { "))
            (s3 (ctx-str ctx s2 some-body))
            (s4 (ctx-str ctx s3 "; } else { "))
            (s5 (ctx-str ctx s4 none-body))
            (s6 (ctx-str ctx s5 "; } (void)0; })")))
        s6)
      ;; Non-void - use ternary
      ;; ({ __auto_type _mv = scrutinee; _mv.has_value ? (some_body) : (none_body); })
      (let ((typed-none-body (typed-none ctx result-type none-body))
            (s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
            (s2 (ctx-str ctx s1 "; _mv.has_value ? ("))
            (s3 (ctx-str ctx s2 some-body))
            (s4 (ctx-str ctx s3 ") : ("))
            (s5 (ctx-str ctx s4 typed-none-body))
            (s6 (ctx-str ctx s5 "); })")))
        s6)))

  (fn build-option-match-with-binding ((ctx (Ptr TranspileContext)) (arena Arena) (scrutinee-c String)
                                       (binding String) (some-body String) (none-body String) (result-type String))
    (@intent "Build Option match with binding using ternary or if/else for void")
    (@spec (((Ptr TranspileContext) Arena String String String String String) -> String))
    (@pre {ctx != nil})
    (let ((var-c (to-c-name arena binding)))
      (if (string-eq result-type "void")
        ;; Void result - use if/else statement
        ;; ({ __auto_type _mv = scrutinee; if (_mv.has_value) { __auto_type v = _mv.value; some_body; } else { none_body; } (void)0; })
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; if (_mv.has_value) { __auto_type "))
              (s3 (ctx-str ctx s2 var-c))
              (s4 (ctx-str ctx s3 " = _mv.value; "))
              (s5 (ctx-str ctx s4 some-body))
              (s6 (ctx-str ctx s5 "; } else { "))
              (s7 (ctx-str ctx s6 none-body))
              (s8 (ctx-str ctx s7 "; } (void)0; })")))
          s8)
        ;; Non-void - use ternary
        ;; ({ __auto_type _mv = scrutinee; _mv.has_value ? ({ __auto_type v = _mv.value; some_body; }) : (none_body); })
        (let ((typed-none-body (typed-none ctx result-type none-body))
              (s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; _mv.has_value ? ({ __auto_type "))
              (s3 (ctx-str ctx s2 var-c))
              (s4 (ctx-str ctx s3 " = _mv.value; "))
              (s5 (ctx-str ctx s4 some-body))
              (s6 (ctx-str ctx s5 "; }) : ("))
              (s7 (ctx-str ctx s6 typed-none-body))
              (s8 (ctx-str ctx s7 "); })")))
          s8))))

  (fn infer-cond-result-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C result type for cond expression from first clause's body")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Look at first clause (index 1) to determine result type
    (let ((len (list-len items)))
      (if (< len 2)
        "int64_t"
        (match (list-get items 1)
          ((some first-clause)
            (match (deref first-clause)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (if (< clause-len 2)
                    "int64_t"
                    ;; Body is last element in clause
                    (match (list-get clause-items (- clause-len 1))
                      ((some body-expr)
                        (infer-expr-c-type ctx body-expr))
                      ((none) "int64_t")))))
              (else "int64_t")))
          ((none) "int64_t")))))

  (fn infer-match-result-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Infer C result type for match expression from first branch body")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Look at first branch (index 2) to determine result type
    (let ((len (list-len items)))
      (if (< len 3)
        "int64_t"
        (match (list-get items 2)
          ((some first-branch)
            (match (deref first-branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items))
                      (branch-len (list-len branch-items)))
                  (if (< branch-len 2)
                    "int64_t"
                    ;; Body is last element
                    (match (list-get branch-items (- branch-len 1))
                      ((some body-expr)
                        (infer-expr-c-type ctx body-expr))
                      ((none) "int64_t")))))
              (else "int64_t")))
          ((none) "int64_t")))))

  (fn slop-type-to-c-type ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Convert a SLOP type name to its C type equivalent")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; First check if it's a registered type
      (match (ctx-lookup-type ctx slop-type)
        ((some entry) (. entry c-name))
        ((none)
          ;; Check common primitive types
          (cond
            ((string-eq slop-type "String") "slop_string")
            ((string-eq slop-type "Int") "int64_t")
            ((string-eq slop-type "Bool") "uint8_t")
            ((string-eq slop-type "Unit") "void")
            ((string-eq slop-type "Arena") "slop_arena*")
            ;; Pointer types like "(Ptr T)"
            ((starts-with slop-type "(Ptr ")
              (let ((inner (substring arena slop-type 5 (max 0 (- (cast Int (string-len slop-type)) 1)))))
                (ctx-str ctx (slop-type-to-c-type ctx inner) "*")))
            ;; Map/Set types -> slop_map*
            ((or (starts-with slop-type "(Map ") (starts-with slop-type "(Set "))
              "slop_map*")
            ;; List types -> need to generate list type name
            ((starts-with slop-type "(List ")
              (let ((inner (substring arena slop-type 6 (max 0 (- (cast Int (string-len slop-type)) 1)))))
                (ctx-str ctx "slop_list_" (slop-type-to-c-type ctx inner))))
            ;; Option types
            ((starts-with slop-type "(Option ")
              (let ((inner (substring arena slop-type 8 (max 0 (- (cast Int (string-len slop-type)) 1)))))
                (ctx-str ctx "slop_option_" (slop-type-to-c-type ctx inner))))
            ;; Default: use as-is (might be a C type already)
            (else slop-type))))))

  (fn infer-expr-c-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer C type of an expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ;; String literal -> slop_string
      ((str _) "slop_string")
      ;; Number -> int64_t or double
      ((num num)
        (if (. num is-float) "double" "int64_t"))
      ;; Symbol -> look up type, handling "auto" from match bindings
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some entry)
              (let ((c-type (. entry c-type))
                    (slop-type (. entry slop-type)))
                (cond
                  ;; If c-type is "auto" or empty, try to convert slop-type
                  ((or (string-eq c-type "auto") (== (string-len c-type) 0))
                    (if (> (string-len slop-type) 0)
                      (slop-type-to-c-type ctx slop-type)
                      "int64_t"))
                  ;; Otherwise use the stored c-type
                  (else c-type))))
            ((none) "int64_t"))))
      ;; List -> check for known patterns
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "int64_t"
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; First check function registry - this handles prescanned functions
                        ((match (ctx-lookup-func ctx op)
                           ((some func-entry) (. func-entry returns-string))
                           ((none) false))
                          "slop_string")
                        ;; String operations (hardcoded fallback)
                        ((or (string-eq op "ctx-str")
                             (or (string-eq op "ctx-str3")
                                 (or (string-eq op "ctx-str4")
                                     (or (string-eq op "ctx-str5")
                                         (or (string-eq op "string-concat")
                                             (or (string-eq op "substring")
                                                 (or (string-eq op "to-c-name")
                                                     (or (string-eq op "to-c-type")
                                                         (or (string-eq op "to-c-type-prefixed")
                                                             (or (string-eq op "transpile-expr")
                                                                 (or (string-eq op "transpile-literal")
                                                                     (or (string-eq op "ctx-prefix-type")
                                                                         (or (string-eq op "type-to-identifier")
                                                                             (or (string-eq op "fix-ternary-none")
                                                                                (or (string-eq op "transpile-enum-variant")
                                                                                    (string-eq op "extract-module-name"))))))))))))))))
                          "slop_string")
                        ;; Field access - look up field's C type from context
                        ((string-eq op ".")
                          (if (< (list-len items) 3)
                            "/* TRANSPILER ERROR: malformed field access */"
                            (match (list-get items 1)
                              ((some obj-expr)
                                (match (list-get items 2)
                                  ((some field-expr)
                                    (match (deref field-expr)
                                      ((sym field-sym)
                                        (let ((field-name (. field-sym name))
                                              (obj-c-type (infer-expr-c-type ctx obj-expr)))
                                          ;; Look up field's C type
                                          (match (ctx-lookup-field-type ctx obj-c-type field-name)
                                            ((some c-type) c-type)
                                            ((none)
                                              ;; Try with SLOP type instead of C type
                                              (match (ctx-lookup-var ctx (get-var-name-from-expr obj-expr))
                                                ((some var-entry)
                                                  (let ((obj-slop-type (. var-entry slop-type)))
                                                    (match (ctx-lookup-field-type ctx obj-slop-type field-name)
                                                      ((some c-type2) c-type2)
                                                      ((none) "/* TRANSPILER ERROR: unknown field type */"))))
                                                ((none) "/* TRANSPILER ERROR: unknown object type */"))))))
                                      (else "/* TRANSPILER ERROR: field name must be symbol */")))
                                  ((none) "/* TRANSPILER ERROR: missing field expression */")))
                              ((none) "/* TRANSPILER ERROR: missing object expression */"))))
                        ;; Let expression - infer from body (last element after bindings)
                        ((or (string-eq op "let") (string-eq op "let*"))
                          (if (< (list-len items) 3)
                            "int64_t"
                            ;; Body is last element
                            (match (list-get items (- (list-len items) 1))
                              ((some body) (infer-expr-c-type ctx body))
                              ((none) "int64_t"))))
                        ;; do expression - infer from last subexpression
                        ((string-eq op "do")
                          (if (< (list-len items) 2)
                            "void"
                            (match (list-get items (- (list-len items) 1))
                              ((some last-expr) (infer-expr-c-type ctx last-expr))
                              ((none) "void"))))
                        ;; Cond expression - infer from first clause's body
                        ((string-eq op "cond")
                          (infer-cond-result-c-type ctx items))
                        ;; Match expression - infer from first branch's body
                        ((string-eq op "match")
                          (infer-match-result-c-type ctx items))
                        ;; If expression - infer from then branch
                        ((string-eq op "if")
                          (if (< (list-len items) 3)
                            "int64_t"
                            (match (list-get items 2)
                              ((some then-expr) (infer-expr-c-type ctx then-expr))
                              ((none) "int64_t"))))
                        ;; some constructor - infer Option type from value
                        ((string-eq op "some")
                          (if (< (list-len items) 2)
                            "/* TRANSPILER ERROR: some without value */"
                            (match (list-get items 1)
                              ((some val-expr)
                                (let ((val-type (infer-expr-c-type ctx val-expr)))
                                  (cond
                                    ((string-eq val-type "slop_string") "slop_option_string")
                                    ((string-eq val-type "int64_t") "slop_option_int")
                                    ((string-eq val-type "double") "slop_option_double")
                                    ;; Pointer type - generate slop_option_<base>_ptr
                                    ((ends-with val-type "*")
                                      (let ((ctx-arena (. (deref ctx) arena))
                                            (base-type (strip-pointer-suffix ctx-arena val-type)))
                                        (ctx-str3 ctx "slop_option_" base-type "_ptr")))
                                    ;; Other types - generate slop_option_<type>
                                    (else (ctx-str3 ctx "slop_option_" val-type "")))))
                              ((none) "/* TRANSPILER ERROR: some with no value expression */"))))
                        ;; none constructor - use return type context if available
                        ((string-eq op "none")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                ret-type
                                "slop_option_int"))
                            ((none) "slop_option_int")))
                        ;; list-push returns void
                        ((string-eq op "list-push")
                          "void")
                        ;; set! returns void
                        ((string-eq op "set!")
                          "void")
                        ;; cast - return the target type
                        ((string-eq op "cast")
                          (if (< (list-len items) 2)
                            "void*"
                            (match (list-get items 1)
                              ((some type-expr)
                                (to-c-type-prefixed ctx type-expr))
                              ((none) "void*"))))
                        ;; when returns void
                        ((string-eq op "when")
                          "void")
                        ;; Function call or struct constructor - check type registry first
                        (else
                          ;; First check if it's a struct/union constructor
                          (match (ctx-lookup-type ctx op)
                            ((some type-entry)
                              ;; It's a type! Return its C name
                              (. type-entry c-name))
                            ((none)
                              ;; Not a type, check function registry
                              (match (ctx-lookup-func ctx op)
                                ((some func-entry)
                                  (let ((ret-type (. func-entry return-type)))
                                    (cond
                                      ((. func-entry returns-string) "slop_string")
                                      ((string-eq ret-type "void") "void")
                                      ((> (string-len ret-type) 0) ret-type)
                                      ;; Empty return type = incomplete info (e.g., imported but not processed)
                                      (else "__type_error__"))))
                                ;; Function not found in registry - return error marker
                                ((none) "__type_error__"))))))))
                  (else "__type_error__")))
              ((none) "__type_error__")))))
      (else "__type_error__")))

  (fn build-result-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build Result match as GCC statement expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-match-result-c-type ctx items))
          (mut ok-body "0")
          (mut err-body "0")
          (mut ok-binding "")
          (mut err-binding "")
          (mut i 2))
      (do (while (< i len)
            (match (list-get items i)
              ((some branch)
                (match (deref branch)
                  ((lst branch-lst)
                    (let ((branch-items (. branch-lst items)))
                      (when (>= (list-len branch-items) 2)
                        (match (list-get branch-items 0)
                          ((some pattern)
                            (let ((tag (get-expr-pattern-tag pattern)))
                              (cond
                                ((string-eq tag "ok")
                                  (match (get-expr-binding-name pattern)
                                    ((some name)
                                      (set! ok-binding name)
                                      ;; Transpile body with binding in scope
                                      (set! ok-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                    ((none)
                                      ;; No binding - transpile normally
                                      (set! ok-body (get-match-branch-body ctx branch-items)))))
                                ((string-eq tag "error")
                                  (match (get-expr-binding-name pattern)
                                    ((some name)
                                      (set! err-binding name)
                                      ;; Transpile body with binding in scope
                                      (set! err-body (transpile-branch-body-with-binding ctx scrutinee branch-items name)))
                                    ((none)
                                      ;; No binding - transpile normally
                                      (set! err-body (get-match-branch-body ctx branch-items)))))
                                (else (do)))))
                          ((none) (do))))))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          ;; Build GCC statement expression with if/else
      ;; ({ __auto_type _mv = scrutinee; <type> _mr;
      ;;    if (_mv.is_ok) { ok_bind _mr = ok_body; } else { err_bind _mr = err_body; } _mr; })
      (let ((ok-bind (if (string-eq ok-binding "")
                        ""
                        (ctx-str3 ctx "__auto_type " (to-c-name arena ok-binding) " = _mv.data.ok; ")))
            (err-bind (if (string-eq err-binding "")
                         ""
                         (ctx-str3 ctx "__auto_type " (to-c-name arena err-binding) " = _mv.data.err; "))))
        (if (string-eq result-type "void")
          ;; Void match - execute branches for side effects only
          (ctx-str ctx
            (ctx-str ctx "({ __auto_type _mv = " scrutinee-c)
            (ctx-str ctx "; if (_mv.is_ok) { "
              (ctx-str ctx ok-bind
                (ctx-str ctx ok-body
                  (ctx-str ctx "; } else { "
                    (ctx-str ctx err-bind
                      (ctx-str ctx err-body "; } (void)0; })"))))))))
          ;; Normal match with result variable using inferred type
          (ctx-str ctx
            (ctx-str ctx "({ __auto_type _mv = " scrutinee-c)
            (ctx-str ctx (ctx-str3 ctx "; " result-type " _mr; if (_mv.is_ok) { ")
              (ctx-str ctx ok-bind
                (ctx-str ctx "_mr = "
                  (ctx-str ctx ok-body
                    (ctx-str ctx "; } else { "
                      (ctx-str ctx err-bind
                        (ctx-str ctx "_mr = "
                          (ctx-str ctx err-body "; } _mr; })")))))))))))))

  (fn build-union-match-expr ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build union (tagged union) match as GCC statement expression with switch")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Generate: ({ __auto_type _mv = scrutinee; <type> _mr = {0};
    ;;              switch (_mv.tag) { case T_v: { __auto_type b = _mv.data.v; _mr = body; break; } ... } _mr; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (result-type (infer-match-result-c-type ctx items))
          (mut cases "")
          (mut i 2))
      ;; Build switch cases
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (set! cases (build-union-case-expr ctx arena cases scrutinee pattern branch-items result-type)))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Build the full expression with inferred result type
      (if (string-eq result-type "void")
        ;; Void match - no result variable, execute for side effects only
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 "; switch (_mv.tag) { "))
              (s3 (ctx-str ctx s2 cases))
              (s4 (ctx-str ctx s3 " } (void)0; })")))
          s4)
        ;; Non-void match with result variable
        (let ((s1 (ctx-str ctx "({ __auto_type _mv = " scrutinee-c))
              (s2 (ctx-str ctx s1 (ctx-str ctx "; " (ctx-str ctx result-type " _mr = {0}; switch (_mv.tag) { "))))
              (s3 (ctx-str ctx s2 cases))
              (s4 (ctx-str ctx s3 " } _mr; })")))
          s4))))

  (fn typed-none ((ctx (Ptr TranspileContext)) (result-type String) (body String))
    (@intent "Convert 'none' to typed none if result type is an Option type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    (if (and (string-eq body "none")
             (starts-with result-type "slop_option_"))
      (ctx-str3 ctx "(" result-type "){.has_value = false}")
      body))

  (fn typed-none-arg ((ctx (Ptr TranspileContext)) (expected-type String) (arg-c String))
    (@intent "Convert 'none' to typed Option compound literal if expected type is Option")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; If arg is "none" and expected type starts with "slop_option_",
    ;; generate: ((slop_option_T){.has_value = false})
    (if (and (string-eq arg-c "none")
             (starts-with expected-type "slop_option_"))
      (ctx-str3 ctx "((" expected-type "){.has_value = false})")
      arg-c))

  (fn build-union-case-expr ((ctx (Ptr TranspileContext)) (arena Arena) (cases String)
                             (scrutinee (Ptr SExpr)) (pattern (Ptr SExpr)) (branch-items (List (Ptr SExpr))) (result-type String))
    (@intent "Build a single union case for expression-level match")
    (@spec (((Ptr TranspileContext) Arena String (Ptr SExpr) (Ptr SExpr) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (let ((tag (get-expr-pattern-tag pattern))
          (is-void (string-eq result-type "void")))
      (cond
        ((or (string-eq tag "else") (string-eq tag "_"))
          ;; Default case
          (let ((body (typed-none ctx result-type (get-match-branch-body ctx branch-items))))
            (if is-void
              (ctx-str ctx cases (ctx-str3 ctx "default: { " body "; break; } "))
              (ctx-str ctx cases (ctx-str3 ctx "default: { _mr = " body "; break; } ")))))
        (else
          ;; Regular variant case
          (match (ctx-lookup-enum-variant ctx tag)
            ((some type-name)
              (let ((case-label (ctx-str4 ctx type-name "_" tag ""))
                    (binding-opt (get-expr-binding-name pattern)))
                (match binding-opt
                  ((some binding-name)
                    ;; Has binding - need to bind variable and transpile body with scope
                    (let ((c-binding (to-c-name arena binding-name))
                          (body (typed-none ctx result-type (transpile-branch-body-with-binding ctx scrutinee branch-items binding-name)))
                          (s1 (ctx-str ctx cases "case "))
                          (s2 (ctx-str ctx s1 case-label))
                          (s3 (ctx-str ctx s2 ": { __auto_type "))
                          (s4 (ctx-str ctx s3 c-binding))
                          (s5 (ctx-str ctx s4 " = _mv.data."))
                          (s6 (ctx-str ctx s5 tag))
                          (s7 (if is-void
                                (ctx-str ctx s6 "; ")
                                (ctx-str ctx s6 "; _mr = ")))
                          (s8 (ctx-str ctx s7 body))
                          (s9 (ctx-str ctx s8 "; break; } ")))
                      s9))
                  ((none)
                    ;; No binding
                    (let ((body (typed-none ctx result-type (get-match-branch-body ctx branch-items)))
                          (s1 (ctx-str ctx cases "case "))
                          (s2 (ctx-str ctx s1 case-label))
                          (s3 (if is-void
                                (ctx-str ctx s2 ": { ")
                                (ctx-str ctx s2 ": { _mr = ")))
                          (s4 (ctx-str ctx s3 body))
                          (s5 (ctx-str ctx s4 "; break; } ")))
                      s5)))))
            ((none) cases))))))

  (fn build-ternary-match-expr ((ctx (Ptr TranspileContext)) (scrutinee-c String) (items (List (Ptr SExpr))))
    (@intent "Build match as ternary chain for literals/enums")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; For exhaustive matches (no else), use last branch as default to avoid type mismatch
    ;; Build chain in reverse: last branch becomes innermost fallback
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result "")
          (mut has-else false)
          (mut first-branch true)
          (mut i (- len 1)))
      (while (>= i 2)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((lst branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-expr-pattern-tag pattern))
                              (body (get-match-branch-body ctx branch-items)))
                          (cond
                            ;; else/_ clause - use as default
                            ((or (string-eq tag "else") (string-eq tag "_"))
                              (set! result body)
                              (set! has-else true)
                              (set! first-branch false))
                            ;; First non-else branch in reverse order - use as default for exhaustive matches
                            (first-branch
                              (set! result body)
                              (set! first-branch false))
                            ;; Subsequent branches - wrap in ternary
                            (else
                              (let ((pattern-c (transpile-expr ctx pattern)))
                                ;; Build: ((scrutinee == pattern) ? body : result)
                                (set! result (ctx-str ctx
                                  (ctx-str ctx "((" scrutinee-c)
                                  (ctx-str ctx " == "
                                    (ctx-str ctx pattern-c
                                      (ctx-str ctx ") ? "
                                        (ctx-str ctx body
                                          (ctx-str ctx " : " (ctx-str ctx result ")")))))))))))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (- i 1)))
      ;; If no branches at all, return 0
      (if (string-eq result "")
        "0"
        result)))

  ;; ============================================================
  ;; Expression-position statement forms (GCC statement expressions)
  ;; ============================================================

  (fn transpile-let-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile let as expression using GCC statement expression")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (let ((bindings...)) body...) -> ({ binding1; binding2; ...; result; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some bindings-expr)
            (match (deref bindings-expr)
              ((lst bindings-lst)
                (let ((mut result "({ ")
                      (bindings-items (. bindings-lst items))
                      (bindings-len (list-len bindings-items))
                      (mut bi 0))
                  ;; Emit bindings
                  (while (< bi bindings-len)
                    (match (list-get bindings-items bi)
                      ((some binding)
                        (let ((binding-c (transpile-binding-expr ctx binding)))
                          (set! result (ctx-str3 ctx result binding-c " "))))
                      ((none) (do)))
                    (set! bi (+ bi 1)))
                  ;; Emit body expressions (all but last as statements)
                  (let ((mut i 2))
                    (while (< i (- len 1))
                      (match (list-get items i)
                        ((some body-expr)
                          (let ((body-c (transpile-expr ctx body-expr)))
                            (set! result (ctx-str3 ctx result body-c "; "))))
                        ((none) (do)))
                      (set! i (+ i 1)))
                    ;; Last body expression is the result
                    (match (list-get items (- len 1))
                      ((some last-expr)
                        (let ((last-c (transpile-expr ctx last-expr)))
                          (ctx-str3 ctx result last-c "; })")))
                      ((none) (ctx-str ctx result "0; })"))))))
              (else "({ (void)0; })")))
          ((none) "({ (void)0; })")))))

  (fn transpile-binding-expr ((ctx (Ptr TranspileContext)) (binding (Ptr SExpr)))
    (@intent "Transpile a single let binding for expression context")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {binding != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref binding)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              ""
              ;; Check for mut: (mut name init) or (mut name Type init)
              (let ((has-mut (binding-has-mut items))
                    (name-idx (if has-mut 1 0)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((sym name-sym)
                        (let ((var-name (to-c-name arena (. name-sym name)))
                              ;; Determine init index: (name init) or (name Type init) or (mut name init) or (mut name Type init)
                              (has-type (if has-mut (>= len 4) (>= len 3)))
                              (type-idx (+ name-idx 1))
                              (init-idx (if has-mut (if has-type 3 2) (if has-type 2 1))))
                          ;; Use explicit type if provided, otherwise __auto_type
                          (if has-type
                            (match (list-get items type-idx)
                              ((some type-expr)
                                (let ((c-type (to-c-type-prefixed ctx type-expr)))
                                  (match (list-get items init-idx)
                                    ((some init-expr)
                                      ;; Check if init is (some ...) and use annotated type
                                      (let ((init-c (transpile-typed-init ctx init-expr c-type)))
                                        (ctx-str5 ctx c-type " " (ctx-str3 ctx var-name " = " init-c) ";" "")))
                                    ((none) (ctx-str5 ctx c-type " " var-name " = {0};" "")))))
                              ((none)
                                (match (list-get items init-idx)
                                  ((some init-expr)
                                    (let ((init-c (transpile-expr ctx init-expr)))
                                      (ctx-str5 ctx "__auto_type " var-name " = " init-c ";")))
                                  ((none) (ctx-str3 ctx "__auto_type " var-name " = 0;")))))
                            ;; No explicit type - use __auto_type
                            (match (list-get items init-idx)
                              ((some init-expr)
                                (let ((init-c (transpile-expr ctx init-expr)))
                                  (ctx-str5 ctx "__auto_type " var-name " = " init-c ";")))
                              ((none) (ctx-str3 ctx "__auto_type " var-name " = 0;"))))))
                      (else "")))
                  ((none) ""))))))
        (else ""))))

  (fn binding-has-mut ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with mut keyword")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym) (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn transpile-typed-init ((ctx (Ptr TranspileContext)) (init-expr (Ptr SExpr)) (target-type String))
    (@intent "Transpile init expression with known target type (handles some/none)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (@pre {init-expr != nil})
    ;; Check if init is (some ...) or (none) and target is an Option type
    (match (deref init-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            (transpile-expr ctx init-expr)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; (some value) with known Option type
                        ((string-eq op "some")
                          (if (< (list-len items) 2)
                            (transpile-expr ctx init-expr)
                            (match (list-get items 1)
                              ((some val-expr)
                                (let ((val-c (transpile-expr ctx val-expr)))
                                  ;; Use target type for Option construction
                                  (ctx-str5 ctx "(" target-type "){.has_value = 1, .value = " val-c "}")))
                              ((none) (transpile-expr ctx init-expr)))))
                        ;; (none) with known Option type
                        ((string-eq op "none")
                          (ctx-str3 ctx "(" target-type "){.has_value = false}"))
                        ;; Other expressions - default transpilation
                        (else (transpile-expr ctx init-expr)))))
                  (else (transpile-expr ctx init-expr))))
              ((none) (transpile-expr ctx init-expr))))))
      (else (transpile-expr ctx init-expr))))

  (fn transpile-while-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile while as expression (side effect only, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (while cond body) -> ({ while (cond) { body; } 0; })
    (let ((len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some cond-expr)
            (let ((cond-c (transpile-expr ctx cond-expr))
                  (mut body-str ""))
              ;; Emit body statements
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some body-expr)
                      (let ((body-c (transpile-expr ctx body-expr)))
                        (set! body-str (ctx-str3 ctx body-str body-c "; "))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              ;; Build result string
              (let ((part1 (ctx-str3 ctx "({ while (" cond-c ") { "))
                    (part2 (ctx-str ctx body-str "} 0; })")))
                (ctx-str ctx part1 part2))))
          ((none) "({ (void)0; })")))))

  (fn transpile-do-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile do as expression (sequence, returns last value)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (do e1 e2 ... en) -> ({ e1; e2; ...; en; })
    (let ((len (list-len items)))
      (if (<= len 1)
        "({ (void)0; })"
        (let ((mut result "({ ")
              (mut i 1))
          (while (< i len)
            (match (list-get items i)
              ((some expr)
                (let ((expr-c (transpile-expr ctx expr))
                      (is-last (== i (- len 1))))
                  (set! result (ctx-str3 ctx result expr-c "; "))))
              ((none) (do)))
            (set! i (+ i 1)))
          (ctx-str ctx result "})")))))

  (fn transpile-when-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile when as expression (side effect, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (when cond body...) -> ((cond) ? ({ body...; (void)0; }) : ({ (void)0; }))
    (let ((len (list-len items)))
      (if (< len 2)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some cond-expr)
            (let ((cond-c (transpile-expr ctx cond-expr))
                  (mut body-c "({ "))
              ;; Transpile body expressions (items 2..n)
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some body-expr)
                      (set! body-c (ctx-str3 ctx body-c (transpile-expr ctx body-expr) "; ")))
                    ((none) (do)))
                  (set! i (+ i 1))))
              (set! body-c (ctx-str ctx body-c "0; })"))
              (ctx-str5 ctx "((" cond-c ") ? " body-c " : ({ (void)0; }))")))
          ((none) "({ (void)0; })")))))

  (fn transpile-set-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set! as expression (side effect, returns 0)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (set! target value) -> ({ target = value; (void)0; })
    ;; or (set! (@ arr idx) value) -> ({ arr[idx] = value; (void)0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        "({ (void)0; })"
        (match (list-get items 1)
          ((some target-expr)
            (match (list-get items 2)
              ((some val-expr)
                (let ((val-c (transpile-expr ctx val-expr)))
                  ;; Check if target is array indexing (@ arr idx)
                  (match (deref target-expr)
                    ((lst target-lst)
                      (let ((target-items (. target-lst items)))
                        (if (< (list-len target-items) 1)
                          (ctx-str5 ctx "({ " (transpile-expr ctx target-expr) " = " val-c "; (void)0; })")
                          (match (list-get target-items 0)
                            ((some head)
                              (match (deref head)
                                ((sym sym)
                                  (let ((op (. sym name)))
                                    (cond
                                      ;; Array indexing: (@ arr idx) = value
                                      ((string-eq op "@")
                                        (if (< (list-len target-items) 3)
                                          "({ (void)0; })"
                                          (match (list-get target-items 1)
                                            ((some arr-expr)
                                              (match (list-get target-items 2)
                                                ((some idx-expr)
                                                  (let ((arr-c (transpile-expr ctx arr-expr))
                                                        (idx-c (transpile-expr ctx idx-expr)))
                                                    (ctx-str ctx "({ " (ctx-str ctx arr-c (ctx-str ctx "[" (ctx-str ctx idx-c (ctx-str ctx "] = " (ctx-str ctx val-c "; (void)0; })"))))))))
                                                ((none) "({ (void)0; })")))
                                            ((none) "({ (void)0; })"))))
                                      ;; Field assignment: (. obj field) = value
                                      ((string-eq op ".")
                                        (let ((target-c (transpile-expr ctx target-expr)))
                                          (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))
                                      (else
                                        (let ((target-c (transpile-expr ctx target-expr)))
                                          (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })"))))))
                                (_ (let ((target-c (transpile-expr ctx target-expr)))
                                     (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))))
                            ((none) "({ (void)0; })")))))
                    ;; Simple variable assignment
                    ((sym sym)
                      (let ((target-c (to-c-name arena (. sym name))))
                        (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })")))
                    (else
                      (let ((target-c (transpile-expr ctx target-expr)))
                        (ctx-str5 ctx "({ " target-c " = " val-c "; (void)0; })"))))))
              ((none) "({ (void)0; })")))
          ((none) "({ (void)0; })")))))

  ;; ============================================================
  ;; Arena Detection for list-push
  ;; ============================================================

  (fn get-arena-for-list-push-expr ((ctx (Ptr TranspileContext)) (list-expr (Ptr SExpr)) (list-c String))
    (@intent "Get arena source for list-push by analyzing list expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (@pre {list-expr != nil})
    ;; First priority: check if "arena" variable is in scope (most functions have arena param)
    (match (ctx-lookup-var ctx "arena")
      ((some arena-var)
        ;; arena is in scope - use it directly
        (. arena-var c-name))
      ((none)
        ;; Second priority: check for "ctx" variable which has arena field
        (match (ctx-lookup-var ctx "ctx")
          ((some ctx-var)
            ;; ctx is in scope - use ctx->arena
            (ctx-str ctx (. ctx-var c-name) "->arena"))
          ((none)
            ;; Third priority: check if list-expr is a field access pattern (. BASE FIELD)
            ;; Extract arena from BASE (e.g., (. (deref env) types) -> env->arena)
            (let ((arena-from-field (get-arena-from-field-access ctx list-expr)))
              (if (> (string-len arena-from-field) 0)
                arena-from-field
                ;; Fallback to "arena" - will error if not available
                "arena")))))))

  (fn get-arena-from-field-access ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract arena from base struct if expr is field access (. BASE FIELD)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Match pattern: (. BASE FIELD) where BASE might be (deref VAR) or VAR
    ;; Returns arena from BASE, or empty string if not a field access
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 3)
            "" ;; Not enough elements for field access
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (if (string-eq (. sym name) ".")
                      ;; This is a field access: (. BASE FIELD)
                      (match (list-get items 1)
                        ((some base-expr)
                          ;; Get arena from the base expression
                          (get-arena-from-base ctx base-expr))
                        ((none) ""))
                      "")) ;; Not a field access
                  (else ""))) ;; Head is not a symbol
              ((none) ""))))) ;; Missing head
      (else ""))) ;; Not a list

  (fn get-arena-from-base ((ctx (Ptr TranspileContext)) (base-expr (Ptr SExpr)))
    (@intent "Extract arena from a base expression - return base->arena or base.arena")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {base-expr != nil})
    (match (deref base-expr)
      ;; Simple symbol - check if it's a pointer variable
      ((sym sym)
        (let ((var-name (. sym name)))
          (match (ctx-lookup-var ctx var-name)
            ((some entry)
              ;; Check if it's a pointer variable
              (if (. entry is-pointer)
                (ctx-str ctx (. entry c-name) "->arena")
                (ctx-str ctx (. entry c-name) ".arena")))
            ((none)
              ;; Unknown variable - assume pointer access
              (let ((arena (. (deref ctx) arena))
                    (c-name (to-c-name arena var-name)))
                (ctx-str ctx c-name "->arena"))))))
      ;; Deref expression: (deref ptr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            "arena"
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (if (string-eq (. sym name) "deref")
                      ;; (deref ptr) -> ptr->arena
                      (match (list-get items 1)
                        ((some ptr-expr)
                          (let ((ptr-c (transpile-expr ctx ptr-expr)))
                            (ctx-str ctx ptr-c "->arena")))
                        ((none) "arena"))
                      ;; Not a deref
                      "arena"))
                  (else "arena")))
              ((none) "arena")))))
      (else "arena")))

  ;; Keep old function for compatibility
  (fn get-arena-for-list-push ((ctx (Ptr TranspileContext)) (list-c String))
    (@intent "Get arena source for list-push - use arena from scope")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Fallback - use arena from scope
    "arena")

  ;; ============================================================
  ;; Map Type Helpers
  ;; ============================================================

  (fn is-ptr-to-ptr-map ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression is a pointer-to-pointer map (Ptr (Map ...)) -> slop_map**")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Check if expr is a symbol with type ending in **
    (match (deref expr)
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some entry)
              (let ((c-type (. entry c-type)))
                (ends-with c-type "**")))
            ((none) false))))
      (else false)))

  ;; ============================================================
  ;; Record-new, List Literal, and Map Operations
  ;; ============================================================

  (fn transpile-record-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile record-new expression to C compound literal")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "record-new: missing type" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some type-expr)
            (match (deref type-expr)
              ;; Named type: (record-new TypeName (field1 val1) ...)
              ((sym type-sym)
                (let ((raw-type-name (. type-sym name))
                      (type-name (match (ctx-lookup-type ctx raw-type-name)
                                   ((some entry) (. entry c-name))
                                   ((none) (ctx-prefix-type ctx (to-c-name arena raw-type-name))))))
                  (transpile-record-fields ctx type-name items 2)))
              ;; Inline record type: (record-new (record (f1 T1) (f2 T2)) (f1 v1) (f2 v2))
              ((lst type-lst)
                (let ((type-items (. type-lst items)))
                  (if (< (list-len type-items) 1)
                    (do
                      (ctx-add-error-at ctx "record-new: invalid inline type" (list-first-line items) (list-first-col items))
                      "0")
                    (match (list-get type-items 0)
                      ((some head)
                        (match (deref head)
                          ((sym head-sym)
                            (if (string-eq (. head-sym name) "record")
                              ;; Use to-c-type-prefixed to get the registered typedef name
                              (let ((type-name (to-c-type-prefixed ctx type-expr)))
                                (transpile-record-fields ctx type-name items 2))
                              (do
                                (ctx-add-error-at ctx "record-new: expected record keyword" (list-first-line items) (list-first-col items))
                                "0")))
                          (else
                            (do
                              (ctx-add-error-at ctx "record-new: invalid type head" (list-first-line items) (list-first-col items))
                              "0"))))
                      ((none)
                        (do
                          (ctx-add-error-at ctx "record-new: empty type" (list-first-line items) (list-first-col items))
                          "0"))))))
              (else
                (do
                  (ctx-add-error-at ctx "record-new: invalid type" (list-first-line items) (list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "record-new: missing type" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn transpile-record-fields ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Build field assignments for record compound literal")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (ctx-str ctx "((" (ctx-str ctx type-name "){")))
          (mut i start-idx)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some val-expr)
                                (let ((raw-field-name (. name-sym name))
                                      (field-name (to-c-name arena raw-field-name))
                                      (field-type-opt (ctx-lookup-field-type ctx type-name raw-field-name))
                                      (field-val (match field-type-opt
                                                   ((some field-type) (transpile-typed-init ctx val-expr field-type))
                                                   ((none) (transpile-expr ctx val-expr)))))
                                  (if first
                                    (set! result (ctx-str ctx result (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " field-val)))))
                                    (set! result (ctx-str ctx result (ctx-str ctx ", ." (ctx-str ctx field-name (ctx-str ctx " = " field-val))))))
                                  (set! first false)))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "})")))

  (fn build-inline-struct-type ((ctx (Ptr TranspileContext)) (type-items (List (Ptr SExpr))))
    (@intent "Build anonymous struct type definition from inline record")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len type-items))
          (mut result "struct { ")
          (mut i 1))  ;; Skip 'record' keyword
      (while (< i len)
        (match (list-get type-items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some type-expr)
                                (let ((field-name (to-c-name arena (. name-sym name)))
                                      (field-type (to-c-type-prefixed ctx type-expr)))
                                  (set! result (ctx-str ctx result (ctx-str ctx field-type (ctx-str ctx " " (ctx-str ctx field-name "; ")))))))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "}")))

  (fn transpile-inline-record-fields ((ctx (Ptr TranspileContext)) (struct-def String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Build field assignments for inline record compound literal")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (ctx-str ctx "((" (ctx-str ctx struct-def "){")))
          (mut i start-idx)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get field-items 1)
                              ((some val-expr)
                                (let ((field-name (to-c-name arena (. name-sym name)))
                                      (field-val (transpile-expr ctx val-expr)))
                                  (if first
                                    (set! result (ctx-str ctx result (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " field-val)))))
                                    (set! result (ctx-str ctx result (ctx-str ctx ", ." (ctx-str ctx field-name (ctx-str ctx " = " field-val))))))
                                  (set! first false)))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result "})")))

  (fn transpile-list-literal ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile list literal to inline array")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "list: missing type" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some type-expr)
            (let ((elem-type (to-c-type-prefixed ctx type-expr))
                  (elem-count (- len 2)))
              ;; Generate: (slop_list_TYPE){.len = N, .cap = N, .data = (TYPE[]){e1, e2, ...}}
              (let ((type-id (type-to-identifier arena elem-type))
                    (count-str (int-to-string arena elem-count))
                    (mut result (ctx-str ctx "((slop_list_" (ctx-str ctx type-id "){")))
                    (mut data-part (ctx-str ctx ".len = " (ctx-str ctx count-str (ctx-str ctx ", .cap = " (ctx-str ctx count-str (ctx-str ctx ", .data = (" (ctx-str ctx elem-type "[]){")))))))
                    (mut i 2)
                    (mut first true))
                (while (< i len)
                  (match (list-get items i)
                    ((some elem-expr)
                      (let ((elem-c (transpile-expr ctx elem-expr)))
                        (if first
                          (set! data-part (ctx-str ctx data-part elem-c))
                          (set! data-part (ctx-str ctx data-part (ctx-str ctx ", " elem-c))))
                        (set! first false)))
                    ((none) (do)))
                  (set! i (+ i 1)))
                (ctx-str ctx result (ctx-str ctx data-part "}})")))))
          ((none)
            (do
              (ctx-add-error-at ctx "list: missing type" (list-first-line items) (list-first-col items))
              "0"))))))

  ;; ============================================================
  ;; Map Key Type Info
  ;;
  ;; Returns C code suffix with sizeof, hash function, and eq function
  ;; for the given key type expression: "sizeof(...), hash_fn, eq_fn"
  ;; ============================================================

  (fn build-struct-key-info ((ctx (Ptr TranspileContext)) (c-name String))
    (@intent "Build sizeof/hash/eq info string for a struct key type")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Generate: sizeof(TypeName), slop_hash_TypeName, slop_eq_TypeName
    (ctx-str ctx "sizeof("
      (ctx-str ctx c-name
        (ctx-str ctx "), slop_hash_"
          (ctx-str ctx c-name
            (ctx-str ctx ", slop_eq_" c-name))))))

  (fn get-map-key-c-info ((ctx (Ptr TranspileContext)) (key-type-expr (Ptr SExpr)))
    (@intent "Get sizeof, hash fn, eq fn suffix for map key type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {key-type-expr != nil})
    (match (deref key-type-expr)
      ;; Symbol: check for builtin types
      ((sym sym)
        (let ((name (. sym name)))
          (cond
            ;; String -> slop_string
            ((string-eq name "String")
              "sizeof(slop_string), slop_hash_string, slop_eq_string")
            ;; Int, I64 -> int64_t
            ((or (string-eq name "Int") (string-eq name "I64"))
              "sizeof(int64_t), slop_hash_int, slop_eq_int")
            ;; I32 -> int32_t (use int hash)
            ((string-eq name "I32")
              "sizeof(int32_t), slop_hash_int, slop_eq_int")
            ;; Uint, U64 -> uint64_t
            ((or (string-eq name "Uint") (string-eq name "U64"))
              "sizeof(uint64_t), slop_hash_uint, slop_eq_uint")
            ;; U32 -> uint32_t (use uint hash)
            ((string-eq name "U32")
              "sizeof(uint32_t), slop_hash_uint, slop_eq_uint")
            ;; Symbol -> int64_t (symbols are interned as integers)
            ((string-eq name "Symbol")
              "sizeof(int64_t), slop_hash_symbol, slop_eq_symbol")
            ;; User-defined type: look up and generate struct hash/eq
            (else
              (let ((arena (. (deref ctx) arena))
                    (result (get-struct-key-info-by-name ctx name)))
                (if (> (string-len result) 0)
                  result
                  ;; Fall back to direct name conversion
                  (let ((c-name (to-c-name arena name)))
                    (ctx-register-struct-key-type ctx c-name)
                    (build-struct-key-info ctx c-name))))))))
      ;; List: check for (Ptr T)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "sizeof(void*), slop_hash_ptr, slop_eq_ptr"
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((head-name (. sym name)))
                      (if (string-eq head-name "Ptr")
                        "sizeof(void*), slop_hash_ptr, slop_eq_ptr"
                        ;; Default to string for unknown compound types
                        "sizeof(slop_string), slop_hash_string, slop_eq_string")))
                  (_ "sizeof(slop_string), slop_hash_string, slop_eq_string")))
              ((none) "sizeof(void*), slop_hash_ptr, slop_eq_ptr")))))
      ;; Default fallback
      (_ "sizeof(slop_string), slop_hash_string, slop_eq_string")))

  (fn get-struct-key-info-by-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Look up a type by name and return struct key info if found")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    ;; Try direct lookup first
    (match (ctx-lookup-type ctx name)
      ((some type-entry)
        (let ((c-name (. type-entry c-name)))
          (ctx-register-struct-key-type ctx c-name)
          (build-struct-key-info ctx c-name)))
      ((none)
        ;; Try with module prefix
        (match (ctx-get-module ctx)
          ((some mod)
            (let ((prefixed (ctx-str3 ctx mod "_" name)))
              (match (ctx-lookup-type ctx prefixed)
                ((some type-entry)
                  (let ((c-name (. type-entry c-name)))
                    (ctx-register-struct-key-type ctx c-name)
                    (build-struct-key-info ctx c-name)))
                ((none) ""))))
          ((none) "")))))

  (fn transpile-map-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-new to slop_map_new_ptr with key type info")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        ;; Backward compat: if only arena, default to string keys
        (if (< len 2)
          (do
            (ctx-add-error-at ctx "map-new: missing arena" (list-first-line items) (list-first-col items))
            "NULL")
          (match (list-get items 1)
            ((some arena-expr)
              (let ((arena-c (transpile-expr ctx arena-expr)))
                ;; Default to string keys for backward compatibility
                (ctx-str ctx "slop_map_new_ptr(" (ctx-str ctx arena-c ", 16, sizeof(slop_string), slop_hash_string, slop_eq_string)"))))
            ((none)
              (do
                (ctx-add-error-at ctx "map-new: missing arena" (list-first-line items) (list-first-col items))
                "NULL"))))
        ;; Full form: (map-new arena KeyType ValueType)
        (match (list-get items 1)
          ((some arena-expr)
            (match (list-get items 2)
              ((some key-type-expr)
                (let ((arena-c (transpile-expr ctx arena-expr))
                      (key-info (get-map-key-c-info ctx key-type-expr)))
                  ;; Generate: slop_map_new_ptr(arena, 16, sizeof_expr, hash_fn, eq_fn)
                  ;; key-info is already the formatted string "sizeof(...), hash_fn, eq_fn"
                  (ctx-str ctx "slop_map_new_ptr("
                    (ctx-str ctx arena-c
                      (ctx-str ctx ", 16, "
                        (ctx-str ctx key-info ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-new: missing KeyType" (list-first-line items) (list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-new: missing arena" (list-first-line items) (list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; Map Key Wrapping
  ;;
  ;; The generic map API expects keys as const void*.
  ;; For structs (slop_string), pass &key.
  ;; For primitives, use compound literal: &(type){key}
  ;; ============================================================

  (fn is-c-primitive-type ((t String))
    (@intent "Check if type is a C primitive that works with compound literals")
    (@spec ((String) -> Bool))
    (cond
      ((string-eq t "int64_t") true)
      ((string-eq t "int32_t") true)
      ((string-eq t "int16_t") true)
      ((string-eq t "int8_t") true)
      ((string-eq t "uint64_t") true)
      ((string-eq t "uint32_t") true)
      ((string-eq t "uint16_t") true)
      ((string-eq t "uint8_t") true)
      ((string-eq t "double") true)
      ((string-eq t "float") true)
      ((string-eq t "bool") true)
      (else false)))

  (fn wrap-map-key-as-ptr ((ctx (Ptr TranspileContext)) (key-c String) (key-expr (Ptr SExpr)) (container-expr (Ptr SExpr)))
    (@intent "Wrap transpiled key expression as pointer for map/set operations")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {key-expr != nil})
    ;; container-expr may be nil (e.g., for set literals where type is explicit)
    (let ((container-key-type
            (if (!= container-expr nil)
              ;; Try map key type first, then set element type
              (let ((map-type (infer-map-key-c-type ctx container-expr)))
                (if (> (string-len map-type) 0)
                  map-type
                  (infer-set-elem-c-type ctx container-expr)))
              ""))
          (key-type (if (> (string-len container-key-type) 0)
                      container-key-type
                      (infer-expr-c-type ctx key-expr))))
      (cond
        ;; slop_string is a struct, just take address
        ((string-eq key-type "slop_string")
          (ctx-str ctx "&(" (ctx-str ctx key-c ")")))
        ;; Pointer types - cast and take address
        ((ends-with key-type "*")
          (ctx-str ctx "&(void*){" (ctx-str ctx key-c "}")))
        ;; Primitives - use compound literal (works for scalars)
        ((is-c-primitive-type key-type)
          (ctx-str ctx "&(" (ctx-str ctx key-type (ctx-str ctx "){" (ctx-str ctx key-c "}")))))
        ;; Struct/union types - just take address (compound literal doesn't work)
        (else
          (ctx-str ctx "&(" (ctx-str ctx key-c ")"))))))

  (fn transpile-map-put ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-put to slop_map_put with proper key pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 4)
        (do
          (ctx-add-error-at ctx "map-put: needs map, key, val" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (match (list-get items 3)
                  ((some val-expr)
                    (let ((map-c (transpile-expr ctx map-expr))
                          (key-c (transpile-expr ctx key-expr))
                          (val-c (transpile-expr ctx val-expr))
                          ;; Wrap key as pointer for generic map API
                          (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr))
                          ;; Check if map is a pointer-to-pointer (Ptr Map -> slop_map**)
                          (needs-deref (is-ptr-to-ptr-map ctx map-expr)))
                      ;; slop_map_put expects arena, slop_map* and key as const void*
                      ;; Arena is assumed to be in scope from with-arena
                      ;; Allocate value on arena so it persists beyond the statement
                      ;; If we have slop_map**, dereference once
                      (if needs-deref
                        (let ((s1 (ctx-str ctx "({ __auto_type _val = " val-c))
                              (s2 (ctx-str ctx s1 "; void* _vptr = slop_arena_alloc(arena, sizeof(_val)); memcpy(_vptr, &_val, sizeof(_val)); slop_map_put(arena, (*"))
                              (s3 (ctx-str ctx s2 map-c))
                              (s4 (ctx-str ctx s3 "), "))
                              (s5 (ctx-str ctx s4 key-ptr))
                              (s6 (ctx-str ctx s5 ", _vptr); })")))
                          s6)
                        (let ((s1 (ctx-str ctx "({ __auto_type _val = " val-c))
                              (s2 (ctx-str ctx s1 "; void* _vptr = slop_arena_alloc(arena, sizeof(_val)); memcpy(_vptr, &_val, sizeof(_val)); slop_map_put(arena, "))
                              (s3 (ctx-str ctx s2 map-c))
                              (s4 (ctx-str ctx s3 ", "))
                              (s5 (ctx-str ctx s4 key-ptr))
                              (s6 (ctx-str ctx s5 ", _vptr); })")))
                          s6))))
                  ((none)
                    (do
                      (ctx-add-error-at ctx "map-put: missing val" (list-first-line items) (list-first-col items))
                      "0"))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-put: missing key" (list-first-line items) (list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-put: missing map" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn transpile-map-get ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-get to slop_map_get with proper key pointer wrapping and inferred value type")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "map-get: needs map, key" (list-first-line items) (list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (let ((map-c (transpile-expr ctx map-expr))
                      (key-c (transpile-expr ctx key-expr))
                      ;; Wrap key as pointer for generic map API
                      (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr))
                      ;; Infer option type from map's value type
                      (option-type (infer-map-value-option-type ctx map-expr)))
                  ;; If we have a named option type, use it; otherwise use anonymous struct
                  (if (> (string-len option-type) 0)
                    ;; Named option type available - register it and generate proper code
                    (let ((inner-type-name (substring-after-prefix arena option-type "slop_option_"))
                          (value-c-type (option-type-to-value-c-type arena option-type)))
                      ;; Register the option type using inner-type-name so set_* types are properly detected
                      (ctx-register-option-type ctx inner-type-name option-type)
                      (ctx-str ctx "({ void* _ptr = slop_map_get("
                        (ctx-str ctx map-c
                          (ctx-str ctx ", "
                            (ctx-str ctx key-ptr
                              (ctx-str ctx "); _ptr ? ("
                                (ctx-str ctx option-type
                                  (ctx-str ctx "){ .has_value = true, .value = *("
                                    (ctx-str ctx value-c-type
                                      (ctx-str ctx "*)_ptr } : ("
                                        (ctx-str ctx option-type
                                          "){ .has_value = false }; })")))))))))))
                    ;; Fallback to anonymous struct
                    (ctx-str ctx "({ void* _ptr = slop_map_get("
                      (ctx-str ctx map-c
                        (ctx-str ctx ", "
                          (ctx-str ctx key-ptr
                            "); struct { bool has_value; void* value; } _r; if (_ptr) { _r.has_value = true; _r.value = _ptr; } else { _r.has_value = false; } _r; })")))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-get: missing key" (list-first-line items) (list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-get: missing map" (list-first-line items) (list-first-col items))
              "NULL"))))))

  (fn transpile-map-has ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-has to check for non-NULL with proper key pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "map-has: needs map, key" (list-first-line items) (list-first-col items))
          "false")
        (match (list-get items 1)
          ((some map-expr)
            (match (list-get items 2)
              ((some key-expr)
                (let ((map-c (transpile-expr ctx map-expr))
                      (key-c (transpile-expr ctx key-expr))
                      ;; Wrap key as pointer for generic map API
                      (key-ptr (wrap-map-key-as-ptr ctx key-c key-expr map-expr)))
                  ;; Generate: (slop_map_get(MAP, KEY_PTR) != NULL)
                  (ctx-str ctx "(slop_map_get(" (ctx-str ctx map-c (ctx-str ctx ", " (ctx-str ctx key-ptr ") != NULL)"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "map-has: missing key" (list-first-line items) (list-first-col items))
                  "false"))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-has: missing map" (list-first-line items) (list-first-col items))
              "false"))))))

  (fn transpile-map-keys ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile map-keys to properly typed list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (arena (. (deref ctx) arena)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "map-keys: needs map" (list-first-line items) (list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some map-expr)
            (let ((map-c (transpile-expr ctx map-expr))
                  (key-c-type (infer-map-key-c-type ctx map-expr))
                  ;; Debug: get variable name and slop-type
                  (debug-var-name (get-var-name-from-expr map-expr))
                  (debug-slop-type (match (ctx-lookup-var ctx debug-var-name)
                                     ((some entry) (. entry slop-type))
                                     ((none) "VAR_NOT_FOUND"))))
              ;; Check if key type is string - use legacy slop_map_keys
              (if (or (string-eq key-c-type "slop_string") (== (string-len key-c-type) 0))
                ;; Generate: slop_map_keys(arena, MAP) with debug info
                (ctx-str ctx "/* DEBUG: var=" (ctx-str ctx debug-var-name (ctx-str ctx " slop=" (ctx-str ctx debug-slop-type (ctx-str ctx " key=" (ctx-str ctx key-c-type (ctx-str ctx " */ slop_map_keys(arena, " (ctx-str ctx map-c ")"))))))))
                ;; Generate typed list from raw elements:
                ;; ({ slop_set_elements_result _r = slop_set_elements_raw(arena, MAP);
                ;;    (slop_list_KeyType){.data = (KeyType*)_r.data, .len = _r.len, .cap = _r.cap}; })
                (let ((list-type (ctx-str ctx "slop_list_" key-c-type)))
                  (ctx-str ctx "({ slop_set_elements_result _r = slop_set_elements_raw(arena, "
                    (ctx-str ctx map-c
                      (ctx-str ctx "); ("
                        (ctx-str ctx list-type
                          (ctx-str ctx "){.data = ("
                            (ctx-str ctx key-c-type
                              (ctx-str ctx "*)_r.data, .len = _r.len, .cap = _r.cap}; })" "")))))))))))
          ((none)
            (do
              (ctx-add-error-at ctx "map-keys: missing map" (list-first-line items) (list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; Set Operations
  ;; ============================================================

  (fn transpile-set-new ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-new to slop_map_new_ptr with element type info")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-new: needs arena and ElementType" (list-first-line items) (list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some arena-expr)
            (match (list-get items 2)
              ((some elem-type-expr)
                (let ((arena-c (transpile-expr ctx arena-expr))
                      (elem-info (get-map-key-c-info ctx elem-type-expr)))
                  ;; Generate: slop_map_new_ptr(arena, 16, sizeof_expr, hash_fn, eq_fn)
                  (ctx-str ctx "slop_map_new_ptr("
                    (ctx-str ctx arena-c
                      (ctx-str ctx ", 16, "
                        (ctx-str ctx elem-info ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-new: missing ElementType" (list-first-line items) (list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-new: missing arena" (list-first-line items) (list-first-col items))
              "NULL"))))))

  (fn transpile-set-put ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-put to slop_map_put with dummy value")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-put: needs set, element" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  ;; Use a dummy 1-byte value for set membership
                  (ctx-str ctx "({ uint8_t _dummy = 1; slop_map_put(arena, "
                    (ctx-str ctx set-c
                      (ctx-str ctx ", "
                        (ctx-str ctx elem-ptr ", &_dummy); })"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-put: missing element" (list-first-line items) (list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-put: missing set" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn transpile-set-has ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-has to check for non-NULL with proper element pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-has: needs set, element" (list-first-line items) (list-first-col items))
          "false")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  (ctx-str ctx "(slop_map_get(" (ctx-str ctx set-c (ctx-str ctx ", " (ctx-str ctx elem-ptr ") != NULL)"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-has: missing element" (list-first-line items) (list-first-col items))
                  "false"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-has: missing set" (list-first-line items) (list-first-col items))
              "false"))))))

  (fn transpile-set-remove ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-remove to slop_map_remove with proper element pointer wrapping")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 3)
        (do
          (ctx-add-error-at ctx "set-remove: needs set, element" (list-first-line items) (list-first-col items))
          "0")
        (match (list-get items 1)
          ((some set-expr)
            (match (list-get items 2)
              ((some elem-expr)
                (let ((set-c (transpile-expr ctx set-expr))
                      (elem-c (transpile-expr ctx elem-expr))
                      (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr set-expr)))
                  (ctx-str ctx "slop_map_remove(" (ctx-str ctx set-c (ctx-str ctx ", " (ctx-str ctx elem-ptr ")"))))))
              ((none)
                (do
                  (ctx-add-error-at ctx "set-remove: missing element" (list-first-line items) (list-first-col items))
                  "0"))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-remove: missing set" (list-first-line items) (list-first-col items))
              "0"))))))

  (fn transpile-set-elements ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set-elements to properly typed list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "set-elements: needs set" (list-first-line items) (list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some set-expr)
            (let ((set-c (transpile-expr ctx set-expr))
                  (elem-c-type (infer-set-elem-c-type ctx set-expr)))
              ;; Check if element type is string - use legacy slop_map_keys
              (if (or (string-eq elem-c-type "slop_string") (== (string-len elem-c-type) 0))
                ;; Generate: slop_map_keys(arena, SET)
                (ctx-str ctx "slop_map_keys(arena, " (ctx-str ctx set-c ")"))
                ;; Generate typed list from raw elements:
                ;; ({ slop_set_elements_result _r = slop_set_elements_raw(arena, SET);
                ;;    (slop_list_ElemType){.data = (ElemType*)_r.data, .len = _r.len, .cap = _r.cap}; })
                (let ((list-type (ctx-str ctx "slop_list_" elem-c-type)))
                  (ctx-str ctx "({ slop_set_elements_result _r = slop_set_elements_raw(arena, "
                    (ctx-str ctx set-c
                      (ctx-str ctx "); ("
                        (ctx-str ctx list-type
                          (ctx-str ctx "){.data = ("
                            (ctx-str ctx elem-c-type
                              (ctx-str ctx "*)_r.data, .len = _r.len, .cap = _r.cap}; })" "")))))))))))
          ((none)
            (do
              (ctx-add-error-at ctx "set-elements: missing set" (list-first-line items) (list-first-col items))
              "NULL"))))))

  (fn transpile-set-literal ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile set literal (set Type e1 e2...) to inline set construction")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "set: needs at least Type" (list-first-line items) (list-first-col items))
          "NULL")
        (match (list-get items 1)
          ((some type-expr)
            (let ((elem-info (get-map-key-c-info ctx type-expr))
                  ;; Build: ({ slop_map* _s = slop_map_new_ptr(arena, N, elem_info);
                  (num-elems (- len 2))
                  (init-cap (if (> num-elems 16) num-elems 16))
                  (mut result (ctx-str ctx "({ slop_map* _s = slop_map_new_ptr(arena, "
                                (ctx-str ctx (int-to-string arena init-cap)
                                  (ctx-str ctx ", "
                                    (ctx-str ctx elem-info "); "))))))
              ;; Add each element: slop_map_put(arena, _s, &elem, &(uint8_t){1});
              (let ((mut i 2))
                (while (< i len)
                  (match (list-get items i)
                    ((some elem-expr)
                      (let ((elem-c (transpile-expr ctx elem-expr))
                            (elem-ptr (wrap-map-key-as-ptr ctx elem-c elem-expr nil)))
                        (set! result (ctx-str ctx result
                          (ctx-str ctx "slop_map_put(arena, _s, "
                            (ctx-str ctx elem-ptr ", &(uint8_t){1}); "))))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              ;; Close: _s; })
              (ctx-str ctx result "_s; })")))
          ((none)
            (do
              (ctx-add-error-at ctx "set: missing type" (list-first-line items) (list-first-col items))
              "NULL"))))))

  ;; ============================================================
  ;; For Loop as Expression
  ;; ============================================================

  (fn transpile-for-as-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile for loop as expression returning 0")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (for (var start end) body...) -> ({ for (int64_t var = start; var < end; var++) { body... } 0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        "({ /* for: need binding */ 0; })"
        (match (list-get items 1)
          ((some binding-expr)
            (match (deref binding-expr)
              ((lst binding-lst)
                (let ((binding-items (. binding-lst items))
                      (binding-len (list-len binding-items)))
                  (if (< binding-len 3)
                    "({ /* for: binding needs (var start end) */ 0; })"
                    (match (list-get binding-items 0)
                      ((some var-expr)
                        (match (deref var-expr)
                          ((sym var-sym)
                            (let ((var-name (to-c-name arena (. var-sym name))))
                              (match (list-get binding-items 1)
                                ((some start-expr)
                                  (match (list-get binding-items 2)
                                    ((some end-expr)
                                      (let ((start-c (transpile-expr ctx start-expr))
                                            (end-c (transpile-expr ctx end-expr))
                                            ;; Build: ({ for (int64_t var = start; var < end; var++) {
                                            (mut result (ctx-str5 ctx "({ for (int64_t " var-name " = " start-c
                                                          (ctx-str5 ctx "; " var-name " < " end-c
                                                            (ctx-str3 ctx "; " var-name "++) { ")))))
                                        ;; Bind loop variable for body expressions
                                        (ctx-push-scope ctx)
                                        (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "int64_t" "" false false false "" ""))
                                        ;; Process body expressions
                                        (let ((mut i 2))
                                          (while (< i len)
                                            (match (list-get items i)
                                              ((some body-expr)
                                                (let ((body-c (transpile-expr ctx body-expr)))
                                                  (set! result (ctx-str3 ctx result body-c "; "))))
                                              ((none) (do)))
                                            (set! i (+ i 1))))
                                        (ctx-pop-scope ctx)
                                        ;; Close: } 0; })
                                        (ctx-str ctx result "} 0; })")))
                                    ((none) "({ /* for: missing end */ 0; })")))
                                ((none) "({ /* for: missing start */ 0; })"))))
                          (else "({ /* for: var must be symbol */ 0; })")))
                      ((none) "({ /* for: missing var */ 0; })")))))
              (else "({ /* for: binding must be list */ 0; })")))
          ((none) "({ /* for: missing binding */ 0; })")))))

  ;; ============================================================
  ;; For-Each Loop as Expression
  ;; ============================================================

  (fn transpile-for-each-as-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile for-each loop as expression returning 0")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; (for-each (item coll) body...) -> ({ for (size_t _i = 0; _i < coll.len; _i++) { __auto_type item = coll.data[_i]; body... } 0; })
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        "({ /* for-each: need binding */ 0; })"
        (match (list-get items 1)
          ((some binding-expr)
            (match (deref binding-expr)
              ((lst binding-lst)
                (let ((binding-items (. binding-lst items))
                      (binding-len (list-len binding-items)))
                  (if (< binding-len 2)
                    "({ /* for-each: binding needs (var coll) */ 0; })"
                    (match (list-get binding-items 0)
                      ((some var-expr)
                        (match (deref var-expr)
                          ((sym var-sym)
                            (let ((var-name (to-c-name arena (. var-sym name))))
                              (match (list-get binding-items 1)
                                ((some coll-expr)
                                  (let ((coll-c (transpile-expr ctx coll-expr))
                                        ;; Infer element type from collection for proper type propagation
                                        (elem-slop-type (infer-collection-element-slop-type ctx coll-expr))
                                        ;; Build: ({ for (size_t _i = 0; _i < coll.len; _i++) { __auto_type item = coll.data[_i];
                                        (mut result (ctx-str3 ctx "({ for (size_t _i = 0; _i < " coll-c
                                                      (ctx-str5 ctx ".len; _i++) { __auto_type " var-name " = " coll-c ".data[_i]; "))))
                                    ;; Bind loop variable for body expressions with inferred element type
                                    (ctx-push-scope ctx)
                                    (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "auto" elem-slop-type false false false "" ""))
                                    ;; Process body expressions
                                    (let ((mut i 2))
                                      (while (< i len)
                                        (match (list-get items i)
                                          ((some body-expr)
                                            (let ((body-c (transpile-expr ctx body-expr)))
                                              (set! result (ctx-str3 ctx result body-c "; "))))
                                          ((none) (do)))
                                        (set! i (+ i 1))))
                                    (ctx-pop-scope ctx)
                                    ;; Close: } 0; })
                                    (ctx-str ctx result "} 0; })")))
                                ((none) "({ /* for-each: missing collection */ 0; })"))))
                          (else "({ /* for-each: var must be symbol */ 0; })")))
                      ((none) "({ /* for-each: missing var */ 0; })")))))
              (else "({ /* for-each: binding must be list */ 0; })")))
          ((none) "({ /* for-each: missing binding */ 0; })")))))

  ;; ============================================================
  ;; Lambda Expression Transpilation
  ;; ============================================================

  (fn transpile-lambda-expr ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile lambda expression to static function, return function name")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Lambda: (fn ((param Type)...) body...)
    ;; items[0] = "fn", items[1] = params list, items[2..] = body
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (do
          (ctx-add-error-at ctx "lambda needs params" (list-first-line items) (list-first-col items))
          "NULL")
        ;; Check if items[1] is a list (lambda) or symbol (named fn - error in expr context)
        (match (list-get items 1)
          ((some second)
            (match (deref second)
              ;; Lambda: params list is second element
              ((lst params-lst)
                (transpile-lambda-with-params ctx items (. params-lst items)))
              ;; Named function definition in expression context - error
              ((sym _)
                (do
                  (ctx-add-error-at ctx "named function not allowed in expression context" (list-first-line items) (list-first-col items))
                  "NULL"))
              (else
                (do
                  (ctx-add-error-at ctx "invalid lambda form" (list-first-line items) (list-first-col items))
                  "NULL"))))
          ((none)
            (do
              (ctx-add-error-at ctx "lambda missing params" (list-first-line items) (list-first-col items))
              "NULL"))))))

  (fn transpile-lambda-with-params ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))))
    (@intent "Transpile lambda with extracted parameter list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          ;; Extract param names for free variable analysis
          (param-names (extract-param-names arena params))
          ;; Find free variables BEFORE pushing scope
          ;; (so we can see what's captured from enclosing scope)
          (free-vars (find-free-vars ctx param-names items 2)))
      ;; Generate unique lambda name with module prefix
      (let ((base-name (ctx-gensym ctx "_lambda"))
            (lambda-name (match (ctx-get-module ctx)
                           ((some mod) (ctx-str3 ctx (to-c-name arena mod) "_" base-name))
                           ((none) base-name))))
        ;; Check if we have captures
        (if (> (list-len free-vars) 0)
          ;; Closure: generate struct and modified lambda
          (transpile-closure ctx items params param-names free-vars lambda-name)
          ;; Simple lambda: no captures
          (transpile-simple-lambda ctx items params lambda-name)))))

  (fn extract-param-names ((arena Arena) (params (List (Ptr SExpr))))
    (@intent "Extract parameter names from params list")
    (@spec ((Arena (List (Ptr SExpr))) -> (List String)))
    (let ((names (list-new arena String))
          (count (list-len params))
          (mut i 0))
      (while (< i count)
        (match (list-get params i)
          ((some param-expr)
            (match (deref param-expr)
              ((lst param-lst)
                (let ((param-items (. param-lst items)))
                  (when (>= (list-len param-items) 1)
                    (match (list-get param-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (list-push names (. name-sym name)))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      names))

  (fn transpile-simple-lambda ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))) (lambda-name String))
    (@intent "Transpile non-capturing lambda")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (let ((param-str (build-lambda-params ctx params))
          ;; For now, default return type is int64_t
          (return-type "int64_t"))
      ;; Push scope for lambda body
      (ctx-push-scope ctx)
      ;; Bind parameter names in scope
      (bind-lambda-params ctx params)
      ;; Transpile body expressions
      (let ((body-start 2)
            (body-code (transpile-lambda-body ctx items body-start)))
        (ctx-pop-scope ctx)
        ;; Build complete function definition
        (let ((fn-def (build-lambda-function ctx lambda-name return-type param-str body-code)))
          ;; Add to deferred lambdas
          (ctx-add-deferred-lambda ctx fn-def)
          ;; Return the lambda name as expression value (function pointer)
          lambda-name))))

  (fn transpile-closure ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (params (List (Ptr SExpr))) (param-names (List String)) (free-vars (List String)) (lambda-name String))
    (@intent "Transpile capturing lambda (closure)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (List (Ptr SExpr)) (List String) (List String) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          ;; Generate closure struct name
          (env-name (ctx-str ctx lambda-name "_env"))
          (env-type (ctx-str ctx env-name "_t")))
      ;; Build closure environment struct
      (let ((struct-def (build-closure-struct ctx env-type free-vars)))
        ;; Add struct to deferred lambdas (before the function)
        (ctx-add-deferred-lambda ctx struct-def)
        ;; Build lambda with env parameter
        (let ((param-str (build-closure-params ctx params))
              (return-type "int64_t"))
          ;; Push scope for lambda body
          (ctx-push-scope ctx)
          ;; Bind env-accessed variables (they come from _env)
          (bind-closure-captures ctx free-vars)
          ;; Bind regular parameters
          (bind-lambda-params ctx params)
          ;; Transpile body expressions
          (let ((body-start 2)
                (body-code (transpile-lambda-body ctx items body-start)))
            (ctx-pop-scope ctx)
            ;; Build closure function (takes void* env as first param)
            (let ((fn-def (build-closure-function ctx lambda-name env-type return-type param-str body-code free-vars)))
              (ctx-add-deferred-lambda ctx fn-def)
              ;; Set last lambda info for closure variable binding
              (ctx-set-last-lambda-info ctx true env-type lambda-name)
              ;; Generate closure instantiation expression
              ;; This creates the env struct and returns a packaged closure
              (build-closure-instance ctx lambda-name env-name env-type free-vars)))))))

  (fn build-closure-struct ((ctx (Ptr TranspileContext)) (env-type String) (free-vars (List String)))
    (@intent "Build typedef for closure environment struct")
    (@spec (((Ptr TranspileContext) String (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut fields "")
          (mut i 0))
      ;; Build fields for each captured variable
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            ;; Look up variable type
            (let ((var-type (match (ctx-lookup-var ctx var-name)
                              ((some entry) (. entry c-type))
                              ((none) "int64_t")))  ;; Default to int64_t
                  (c-name (to-c-name arena var-name)))
              (set! fields (ctx-str ctx fields (ctx-str4 ctx var-type " " c-name "; ")))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; typedef struct { fields } env_type;
      (ctx-str ctx "typedef struct { " (ctx-str3 ctx fields "} " (ctx-str ctx env-type ";")))))

  (fn build-closure-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Build C parameter string for closure (without env, added separately)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Same as build-lambda-params but we prepend void* _env in the function def
    (build-lambda-params ctx params))

  (fn bind-closure-captures ((ctx (Ptr TranspileContext)) (free-vars (List String)))
    (@intent "Bind captured variables to access via _env pointer")
    (@spec (((Ptr TranspileContext) (List String)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut i 0))
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            ;; The variable access will be translated to _env->var_name
            ;; We bind it with a special marker that the transpiler recognizes
            (let ((c-name (to-c-name arena var-name))
                  (access-expr (ctx-str3 ctx "_env->" c-name ""))
                  (var-type (match (ctx-lookup-var ctx var-name)
                              ((some entry) (. entry c-type))
                              ((none) "int64_t"))))
              ;; Bind with the access expression as the C name
              (ctx-bind-var ctx (VarEntry var-name access-expr var-type "" false false false "" ""))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn build-closure-function ((ctx (Ptr TranspileContext)) (name String) (env-type String) (ret-type String) (params String) (body String) (free-vars (List String)))
    (@intent "Build static closure function with env parameter")
    (@spec (((Ptr TranspileContext) String String String String String (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; static ret_type name(env_type* _env, params) { body }
      (let ((env-param (ctx-str3 ctx env-type "* _env" ""))
            (full-params (if (string-eq params "(void)")
                           (ctx-str3 ctx "(" env-param ")")
                           (ctx-str5 ctx "(" env-param ", " (trim-parens arena params) ")"))))
        (ctx-str ctx "static " (ctx-str ctx ret-type (ctx-str ctx " " (ctx-str ctx name (ctx-str ctx full-params (ctx-str ctx " { " (ctx-str ctx body " }"))))))))))

  (fn trim-parens ((arena Arena) (s String))
    (@intent "Remove leading ( and trailing ) from string")
    (@spec ((Arena String) -> String))
    (let ((len (cast Int (string-len s))))
      (if (< len 2)
        s
        (substring arena s (cast (Int 0 ..) 1) (cast (Int 0 ..) (- len 2))))))

  (fn build-closure-instance ((ctx (Ptr TranspileContext)) (lambda-name String) (env-name String) (env-type String) (free-vars (List String)))
    (@intent "Build expression that creates closure instance")
    (@spec (((Ptr TranspileContext) String String String (List String)) -> String))
    (@pre {ctx != nil})
    ;; For now, return a compound literal that packages the env
    ;; The caller needs to handle allocating the env struct
    ;; This generates: ({ static env_type _env = { .field1 = val1, ... }; (void*)&_env; })
    ;; But that's complex. For simplicity, just return the lambda name.
    ;; The caller (like spawn) should handle env creation.
    ;;
    ;; Actually, we need to emit the env creation at the call site.
    ;; For now, emit an error placeholder.
    (let ((arena (. (deref ctx) arena)))
      ;; Emit env declaration as a separate statement so it has proper scope
      ;; env_type env_name = { captures... };
      (let ((initializer (build-env-initializer ctx free-vars)))
        (let ((env-decl (ctx-str ctx env-type
                          (ctx-str ctx " "
                            (ctx-str ctx env-name
                              (ctx-str ctx " = "
                                (ctx-str ctx initializer ";")))))))
          ;; Emit the env declaration
          (ctx-emit ctx env-decl)
          ;; Return just the closure struct literal (no compound expression)
          ;; (slop_closure_t){ (void*)lambda, (void*)&env_name }
          (ctx-str ctx "(slop_closure_t){ (void*)"
            (ctx-str ctx lambda-name
              (ctx-str ctx ", (void*)&"
                (ctx-str ctx env-name " }"))))))))

  (fn build-env-initializer ((ctx (Ptr TranspileContext)) (free-vars (List String)))
    (@intent "Build initializer for closure environment struct")
    (@spec (((Ptr TranspileContext) (List String)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (count (list-len free-vars))
          (mut result "{ ")
          (mut i 0))
      (while (< i count)
        (match (list-get free-vars i)
          ((some var-name)
            (let ((c-name (to-c-name arena var-name)))
              (if (> i 0)
                (set! result (ctx-str ctx result (ctx-str5 ctx ", ." c-name " = " c-name "")))
                (set! result (ctx-str ctx result (ctx-str5 ctx "." c-name " = " c-name ""))))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-str ctx result " }")))

  (fn build-lambda-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Build C parameter string from lambda params list")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (param-count (list-len params)))
      (if (== param-count 0)
        "(void)"
        (let ((mut result "(")
              (mut i 0))
          (while (< i param-count)
            (match (list-get params i)
              ((some param-expr)
                (match (deref param-expr)
                  ((lst param-lst)
                    (let ((param-items (. param-lst items)))
                      (when (>= (list-len param-items) 2)
                        (match (list-get param-items 0)
                          ((some name-expr)
                            (match (deref name-expr)
                              ((sym name-sym)
                                (match (list-get param-items 1)
                                  ((some type-expr)
                                    (let ((param-name (to-c-name arena (. name-sym name)))
                                          (param-type (to-c-type-prefixed ctx type-expr)))
                                      (if (> i 0)
                                        (set! result (ctx-str ctx result (ctx-str5 ctx ", " param-type " " param-name "")))
                                        (set! result (ctx-str ctx result (ctx-str4 ctx param-type " " param-name ""))))))
                                  ((none) (do))))
                              (else (do))))
                          ((none) (do))))))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          (ctx-str ctx result ")")))))

  (fn bind-lambda-params ((ctx (Ptr TranspileContext)) (params (List (Ptr SExpr))))
    (@intent "Bind lambda parameters in current scope")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (param-count (list-len params))
          (mut i 0))
      (while (< i param-count)
        (match (list-get params i)
          ((some param-expr)
            (match (deref param-expr)
              ((lst param-lst)
                (let ((param-items (. param-lst items)))
                  (when (>= (list-len param-items) 2)
                    (match (list-get param-items 0)
                      ((some name-expr)
                        (match (deref name-expr)
                          ((sym name-sym)
                            (match (list-get param-items 1)
                              ((some type-expr)
                                (let ((param-name (. name-sym name))
                                      (c-name (to-c-name arena param-name))
                                      (c-type (to-c-type-prefixed ctx type-expr))
                                      (is-ptr (is-pointer-type-sexpr type-expr)))
                                  (ctx-bind-var ctx (VarEntry param-name c-name c-type "" is-ptr false false "" ""))))
                              ((none) (do))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-pointer-type-sexpr ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn transpile-lambda-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Transpile lambda body expressions, return last as value")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> String))
    (@pre {ctx != nil})
    ;; Thread Unit lambdas return int64_t but last expression may be Result
    ;; We wrap to: (expr, 0) to evaluate and return 0
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result "")
          (mut i start))
      (if (<= len start)
        ;; No body - return 0
        "return 0;"
        (do
          (while (< i len)
            (match (list-get items i)
              ((some expr)
                (let ((expr-c (transpile-expr ctx expr))
                      (is-last (== i (- len 1))))
                  (if is-last
                    ;; Last expression: evaluate for side effects and return 0
                    ;; This handles Thread Unit where body might return Result but lambda returns int
                    (set! result (ctx-str ctx result (ctx-str ctx "(" (ctx-str ctx expr-c ", 0); return 0;"))))
                    ;; Not last: just evaluate for side effects
                    (set! result (ctx-str ctx result (ctx-str3 ctx expr-c "; " ""))))))
              ((none) (do)))
            (set! i (+ i 1)))
          result))))

  (fn build-lambda-function ((ctx (Ptr TranspileContext)) (name String) (ret-type String) (params String) (body String))
    (@intent "Build complete static function definition for lambda")
    (@spec (((Ptr TranspileContext) String String String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; static ret_type name(params) { body }
      (ctx-str ctx "static " (ctx-str ctx ret-type (ctx-str ctx " " (ctx-str ctx name (ctx-str ctx params (ctx-str ctx " { " (ctx-str ctx body " }")))))))))

  ;; ============================================================
  ;; spawn + Closure Support
  ;; ============================================================

  (fn is-capturing-lambda ((expr (Ptr SExpr)))
    (@intent "Check if expression is a lambda form (fn ((params...)) body)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    ;; Check if expr is (fn ((params...)) body) form
    ;; Note: This only checks the structure, not whether it actually captures
    ;; The actual capture detection happens in transpile-spawn-closure
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (if (not (string-eq (. sym name) "fn"))
                      false
                      ;; It's a fn form - check if it has params list (lambda vs named fn)
                      (match (list-get items 1)
                        ((some second)
                          (match (deref second)
                            ((lst _) true)  ;; Lambda form
                            (_ false)))
                        ((none) false))))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn transpile-spawn-closure ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (fn-expr (Ptr SExpr)))
    (@intent "Transpile spawn call with lambda - inline thread creation, handles both capturing and non-capturing")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {fn-expr != nil})
    ;; First check if the lambda actually captures anything
    (let ((arena (. (deref ctx) arena)))
      (match (list-get items 1)
        ((some arena-expr)
          (let ((arena-c (transpile-expr ctx arena-expr))
                (has-captures (lambda-has-captures ctx fn-expr)))
            (if has-captures
              ;; Capturing lambda - transpile returns slop_closure_t
              (let ((closure-c (transpile-expr ctx fn-expr)))
                (ctx-str ctx "({ slop_closure_t _spawn_cl = " (ctx-str ctx closure-c
                  (ctx-str ctx "; slop_thread_int* _spawn_th = slop_arena_alloc(" (ctx-str ctx arena-c
                    (ctx-str ctx ", sizeof(slop_thread_int));"
                      (ctx-str ctx " _spawn_th->func = _spawn_cl.fn;"
                        (ctx-str ctx " _spawn_th->env = _spawn_cl.env;"
                          (ctx-str ctx " _spawn_th->done = false;"
                            (ctx-str ctx " pthread_create(&_spawn_th->id, NULL, (void*)slop_thread_int_entry, (void*)_spawn_th);"
                              " _spawn_th; })"))))))))))
              ;; Non-capturing lambda - use regular spawn call
              (transpile-regular-fn-call ctx "spawn" items))))
        ((none)
          (do
            (ctx-add-error-at ctx "spawn: missing arena argument" (list-first-line items) (list-first-col items))
            "NULL")))))

  (fn lambda-has-captures ((ctx (Ptr TranspileContext)) (fn-expr (Ptr SExpr)))
    (@intent "Check if lambda expression has free variables that need capturing")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {fn-expr != nil})
    ;; Extract params and body from lambda, then check for free vars
    (match (deref fn-expr)
      ((lst lst)
        (let ((items (. lst items))
              (arena (. (deref ctx) arena)))
          (if (< (list-len items) 2)
            false
            (match (list-get items 1)
              ((some params-expr)
                (match (deref params-expr)
                  ((lst params-lst)
                    (let ((params (. params-lst items))
                          (param-names (extract-param-names arena params))
                          (free-vars (find-free-vars ctx param-names items 2)))
                      (> (list-len free-vars) 0)))
                  (_ false)))
              ((none) false)))))
      (_ false)))

  (fn transpile-regular-fn-call ((ctx (Ptr TranspileContext)) (fn-name String) (items (List (Ptr SExpr))))
    (@intent "Transpile regular function call (non-special cases)")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Build argument list and call transpile-call
    ;; Look up function to get parameter types for typed none handling
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (func-opt (ctx-lookup-func ctx fn-name))
          (mut args "")
          (mut i 1)
          (mut param-idx 0))
      (while (< i len)
        (match (list-get items i)
          ((some arg)
            (let ((arg-c (transpile-expr ctx arg))
                  ;; Get expected type for this parameter if available
                  (expected-type (match func-opt
                                   ((some func-entry)
                                     (match (list-get (. func-entry param-types) param-idx)
                                       ((some p) (. (deref p) c-type))
                                       ((none) "")))
                                   ((none) "")))
                  ;; Convert none to typed Option if needed
                  (final-arg (typed-none-arg ctx expected-type arg-c)))
              (if (string-eq args "")
                (set! args final-arg)
                (set! args (ctx-str3 ctx args ", " final-arg)))
              (set! param-idx (+ param-idx 1))))
          ((none) (do)))
        (set! i (+ i 1)))
      (transpile-call ctx fn-name args)))

  ;; ============================================================
  ;; Free Variable Analysis for Closures
  ;; ============================================================

  (fn find-free-vars ((ctx (Ptr TranspileContext)) (param-names (List String)) (body-items (List (Ptr SExpr))) (start Int))
    (@intent "Find variables in lambda body that are captured from enclosing scope")
    (@spec (((Ptr TranspileContext) (List String) (List (Ptr SExpr)) Int) -> (List String)))
    (@pre {ctx != nil})
    ;; Collect all symbol references in the body
    ;; Filter out: params, known functions, builtins, type names
    ;; What remains are captured variables
    (let ((arena (. (deref ctx) arena))
          (all-symbols (list-new arena String))
          (free-vars (list-new arena String))
          (len (list-len body-items))
          (mut i start))
      ;; Collect all symbols from body expressions
      (while (< i len)
        (match (list-get body-items i)
          ((some expr)
            (collect-symbols-in-expr ctx (addr all-symbols) expr))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Filter to find truly free variables
      (let ((sym-count (list-len all-symbols))
            (mut j 0))
        (while (< j sym-count)
          (match (list-get all-symbols j)
            ((some sym-name)
              (when (is-free-var ctx param-names sym-name)
                ;; Check not already in free-vars
                (when (not (list-contains-string free-vars sym-name))
                  (list-push free-vars sym-name))))
            ((none) (do)))
          (set! j (+ j 1))))
      free-vars))

  (fn collect-symbols-in-expr ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (expr (Ptr SExpr)))
    (@intent "Recursively collect all symbol references in an expression")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Add symbol name if not a special keyword
        (let ((name (. sym name)))
          (when (not (is-special-keyword name))
            (list-push (deref symbols) name))))
      ((lst lst)
        ;; Recursively collect from list items
        ;; But be smart about special forms that introduce bindings
        (let ((items (. lst items))
              (len (list-len items)))
          (when (> len 0)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym head-sym)
                    (let ((op (. head-sym name)))
                      (cond
                        ;; let: skip binding names, recurse into values and body
                        ((string-eq op "let")
                          (collect-symbols-in-let ctx symbols items))
                        ;; fn: skip (we're analyzing inside a lambda, nested lambdas are separate)
                        ((string-eq op "fn")
                          (do))  ;; Don't recurse into nested lambdas
                        ;; match: recurse into scrutinee and bodies (pattern vars are local)
                        ((string-eq op "match")
                          (collect-symbols-in-match ctx symbols items))
                        ;; for/for-each: skip loop var, recurse into range/collection and body
                        ((or (string-eq op "for") (string-eq op "for-each"))
                          (collect-symbols-in-for ctx symbols items))
                        ;; Default: recurse into all items
                        (else
                          (collect-symbols-in-list ctx symbols items 0)))))
                  (else
                    ;; Non-symbol head, recurse into all
                    (collect-symbols-in-list ctx symbols items 0))))
              ((none) (do))))))
      (else (do))))

  (fn collect-symbols-in-list ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (items (List (Ptr SExpr))) (start Int))
    (@intent "Collect symbols from list items starting at index")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (collect-symbols-in-expr ctx symbols item))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn collect-symbols-in-let ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from let form, excluding bound names")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (let ((name val) ...) body...)
    ;; Recurse into values and body, but not binding names
    (let ((len (list-len items)))
      (when (>= len 2)
        (match (list-get items 1)
          ((some bindings-expr)
            (match (deref bindings-expr)
              ((lst bindings-lst)
                ;; For each binding, only collect from the value
                (let ((bindings (. bindings-lst items))
                      (binding-count (list-len bindings))
                      (mut i 0))
                  (while (< i binding-count)
                    (match (list-get bindings i)
                      ((some binding)
                        (match (deref binding)
                          ((lst bind-lst)
                            (let ((bind-items (. bind-lst items)))
                              ;; binding is (name value) or (mut name value)
                              ;; Collect from value only
                              (when (>= (list-len bind-items) 2)
                                (let ((val-idx (if (is-mut-binding bind-items) 2 1)))
                                  (match (list-get bind-items val-idx)
                                    ((some val-expr)
                                      (collect-symbols-in-expr ctx symbols val-expr))
                                    ((none) (do)))))))
                          (else (do))))
                      ((none) (do)))
                    (set! i (+ i 1)))))
              (else (do))))
          ((none) (do)))
        ;; Collect from body expressions
        (collect-symbols-in-list ctx symbols items 2))))

  (fn is-mut-binding ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with mut keyword")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym) (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn collect-symbols-in-match ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from match form")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (match scrutinee (pattern body)...)
    ;; Collect from scrutinee and bodies (pattern vars are local)
    (let ((len (list-len items)))
      (when (>= len 2)
        ;; Collect from scrutinee
        (match (list-get items 1)
          ((some scrutinee)
            (collect-symbols-in-expr ctx symbols scrutinee))
          ((none) (do)))
        ;; Collect from clause bodies (skip patterns)
        (let ((mut i 2))
          (while (< i len)
            (match (list-get items i)
              ((some clause)
                (match (deref clause)
                  ((lst clause-lst)
                    (let ((clause-items (. clause-lst items)))
                      ;; Clause is (pattern body...), collect from body only
                      (collect-symbols-in-list ctx symbols clause-items 1)))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))))))

  (fn collect-symbols-in-for ((ctx (Ptr TranspileContext)) (symbols (Ptr (List String))) (items (List (Ptr SExpr))))
    (@intent "Collect symbols from for/for-each form")
    (@spec (((Ptr TranspileContext) (Ptr (List String)) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (for (i start end) body...) or (for-each (item coll) body...)
    ;; Skip loop variable, collect from range/collection and body
    (let ((len (list-len items)))
      (when (>= len 2)
        (match (list-get items 1)
          ((some binding)
            (match (deref binding)
              ((lst bind-lst)
                (let ((bind-items (. bind-lst items)))
                  ;; Collect from start/end or collection (items after first)
                  (collect-symbols-in-list ctx symbols bind-items 1)))
              (else (do))))
          ((none) (do)))
        ;; Collect from body
        (collect-symbols-in-list ctx symbols items 2))))

  (fn is-special-keyword ((name String))
    (@intent "Check if name is a special keyword that shouldn't be collected")
    (@spec ((String) -> Bool))
    ;; Special forms, operators, and type names
    (or (string-eq name "let")
        (string-eq name "if")
        (string-eq name "cond")
        (string-eq name "match")
        (string-eq name "when")
        (string-eq name "while")
        (string-eq name "for")
        (string-eq name "for-each")
        (string-eq name "do")
        (string-eq name "set!")
        (string-eq name "deref")
        (string-eq name "cast")
        (string-eq name "fn")
        (string-eq name "true")
        (string-eq name "false")
        (string-eq name "nil")
        (string-eq name "none")
        (string-eq name "some")
        (string-eq name "ok")
        (string-eq name "error")
        (string-eq name "mut")
        (string-eq name "else")
        (string-eq name "and")
        (string-eq name "or")
        (string-eq name "not")))

  (fn is-free-var ((ctx (Ptr TranspileContext)) (param-names (List String)) (sym-name String))
    (@intent "Check if symbol is a free variable (captured from enclosing scope)")
    (@spec (((Ptr TranspileContext) (List String) String) -> Bool))
    (@pre {ctx != nil})
    ;; A symbol is free if:
    ;; - Not a lambda parameter
    ;; - Not a known function
    ;; - Not a type name
    ;; - Not a builtin operator
    ;; - IS a variable in the current scope (from enclosing context)
    (if (list-contains-string param-names sym-name)
      false  ;; Lambda parameter, not free
      (if (is-builtin-op sym-name)
        false  ;; Builtin operator
        (match (ctx-lookup-func ctx sym-name)
          ((some _) false)  ;; Known function
          ((none)
            (match (ctx-lookup-type ctx sym-name)
              ((some _) false)  ;; Type name
              ((none)
                ;; Check if it's a variable in scope
                (match (ctx-lookup-var ctx sym-name)
                  ((some _) true)  ;; It's a captured variable!
                  ((none) false)))))))))  ;; Unknown symbol

  (fn is-builtin-op ((name String))
    (@intent "Check if name is a builtin operator")
    (@spec ((String) -> Bool))
    (or (string-eq name "+")
        (string-eq name "-")
        (string-eq name "*")
        (string-eq name "/")
        (string-eq name "%")
        (string-eq name "==")
        (string-eq name "!=")
        (string-eq name "<")
        (string-eq name ">")
        (string-eq name "<=")
        (string-eq name ">=")
        (string-eq name "@")))

  (fn list-contains-string ((lst (List String)) (needle String))
    (@intent "Check if string list contains the given string")
    (@spec (((List String) String) -> Bool))
    (let ((len (list-len lst))
          (mut i 0)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get lst i)
          ((some s)
            (when (string-eq s needle)
              (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  ;; ============================================================
  ;; Type Argument Extraction Helpers
  ;; ============================================================

  (fn extract-first-type-arg ((arena Arena) (slop-type String) (start Int))
    (@intent "Extract first type arg, handling nested parens")
    (@spec ((Arena String Int) -> String))
    (let ((len (cast Int (string-len slop-type)))
          (mut depth 0)
          (mut end-pos start)
          (mut found false))
      (while (and (< end-pos len) (not found))
        (let ((c (char-at slop-type (cast (Int 0 ..) end-pos))))
          (cond
            ((== c 40)
              (set! depth (+ depth 1))
              (set! end-pos (+ end-pos 1)))
            ((== c 41)
              (if (== depth 0)
                (set! found true)
                (do
                  (set! depth (- depth 1))
                  (set! end-pos (+ end-pos 1)))))
            ((and (== c 32) (== depth 0))
              (set! found true))
            (else
              (set! end-pos (+ end-pos 1))))))
      (if (> end-pos start)
        (substring arena slop-type (cast (Int 0 ..) start) (cast (Int 0 ..) (- end-pos start)))
        "")))

  (fn extract-second-type-arg ((arena Arena) (slop-type String) (start Int))
    (@intent "Extract second type arg from compound type")
    (@spec ((Arena String Int) -> String))
    (let ((first-arg (extract-first-type-arg arena slop-type start))
          (first-len (string-len first-arg)))
      (if (== first-len 0)
        ""
        (extract-first-type-arg arena slop-type (+ start (+ (cast Int first-len) 1))))))

  ;; ============================================================
  ;; Result Type Inference Helpers
  ;; ============================================================

  (fn infer-result-ok-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Extract OK type T from (Result T E) scrutinee")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref scrutinee)
        ((sym sym)
          (match (ctx-lookup-var ctx (. sym name))
            ((some var-entry)
              (let ((slop-type (. var-entry slop-type)))
                (if (starts-with slop-type "(Result ")
                  (extract-first-type-arg arena slop-type 8)
                  "")))
            ((none) "")))
        (_ ""))))

  (fn infer-result-err-slop-type ((ctx (Ptr TranspileContext)) (scrutinee (Ptr SExpr)))
    (@intent "Extract Error type E from (Result T E) scrutinee")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {scrutinee != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref scrutinee)
        ((sym sym)
          (match (ctx-lookup-var ctx (. sym name))
            ((some var-entry)
              (let ((slop-type (. var-entry slop-type)))
                (if (starts-with slop-type "(Result ")
                  (extract-second-type-arg arena slop-type 8)
                  "")))
            ((none) "")))
        (_ ""))))

  ;; ============================================================
  ;; Collection Element Type Inference
  ;; ============================================================

  (fn infer-collection-element-slop-type ((ctx (Ptr TranspileContext)) (coll-expr (Ptr SExpr)))
    (@intent "Infer the SLOP element type from a collection expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {coll-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref coll-expr)
        ((lst lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (let ((op (. sym name)))
                        (cond
                          ((string-eq op "map-keys")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-slop-type (infer-expr-slop-type ctx map-expr)))
                                    (if (> (string-len map-slop-type) 0)
                                      (let ((resolved (resolve-type-alias-for-map ctx map-slop-type)))
                                        (extract-map-key-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          ((string-eq op "set-elements")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some set-expr)
                                  (let ((set-slop-type (infer-expr-slop-type ctx set-expr)))
                                    (if (> (string-len set-slop-type) 0)
                                      (let ((resolved (resolve-type-alias-for-map ctx set-slop-type)))
                                        (extract-set-elem-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          ((string-eq op "map-values")
                            (if (< (list-len items) 2)
                              ""
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-slop-type (infer-expr-slop-type ctx map-expr)))
                                    (if (> (string-len map-slop-type) 0)
                                      (let ((resolved (resolve-type-alias-for-map ctx map-slop-type)))
                                        (extract-map-value-from-slop-type arena resolved))
                                      "")))
                                ((none) ""))))
                          (else (infer-elem-from-type ctx coll-expr)))))
                    (_ (infer-elem-from-type ctx coll-expr))))
                ((none) "")))))
        (_ (infer-elem-from-type ctx coll-expr)))))

  (fn infer-elem-from-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer element type from expression's SLOP type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena))
          (slop-type (infer-expr-slop-type ctx expr)))
      (if (== (string-len slop-type) 0)
        ""
        ;; Resolve type alias before pattern matching (e.g., TermSet -> (Set Term))
        (let ((resolved-type (resolve-type-alias-for-map ctx slop-type)))
          (cond
            ((starts-with resolved-type "(List ")
              (let ((elem-len (- (- (string-len resolved-type) 6) 1)))
                (if (> elem-len 0)
                  (substring arena resolved-type 6 (cast (Int 0 ..) elem-len))
                  "")))
            ((starts-with resolved-type "(Set ")
              (extract-set-elem-from-slop-type arena resolved-type))
            ((starts-with resolved-type "(Map ")
              ;; For maps, return the key type (used for iteration)
              (extract-map-key-from-slop-type arena resolved-type))
            (else ""))))))

) ;; end module
