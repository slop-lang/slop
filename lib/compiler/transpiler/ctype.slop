(module ctype
  (export
    to-c-type
    is-pointer-type
    is-string-type
    is-void-type
    is-option-type
    is-result-type
    is-list-type
    is-map-type
    get-range-bounds
    select-int-type
    get-inner-type
    get-result-types
    get-map-types)
  (import parser (SExpr SExprList SExprSymbol SExprNumber is-form))
  (import context
    (TranspileContext ctx-lookup-type ctx-register-option ctx-register-result ctx-register-list ctx-register-map))
  (import names (to-c-type-name type-to-identifier))
  (import strlib (string-eq string-concat))

  (type ResultTypePair (record (ok (Ptr SExpr)) (err (Ptr SExpr))))

  (type MapTypePair (record (key (Ptr SExpr)) (val (Ptr SExpr))))

  (type RangeBoundsInfo (record
      (has-min Bool)
      (min-val I64)
      (has-max Bool)
      (max-val I64)))

  (const BUILTIN_TYPES (Map String String) (map-from-pairs String String (list (pair "Int" "int64_t") (pair "I8" "int8_t") (pair "I16" "int16_t") (pair "I32" "int32_t") (pair "I64" "int64_t") (pair "U8" "uint8_t") (pair "U16" "uint16_t") (pair "U32" "uint32_t") (pair "U64" "uint64_t") (pair "Char" "char") (pair "Float" "double") (pair "F32" "float") (pair "F64" "double") (pair "Bool" "bool") (pair "String" "slop_string") (pair "Bytes" "slop_bytes") (pair "Unit" "void") (pair "Void" "void") (pair "Arena" "slop_arena*") (pair "Milliseconds" "int64_t"))))

  (fn to-c-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Convert SLOP type expression to C type string")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= type-expr nil))
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((symbol sym)
          (let ((name (. sym name)))
            (match (map-get BUILTIN_TYPES name)
              ((some c-type) c-type)
              ((none)
                (match (ctx-lookup-type ctx name)
                  ((some info) (to-c-type-name name))
                  ((none) (to-c-type-name name)))))))
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol s)
                    (let ((op (. s name)))
                      (cond
                        ((string-eq op "Ptr")
                          (match (list-get items 1)
                            ((some inner)
                              (string-concat arena (to-c-type ctx inner) "*"))
                            ((none) "void*")))
                        ((string-eq op "Option")
                          (match (list-get items 1)
                            ((some inner)
                              (let ((inner-c (to-c-type ctx inner))
                                    (inner-id (type-to-identifier inner-c))
                                    (opt-name (string-concat arena "slop_option_" inner-id)))
                                (do
                                  (ctx-register-option ctx opt-name inner-c)
                                  opt-name)))
                            ((none) "slop_option_void")))
                        ((string-eq op "Result")
                          (match (list-get items 1)
                            ((some ok-expr)
                              (match (list-get items 2)
                                ((some err-expr)
                                  (let ((ok-c (to-c-type ctx ok-expr))
                                        (err-c (to-c-type ctx err-expr))
                                        (ok-id (type-to-identifier ok-c))
                                        (err-id (type-to-identifier err-c))
                                        (mid (string-concat arena ok-id "_"))
                                        (suffix (string-concat arena mid err-id))
                                        (res-name (string-concat arena "slop_result_" suffix)))
                                    (do
                                      (ctx-register-result ctx res-name ok-c err-c)
                                      res-name)))
                                ((none) "slop_result_void_void")))
                            ((none) "slop_result_void_void")))
                        ((string-eq op "List")
                          (match (list-get items 1)
                            ((some elem-expr)
                              (let ((elem-c (to-c-type ctx elem-expr))
                                    (elem-id (type-to-identifier elem-c))
                                    (list-name (string-concat arena "slop_list_" elem-id)))
                                (do
                                  (ctx-register-list ctx list-name elem-c)
                                  list-name)))
                            ((none) "slop_list_void")))
                        ((string-eq op "Map")
                          (match (list-get items 1)
                            ((some key-expr)
                              (match (list-get items 2)
                                ((some val-expr)
                                  (let ((key-c (to-c-type ctx key-expr))
                                        (val-c (to-c-type ctx val-expr))
                                        (key-id (type-to-identifier key-c))
                                        (val-id (type-to-identifier val-c))
                                        (mid (string-concat arena key-id "_"))
                                        (suffix (string-concat arena mid val-id))
                                        (map-name (string-concat arena "slop_map_" suffix)))
                                    (do
                                      (ctx-register-map ctx map-name key-c val-c)
                                      map-name)))
                                ((none) "slop_map_void_void")))
                            ((none) "slop_map_void_void")))
                        ((string-eq op "Int")
                          (if (> (list-len items) 1)
                            (let ((bounds (get-range-bounds type-expr)))
                              (select-int-type
                                (. bounds has-min)
                                (. bounds min-val)
                                (. bounds has-max)
                                (. bounds max-val)))
                            "int64_t"))
                        ((string-eq op "Array") (to-c-type-name "array"))
                        (else (to-c-type-name op)))))
                  (_ "void")))
              ((none) "void"))))
        (_ "void"))))

  (fn is-pointer-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Ptr T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Ptr"))

  (fn is-string-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is String")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((symbol sym) (string-eq (. sym name) "String"))
      (_ false)))

  (fn is-void-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is Unit or Void")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((symbol sym)
        (or (string-eq (. sym name) "Unit") (string-eq (. sym name) "Void")))
      (_ false)))

  (fn is-option-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Option T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Option"))

  (fn is-result-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Result T E)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Result"))

  (fn is-list-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (List T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "List"))

  (fn is-map-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Map K V)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Map"))

  (fn get-inner-type ((type-expr (Ptr SExpr)))
    (@intent "Get inner type from Option, List, or Ptr")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst) (list-get (. lst items) 1))
      (_ (none))))

  (fn get-result-types ((type-expr (Ptr SExpr)))
    (@intent "Get Ok and Error types from Result")
    (@spec (((Ptr SExpr)) -> (Option ResultTypePair)))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (>= (list-len items) 3)
            (match (list-get items 1)
              ((some ok-type)
                (match (list-get items 2)
                  ((some err-type) (some (ResultTypePair ok-type err-type)))
                  ((none) (none))))
              ((none) (none)))
            (none))))
      (_ (none))))

  (fn get-map-types ((type-expr (Ptr SExpr)))
    (@intent "Get Key and Value types from Map")
    (@spec (((Ptr SExpr)) -> (Option MapTypePair)))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (>= (list-len items) 3)
            (match (list-get items 1)
              ((some key-type)
                (match (list-get items 2)
                  ((some val-type) (some (MapTypePair key-type val-type)))
                  ((none) (none))))
              ((none) (none)))
            (none))))
      (_ (none))))

  (fn get-range-bounds ((type-expr (Ptr SExpr)))
    (@intent "Extract min/max bounds from range type (Int min .. max)")
    (@spec (((Ptr SExpr)) -> RangeBoundsInfo))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (cond
            ((== len 4)
              (match (list-get items 1)
                ((some min-expr)
                  (match (deref min-expr)
                    ((number n)
                      (match (list-get items 3)
                        ((some max-expr)
                          (match (deref max-expr)
                            ((number m)
                              (RangeBoundsInfo
                                true
                                (. n int-value)
                                true
                                (. m int-value)))
                            (_ (RangeBoundsInfo true (. n int-value) false 0))))
                        ((none) (RangeBoundsInfo true (. n int-value) false 0))))
                    (_ (RangeBoundsInfo false 0 false 0))))
                ((none) (RangeBoundsInfo false 0 false 0))))
            ((== len 3)
              (match (list-get items 1)
                ((some second)
                  (match (deref second)
                    ((number n) (RangeBoundsInfo true (. n int-value) false 0))
                    ((symbol s)
                      (if (string-eq (. s name) "..")
                        (match (list-get items 2)
                          ((some max-expr)
                            (match (deref max-expr)
                              ((number m)
                                (RangeBoundsInfo false 0 true (. m int-value)))
                              (_ (RangeBoundsInfo false 0 false 0))))
                          ((none) (RangeBoundsInfo false 0 false 0)))
                        (RangeBoundsInfo false 0 false 0)))
                    (_ (RangeBoundsInfo false 0 false 0))))
                ((none) (RangeBoundsInfo false 0 false 0))))
            (else (RangeBoundsInfo false 0 false 0)))))
      (_ (RangeBoundsInfo false 0 false 0))))

  (fn select-int-type ((has-min Bool) (min-val I64) (has-max Bool) (max-val I64))
    (@intent "Select smallest C integer type that fits the range")
    (@spec ((Bool I64 Bool I64) -> String))
    (@pure)
    (cond
      ((and has-min (>= min-val 0))
        (cond
          ((and has-max (<= max-val 255)) "uint8_t")
          ((and has-max (<= max-val 65535)) "uint16_t")
          ((and has-max (<= max-val 4294967295)) "uint32_t")
          (else "uint64_t")))
      ((and has-min (>= min-val -128) has-max (<= max-val 127))
        "int8_t")
      ((and has-min (>= min-val -32768) has-max (<= max-val 32767))
        "int16_t")
      ((and has-min (>= min-val -2147483648) has-max (<= max-val 2147483647))
        "int32_t")
      (else "int64_t"))))
