;; ============================================================
;; SLOP Native Transpiler - C Type Module
;;
;; SLOP type â†’ C type conversion, identifier mangling,
;; and builtin type mappings.
;; ============================================================

(module ctype
  (export
    ;; Type conversion
    to-c-type to-c-name type-to-identifier
    ;; Builtin type lookup
    builtin-type-c is-builtin-type is-builtin-c-type
    ;; C keyword check
    is-c-keyword)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import strlib (replace replace-all starts-with substring))

  ;; ============================================================
  ;; C Keywords (must be escaped in identifiers)
  ;; ============================================================

  (fn is-c-keyword ((name String))
    (@intent "Check if name is a C reserved keyword")
    (@spec ((String) -> Bool))
    (@example ("int") -> true)
    (@example ("foo") -> false)
    (or (string-eq name "auto")
        (string-eq name "break")
        (string-eq name "case")
        (string-eq name "char")
        (string-eq name "const")
        (string-eq name "continue")
        (string-eq name "default")
        (string-eq name "do")
        (string-eq name "double")
        (string-eq name "else")
        (string-eq name "enum")
        (string-eq name "extern")
        (string-eq name "float")
        (string-eq name "for")
        (string-eq name "goto")
        (string-eq name "if")
        (string-eq name "int")
        (string-eq name "long")
        (string-eq name "register")
        (string-eq name "return")
        (string-eq name "short")
        (string-eq name "signed")
        (string-eq name "sizeof")
        (string-eq name "static")
        (string-eq name "struct")
        (string-eq name "switch")
        (string-eq name "typedef")
        (string-eq name "union")
        (string-eq name "unsigned")
        (string-eq name "void")
        (string-eq name "volatile")
        (string-eq name "while")
        (string-eq name "inline")
        (string-eq name "restrict")))

  ;; ============================================================
  ;; Builtin Type Mapping
  ;; ============================================================

  (fn is-builtin-type ((name String))
    (@intent "Check if name is a builtin SLOP type")
    (@spec ((String) -> Bool))
    (@example ("Int") -> true)
    (@example ("MyRecord") -> false)
    (or (string-eq name "Int")
        (string-eq name "I8")
        (string-eq name "I16")
        (string-eq name "I32")
        (string-eq name "I64")
        (string-eq name "U8")
        (string-eq name "U16")
        (string-eq name "U32")
        (string-eq name "U64")
        (string-eq name "Char")
        (string-eq name "Float")
        (string-eq name "F32")
        (string-eq name "Bool")
        (string-eq name "String")
        (string-eq name "Bytes")
        (string-eq name "Unit")
        (string-eq name "Void")
        (string-eq name "Arena")
        (string-eq name "Milliseconds")))

  (fn is-builtin-c-type ((c-name String))
    (@intent "Check if name is a builtin C type (int64_t, slop_string, etc.)")
    (@spec ((String) -> Bool))
    (@example ("int64_t") -> true)
    (@example ("slop_string") -> true)
    (@example ("MyRecord") -> false)
    (or (string-eq c-name "int64_t")
        (string-eq c-name "int32_t")
        (string-eq c-name "int16_t")
        (string-eq c-name "int8_t")
        (string-eq c-name "uint64_t")
        (string-eq c-name "uint32_t")
        (string-eq c-name "uint16_t")
        (string-eq c-name "uint8_t")
        (string-eq c-name "double")
        (string-eq c-name "float")
        (string-eq c-name "bool")
        (string-eq c-name "char")
        (string-eq c-name "void")
        (string-eq c-name "slop_string")
        (string-eq c-name "slop_bytes")
        (string-eq c-name "slop_arena")
        (string-eq c-name "slop_arena*")))

  (fn builtin-type-c ((arena Arena) (name String))
    (@intent "Get C type for a builtin SLOP type")
    (@spec ((Arena String) -> (Option String)))
    (@example (arena "Int") -> (some "int64_t"))
    (@example (arena "String") -> (some "slop_string"))
    (@example (arena "MyRecord") -> none)
    (cond
      ((string-eq name "Int") (some "int64_t"))
      ((string-eq name "I8") (some "int8_t"))
      ((string-eq name "I16") (some "int16_t"))
      ((string-eq name "I32") (some "int32_t"))
      ((string-eq name "I64") (some "int64_t"))
      ((string-eq name "U8") (some "uint8_t"))
      ((string-eq name "U16") (some "uint16_t"))
      ((string-eq name "U32") (some "uint32_t"))
      ((string-eq name "U64") (some "uint64_t"))
      ((string-eq name "Char") (some "char"))
      ((string-eq name "Float") (some "double"))
      ((string-eq name "F32") (some "float"))
      ((string-eq name "Bool") (some "uint8_t"))
      ((string-eq name "String") (some "slop_string"))
      ((string-eq name "Bytes") (some "slop_bytes"))
      ((string-eq name "Unit") (some "void"))
      ((string-eq name "Void") (some "void"))
      ((string-eq name "Arena") (some "slop_arena*"))
      ((string-eq name "Milliseconds") (some "int64_t"))
      (else none)))

  ;; ============================================================
  ;; Identifier Conversion
  ;; ============================================================

  (fn to-c-name ((arena Arena) (name String))
    (@intent "Convert SLOP identifier to valid C name")
    (@spec ((Arena String) -> String))
    (@example (arena "foo-bar") -> "foo_bar")
    (@example (arena "empty?") -> "empty_p")
    (@example (arena "set!") -> "set_x")
    (@example (arena "int") -> "slop_int")
    ;; Replace special characters using strlib's replace-all
    (let ((mut result (replace-all arena name "-" "_")))
      (set! result (replace-all arena result "?" "_p"))
      (set! result (replace-all arena result "!" "_x"))
      (set! result (replace-all arena result "$" "_"))
      ;; Escape C keywords
      (if (is-c-keyword result)
        (string-concat arena "slop_" result)
        result)))

  (fn type-to-identifier ((arena Arena) (c-type String))
    (@intent "Convert C type to valid identifier component for container type names")
    (@spec ((Arena String) -> String))
    (@example (arena "int64_t") -> "int")
    (@example (arena "slop_string") -> "string")
    (@example (arena "MyRecord*") -> "MyRecord_ptr")
    (@example (arena "void*") -> "void_ptr")
    ;; Replace pointer with _ptr suffix
    (let ((mut result (replace arena c-type "*" "_ptr")))
      (set! result (replace arena result " " "_"))
      ;; Strip slop_ prefix for cleaner container names (5 = len("slop_"))
      (when (starts-with result "slop_")
        (let ((len-minus-5 (cast (Int 0 ..) (- (string-len result) 5))))
          (set! result (substring arena result 5 len-minus-5))))
      ;; Normalize int64_t to int for runtime compatibility
      (when (string-eq result "int64_t")
        (set! result "int"))
      result))

  ;; ============================================================
  ;; Type Conversion (SExpr -> C type string)
  ;; ============================================================

  (fn to-c-type ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Convert SLOP type expression to C type string")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@example (arena (parse-type "Int")) -> "int64_t")
    (@example (arena (parse-type "(Ptr Int)")) -> "int64_t*")
    (@example (arena (parse-type "(Option String)")) -> "slop_option_string")
    (@pre {expr != nil})
    (match (deref expr)
      ;; Symbol: builtin type or user-defined type name
      ((symbol sym)
        (let ((name (. sym name)))
          (match (builtin-type-c arena name)
            ((some c-type) c-type)
            ;; Not a builtin - return as-is (user type)
            ((none) (to-c-name arena name)))))
      ;; List: compound type like (Ptr T), (Option T), etc.
      ((list lst)
        (to-c-type-compound arena (. lst items)))
      ;; Other forms shouldn't appear as types
      ((string _) "void*")
      ((number _) "void*")))

  (fn to-c-type-compound ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Convert SLOP compound type to C type string")
    (@spec ((Arena (List (Ptr SExpr))) -> String))
    (let ((len (list-len items)))
      (if (< len 1)
        "void*"
        (match (list-get items 0)
          ((some first-expr)
            (match (deref first-expr)
              ((symbol head-sym)
                (let ((head (. head-sym name)))
                  (cond
                    ;; (Ptr T) -> T*
                    ((string-eq head "Ptr")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (ScopedPtr T) -> T* (same as Ptr in C)
                    ((string-eq head "ScopedPtr")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (Option T) -> slop_option_<inner>
                    ((string-eq head "Option")
                      (if (< len 2)
                        "slop_option_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_option_" inner-id)))
                          ((none) "slop_option_void"))))

                    ;; (Result T E) -> slop_result_<ok>_<err>
                    ((string-eq head "Result")
                      (let ((ok-id (if (< len 2)
                                      "void"
                                      (match (list-get items 1)
                                        ((some ok-expr)
                                          (type-to-identifier arena (to-c-type arena ok-expr)))
                                        ((none) "void"))))
                            (err-id (if (< len 3)
                                       "slop_error"
                                       (match (list-get items 2)
                                         ((some err-expr)
                                           (type-to-identifier arena (to-c-type arena err-expr)))
                                         ((none) "slop_error")))))
                        (string-concat arena
                          (string-concat arena "slop_result_" ok-id)
                          (string-concat arena "_" err-id))))

                    ;; (List T) -> slop_list_<inner>
                    ((string-eq head "List")
                      (if (< len 2)
                        "slop_list_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_list_" inner-id)))
                          ((none) "slop_list_void"))))

                    ;; (Map K V) -> slop_map* (generic for now)
                    ((string-eq head "Map")
                      "slop_map*")

                    ;; (Array T size) -> T*
                    ((string-eq head "Array")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (Chan T) -> slop_chan_<inner>
                    ((string-eq head "Chan")
                      (if (< len 2)
                        "slop_chan_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_chan_" inner-id)))
                          ((none) "slop_chan_void"))))

                    ;; (Thread T) -> slop_thread_<inner>
                    ((string-eq head "Thread")
                      (if (< len 2)
                        "slop_thread_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_thread_" inner-id)))
                          ((none) "slop_thread_void"))))

                    ;; (Fn (args...) return) -> return_type(*)(arg_types...)
                    ((string-eq head "Fn")
                      (if (< len 2)
                        "void*"
                        ;; Return type is the last item
                        (let ((ret-type (match (list-get items (- len 1))
                                          ((some ret) (to-c-type arena ret))
                                          ((none) "void"))))
                          ;; Build argument list from items 1 to len-2
                          (if (= len 2)
                            ;; (Fn RetType) - no args list
                            (string-concat arena ret-type "(*)(void)")
                            ;; (Fn (args...) RetType)
                            (match (list-get items 1)
                              ((some args-expr)
                                (let ((args-str (build-fn-args-str arena args-expr)))
                                  (string-concat arena
                                    (string-concat arena ret-type "(*)")
                                    args-str)))
                              ((none) (string-concat arena ret-type "(*)(void)")))))))

                    ;; Default: treat as type name
                    (else
                      (match (builtin-type-c arena head)
                        ((some c-type) c-type)
                        ((none) (to-c-name arena head)))))))
              ;; Not a symbol head
              (_ "void*")))
          ((none) "void*")))))

(fn build-fn-args-str ((arena Arena) (args-expr (Ptr SExpr)))
  (@intent "Build C function argument string from SLOP Fn args list")
  (@spec ((Arena (Ptr SExpr)) -> String))
  (match (deref args-expr)
    ((list args-list)
      (let ((arg-items (. args-list items))
            (arg-count (list-len arg-items)))
        (if (= arg-count 0)
          "(void)"
          ;; Build comma-separated args
          (let ((mut result "(")
                (mut i 0))
            (while (< i arg-count)
              (match (list-get arg-items i)
                ((some arg-expr)
                  (let ((arg-type (to-c-type arena arg-expr)))
                    (if (> i 0)
                      (set! result (string-concat arena result (string-concat arena ", " arg-type)))
                      (set! result (string-concat arena result arg-type)))))
                ((none) ()))
              (set! i (+ i 1)))
            (string-concat arena result ")")))))
    ;; Not a list - treat as void
    (_ "(void)")))

) ;; end module
