(module ctype
  (export
    to-c-type
    is-pointer-type
    is-string-type
    is-void-type
    is-option-type
    is-result-type
    is-list-type
    is-map-type
    get-range-bounds
    select-int-type
    get-inner-type
    get-result-types
    get-map-types)
  (import parser (SExpr SExprList SExprSymbol SExprNumber is-form))
  (import context
    (TranspileContext ctx-lookup-type ctx-register-option ctx-register-result ctx-register-list ctx-register-map
     ctx-lookup-array-element))
  (import names (to-c-type-name to-qualified-type-name type-to-identifier))

  (type ResultTypePair (record (ok (Ptr SExpr)) (err (Ptr SExpr))))

  (type MapTypePair (record (key (Ptr SExpr)) (val (Ptr SExpr))))

  (type RangeBoundsInfo (record
      (has-min Bool)
      (min-val I64)
      (has-max Bool)
      (max-val I64)))

  ;; Helper function to look up builtin type mappings
  ;; Uses cond chain because const map literals can't be transpiled to C
  (fn lookup-builtin-type ((name String))
    (@intent "Look up C type for a builtin SLOP type")
    (@spec ((String) -> (Option String)))
    (@pure)
    (@example "Int" -> (some "int64_t"))
    (@example "Bool" -> (some "bool"))
    (@example "String" -> (some "slop_string"))
    (@example "U8" -> (some "uint8_t"))
    (@example "Unknown" -> (none))
    (cond
      ((string-eq name "Int") (some "int64_t"))
      ((string-eq name "I8") (some "int8_t"))
      ((string-eq name "I16") (some "int16_t"))
      ((string-eq name "I32") (some "int32_t"))
      ((string-eq name "I64") (some "int64_t"))
      ((string-eq name "U8") (some "uint8_t"))
      ((string-eq name "U16") (some "uint16_t"))
      ((string-eq name "U32") (some "uint32_t"))
      ((string-eq name "U64") (some "uint64_t"))
      ((string-eq name "Char") (some "char"))
      ((string-eq name "Float") (some "double"))
      ((string-eq name "F32") (some "float"))
      ((string-eq name "F64") (some "double"))
      ((string-eq name "Bool") (some "bool"))
      ((string-eq name "String") (some "slop_string"))
      ((string-eq name "Bytes") (some "slop_bytes"))
      ((string-eq name "Unit") (some "void"))
      ((string-eq name "Void") (some "void"))
      ((string-eq name "Arena") (some "slop_arena*"))
      ((string-eq name "Milliseconds") (some "int64_t"))
      (else (none))))

  (fn to-c-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Convert SLOP type expression to C type string")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= type-expr nil))
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((symbol sym)
          (let ((name (. sym name)))
            (match (lookup-builtin-type name)
              ((some c-type) c-type)
              ((none)
                ;; User-defined type - use qualified name with module prefix
                (to-qualified-type-name arena ctx name)))))
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol s)
                    (let ((op (. s name)))
                      (cond
                        ((string-eq op "Ptr")
                          (match (list-get items 1)
                            ((some inner)
                              ;; Check if inner type is an array type alias
                              (match (deref inner)
                                ((symbol inner-sym)
                                  ;; Look up if this is an array type
                                  (match (ctx-lookup-array-element ctx (. inner-sym name))
                                    ((some elem-type)
                                      ;; Array type - use element pointer: int64_t*
                                      (string-concat arena elem-type "*"))
                                    ((none)
                                      ;; Not an array type - normal handling
                                      (string-concat arena (to-c-type ctx inner) "*"))))
                                (_ ;; Inner is a complex expression, use normal handling
                                   (string-concat arena (to-c-type ctx inner) "*"))))
                            ((none) "void*")))
                        ((string-eq op "Option")
                          (match (list-get items 1)
                            ((some inner)
                              (let ((inner-c (to-c-type ctx inner))
                                    (inner-id (type-to-identifier arena inner-c))
                                    (opt-name (string-concat arena "slop_option_" inner-id)))
                                (do
                                  (ctx-register-option ctx opt-name inner-c)
                                  opt-name)))
                            ((none) "slop_option_void")))
                        ((string-eq op "Result")
                          (match (list-get items 1)
                            ((some ok-expr)
                              (match (list-get items 2)
                                ((some err-expr)
                                  (let ((ok-c (to-c-type ctx ok-expr))
                                        (err-c (to-c-type ctx err-expr))
                                        (ok-id (type-to-identifier arena ok-c))
                                        (err-id (type-to-identifier arena err-c))
                                        (mid (string-concat arena ok-id "_"))
                                        (suffix (string-concat arena mid err-id))
                                        (res-name (string-concat arena "slop_result_" suffix)))
                                    (do
                                      (ctx-register-result ctx res-name ok-c err-c)
                                      res-name)))
                                ((none) "slop_result_void_void")))
                            ((none) "slop_result_void_void")))
                        ((string-eq op "List")
                          (match (list-get items 1)
                            ((some elem-expr)
                              (let ((elem-c (to-c-type ctx elem-expr))
                                    (elem-id (type-to-identifier arena elem-c))
                                    (list-name (string-concat arena "slop_list_" elem-id)))
                                (do
                                  (ctx-register-list ctx list-name elem-c)
                                  list-name)))
                            ((none) "slop_list_void")))
                        ((string-eq op "Map")
                          (match (list-get items 1)
                            ((some key-expr)
                              (match (list-get items 2)
                                ((some val-expr)
                                  (let ((key-c (to-c-type ctx key-expr))
                                        (val-c (to-c-type ctx val-expr))
                                        (key-id (type-to-identifier arena key-c))
                                        (val-id (type-to-identifier arena val-c))
                                        (mid (string-concat arena key-id "_"))
                                        (suffix (string-concat arena mid val-id))
                                        (map-name (string-concat arena "slop_map_" suffix)))
                                    (do
                                      (ctx-register-map ctx map-name key-c val-c)
                                      map-name)))
                                ((none) "slop_map_void_void")))
                            ((none) "slop_map_void_void")))
                        ((string-eq op "Int")
                          (if (> (list-len items) 1)
                            (let ((bounds (get-range-bounds type-expr)))
                              (select-int-type
                                (. bounds has-min)
                                (. bounds min-val)
                                (. bounds has-max)
                                (. bounds max-val)))
                            "int64_t"))
                        ((string-eq op "Array") (to-c-type-name arena "array"))
                        (else (to-c-type-name arena op)))))
                  (_ "void")))
              ((none) "void"))))
        (_ "void"))))

  (fn is-pointer-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Ptr T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Ptr"))

  (fn is-string-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is String")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((symbol sym) (string-eq (. sym name) "String"))
      (_ false)))

  (fn is-void-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is Unit or Void")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((symbol sym)
        (or (string-eq (. sym name) "Unit") (string-eq (. sym name) "Void")))
      (_ false)))

  (fn is-option-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Option T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Option"))

  (fn is-result-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Result T E)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Result"))

  (fn is-list-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (List T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "List"))

  (fn is-map-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is (Map K V)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= type-expr nil))
    (@pure)
    (is-form type-expr "Map"))

  (fn get-inner-type ((type-expr (Ptr SExpr)))
    (@intent "Get inner type from Option, List, or Ptr")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst) (list-get (. lst items) 1))
      (_ (none))))

  (fn get-result-types ((type-expr (Ptr SExpr)))
    (@intent "Get Ok and Error types from Result")
    (@spec (((Ptr SExpr)) -> (Option ResultTypePair)))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (>= (list-len items) 3)
            (match (list-get items 1)
              ((some ok-type)
                (match (list-get items 2)
                  ((some err-type) (some (ResultTypePair ok-type err-type)))
                  ((none) (none))))
              ((none) (none)))
            (none))))
      (_ (none))))

  (fn get-map-types ((type-expr (Ptr SExpr)))
    (@intent "Get Key and Value types from Map")
    (@spec (((Ptr SExpr)) -> (Option MapTypePair)))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (>= (list-len items) 3)
            (match (list-get items 1)
              ((some key-type)
                (match (list-get items 2)
                  ((some val-type) (some (MapTypePair key-type val-type)))
                  ((none) (none))))
              ((none) (none)))
            (none))))
      (_ (none))))

  (fn get-range-bounds ((type-expr (Ptr SExpr)))
    (@intent "Extract min/max bounds from range type (Int min .. max)")
    (@spec (((Ptr SExpr)) -> RangeBoundsInfo))
    (@pre (!= type-expr nil))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (cond
            ((== len 4)
              (match (list-get items 1)
                ((some min-expr)
                  (match (deref min-expr)
                    ((number n)
                      (match (list-get items 3)
                        ((some max-expr)
                          (match (deref max-expr)
                            ((number m)
                              (RangeBoundsInfo
                                true
                                (. n int-value)
                                true
                                (. m int-value)))
                            (_ (RangeBoundsInfo true (. n int-value) false 0))))
                        ((none) (RangeBoundsInfo true (. n int-value) false 0))))
                    (_ (RangeBoundsInfo false 0 false 0))))
                ((none) (RangeBoundsInfo false 0 false 0))))
            ((== len 3)
              (match (list-get items 1)
                ((some second)
                  (match (deref second)
                    ((number n) (RangeBoundsInfo true (. n int-value) false 0))
                    ((symbol s)
                      (if (string-eq (. s name) "..")
                        (match (list-get items 2)
                          ((some max-expr)
                            (match (deref max-expr)
                              ((number m)
                                (RangeBoundsInfo false 0 true (. m int-value)))
                              (_ (RangeBoundsInfo false 0 false 0))))
                          ((none) (RangeBoundsInfo false 0 false 0)))
                        (RangeBoundsInfo false 0 false 0)))
                    (_ (RangeBoundsInfo false 0 false 0))))
                ((none) (RangeBoundsInfo false 0 false 0))))
            (else (RangeBoundsInfo false 0 false 0)))))
      (_ (RangeBoundsInfo false 0 false 0))))

  (fn select-int-type ((has-min Bool) (min-val I64) (has-max Bool) (max-val I64))
    (@intent "Select smallest C integer type that fits the range")
    (@spec ((Bool I64 Bool I64) -> String))
    (@pure)
    (@example true 0 true 255 -> "uint8_t")
    (@example true 0 true 65535 -> "uint16_t")
    (@example true -128 true 127 -> "int8_t")
    (@example false 0 false 0 -> "int64_t")
    (cond
      ((and has-min (>= min-val 0))
        (cond
          ((and has-max (<= max-val 255)) "uint8_t")
          ((and has-max (<= max-val 65535)) "uint16_t")
          ((and has-max (<= max-val 4294967295)) "uint32_t")
          (else "uint64_t")))
      ((and has-min (>= min-val -128) has-max (<= max-val 127))
        "int8_t")
      ((and has-min (>= min-val -32768) has-max (<= max-val 32767))
        "int16_t")
      ((and has-min (>= min-val -2147483648) has-max (<= max-val 2147483647))
        "int32_t")
      (else "int64_t"))))
