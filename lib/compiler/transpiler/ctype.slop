;; ============================================================
;; SLOP Native Transpiler - C Type Mapping
;;
;; Converts SLOP types to C type strings. Handles:
;; - Primitive types (Int, Bool, String, U8, I64, etc.)
;; - Range types with optimal C integer selection
;; - Pointer, array, and container types
;; - Module-qualified naming
;; ============================================================

(module ctype
  (export
    ;; Primitive type conversion
    slop-type-to-c primitive-to-c
    ;; Range type optimization
    range-to-c-int optimal-int-type
    ;; Name mangling
    mangle-identifier mangle-type-name mangle-fn-name
    ;; Qualified names
    qualified-type-name qualified-fn-name
    ;; Type predicates
    is-primitive-type is-builtin-type needs-pointer-access)

  (import types (SExpr RangeBounds ResolvedType ResolvedTypeKind))
  (import context (TranspileContext ctx-get-module ctx-prefixing-enabled))
  (import strlib (char-at AsciiChar))

  ;; ============================================================
  ;; Primitive Type Mapping
  ;; ============================================================

  (fn primitive-to-c ((name String))
    (@intent "Convert SLOP primitive type name to C type")
    (@spec ((String) -> String))
    (@pure)
    (@example ("Int") -> "int64_t")
    (@example ("Bool") -> "uint8_t")
    (@example ("String") -> "slop_string")
    (@example ("Float") -> "double")
    (@example ("U8") -> "uint8_t")
    (@example ("I64") -> "int64_t")
    (cond
      ((string-eq name "Int") "int64_t")
      ((string-eq name "I8") "int8_t")
      ((string-eq name "I16") "int16_t")
      ((string-eq name "I32") "int32_t")
      ((string-eq name "I64") "int64_t")
      ((string-eq name "U8") "uint8_t")
      ((string-eq name "U16") "uint16_t")
      ((string-eq name "U32") "uint32_t")
      ((string-eq name "U64") "uint64_t")
      ((string-eq name "Bool") "uint8_t")
      ((string-eq name "Float") "double")
      ((string-eq name "Char") "char")
      ((string-eq name "String") "slop_string")
      ((string-eq name "Unit") "void")
      ((string-eq name "Arena") "slop_arena*")
      (else name)))

  (fn is-primitive-type ((name String))
    (@intent "Check if type name is a primitive type")
    (@spec ((String) -> Bool))
    (@pure)
    (@example ("Int") -> true)
    (@example ("MyRecord") -> false)
    (or (string-eq name "Int")
        (string-eq name "I8")
        (string-eq name "I16")
        (string-eq name "I32")
        (string-eq name "I64")
        (string-eq name "U8")
        (string-eq name "U16")
        (string-eq name "U32")
        (string-eq name "U64")
        (string-eq name "Bool")
        (string-eq name "Float")
        (string-eq name "Char")
        (string-eq name "String")
        (string-eq name "Unit")
        (string-eq name "Arena")))

  (fn is-builtin-type ((name String))
    (@intent "Check if type name is a builtin (primitive or container)")
    (@spec ((String) -> Bool))
    (@pure)
    (@example ("Int") -> true)
    (@example ("List") -> true)
    (@example ("MyRecord") -> false)
    (or (is-primitive-type name)
        (string-eq name "Ptr")
        (string-eq name "List")
        (string-eq name "Map")
        (string-eq name "Option")
        (string-eq name "Result")
        (string-eq name "Array")))

  ;; ============================================================
  ;; Range Type Optimization
  ;; ============================================================

  (fn optimal-int-type ((bounds RangeBounds))
    (@intent "Select smallest C integer type that can hold the range")
    (@spec ((RangeBounds) -> String))
    (@pure)
    (@example ((RangeBounds true false 0 0)) -> "uint64_t")
    (@example ((RangeBounds true true 0 255)) -> "uint8_t")
    (@example ((RangeBounds true true -128 127)) -> "int8_t")
    (let ((has-min (. bounds has-min))
          (has-max (. bounds has-max))
          (min-val (. bounds min-val))
          (max-val (. bounds max-val)))
      (cond
        ;; Unbounded or semi-bounded - use int64_t
        ((not has-max) "int64_t")
        ((not has-min) "int64_t")
        ;; Check if unsigned (min >= 0)
        ((>= min-val 0)
          (cond
            ((<= max-val 255) "uint8_t")
            ((<= max-val 65535) "uint16_t")
            ((<= max-val 4294967295) "uint32_t")
            (else "uint64_t")))
        ;; Signed types
        (else
          (cond
            ((and (>= min-val -128) (<= max-val 127)) "int8_t")
            ((and (>= min-val -32768) (<= max-val 32767)) "int16_t")
            ((and (>= min-val -2147483648) (<= max-val 2147483647)) "int32_t")
            (else "int64_t"))))))

  (fn range-to-c-int ((bounds RangeBounds))
    (@intent "Convert range bounds to optimal C integer type")
    (@spec ((RangeBounds) -> String))
    (@pure)
    (optimal-int-type bounds))

  ;; ============================================================
  ;; Name Mangling
  ;; ============================================================

  (fn mangle-identifier ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert SLOP identifier to valid C identifier")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (@pre {(string-len name) > 0})
    (@example (ctx "my-func") -> "my_func")
    (@example (ctx "set!") -> "set_bang")
    (@example (ctx "nil?") -> "nil_p")
    (let ((arena (. (deref ctx) arena))
          (len (string-len name))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (let ((c (char-at name (cast (Int 0 ..) i))))
          (cond
            ((== c 45)  ;; '-' -> '_'
              (set! result (string-concat arena result "_")))
            ((== c 33)  ;; '!' -> '_bang'
              (set! result (string-concat arena result "_bang")))
            ((== c 63)  ;; '?' -> '_p'
              (set! result (string-concat arena result "_p")))
            ((== c 62)  ;; '>' -> '_gt'
              (set! result (string-concat arena result "_gt")))
            ((== c 60)  ;; '<' -> '_lt'
              (set! result (string-concat arena result "_lt")))
            ((== c 61)  ;; '=' -> '_eq'
              (set! result (string-concat arena result "_eq")))
            ((== c 43)  ;; '+' -> '_plus'
              (set! result (string-concat arena result "_plus")))
            ((== c 42)  ;; '*' -> '_star'
              (set! result (string-concat arena result "_star")))
            ((== c 47)  ;; '/' -> '_slash'
              (set! result (string-concat arena result "_slash")))
            (else
              ;; Use string-slice to get single character as string
              (set! result (string-concat arena result (string-slice name i (+ i 1)))))))
        (set! i (+ i 1)))
      result))

  (fn mangle-type-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert SLOP type name to C type identifier")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (@pre {(string-len name) > 0})
    (@example (ctx "MyType") -> "MyType")
    (@example (ctx "parse-result") -> "parse_result")
    (mangle-identifier ctx name))

  (fn mangle-fn-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert SLOP function name to C function identifier")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (@pre {(string-len name) > 0})
    (@example (ctx "my-function") -> "my_function")
    (@example (ctx "empty?") -> "empty_p")
    (mangle-identifier ctx name))

  ;; ============================================================
  ;; Qualified Names
  ;; ============================================================

  (fn qualified-type-name ((ctx (Ptr TranspileContext)) (type-name String))
    (@intent "Generate qualified C type name with module prefix if enabled")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (@example (ctx "SExpr") -> "parser_SExpr")
    (let ((arena (. (deref ctx) arena))
          (mangled (mangle-type-name ctx type-name)))
      (if (ctx-prefixing-enabled ctx)
        (match (ctx-get-module ctx)
          ((some mod-name)
            (string-concat arena (string-concat arena (mangle-identifier ctx mod-name) "_") mangled))
          ((none) mangled))
        mangled)))

  (fn qualified-fn-name ((ctx (Ptr TranspileContext)) (fn-name String))
    (@intent "Generate qualified C function name with module prefix if enabled")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (@example (ctx "parse") -> "parser_parse")
    (let ((arena (. (deref ctx) arena))
          (mangled (mangle-fn-name ctx fn-name)))
      (if (ctx-prefixing-enabled ctx)
        (match (ctx-get-module ctx)
          ((some mod-name)
            (string-concat arena (string-concat arena (mangle-identifier ctx mod-name) "_") mangled))
          ((none) mangled))
        mangled)))

  ;; ============================================================
  ;; Type Conversion
  ;; ============================================================

  (fn slop-type-to-c ((ctx (Ptr TranspileContext)) (typ (Ptr ResolvedType)))
    (@intent "Convert resolved SLOP type to C type string")
    (@spec (((Ptr TranspileContext) (Ptr ResolvedType)) -> String))
    (@pre {ctx != nil})
    (@pre {typ != nil})
    (@example (ctx int-type) -> "int64_t")
    (@example (ctx ptr-to-sexpr) -> "parser_SExpr*")
    (let ((arena (. (deref ctx) arena))
          (kind (. (deref typ) kind))
          (name (. (deref typ) name)))
      (cond
        ;; Primitive types
        ((== kind 'rk-primitive)
          (primitive-to-c name))
        ;; Range types
        ((== kind 'rk-range)
          (match (. (deref typ) range)
            ((some bounds) (range-to-c-int bounds))
            ((none) "int64_t")))
        ;; Pointer types
        ((== kind 'rk-ptr)
          (match (. (deref typ) inner-type)
            ((some inner)
              (string-concat arena (slop-type-to-c ctx inner) "*"))
            ((none) "void*")))
        ;; List types
        ((== kind 'rk-list)
          (match (. (deref typ) inner-type)
            ((some inner)
              (string-concat arena "slop_list_" (slop-type-to-c ctx inner)))
            ((none) "slop_list")))
        ;; Option types
        ((== kind 'rk-option)
          (match (. (deref typ) inner-type)
            ((some inner)
              (string-concat arena "slop_option_" (slop-type-to-c ctx inner)))
            ((none) "slop_option")))
        ;; Result types
        ((== kind 'rk-result)
          (match (. (deref typ) inner-type)
            ((some ok-type)
              (match (. (deref typ) inner-type2)
                ((some err-type)
                  (string-concat arena (string-concat arena "slop_result_" (slop-type-to-c ctx ok-type))
                                 (string-concat arena "_" (slop-type-to-c ctx err-type))))
                ((none) (string-concat arena "slop_result_" (slop-type-to-c ctx ok-type)))))
            ((none) "slop_result")))
        ;; Map types
        ((== kind 'rk-map)
          "slop_map")
        ;; Array types
        ((== kind 'rk-array)
          (match (. (deref typ) inner-type)
            ((some inner)
              (string-concat arena (slop-type-to-c ctx inner) "*"))
            ((none) "void*")))
        ;; User-defined types (record, union, enum)
        (else
          (qualified-type-name ctx name)))))

  (fn needs-pointer-access ((typ (Ptr ResolvedType)))
    (@intent "Check if field access on this type needs -> instead of .")
    (@spec (((Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre {typ != nil})
    (@example (ptr-type) -> true)
    (@example (record-type) -> false)
    (== (. (deref typ) kind) 'rk-ptr)))
