;; ============================================================
;; SLOP Transpiler - Generic Type Instantiation
;;
;; Generate C code for Option, Result, List, and Map types
;; that were registered during type conversion.
;; ============================================================

(module generic
  (export
    emit-generated-types
    is-runtime-predefined
    make-option-name make-result-name make-list-name make-map-name)

  (import context (TranspileContext
                   ctx-get-options ctx-get-results
                   ctx-get-lists ctx-get-maps
                   ctx-is-emitted ctx-mark-emitted))
  (import emit (Emitter emit-line emit-blank emit-guard-start emit-guard-end))
  (import names (type-to-identifier))
  (import strlib (string-eq string-concat to-upper))

  ;; ============================================================
  ;; Runtime Predefined Types
  ;; ============================================================

  ;; Types already defined in slop_runtime.h - don't emit
  (const RUNTIME_PREDEFINED (List String)
    (list
      ;; Option types
      "slop_option_int" "slop_option_float" "slop_option_string"
      "slop_option_ptr" "slop_option_bool"
      ;; Result types
      "slop_result_int" "slop_result_ptr" "slop_result_string"
      "slop_result_void"
      ;; List types
      "slop_list_int" "slop_list_float" "slop_list_string"
      "slop_list_ptr" "slop_list_u8"
      ;; Map types
      "slop_map_string_string" "slop_map_string_int"
      "slop_map_string_ptr"))

  (fn is-runtime-predefined ((type-name String))
    (@intent "Check if type is predefined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (@pure)
    (let ((mut i 0)
          (len (cast Int (list-len RUNTIME_PREDEFINED))))
      (while (< i len)
        (do
          (match (list-get RUNTIME_PREDEFINED i)
            ((some item) (when (string-eq item type-name) (return true)))
            ((none) ()))
          (set! i (+ i 1))))
      false))

  ;; ============================================================
  ;; Type Name Generation
  ;; ============================================================

  (fn make-option-name ((inner-type String))
    (@intent "Generate Option type name from inner type")
    (@spec ((String) -> String))
    (@pure)
    ;; slop_option_<normalized_inner>
    (with-arena 256
      (string-concat arena "slop_option_" (type-to-identifier inner-type))))

  (fn make-result-name ((ok-type String) (err-type String))
    (@intent "Generate Result type name from ok and error types")
    (@spec ((String String) -> String))
    (@pure)
    ;; slop_result_<ok>_<err>
    (with-arena 256
      (let ((ok-id (type-to-identifier ok-type))
            (err-id (type-to-identifier err-type))
            (prefix (string-concat arena "slop_result_" ok-id)))
        (string-concat arena prefix (string-concat arena "_" err-id)))))

  (fn make-list-name ((elem-type String))
    (@intent "Generate List type name from element type")
    (@spec ((String) -> String))
    (@pure)
    ;; slop_list_<normalized_elem>
    (with-arena 256
      (string-concat arena "slop_list_" (type-to-identifier elem-type))))

  (fn make-map-name ((key-type String) (val-type String))
    (@intent "Generate Map type name from key and value types")
    (@spec ((String String) -> String))
    (@pure)
    ;; slop_map_<key>_<val>
    (with-arena 256
      (let ((key-id (type-to-identifier key-type))
            (val-id (type-to-identifier val-type))
            (prefix (string-concat arena "slop_map_" key-id)))
        (string-concat arena prefix (string-concat arena "_" val-id)))))

  ;; ============================================================
  ;; Main Emission
  ;; ============================================================

  (fn emit-generated-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered generated type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (do
      (emit-line em "/* ===== Generated Generic Types ===== */")
      (emit-blank em)

      ;; Emit Option types first (no dependencies)
      (emit-option-types ctx em)

      ;; Emit List types (may depend on Options for list-get)
      (emit-list-types ctx em)

      ;; Emit Result types
      (emit-result-types ctx em)

      ;; Emit Map types last (most complex)
      (emit-map-types ctx em)

      (emit-blank em)))

  ;; ============================================================
  ;; Option Type Emission
  ;; ============================================================

  (fn emit-option-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Option type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((options (ctx-get-options ctx))
          (keys (map-keys options)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          (when (not (ctx-is-emitted ctx type-name))
            (match (map-get options type-name)
              ((some inner-type)
               (do
                 (emit-option-type em type-name inner-type)
                 (ctx-mark-emitted ctx type-name)))
              ((none) ())))))))

  (fn emit-option-type ((em (Ptr Emitter)) (type-name String) (inner-type String))
    (@intent "Emit single Option<T> typedef")
    (@spec (((Ptr Emitter) String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena)))
      ;; #ifndef GUARD
      ;; #define GUARD
      ;; typedef struct { bool has_value; T value; } type_name;
      ;; #endif
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena
            (string-concat arena
              (string-concat arena
                (string-concat arena "typedef struct { bool has_value; " inner-type)
                " value; } ")
              type-name)
            ";"))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; List Type Emission
  ;; ============================================================

  (fn emit-list-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered List type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((lists (ctx-get-lists ctx))
          (keys (map-keys lists)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          (when (not (ctx-is-emitted ctx type-name))
            (match (map-get lists type-name)
              ((some elem-type)
               (do
                 (emit-list-type em type-name elem-type)
                 (ctx-mark-emitted ctx type-name)))
              ((none) ())))))))

  (fn emit-list-type ((em (Ptr Emitter)) (type-name String) (elem-type String))
    (@intent "Emit single List<T> typedef")
    (@spec (((Ptr Emitter) String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena)))
      ;; typedef struct { T* data; size_t len; size_t cap; } type_name;
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena
            (string-concat arena
              (string-concat arena
                (string-concat arena "typedef struct { " elem-type)
                "* data; size_t len; size_t cap; } ")
              type-name)
            ";"))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Result Type Emission
  ;; ============================================================

  (fn emit-result-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Result type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((results (ctx-get-results ctx))
          (keys (map-keys results)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          (when (not (ctx-is-emitted ctx type-name))
            (match (map-get results type-name)
              ((some info)
               (do
                 (emit-result-type em type-name (. info ok) (. info err))
                 (ctx-mark-emitted ctx type-name)))
              ((none) ())))))))

  (fn emit-result-type ((em (Ptr Emitter)) (type-name String)
                        (ok-type String) (err-type String))
    (@intent "Emit single Result<T, E> typedef")
    (@spec (((Ptr Emitter) String String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena))
          (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type)))
      ;; typedef struct { bool is_ok; union { T ok; E err; } data; } type_name;
      ;; Handle void ok type (use uint8_t placeholder)
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena "typedef struct { bool is_ok; union { "
            (string-concat arena actual-ok-type
              (string-concat arena " ok; "
                (string-concat arena err-type
                  (string-concat arena " err; } data; } "
                    (string-concat arena type-name ";")))))))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Map Type Emission
  ;; ============================================================

  (fn emit-map-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Map type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((maps (ctx-get-maps ctx))
          (keys (map-keys maps)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          (when (not (ctx-is-emitted ctx type-name))
            (match (map-get maps type-name)
              ((some info)
               (do
                 (emit-map-type em type-name (. info key) (. info val))
                 (ctx-mark-emitted ctx type-name)))
              ((none) ())))))))

  (fn emit-map-type ((em (Ptr Emitter)) (type-name String)
                     (key-type String) (val-type String))
    (@intent "Emit single Map<K, V> typedef")
    (@spec (((Ptr Emitter) String String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena)))
      ;; For string keys, use SLOP_STRING_MAP_DEFINE macro
      ;; For other keys, emit custom struct
      (do
        (emit-guard-start em guard)
        (if (string-eq key-type "char*")
          (emit-line em
            (string-concat arena "SLOP_STRING_MAP_DEFINE("
              (string-concat arena type-name
                (string-concat arena ", "
                  (string-concat arena val-type ")")))))
          (emit-line em
            (string-concat arena "typedef struct { "
              (string-concat arena key-type
                (string-concat arena "* keys; "
                  (string-concat arena val-type
                    (string-concat arena "* vals; size_t len; size_t cap; } "
                      (string-concat arena type-name ";"))))))))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Helper Functions
  ;; ============================================================

  (fn make-guard-name ((type-name String))
    (@intent "Generate include guard name from type name")
    (@spec ((String) -> String))
    (@pure)
    ;; slop_option_string -> SLOP_OPTION_STRING_DEFINED
    (with-arena 256
      (string-concat arena (to-upper arena type-name) "_DEFINED"))))
