;; ============================================================
;; SLOP Transpiler - Generic Type Instantiation
;;
;; Generate C code for Option, Result, List, and Map types
;; that were registered during type conversion.
;; ============================================================

(module generic
  (export
    emit-generated-types
    emit-all-types-sorted
    is-runtime-predefined
    is-primitive-c-type
    make-option-name make-result-name make-list-name make-map-name
    TypeEntry TypeKindEnum)

  (import context (TranspileContext ResultTypeInfo MapTypeInfo
                   ctx-get-options ctx-get-results
                   ctx-get-lists ctx-get-maps
                   ctx-is-emitted ctx-mark-emitted
                   ctx-lookup-type-def ctx-lookup-type-module
                   ctx-set-module ctx-set-prefixing
                   ctx-register-enum-value ctx-register-fields
                   ctx-register-array-element))
  (import transpiler-types (CFieldInfo))
  (import emit (Emitter emit-line emit-blank emit-guard-start emit-guard-end indent dedent))
  (import names (type-to-identifier to-qualified-type-name to-c-name))
  (import ctype (to-c-type is-pointer-type))
  (import parser (SExpr SExprList SExprSymbol is-form))
  (import strlib (to-upper starts-with))

  ;; ============================================================
  ;; Type Entry for Topological Sort
  ;; ============================================================

  ;; Enum for type kinds
  (type TypeKindEnum (enum
    kind-option
    kind-result
    kind-list
    kind-map
    kind-record
    kind-union
    kind-enum
    kind-range
    kind-array))

  ;; Entry for topological sort - holds type info and dependencies
  (type TypeEntry (record
    (name String)                      ;; C type name
    (kind TypeKindEnum)                ;; What kind of type
    (deps (List String))               ;; By-value dependencies (C type names)
    (ast (Option (Ptr SExpr)))         ;; AST for record/union types
    (inner (Option String))            ;; For Option/List/Array: inner/element type
    (ok-type (Option String))          ;; For Result: ok type
    (err-type (Option String))         ;; For Result: err type
    (key-type (Option String))         ;; For Map: key type
    (val-type (Option String))         ;; For Map: value type
    (module-name (Option String))
    (base-type (Option String))
    (array-size (Option I64))))

  ;; ============================================================
  ;; Runtime Predefined Types
  ;; ============================================================

  ;; Check if type is predefined in slop_runtime.h
  ;; Uses cond chain because const list literals can't be transpiled to C
  (fn is-runtime-predefined ((type-name String))
    (@intent "Check if type is predefined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (@pure)
    (@example "slop_option_int" -> true)
    (@example "slop_list_string" -> true)
    (@example "my_custom_type" -> false)
    (cond
      ;; Option types
      ((string-eq type-name "slop_option_int") true)
      ((string-eq type-name "slop_option_float") true)
      ((string-eq type-name "slop_option_string") true)
      ((string-eq type-name "slop_option_ptr") true)
      ((string-eq type-name "slop_option_bool") true)
      ;; Result types
      ((string-eq type-name "slop_result_int") true)
      ((string-eq type-name "slop_result_ptr") true)
      ((string-eq type-name "slop_result_string") true)
      ((string-eq type-name "slop_result_void") true)
      ;; List types
      ((string-eq type-name "slop_list_int") true)
      ((string-eq type-name "slop_list_float") true)
      ((string-eq type-name "slop_list_string") true)
      ((string-eq type-name "slop_list_ptr") true)
      ((string-eq type-name "slop_list_u8") true)
      ;; Map types
      ((string-eq type-name "slop_map_string_string") true)
      ((string-eq type-name "slop_map_string_int") true)
      ((string-eq type-name "slop_map_string_ptr") true)
      (else false)))

  ;; ============================================================
  ;; Type Name Generation
  ;; ============================================================

  (fn make-option-name ((arena Arena) (inner-type String))
    (@intent "Generate Option type name from inner type")
    (@spec ((Arena String) -> String))
    (@pure)
    (@example "int64_t" -> "slop_option_int")
    (@example "slop_string" -> "slop_option_string")
    ;; slop_option_<normalized_inner>
    (string-concat arena "slop_option_" (type-to-identifier arena inner-type)))

  (fn make-result-name ((arena Arena) (ok-type String) (err-type String))
    (@intent "Generate Result type name from ok and error types")
    (@spec ((Arena String String) -> String))
    (@pure)
    (@example "int64_t" "slop_string" -> "slop_result_int_string")
    ;; slop_result_<ok>_<err>
    (let ((ok-id (type-to-identifier arena ok-type))
          (err-id (type-to-identifier arena err-type))
          (prefix (string-concat arena "slop_result_" ok-id)))
      (string-concat arena prefix (string-concat arena "_" err-id))))

  (fn make-list-name ((arena Arena) (elem-type String))
    (@intent "Generate List type name from element type")
    (@spec ((Arena String) -> String))
    (@pure)
    (@example "int64_t" -> "slop_list_int")
    (@example "slop_string" -> "slop_list_string")
    ;; slop_list_<normalized_elem>
    (string-concat arena "slop_list_" (type-to-identifier arena elem-type)))

  (fn make-map-name ((arena Arena) (key-type String) (val-type String))
    (@intent "Generate Map type name from key and value types")
    (@spec ((Arena String String) -> String))
    (@pure)
    (@example "slop_string" "int64_t" -> "slop_map_string_int")
    ;; slop_map_<key>_<val>
    (let ((key-id (type-to-identifier arena key-type))
          (val-id (type-to-identifier arena val-type))
          (prefix (string-concat arena "slop_map_" key-id)))
      (string-concat arena prefix (string-concat arena "_" val-id))))

  ;; ============================================================
  ;; Main Emission
  ;; ============================================================

  (fn emit-generated-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered generated type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (do
      (emit-line em "/* ===== Generated Generic Types ===== */")
      (emit-blank em)

      ;; Emit Option types first (no dependencies)
      (emit-option-types ctx em)

      ;; Emit List types (may depend on Options for list-get)
      (emit-list-types ctx em)

      ;; Emit Result types
      (emit-result-types ctx em)

      ;; Emit Map types last (most complex)
      (emit-map-types ctx em)

      (emit-blank em)))

  ;; ============================================================
  ;; Option Type Emission
  ;; ============================================================

  (fn emit-option-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Option type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((options (ctx-get-options ctx))
          (keys (map-keys options)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          ;; Always emit - include guards prevent redefinition
          (match (map-get options type-name)
            ((some inner-type)
              (emit-option-type em type-name inner-type))
            ((none) ()))))))

  (fn emit-option-type ((em (Ptr Emitter)) (type-name String) (inner-type String))
    (@intent "Emit single Option<T> typedef")
    (@spec (((Ptr Emitter) String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena)))
      ;; #ifndef GUARD
      ;; #define GUARD
      ;; typedef struct { bool has_value; T value; } type_name;
      ;; #endif
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena
            (string-concat arena
              (string-concat arena
                (string-concat arena "typedef struct { bool has_value; " inner-type)
                " value; } ")
              type-name)
            ";"))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; List Type Emission
  ;; ============================================================

  (fn emit-list-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered List type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((lists (ctx-get-lists ctx))
          (keys (map-keys lists)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          ;; Always emit - include guards prevent redefinition
          (match (map-get lists type-name)
            ((some elem-type)
              (emit-list-type em type-name elem-type))
            ((none) ()))))))

  (fn emit-list-type ((em (Ptr Emitter)) (type-name String) (elem-type String))
    (@intent "Emit single List<T> typedef")
    (@spec (((Ptr Emitter) String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena)))
      ;; typedef struct { T* data; size_t len; size_t cap; } type_name;
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena
            (string-concat arena
              (string-concat arena
                (string-concat arena "typedef struct { " elem-type)
                "* data; size_t len; size_t cap; } ")
              type-name)
            ";"))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Result Type Emission
  ;; ============================================================

  (fn emit-result-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Result type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((results (ctx-get-results ctx))
          (keys (map-keys results)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          ;; Always emit - include guards prevent redefinition
          (match (map-get results type-name)
            ((some info)
              (emit-result-type em type-name (. info ok) (. info err)))
            ((none) ()))))))

  (fn emit-result-type ((em (Ptr Emitter)) (type-name String)
                        (ok-type String) (err-type String))
    (@intent "Emit single Result<T, E> typedef")
    (@spec (((Ptr Emitter) String String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena))
          (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type)))
      ;; typedef struct { bool is_ok; union { T ok; E err; } data; } type_name;
      ;; Handle void ok type (use uint8_t placeholder)
      (do
        (emit-guard-start em guard)
        (emit-line em
          (string-concat arena "typedef struct { bool is_ok; union { "
            (string-concat arena actual-ok-type
              (string-concat arena " ok; "
                (string-concat arena err-type
                  (string-concat arena " err; } data; } "
                    (string-concat arena type-name ";")))))))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Map Type Emission
  ;; ============================================================

  (fn emit-map-types ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)))
    (@intent "Emit all registered Map type definitions")
    (@spec (((Ptr TranspileContext) (Ptr Emitter)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (let ((maps (ctx-get-maps ctx))
          (keys (map-keys maps)))
      (for-each (type-name keys)
        (when (not (is-runtime-predefined type-name))
          ;; Always emit - include guards prevent redefinition
          (match (map-get maps type-name)
            ((some info)
              (emit-map-type em type-name (. info key) (. info val)))
            ((none) ()))))))

  (fn emit-map-type ((em (Ptr Emitter)) (type-name String)
                     (key-type String) (val-type String))
    (@intent "Emit single Map<K, V> typedef")
    (@spec (((Ptr Emitter) String String String) -> Unit))
    (@pre (!= em nil))
    (let ((guard (make-guard-name type-name))
          (arena (. (deref em) arena))
          (is-string-key (or (string-eq key-type "slop_string")
                             (string-eq key-type "char*")
                             (string-eq key-type "String"))))
      ;; For string keys, use SLOP_STRING_MAP_DEFINE macro
      ;; For other keys, emit custom struct
      (do
        (emit-guard-start em guard)
        (if is-string-key
          ;; Use SLOP_STRING_MAP_DEFINE(ValType, MapName, OptName)
          ;; For now, just typedef to slop_map since the macro generates typed accessors
          (emit-line em
            (string-concat arena "typedef slop_map " (string-concat arena type-name ";")))
          (emit-line em
            (string-concat arena "typedef struct { "
              (string-concat arena key-type
                (string-concat arena "* keys; "
                  (string-concat arena val-type
                    (string-concat arena "* vals; size_t len; size_t cap; } "
                      (string-concat arena type-name ";"))))))))
        (emit-blank em)
        (emit-guard-end em))))

  ;; ============================================================
  ;; Helper Functions
  ;; ============================================================

  (fn make-guard-name ((type-name String))
    (@intent "Generate include guard name from type name")
    (@spec ((String) -> String))
    (@pure)
    ;; slop_option_string -> SLOP_OPTION_STRING_DEFINED
    (with-arena 256
      (string-concat arena (to-upper arena type-name) "_DEFINED")))

  ;; ============================================================
  ;; Primitive Type Checking
  ;; ============================================================

  (fn is-primitive-c-type ((c-type String))
    (@intent "Check if C type is primitive (no definition needed)")
    (@spec ((String) -> Bool))
    (@pure)
    (@example "int64_t" -> true)
    (@example "float" -> true)
    (@example "void" -> true)
    (@example "slop_option_int" -> false)
    (cond
      ((string-eq c-type "int8_t") true)
      ((string-eq c-type "int16_t") true)
      ((string-eq c-type "int32_t") true)
      ((string-eq c-type "int64_t") true)
      ((string-eq c-type "uint8_t") true)
      ((string-eq c-type "uint16_t") true)
      ((string-eq c-type "uint32_t") true)
      ((string-eq c-type "uint64_t") true)
      ((string-eq c-type "float") true)
      ((string-eq c-type "double") true)
      ((string-eq c-type "bool") true)
      ((string-eq c-type "char") true)
      ((string-eq c-type "void") true)
      ((string-eq c-type "slop_string") true)
      ((string-eq c-type "slop_bytes") true)
      ((string-eq c-type "slop_arena*") true)
      ((string-eq c-type "size_t") true)
      (else false)))

  (fn contains-pointer ((c-type String))
    (@intent "Check if C type contains a pointer (ends with *)")
    (@spec ((String) -> Bool))
    (@pure)
    (@example "int64_t*" -> true)
    (@example "char*" -> true)
    (@example "int64_t" -> false)
    ;; Simple check: if last char is '*', it's a pointer
    (let ((len (. c-type len)))
      (if (> len 0)
        (== (@ (. c-type data) (- len 1)) (cast U8 42))  ;; '*' = 42
        false)))

  ;; ============================================================
  ;; Range Type Base Type Determination
  ;; ============================================================

  (fn get-range-base-type ((ctx (Ptr TranspileContext)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Determine C base type for range type like (Int 0 .. 127)")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr)) -> String))
    (@pure)
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Parse (Int min .. max) or just (Int)
          (if (< len 1)
            "int64_t"
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((symbol base-sym)
                    (let ((base-name (. base-sym name)))
                      (cond
                        ((string-eq base-name "Int") "int64_t")
                        ((string-eq base-name "Float") "double")
                        ((string-eq base-name "Bool") "bool")
                        ((string-eq base-name "U8") "uint8_t")
                        ((string-eq base-name "U16") "uint16_t")
                        ((string-eq base-name "U32") "uint32_t")
                        ((string-eq base-name "U64") "uint64_t")
                        ((string-eq base-name "I8") "int8_t")
                        ((string-eq base-name "I16") "int16_t")
                        ((string-eq base-name "I32") "int32_t")
                        ((string-eq base-name "I64") "int64_t")
                        ;; Type alias case - convert via to-c-type
                        (else (to-c-type ctx type-expr)))))
                  (_ "int64_t")))
              ((none) "int64_t")))))
      ((symbol sym)
        ;; Simple alias like (type Foo Int)
        (let ((name (. sym name)))
          (cond
            ((string-eq name "Int") "int64_t")
            ((string-eq name "Float") "double")
            ((string-eq name "Bool") "bool")
            ((string-eq name "U8") "uint8_t")
            ((string-eq name "U16") "uint16_t")
            ((string-eq name "U32") "uint32_t")
            ((string-eq name "U64") "uint64_t")
            ((string-eq name "I8") "int8_t")
            ((string-eq name "I16") "int16_t")
            ((string-eq name "I32") "int32_t")
            ((string-eq name "I64") "int64_t")
            (else (to-c-type ctx type-expr)))))
      (_ "int64_t")))

  ;; ============================================================
  ;; Dependency Extraction
  ;; ============================================================

  (fn get-option-deps ((arena Arena) (inner-type String))
    (@intent "Get by-value dependencies for Option type")
    (@spec ((Arena String) -> (List String)))
    (@alloc arena)
    (let ((deps (list-new arena String)))
      ;; Option[T] stores T by value - depend on T if non-primitive non-pointer
      (when (and (not (contains-pointer inner-type))
                 (not (is-primitive-c-type inner-type)))
        (list-push deps inner-type))
      deps))

  (fn get-result-deps ((arena Arena) (ok-type String) (err-type String))
    (@intent "Get by-value dependencies for Result type")
    (@spec ((Arena String String) -> (List String)))
    (@alloc arena)
    (let ((deps (list-new arena String)))
      ;; Result stores both ok and err by value in union
      (when (and (not (string-eq ok-type "void"))
                 (not (contains-pointer ok-type))
                 (not (is-primitive-c-type ok-type)))
        (list-push deps ok-type))
      (when (and (not (contains-pointer err-type))
                 (not (is-primitive-c-type err-type)))
        (list-push deps err-type))
      deps))

  (fn get-list-deps ((arena Arena) (elem-type String))
    (@intent "Get by-value dependencies for List type")
    (@spec ((Arena String) -> (List String)))
    (@alloc arena)
    (let ((deps (list-new arena String)))
      ;; List[T] stores T* (pointer), but for generated types we need T defined
      ;; because they can't be forward-declared
      (when (starts-with elem-type "slop_")
        (when (not (is-primitive-c-type elem-type))
          (list-push deps elem-type)))
      deps))

  (fn get-map-deps ((arena Arena) (key-type String) (val-type String))
    (@intent "Get by-value dependencies for Map type")
    (@spec ((Arena String String) -> (List String)))
    (@alloc arena)
    (let ((deps (list-new arena String)))
      ;; String-keyed maps need Option[V] for SLOP_STRING_MAP_DEFINE
      (when (string-eq key-type "slop_string")
        (let ((val-id (type-to-identifier arena val-type))
              (opt-name (string-concat arena "slop_option_" val-id)))
          (list-push deps opt-name)))
      ;; Also depend on value type if non-primitive non-pointer
      (when (and (not (contains-pointer val-type))
                 (not (is-primitive-c-type val-type)))
        (list-push deps val-type))
      deps))

  (fn get-record-field-deps ((ctx (Ptr TranspileContext)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Extract by-value dependencies from record/union fields")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr)) -> (List String)))
    (@alloc arena)
    (let ((deps (list-new arena String)))
      ;; Iterate over fields (skip first element which is 'record' or 'union')
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (for (i 1 len)
              (match (list-get items i)
                ((some field-form)
                  (match (deref field-form)
                    ((list field-lst)
                      (let ((field-items (. field-lst items)))
                        ;; Field is (name Type)
                        (match (list-get field-items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type ctx type-expr)))
                              ;; Add as dependency if non-pointer non-primitive
                              (when (and (not (contains-pointer c-type))
                                         (not (is-primitive-c-type c-type)))
                                (list-push deps c-type))))
                          ((none) ()))))
                    (_ ())))
                ((none) ())))))
        (_ ()))
      deps))

  ;; ============================================================
  ;; Type Collection
  ;; ============================================================

  (fn collect-all-types ((ctx (Ptr TranspileContext)) (arena Arena) (record-forms (List (Ptr SExpr))))
    (@intent "Collect all types (records + generated) for topological sort")
    (@spec (((Ptr TranspileContext) Arena (List (Ptr SExpr))) -> (List TypeEntry)))
    (@alloc arena)
    (let ((entries (list-new arena TypeEntry)))

      ;; Collect record/union types from AST
      (for-each (form record-forms)
        (match (deref form)
          ((list lst)
            (let ((items (. lst items)))
              ;; Get type name and expression
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol sym)
                      (match (list-get items 2)
                        ((some type-expr)
                          ;; Look up this form's registered C name
                          (let ((c-name (match (ctx-lookup-type-def ctx arena (cast Int form))
                                          ((some registered-name) registered-name)
                                          ((none)
                                           ;; Fallback: use context's current module
                                           (to-qualified-type-name arena ctx (. sym name)))))
                                (is-record (is-form type-expr "record"))
                                (is-union (is-form type-expr "union"))
                                (is-enum (is-form type-expr "enum")))
                            (cond
                              ((or is-record is-union)
                                ;; Set module context for this type before getting deps
                                ;; This ensures field types are resolved with correct prefixes
                                (do
                                  (match (ctx-lookup-type-module ctx arena (cast Int form))
                                    ((some mod-name)
                                      (ctx-set-module ctx (some mod-name))
                                      (ctx-set-prefixing ctx true))
                                    ((none) ()))
                                  (let ((deps (get-record-field-deps ctx arena type-expr))
                                        (kind (if is-record 'kind-record 'kind-union))
                                        (entry (TypeEntry
                                                 c-name
                                                 kind
                                                 deps
                                                 (some form)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none))))
                                    (list-push entries entry))))
                              (is-enum
                                ;; Enums have no dependencies - emit first
                                (let ((entry (TypeEntry
                                               c-name
                                               'kind-enum
                                               (list-new arena String)  ;; no deps
                                               (some form)
                                               (none)
                                               (none)
                                               (none)
                                               (none)
                                               (none)
                                               (none)
                                               (none)
                                               (none))))
                                  (list-push entries entry)))
                              ((is-form type-expr "Array")
                                ;; Array type: (type Scores (Array Int 10))
                                (match (deref type-expr)
                                  ((list arr-lst)
                                    (let ((arr-items (. arr-lst items)))
                                      (match (list-get arr-items 1)
                                        ((some elem-type-expr)
                                          (let ((elem-c-type (to-c-type ctx elem-type-expr))
                                                (slop-name (. sym name)))
                                            (do
                                              ;; Register SLOP name -> element type for (Ptr ArrayType) handling
                                              (ctx-register-array-element ctx slop-name elem-c-type)
                                              (match (list-get arr-items 2)
                                                ((some size-expr)
                                                  (match (deref size-expr)
                                                    ((number size-num)
                                                      (let ((entry (TypeEntry
                                                                     c-name
                                                                     'kind-array
                                                                     (list-new arena String)
                                                                     (some form)
                                                                     (some elem-c-type)
                                                                     (none)
                                                                     (none)
                                                                     (none)
                                                                     (none)
                                                                     (none)
                                                                     (none)
                                                                     (some (. size-num int-value)))))
                                                        (list-push entries entry)))
                                                    (_ ())))
                                                ((none) ())))))
                                        ((none) ()))))
                                  (_ ())))
                              (else
                                ;; Range type or simple alias - e.g., (type AsciiChar (Int 0 .. 127))
                                ;; Set module context for this type before processing
                                (do
                                  (match (ctx-lookup-type-module ctx arena (cast Int form))
                                    ((some mod-name)
                                      (ctx-set-module ctx (some mod-name))
                                      (ctx-set-prefixing ctx true))
                                    ((none) ()))
                                  (let ((base-c-type (get-range-base-type ctx arena type-expr))
                                        ;; Check if base type is a generated type (Option/Result/List/Map)
                                        ;; If so, add it as a dependency
                                        (deps (let ((d (list-new arena String)))
                                                (when (or (starts-with base-c-type "slop_result_")
                                                          (starts-with base-c-type "slop_option_")
                                                          (starts-with base-c-type "slop_list_")
                                                          (starts-with base-c-type "slop_map_"))
                                                  (list-push d base-c-type))
                                                d))
                                        (entry (TypeEntry
                                                 c-name
                                                 'kind-range
                                                 deps
                                                 (some form)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (none)
                                                 (some base-c-type)
                                                 (none))))
                                    (list-push entries entry)))))))
                        ((none) ())))
                    (_ ())))
                ((none) ()))))
          (_ ())))

      ;; Collect Option types
      ;; Always collect - include guards prevent redefinition
      (let ((options (ctx-get-options ctx))
            (opt-keys (map-keys options)))
        (for-each (type-name opt-keys)
          (when (not (is-runtime-predefined type-name))
            (match (map-get options type-name)
              ((some inner-type)
                (let ((deps (get-option-deps arena inner-type))
                      (entry (TypeEntry
                               type-name
                               'kind-option
                               deps
                               (none)
                               (some inner-type)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none))))
                  (list-push entries entry)))
              ((none) ())))))

      ;; Collect Result types
      ;; Always collect - include guards prevent redefinition
      (let ((results (ctx-get-results ctx))
            (res-keys (map-keys results)))
        (for-each (type-name res-keys)
          (when (not (is-runtime-predefined type-name))
            (match (map-get results type-name)
              ((some info)
                (let ((deps (get-result-deps arena (. info ok) (. info err)))
                      (entry (TypeEntry
                               type-name
                               'kind-result
                               deps
                               (none)
                               (none)
                               (some (. info ok))
                               (some (. info err))
                               (none)
                               (none)
                               (none)
                               (none)
                               (none))))
                  (list-push entries entry)))
              ((none) ())))))

      ;; Collect List types
      ;; Always collect - include guards prevent redefinition
      (let ((lists (ctx-get-lists ctx))
            (list-keys (map-keys lists)))
        (for-each (type-name list-keys)
          (when (not (is-runtime-predefined type-name))
            (match (map-get lists type-name)
              ((some elem-type)
                (let ((deps (get-list-deps arena elem-type))
                      (entry (TypeEntry
                               type-name
                               'kind-list
                               deps
                               (none)
                               (some elem-type)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none)
                               (none))))
                  (list-push entries entry)))
              ((none) ())))))

      ;; Collect Map types
      ;; Always collect - include guards prevent redefinition
      (let ((maps (ctx-get-maps ctx))
            (map-keys-list (map-keys maps)))
        (for-each (type-name map-keys-list)
          (when (not (is-runtime-predefined type-name))
            (match (map-get maps type-name)
              ((some info)
                (let ((deps (get-map-deps arena (. info key) (. info val)))
                      (entry (TypeEntry
                               type-name
                               'kind-map
                               deps
                               (none)
                               (none)
                               (none)
                               (none)
                               (some (. info key))
                               (some (. info val))
                               (none)
                               (none)
                               (none))))
                  (list-push entries entry)))
              ((none) ())))))

      entries))

  ;; ============================================================
  ;; Topological Sort (Kahn's Algorithm)
  ;; ============================================================

  (fn find-entry-by-name ((entries (List TypeEntry)) (name String))
    (@intent "Find entry index by type name")
    (@spec (((List TypeEntry) String) -> (Option Int)))
    (@pure)
    (let ((len (list-len entries))
          (mut result (Option Int) (none)))
      (for (i 0 len)
        (match (list-get entries i)
          ((some entry)
            (when (string-eq (. entry name) name)
              (set! result (some (cast Int i)))))
          ((none) ())))
      result))

  (fn topological-sort-types ((arena Arena) (entries (List TypeEntry)))
    (@intent "Topologically sort types based on by-value dependencies")
    (@spec ((Arena (List TypeEntry)) -> (List Int)))
    (@alloc arena)
    ;; Returns list of indices into entries in sorted order
    (let ((n (list-len entries))
          (in-degree (list-new arena Int))
          (sorted (list-new arena Int))
          (queue (list-new arena Int)))

      ;; Initialize in-degree for each entry
      (for (i 0 n)
        (list-push in-degree 0))

      ;; Compute in-degrees
      (for (i 0 n)
        (match (list-get entries i)
          ((some entry)
            (let ((entry-deps (List String) (. entry deps)))
              (for-each (dep entry-deps)
                ;; Find the entry this depends on
                (match (find-entry-by-name entries dep)
                  ((some dep-idx)
                    ;; Increment in-degree for current entry
                    (match (list-get in-degree i)
                      ((some cur)
                        ;; Note: list-set! not available, use workaround
                        (set! (@ (. in-degree data) i) (+ cur 1)))
                      ((none) ())))
                  ((none) ())))))  ;; Dependency not in our set (external type)
          ((none) ())))

      ;; Initialize queue with entries that have no dependencies
      (for (i 0 n)
        (match (list-get in-degree i)
          ((some deg)
            (when (== deg 0)
              (list-push queue i)))
          ((none) ())))

      ;; Process queue
      (while (> (list-len queue) 0)
        ;; Pop from front of queue (simple: swap with last and pop)
        (match (list-get queue 0)
          ((some current)
            ;; Add to sorted output
            (list-push sorted current)
            ;; Remove from queue (shift elements)
            (let ((qlen (list-len queue)))
              (for (j 0 (- qlen 1))
                (match (list-get queue (+ j 1))
                  ((some next)
                    (set! (@ (. queue data) j) next))
                  ((none) ())))
              (set! (. queue len) (- qlen 1)))
            ;; Decrement in-degree for dependents
            (match (list-get entries current)
              ((some entry)
                (let ((entry-name (. entry name)))
                  (for (j 0 n)
                    (match (list-get entries j)
                      ((some other)
                        (let ((other-deps (List String) (. other deps)))
                          ;; Check if other depends on current
                          (for-each (dep other-deps)
                            (when (string-eq dep entry-name)
                              (match (list-get in-degree j)
                                ((some deg)
                                  (let ((new-deg (- deg 1)))
                                    (set! (@ (. in-degree data) j) new-deg)
                                    (when (== new-deg 0)
                                      (list-push queue j))))
                                ((none) ()))))))
                      ((none) ())))))
              ((none) ())))
          ((none) ())))

      ;; If sorted doesn't contain all entries, there's a cycle
      ;; Add remaining entries anyway
      (when (< (list-len sorted) n)
        (for (i 0 n)
          (let ((mut found false))
            (for-each (s sorted)
              (when (== s i)
                (set! found true)))
            (when (not found)
              (list-push sorted i)))))

      sorted))

  ;; ============================================================
  ;; Unified Type Emission
  ;; ============================================================

  (fn emit-type-entry ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)) (entry TypeEntry))
    (@intent "Emit a single type definition based on its kind")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) TypeEntry) -> Unit))
    (let ((arena (. (deref ctx) arena)))
      (match (. entry kind)
        ('kind-option
          (match (. entry inner)
            ((some inner-type)
              (emit-option-type em (. entry name) inner-type)
              (ctx-mark-emitted ctx (. entry name)))
            ((none) ())))

        ('kind-result
          (match (. entry ok-type)
            ((some ok)
              (match (. entry err-type)
                ((some err)
                  (emit-result-type em (. entry name) ok err)
                  (ctx-mark-emitted ctx (. entry name)))
                ((none) ())))
            ((none) ())))

        ('kind-list
          (match (. entry inner)
            ((some elem-type)
              (emit-list-type em (. entry name) elem-type)
              (ctx-mark-emitted ctx (. entry name)))
            ((none) ())))

        ('kind-map
          (match (. entry key-type)
            ((some key)
              (match (. entry val-type)
                ((some val)
                  (emit-map-type em (. entry name) key val)
                  (ctx-mark-emitted ctx (. entry name)))
                ((none) ())))
            ((none) ())))

        ('kind-record
          (match (. entry ast)
            ((some form)
              ;; Set module context before emitting for correct field type prefixing
              (match (ctx-lookup-type-module ctx arena (cast Int form))
                ((some mod-name)
                  (ctx-set-module ctx (some mod-name))
                  (ctx-set-prefixing ctx true))
                ((none) ()))
              ;; Emit record - pass correct c-name from entry
              (emit-record-type ctx em form (. entry name)))
            ((none) ())))

        ('kind-union
          (match (. entry ast)
            ((some form)
              ;; Set module context before emitting for correct field type prefixing
              (match (ctx-lookup-type-module ctx arena (cast Int form))
                ((some mod-name)
                  (ctx-set-module ctx (some mod-name))
                  (ctx-set-prefixing ctx true))
                ((none) ()))
              ;; Emit union - pass correct c-name from entry
              (emit-union-type ctx em form (. entry name)))
            ((none) ())))

        ('kind-enum
          (match (. entry ast)
            ((some form)
              ;; Enums don't have field types, but set context for consistency
              (match (ctx-lookup-type-module ctx arena (cast Int form))
                ((some mod-name)
                  (ctx-set-module ctx (some mod-name))
                  (ctx-set-prefixing ctx true))
                ((none) ()))
              ;; Emit enum - pass correct c-name from entry
              (emit-enum-type ctx em form (. entry name)))
            ((none) ())))

        ('kind-range
          ;; Range type: emit typedef to base C type
          (match (. entry base-type)
            ((some base)
              (emit-line em (string-concat arena "typedef "
                              (string-concat arena base
                                (string-concat arena " "
                                  (string-concat arena (. entry name) ";")))))
              (emit-blank em)
              (ctx-mark-emitted ctx (. entry name)))
            ((none) ())))

        ('kind-array
          ;; Array type: emit typedef elem_type name[size];
          (match (. entry inner)
            ((some elem-type)
              (match (. entry array-size)
                ((some size-val)
                  (let ((size-str (int-to-string arena size-val)))
                    (do
                      (emit-line em (string-concat arena "typedef "
                                      (string-concat arena elem-type
                                        (string-concat arena " "
                                          (string-concat arena (. entry name)
                                            (string-concat arena "["
                                              (string-concat arena size-str "];")))))))
                      (emit-blank em)
                      (ctx-mark-emitted ctx (. entry name)))))
                ((none) ())))
            ((none) ()))))))

  (fn emit-record-type ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)) (form (Ptr SExpr)) (c-name String))
    (@intent "Emit record type definition inline")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (Ptr SExpr) String) -> Unit))
    (let ((arena (. (deref ctx) arena))
          (field-infos (list-new arena CFieldInfo)))
      (match (deref form)
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol sym)
                    ;; Use provided c-name instead of recomputing
                      (match (list-get items 2)
                        ((some type-expr)
                          (emit-line em (string-concat arena "typedef struct "
                                          (string-concat arena c-name " {")))
                          (indent em)
                          ;; Emit fields and collect field info
                          (match (deref type-expr)
                            ((list type-lst)
                              (let ((type-items (. type-lst items))
                                    (type-len (list-len type-items)))
                                (for (i 1 type-len)
                                  (match (list-get type-items i)
                                    ((some field-form)
                                      (match (deref field-form)
                                        ((list field-lst)
                                          (let ((field-items (. field-lst items)))
                                            (match (list-get field-items 0)
                                              ((some fname-expr)
                                                (match (deref fname-expr)
                                                  ((symbol fsym)
                                                    (match (list-get field-items 1)
                                                      ((some ftype-expr)
                                                        (let ((field-c-type (to-c-type ctx ftype-expr))
                                                              (field-c-name (to-c-name arena (. fsym name)))
                                                              (is-ptr (is-pointer-type ftype-expr)))
                                                          (do
                                                            ;; Register field for positional construction
                                                            (list-push field-infos (CFieldInfo (. fsym name) field-c-name field-c-type is-ptr))
                                                            (emit-line em (string-concat arena "    "
                                                                            (string-concat arena field-c-type
                                                                              (string-concat arena " "
                                                                                (string-concat arena field-c-name ";"))))))))
                                                      ((none) ())))
                                                  (_ ())))
                                              ((none) ()))))
                                        (_ ())))
                                    ((none) ())))))
                            (_ ()))
                          (dedent em)
                          (emit-line em (string-concat arena "} " (string-concat arena c-name ";")))
                          (emit-blank em)
                          ;; Register fields for positional construction
                          (ctx-register-fields ctx c-name field-infos))
                        ((none) ())))
                  (_ ())))
              ((none) ()))))
        (_ ()))))

  (fn emit-union-type ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)) (form (Ptr SExpr)) (c-name String))
    (@intent "Emit union type definition inline")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (Ptr SExpr) String) -> Unit))
    (let ((arena (. (deref ctx) arena)))
      (match (deref form)
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol sym)
                    ;; Use provided c-name instead of recomputing
                      (match (list-get items 2)
                        ((some type-expr)
                          ;; struct Name { uint8_t tag; union { ... } data; };
                          (emit-line em (string-concat arena "struct " (string-concat arena c-name " {")))
                          (indent em)
                          (emit-line em "uint8_t tag;")
                          (emit-line em "union {")
                          (indent em)
                          ;; Emit variants
                          (match (deref type-expr)
                            ((list type-lst)
                              (let ((type-items (. type-lst items))
                                    (type-len (list-len type-items)))
                                (for (i 1 type-len)
                                  (match (list-get type-items i)
                                    ((some variant-form)
                                      (match (deref variant-form)
                                        ((list variant-lst)
                                          (let ((variant-items (. variant-lst items)))
                                            (match (list-get variant-items 0)
                                              ((some vname-expr)
                                                (match (deref vname-expr)
                                                  ((symbol vsym)
                                                    (match (list-get variant-items 1)
                                                      ((some vtype-expr)
                                                        (let ((variant-c-type (to-c-type ctx vtype-expr))
                                                              (variant-c-name (to-c-name arena (. vsym name))))
                                                          (emit-line em (string-concat arena variant-c-type
                                                                          (string-concat arena " "
                                                                            (string-concat arena variant-c-name ";"))))))
                                                      ((none) ())))
                                                  (_ ())))
                                              ((none) ()))))
                                        (_ ())))
                                    ((none) ())))))
                            (_ ()))
                          (dedent em)
                          (emit-line em "} data;")
                          (dedent em)
                          (emit-line em "};")
                          ;; typedef struct Name Name;
                          (emit-line em (string-concat arena "typedef struct "
                                          (string-concat arena c-name
                                            (string-concat arena " " (string-concat arena c-name ";")))))
                          (emit-blank em)
                          ;; Emit tag #defines
                          (emit-union-tag-defines em arena c-name type-expr))
                        ((none) ())))
                  (_ ())))
              ((none) ()))))
        (_ ()))))

  ;; Helper to emit union tag #defines
  (fn emit-union-tag-defines ((em (Ptr Emitter)) (arena Arena) (c-name String) (type-expr (Ptr SExpr)))
    (@intent "Emit #define Type_variant_TAG n for each union variant")
    (@spec (((Ptr Emitter) Arena String (Ptr SExpr)) -> Unit))
    (match (deref type-expr)
      ((list type-lst)
        (let ((type-items (. type-lst items))
              (type-len (list-len type-items))
              (mut idx 0))
          (for (i 1 type-len)
            (match (list-get type-items i)
              ((some variant-form)
                (match (deref variant-form)
                  ((list variant-lst)
                    (match (list-get (. variant-lst items) 0)
                      ((some vname-expr)
                        (match (deref vname-expr)
                          ((symbol vsym)
                            (let ((vname (. vsym name))
                                  (tag (string-concat arena c-name
                                          (string-concat arena "_"
                                            (string-concat arena (to-c-name arena vname) "_TAG")))))
                              (emit-line em (string-concat arena "#define "
                                              (string-concat arena tag
                                                (string-concat arena " " (int-to-string arena idx)))))
                              (set! idx (+ idx 1))))
                          (_ ())))
                      ((none) ())))
                  (_ ())))
              ((none) ())))))
      (_ ()))
    (emit-blank em))

  (fn emit-enum-type ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)) (form (Ptr SExpr)) (c-name String))
    (@intent "Emit enum type definition inline")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (Ptr SExpr) String) -> Unit))
    (let ((arena (. (deref ctx) arena)))
      (match (deref form)
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol sym)
                    ;; Use provided c-name instead of recomputing
                      (match (list-get items 2)
                        ((some type-expr)
                          ;; typedef enum NAME { NAME_val1, NAME_val2, ... } NAME;
                          (emit-line em (string-concat arena "typedef enum " (string-concat arena c-name " {")))
                          (indent em)
                          (match (deref type-expr)
                            ((list type-lst)
                              (let ((type-items (. type-lst items))
                                    (type-len (list-len type-items)))
                                (for (i 1 type-len)
                                  (match (list-get type-items i)
                                    ((some variant-expr)
                                      (match (deref variant-expr)
                                        ((symbol vsym)
                                          (let ((variant-name (. vsym name))
                                                (qualified (string-concat arena c-name
                                                              (string-concat arena "_"
                                                                (to-c-name arena variant-name)))))
                                            ;; Register enum value for later lookup
                                            (ctx-register-enum-value ctx variant-name qualified)
                                            (emit-line em (string-concat arena "    "
                                                            (string-concat arena qualified
                                                              (if (< i (- type-len 1)) "," ""))))))
                                        (_ ())))
                                    ((none) ())))))
                            (_ ()))
                          (dedent em)
                          (emit-line em (string-concat arena "} " (string-concat arena c-name ";")))
                          (emit-blank em))
                        ((none) ())))
                  (_ ())))
              ((none) ()))))
        (_ ()))))

  (fn emit-all-types-sorted ((ctx (Ptr TranspileContext)) (em (Ptr Emitter)) (record-forms (List (Ptr SExpr))))
    (@intent "Emit all types (records + generated) in topologically sorted order")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (List (Ptr SExpr))) -> Unit))
    (let ((arena (. (deref ctx) arena)))
      ;; Collect all types
      (let ((entries (collect-all-types ctx arena record-forms)))
        (when (> (list-len entries) 0)
          ;; Sort topologically
          (let ((sorted-indices (topological-sort-types arena entries)))

            ;; First emit range types and enums WITHOUT dependencies - these are self-contained
            ;; primitives and must come before anything that might reference them
            ;; Note: Type aliases like (Result T E) have dependencies and are emitted later
            (emit-line em "/* ===== Primitive Type Aliases and Enums ===== */")
            (emit-blank em)
            (for-each (idx sorted-indices)
              (match (list-get entries idx)
                ((some entry)
                  (let ((kind (. entry kind))
                        (has-deps (> (list-len (. entry deps)) 0)))
                    ;; Only emit range/enum/array types that have NO dependencies here
                    (when (and (or (== kind 'kind-range) (== kind 'kind-enum) (== kind 'kind-array))
                               (not has-deps))
                      (emit-type-entry ctx em entry))))
                ((none) ())))
            (emit-blank em)

            ;; Emit forward declarations for all records and unions
            ;; This allows pointers to be used before full definitions
            (emit-line em "/* ===== Forward Declarations ===== */")
            (emit-blank em)
            (for-each (idx sorted-indices)
              (match (list-get entries idx)
                ((some entry)
                  (let ((kind (. entry kind)))
                    (when (or (== kind 'kind-record) (== kind 'kind-union))
                      (emit-line em (string-concat arena "typedef struct "
                                      (string-concat arena (. entry name)
                                        (string-concat arena " "
                                          (string-concat arena (. entry name) ";"))))))))
                ((none) ())))
            (emit-blank em)

            ;; Emit full type definitions in sorted order
            ;; Skip enums and ranges WITHOUT dependencies (already emitted above)
            ;; Include enums and ranges WITH dependencies (e.g., type aliases to Result types)
            (emit-line em "/* ===== Type Definitions (Topologically Sorted) ===== */")
            (emit-blank em)
            (for-each (idx sorted-indices)
              (match (list-get entries idx)
                ((some entry)
                  (let ((kind (. entry kind))
                        (has-deps (> (list-len (. entry deps)) 0)))
                    ;; Emit if: not a range/enum/array, OR is a range/enum/array WITH deps
                    (when (or (and (!= kind 'kind-range) (!= kind 'kind-enum) (!= kind 'kind-array))
                              has-deps)
                      (emit-type-entry ctx em entry))))
                ((none) ()))))))))

)
