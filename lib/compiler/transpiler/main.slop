;; ============================================================
;; SLOP Native Transpiler - CLI Entry Point
;;
;; Usage: slop-transpiler <file1.slop> [file2.slop ...]
;;
;; Transpiles SLOP source file(s) to C code.
;; Output is JSON to stdout with header and impl per module.
;; Files should be listed in dependency order (dependencies first).
;; ============================================================

(module main
  (export main)

  (import types (SExpr))
  (import parser (parse ParseResult ParseError))
  (import transpiler (transpile-modules TranspileResult TranspileError ModuleOutput))
  (import strlib (char-at))

  ;; FFI for file I/O and string operations
  (ffi "stdio.h"
    (fopen ((path (Ptr Char)) (mode (Ptr Char))) (Ptr U8))
    (fclose ((f (Ptr U8))) Int)
    (fread ((buf (Ptr U8)) (size U64) (count U64) (f (Ptr U8))) U64)
    (fseek ((f (Ptr U8)) (offset I64) (whence Int)) Int)
    (ftell ((f (Ptr U8))) I64)
    (putchar ((c Int)) Int)
    (puts ((s (Ptr Char))) Int))

  (ffi "string.h"
    (strlen ((s (Ptr Char))) U64))

  (ffi "stdlib.h"
    (exit ((code Int)) Unit))

  (const SEEK_END Int 2)
  (const SEEK_SET Int 0)

  ;; ============================================================
  ;; File Reading
  ;; ============================================================

  (fn read-file ((arena Arena) (path String))
    (@intent "Read entire file contents into arena-allocated string")
    (@spec ((Arena String) -> (Result String String)))
    (@alloc arena)
    (@pre {(string-len path) > 0})
    (let ((f (fopen (cast (Ptr Char) (. path data)) (cast (Ptr Char) (. "rb" data)))))
      (if (== f nil)
        (error "Could not open file")
        (do
          ;; Seek to end to get file size
          (fseek f 0 SEEK_END)
          (let ((size (ftell f)))
            (fseek f 0 SEEK_SET)
            ;; Allocate buffer (size + 1 for null terminator)
            (let ((buf (cast (Ptr U8) (arena-alloc arena (+ size 1)))))
              ;; Read file contents
              (let ((bytes-read (fread buf 1 (cast U64 size) f)))
                (fclose f)
                ;; Null terminate
                (set! (@ buf bytes-read) 0)
                (ok (string-new arena buf)))))))))

  ;; ============================================================
  ;; Argument Parsing
  ;; ============================================================

  (fn collect-input-files ((arena Arena) (argc Int) (argv (Ptr (Ptr Char))))
    (@intent "Collect input .slop files from command line arguments")
    (@spec ((Arena Int (Ptr (Ptr Char))) -> (List String)))
    (@alloc arena)
    (@pre {argc >= 1})
    (let ((files (list-new arena String))
          (mut i 1))
      (while (< i argc)
        (let ((arg (@ argv i)))
          ;; Skip flags (arguments starting with -)
          (when (or (== (strlen arg) 0) (!= (@ arg 0) 45))  ;; 45 = '-'
            (list-push files (string-new arena (cast (Ptr U8) arg)))))
        (set! i (+ i 1)))
      files))

  ;; ============================================================
  ;; JSON Output
  ;; ============================================================

  (fn print-json-string ((s String))
    (@intent "Print string with JSON escaping")
    (@spec ((String) -> Unit))
    (do
      (putchar 34)  ;; Opening quote "
      (let ((len (string-len s))
            (mut i 0))
        (while (< i len)
          (let ((c (char-at s (cast (Int 0 ..) i))))
            (cond
              ((== c 92)   ;; Backslash \
                (do (putchar 92) (putchar 92)))
              ((== c 34)   ;; Quote "
                (do (putchar 92) (putchar 34)))
              ((== c 10)   ;; Newline \n
                (do (putchar 92) (putchar 110)))
              ((== c 13)   ;; Carriage return \r
                (do (putchar 92) (putchar 114)))
              ((== c 9)    ;; Tab \t
                (do (putchar 92) (putchar 116)))
              (else
                (putchar c))))
          (set! i (+ i 1))))
      (putchar 34)
      ()))

  (fn output-json ((results (List ModuleOutput)))
    (@intent "Output transpilation results as JSON")
    (@spec (((List ModuleOutput)) -> Unit))
    (@pre {(list-len results) > 0})
    (do
      (putchar 123)  ;; Opening brace {
      (putchar 10)   ;; Newline
      (let ((len (list-len results))
            (mut i 0))
        (while (< i len)
          (match (list-get results i)
            ((some m)
              (do
                ;; Print module name as key
                (puts (cast (Ptr Char) (. "  " data)))
                (print-json-string (. m name))
                (puts (cast (Ptr Char) (. ": {" data)))
                (putchar 10)
                ;; Print header
                (puts (cast (Ptr Char) (. "    \"header\": " data)))
                (print-json-string (. m header))
                (putchar 44)  ;; Comma
                (putchar 10)
                ;; Print impl
                (puts (cast (Ptr Char) (. "    \"impl\": " data)))
                (print-json-string (. m impl))
                (putchar 10)
                (puts (cast (Ptr Char) (. "  }" data)))
                ;; Comma if not last
                (when (< i (- len 1))
                  (putchar 44))
                (putchar 10)))
            ((none) ()))
          (set! i (+ i 1))))
      (putchar 125)  ;; Closing brace }
      (putchar 10)
      ()))

  ;; ============================================================
  ;; Main Entry Point
  ;; ============================================================

  (fn main ((argc Int) (argv (Ptr (Ptr Char))))
    (@intent "CLI entry point: parse args, read files, transpile, output JSON")
    (@spec ((Int (Ptr (Ptr Char))) -> Int))
    (@example (1 argv) -> 1)
    (if (< argc 2)
      (do
        (puts (cast (Ptr Char) (. "Usage: slop-transpiler <file1.slop> [file2.slop ...]" data)))
        (puts (cast (Ptr Char) (. "" data)))
        (puts (cast (Ptr Char) (. "Transpiles SLOP modules to C code (split compilation)." data)))
        (puts (cast (Ptr Char) (. "Output is JSON to stdout: {\"module\": {\"header\": \"...\", \"impl\": \"...\"}}" data)))
        (puts (cast (Ptr Char) (. "" data)))
        (puts (cast (Ptr Char) (. "Files should be listed in dependency order (dependencies first)." data)))
        1)
      (with-arena 134217728  ;; 128MB arena
        (let ((input-files (collect-input-files arena argc argv)))
          (if (== (list-len input-files) 0)
            (do
              (puts (cast (Ptr Char) (. "Error: No input files specified" data)))
              1)
            ;; Parse all input files
            (let ((module-asts (list-new arena (Ptr SExpr)))
                  (mut parse-success true))
              (for-each (path input-files)
                (when parse-success
                  (match (read-file arena path)
                    ((error msg)
                      (do
                        (puts (cast (Ptr Char) (. "Error: Could not read file" data)))
                        (set! parse-success false)))
                    ((ok source)
                      (match (parse arena source)
                        ((error e)
                          (do
                            (puts (cast (Ptr Char) (. "Error: Parse failed" data)))
                            (set! parse-success false)))
                        ((ok asts)
                          ;; Add all top-level forms to module-asts
                          (for-each (ast asts)
                            (list-push module-asts ast))))))))
              (if (not parse-success)
                1
                ;; Transpile all modules
                (match (transpile-modules arena module-asts)
                  ((error e)
                    (do
                      (puts (cast (Ptr Char) (. "Error: Transpile failed" data)))
                      (puts (cast (Ptr Char) (. (. e message) data)))
                      1))
                  ((ok results)
                    (do
                      (output-json results)
                      0)))))))))))  ;; close: do, ok-case, match, if, let, let, if, let, with-arena, if, fn, module
