;; ============================================================
;; SLOP Native Transpiler - Main Orchestration Module
;;
;; Coordinates the transpilation of SLOP programs to C.
;; ============================================================

(module transpiler
  (export
    ;; Main entry points
    transpile-module transpile-file
    ;; Module processing
    prescan-module process-imports process-exports
    emit-all-types emit-all-functions
    ;; Output generation
    generate-c-output
    ;; Type environment integration
    populate-context-from-env
    ;; Result type helpers (for defn.slop)
    build-result-type-name)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber
                 ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo))
  (import context (TranspileContext context-new ctx-emit ctx-emit-header ctx-get-output ctx-get-header
                   ctx-indent ctx-dedent ctx-push-scope ctx-pop-scope
                   ctx-register-type ctx-register-func ctx-lookup-type ctx-lookup-func ctx-set-module ctx-get-module ctx-set-prefixing ctx-prefixing-enabled ctx-prefix-type
                   ctx-add-include ctx-get-includes ctx-register-enum-variant
                   ctx-register-union-variant ctx-get-union-variants UnionVariantEntry
                   ctx-register-result-type ctx-has-result-type ctx-get-result-types ResultType
                   ctx-set-current-result-type ctx-get-current-result-type ctx-clear-current-result-type
                   ctx-register-option-type ctx-has-option-type ctx-get-option-types OptionType
                   ctx-register-list-type ctx-has-list-type ctx-get-list-types ListType
                   ctx-register-chan-type ctx-has-chan-type ctx-get-chan-types ChanType
                   ctx-register-thread-type ctx-has-thread-type ctx-get-thread-types ThreadType
                   ctx-register-result-type-alias ctx-lookup-result-type-alias ResultTypeAlias
                   ctx-register-type-alias ctx-lookup-type-alias
                   ctx-get-inline-records InlineRecord
                   ctx-add-c-name-alias ctx-get-c-name-aliases FuncCNameAlias extract-fn-c-name
                   ctx-add-import ctx-get-imports
                   ctx-str ctx-str3 ctx-str4 ctx-str5 TypeEntry FuncEntry FuncParamType VarEntry
                   ctx-bind-var
                   to-c-type-prefixed
                   ctx-mark-type-emitted ctx-is-type-emitted
                   ctx-register-field-type ctx-get-fields-for-type FieldEntry
                   ctx-register-struct-key-type ctx-get-struct-key-types
                   ctx-get-deferred-lambdas ctx-clear-deferred-lambdas
                   ctx-start-function-buffer ctx-stop-function-buffer ctx-flush-function-buffer))
  (import ctype (to-c-type to-c-name type-to-identifier is-builtin-c-type builtin-type-c))
  (import emit (emit-standard-includes emit-include))
  (import defn (transpile-type transpile-function transpile-const is-const-form emit-forward-declaration
                is-ffi-form is-ffi-struct-form transpile-ffi transpile-ffi-struct
                get-return-type get-slop-return-type get-result-type-name build-param-str eval-const-value get-type-name-str))
  (import stmt (transpile-stmt))
  (import expr (transpile-expr))
  (import match (transpile-match))
  (import strlib (starts-with substring char-at))
  (import ast (pretty-print))
  (import env (TypeEnv env-get-types env-get-functions env-get-constants ConstBinding))

  ;; ============================================================
  ;; Populate Context from Type Environment
  ;; ============================================================

  (fn populate-context-from-env ((ctx (Ptr TranspileContext)) (env (Ptr TypeEnv)) (type-offset Int) (fn-offset Int))
    (@intent "Populate transpiler context with type info from checker's TypeEnv, starting from offsets")
    (@spec (((Ptr TranspileContext) (Ptr TypeEnv) Int Int) -> Unit))
    (@pre {ctx != nil})
    (@pre {env != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Register types starting from offset (only new types from current module)
      (let ((all-types (env-get-types env))
            (type-count (list-len all-types))
            (mut ti type-offset))
        (while (< ti type-count)
          (match (list-get all-types ti)
            ((some resolved-ptr)
              (let ((resolved (deref resolved-ptr))
                    (kind (. resolved kind))
                    (type-name (. resolved name))
                    (base-c-name (to-c-name arena type-name))
                    (c-name (ctx-prefix-type ctx base-c-name))
                    (is-enum (== kind 'rk-enum))
                    (is-record (== kind 'rk-record))
                    (is-union (== kind 'rk-union)))
                ;; Register the type entry only - prescan handles variants, fields, and container types
                (ctx-register-type ctx (TypeEntry type-name c-name c-name is-enum is-record is-union))))
            ((none) (do)))
          (set! ti (+ ti 1))))
      ;; Register functions starting from offset (only new functions from current module)
      (let ((all-fns (env-get-functions env))
            (fn-count (list-len all-fns))
            (mut fi fn-offset))
        (while (< fi fn-count)
          (match (list-get all-fns fi)
            ((some sig-ptr)
              (let ((sig (deref sig-ptr))
                    (fn-name (. sig name))
                    (base-name (to-c-name arena fn-name))
                    ;; Don't prefix main
                    (c-name (if (string-eq base-name "main")
                              base-name
                              (ctx-prefix-type ctx base-name)))
                    ;; Get return type info
                    (ret-type (deref (. sig return-type)))
                    (ret-c (resolve-field-c-type ctx (. ret-type kind) (. ret-type name)))
                    (ret-slop (. ret-type name))
                    (returns-str (string-eq (. ret-type name) "String"))
                    ;; Build parameter type list
                    (params (. sig params))
                    (param-count (list-len params))
                    (param-types (list-new arena (Ptr FuncParamType)))
                    (mut pi 0))
                (while (< pi param-count)
                  (match (list-get params pi)
                    ((some p)
                      (let ((pt (deref (. p param-type)))
                            (pt-c (resolve-field-c-type ctx (. pt kind) (. pt name)))
                            (fpt (cast (Ptr FuncParamType) (arena-alloc arena 16))))
                        (set! (deref fpt) (FuncParamType pt-c))
                        (list-push param-types fpt)))
                    ((none) (do)))
                  (set! pi (+ pi 1)))
                (ctx-register-func ctx (FuncEntry fn-name c-name ret-c ret-slop false returns-str param-types))))
            ((none) (do)))
          (set! fi (+ fi 1))))))

  (fn resolve-field-c-type ((ctx (Ptr TranspileContext)) (kind ResolvedTypeKind) (name String))
    (@intent "Convert a resolved type kind and name to a C type string")
    (@spec (((Ptr TranspileContext) ResolvedTypeKind String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (cond
        ;; Primitive types - use builtin mapping
        ((== kind 'rk-primitive)
          (match (builtin-type-c arena name)
            ((some builtin) builtin)
            ((none) (ctx-prefix-type ctx (to-c-name arena name)))))
        ;; Pointer types
        ((== kind 'rk-ptr)
          (ctx-str ctx (to-c-name arena name) "*"))
        ;; String is slop_string
        ((string-eq name "String") "slop_string")
        ((string-eq name "Bool") "bool")
        ((string-eq name "Int") "int64_t")
        ((string-eq name "U8") "uint8_t")
        ((string-eq name "U16") "uint16_t")
        ((string-eq name "U32") "uint32_t")
        ((string-eq name "U64") "uint64_t")
        ((string-eq name "I8") "int8_t")
        ((string-eq name "I16") "int16_t")
        ((string-eq name "I32") "int32_t")
        ((string-eq name "I64") "int64_t")
        ((string-eq name "F32") "float")
        ((string-eq name "F64") "double")
        ((string-eq name "Unit") "void")
        ((string-eq name "Arena") "slop_arena*")
        ;; List type
        ((== kind 'rk-list)
          "slop_list_t*")
        ;; Option/Result use generated names
        ((== kind 'rk-option)
          (to-c-name arena name))
        ((== kind 'rk-result)
          (to-c-name arena name))
        ;; User-defined types - prefix
        (else
          (ctx-prefix-type ctx (to-c-name arena name))))))

  ;; ============================================================
  ;; Module Prescan
  ;; ============================================================

  (fn prescan-module ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan module for types and function signatures")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (prescan-top-level ctx item))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn prescan-top-level ((ctx (Ptr TranspileContext)) (item (Ptr SExpr)))
    (@intent "Prescan a top-level form")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (when (>= (list-len items) 1)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((name (. sym name)))
                      (cond
                        ((string-eq name "type")
                          (prescan-type ctx items))
                        ((string-eq name "fn")
                          (prescan-fn ctx items))
                        ((string-eq name "const")
                          (prescan-const ctx items))
                        ((string-eq name "ffi")
                          (prescan-ffi ctx items))
                        ((string-eq name "ffi-struct")
                          (prescan-ffi-struct ctx items))
                        ((string-eq name "import")
                          (prescan-import ctx items))
                        (else (do)))))
                  (else (do))))
              ((none) (do))))))
      (else (do))))

  (fn prescan-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a type definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (when (>= (list-len items) 2)
        (match (list-get items 1)
          ((some name-expr)
            (match (deref name-expr)
              ((sym sym)
                (let ((type-name (. sym name))
                      (base-c-name (to-c-name arena type-name))
                      ;; Add module prefix if prefixing is enabled
                      (c-name (if (ctx-prefixing-enabled ctx)
                                (match (ctx-get-module ctx)
                                  ((some mod-name)
                                    (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-c-name)))
                                  ((none) base-c-name))
                                base-c-name)))
                  ;; Determine type kind
                  (let ((is-enum (is-enum-def items))
                        (is-record (is-record-def items))
                        (is-union (is-union-def items))
                        ;; For array types, get element pointer type for c-type
                        (c-type (get-array-c-type ctx items c-name)))
                    (ctx-register-type ctx (TypeEntry type-name c-name c-type is-enum is-record is-union))
                    ;; Register enum variants for quote operator (use prefixed c-name)
                    (when is-enum
                      (register-enum-variants ctx c-name items))
                    ;; Register union variants for pattern matching (use prefixed c-name)
                    (when is-union
                      (register-union-variants ctx c-name items))
                    ;; Scan record/union fields for Option/List types
                    (when (or is-record is-union)
                      (when (>= (list-len items) 3)
                        (match (list-get items 2)
                          ((some def-expr)
                            (match (deref def-expr)
                              ((lst def-lst)
                                (scan-record-fields-for-generics ctx (. def-lst items)))
                              (else (do))))
                          ((none) (do))))
                      ;; Also register Option type for this record/union type itself
                      ;; since (Option UserType) is commonly used
                      (let ((type-id (type-to-identifier arena c-name))
                            (option-c-name (ctx-str ctx "slop_option_" type-id)))
                        (ctx-register-option-type ctx c-name option-c-name)))
                    ;; Check if this is a type alias to Result and register it
                    ;; Also register Map/Set type aliases for key type inference
                    (when (>= (list-len items) 3)
                      (match (list-get items 2)
                        ((some body-expr)
                          (do
                            (check-and-register-result-alias ctx type-name body-expr)
                            ;; Register Map/Set type aliases during prescan and scan for generics
                            (let ((slop-type-str (pretty-print arena body-expr)))
                              (when (or (starts-with slop-type-str "(Map ")
                                        (starts-with slop-type-str "(Set "))
                                (do
                                  (ctx-register-type-alias ctx type-name slop-type-str)
                                  ;; Scan Map/Set body to register list types for key/element
                                  (scan-type-for-generics ctx body-expr))))))
                        ((none) (do)))))))
              (else (do))))
          ((none) (do))))))

  (fn register-enum-variants ((ctx (Ptr TranspileContext)) (enum-name String) (items (List (Ptr SExpr))))
    (@intent "Register all variants of an enum for quote operator lookup")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is (type EnumName (enum variant1 variant2 ...))
    (when (>= (list-len items) 3)
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((lst def-lst)
              (let ((def-items (. def-lst items))
                    (len (list-len def-items))
                    (mut i 1))  ;; Skip 'enum' keyword
                (while (< i len)
                  (match (list-get def-items i)
                    ((some variant-expr)
                      (match (deref variant-expr)
                        ((sym sym)
                          ;; Simple variant
                          (ctx-register-enum-variant ctx (. sym name) enum-name))
                        ((lst variant-lst)
                          ;; Variant with payload - first item is name
                          (when (> (list-len (. variant-lst items)) 0)
                            (match (list-get (. variant-lst items) 0)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((sym name-sym)
                                    (ctx-register-enum-variant ctx (. name-sym name) enum-name))
                                  (else (do))))
                              ((none) (do)))))
                        (else (do))))
                    ((none) (do)))
                  (set! i (+ i 1)))))
            (else (do))))
        ((none) (do)))))

  (fn register-union-variants ((ctx (Ptr TranspileContext)) (union-name String) (items (List (Ptr SExpr))))
    (@intent "Register all variants of a union for pattern matching and hash/eq generation")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is (type UnionName (union (variant1 Type) (variant2 Type) ...))
    (let ((arena (. (deref ctx) arena)))
      (when (>= (list-len items) 3)
        (match (list-get items 2)
          ((some def-expr)
            (match (deref def-expr)
              ((lst def-lst)
                (let ((def-items (. def-lst items))
                      (len (list-len def-items))
                      (mut i 1))  ;; Skip 'union' keyword
                  (while (< i len)
                    (match (list-get def-items i)
                      ((some variant-expr)
                        (match (deref variant-expr)
                          ((sym sym)
                            ;; Simple variant without payload
                            (let ((variant-name (. sym name)))
                              (ctx-register-enum-variant ctx variant-name union-name)
                              ;; Register with empty payload type
                              (ctx-register-union-variant ctx variant-name union-name
                                                          (to-c-name arena variant-name) "" "")))
                          ((lst variant-lst)
                            ;; Variant with payload - first item is name, second is type
                            (let ((vl-items (. variant-lst items)))
                              (when (>= (list-len vl-items) 2)
                                (match (list-get vl-items 0)
                                  ((some name-expr)
                                    (match (deref name-expr)
                                      ((sym name-sym)
                                        (let ((variant-name (. name-sym name))
                                              (c-variant-name (to-c-name arena variant-name)))
                                          (ctx-register-enum-variant ctx variant-name union-name)
                                          ;; Get payload type from second element
                                          (match (list-get vl-items 1)
                                            ((some type-expr)
                                              (let ((slop-type (pretty-print arena type-expr))
                                                    (c-type (to-c-type-prefixed ctx type-expr)))
                                                (ctx-register-union-variant ctx variant-name union-name
                                                                            c-variant-name slop-type c-type)))
                                            ((none)
                                              (ctx-register-union-variant ctx variant-name union-name
                                                                          c-variant-name "" "")))))
                                      (else (do))))
                                  ((none) (do))))))
                          (else (do))))
                      ((none) (do)))
                    (set! i (+ i 1)))))
              (else (do))))
          ((none) (do))))))

  (fn prescan-fn ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a function definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (when (>= (list-len items) 2)
        (match (list-get items 1)
          ((some name-expr)
            (match (deref name-expr)
              ((sym sym)
                (let ((fn-name (. sym name))
                      (base-name (to-c-name arena fn-name))
                      ;; Add module prefix EXCEPT for main function
                      (mangled-name (if (string-eq base-name "main")
                                      base-name
                                      (ctx-prefix-type ctx base-name)))
                      ;; Check for :c-name override
                      (c-name (extract-fn-c-name arena items mangled-name))
                      ;; Check if function returns String
                      (returns-str (fn-returns-string items))
                      ;; Get full return type from @spec
                      (return-type (fn-return-type ctx items))
                      ;; Get SLOP return type for type inference
                      (slop-ret-type (get-slop-return-type ctx items))
                      ;; Collect parameter types for typed none handling
                      (param-types (prescan-collect-param-types ctx items)))
                  ;; If c-name differs from mangled-name, register alias
                  (when (not (string-eq c-name mangled-name))
                    (ctx-add-c-name-alias ctx (FuncCNameAlias fn-name mangled-name c-name)))
                  ;; Register function with the clean name (c-name)
                  (ctx-register-func ctx (FuncEntry fn-name c-name return-type slop-ret-type false returns-str param-types))
                  ;; Scan param types for List/Option generics
                  (prescan-fn-params ctx items)
                  ;; Check for Result type and other generics in @spec
                  (prescan-fn-result-type ctx items)
                  ;; Scan function body for map-new/set-new with struct key types
                  (prescan-fn-for-struct-keys ctx items)))
              (else (do))))
          ((none) (do))))))

  (fn fn-returns-string ((items (List (Ptr SExpr))))
    (@intent "Check if function returns String by examining @spec annotation")
    (@spec (((List (Ptr SExpr))) -> Bool))
    ;; Look for @spec annotation and check if return type is String
    (let ((len (list-len items))
          (mut i 3)  ;; Start after fn, name, params
          (mut result false))
      (while (and (< i len) (not result))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((lst lst)
                (let ((sub-items (. lst items)))
                  (when (>= (list-len sub-items) 2)
                    (match (list-get sub-items 0)
                      ((some head)
                        (match (deref head)
                          ((sym sym)
                            (when (string-eq (. sym name) "@spec")
                              ;; Found @spec, check return type
                              (match (list-get sub-items 1)
                                ((some spec-body)
                                  (match (deref spec-body)
                                    ((lst body-lst)
                                      (let ((body-items (. body-lst items))
                                            (body-len (list-len body-items)))
                                        ;; Return type is last element
                                        (when (>= body-len 1)
                                          (match (list-get body-items (- body-len 1))
                                            ((some ret-type)
                                              (match (deref ret-type)
                                                ((sym ret-sym)
                                                  (set! result (string-eq (. ret-sym name) "String")))
                                                (else (do))))
                                            ((none) (do))))))
                                    (else (do))))
                                ((none) (do)))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn fn-return-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Get full C return type from @spec annotation")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Look for @spec annotation and extract return type, convert to C type
    (let ((len (list-len items))
          (mut i 3)  ;; Start after fn, name, params
          (mut result ""))
      (while (and (< i len) (string-eq result ""))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((lst lst)
                (let ((sub-items (. lst items)))
                  (when (>= (list-len sub-items) 2)
                    (match (list-get sub-items 0)
                      ((some head)
                        (match (deref head)
                          ((sym sym)
                            (when (string-eq (. sym name) "@spec")
                              ;; Found @spec, extract return type
                              (match (list-get sub-items 1)
                                ((some spec-body)
                                  (match (deref spec-body)
                                    ((lst body-lst)
                                      (let ((body-items (. body-lst items))
                                            (body-len (list-len body-items)))
                                        ;; Return type is last element
                                        (when (>= body-len 1)
                                          (match (list-get body-items (- body-len 1))
                                            ((some ret-type)
                                              ;; Convert SLOP type to C type
                                              (set! result (to-c-type-prefixed ctx ret-type)))
                                            ((none) (do))))))
                                    (else (do))))
                                ((none) (do)))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn prescan-fn-params ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan function parameter types for List/Option generics")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items[2] is the param list: ((param1 Type1) (param2 Type2) ...)
    (when (>= (list-len items) 3)
      (match (list-get items 2)
        ((some params-expr)
          (match (deref params-expr)
            ((lst params-lst)
              (let ((params (. params-lst items))
                    (param-count (list-len params))
                    (mut i 0))
                (while (< i param-count)
                  (match (list-get params i)
                    ((some param-expr)
                      ;; Each param is (name Type)
                      (match (deref param-expr)
                        ((lst param-lst)
                          (let ((param-items (. param-lst items)))
                            (when (>= (list-len param-items) 2)
                              (match (list-get param-items 1)
                                ((some type-expr)
                                  (scan-type-for-generics ctx type-expr))
                                ((none) (do))))))
                        (else (do))))
                    ((none) (do)))
                  (set! i (+ i 1)))))
            (else (do))))
        ((none) (do)))))

  (fn prescan-collect-param-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Collect C types of all parameters during prescan for typed none handling")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr FuncParamType))))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (result (list-new arena (Ptr FuncParamType))))
      ;; items[2] is the param list: ((param1 Type1) (param2 Type2) ...)
      (when (>= (list-len items) 3)
        (match (list-get items 2)
          ((some params-expr)
            (match (deref params-expr)
              ((lst params-lst)
                (let ((params (. params-lst items))
                      (param-count (list-len params))
                      (mut i 0))
                  (while (< i param-count)
                    (match (list-get params i)
                      ((some param-expr)
                        (let ((c-type (prescan-get-param-c-type ctx param-expr))
                              (param-info (cast (Ptr FuncParamType) (arena-alloc arena 64))))
                          (set! (. (deref param-info) c-type) c-type)
                          (list-push result param-info)))
                      ((none) (do)))
                    (set! i (+ i 1)))))
              (else (do))))
          ((none) (do))))
      result))

  (fn prescan-get-param-c-type ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Extract C type string from a parameter expression during prescan")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "void*"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (prescan-is-param-mode items)))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items type-idx)
                  ((some type-expr)
                    (to-c-type-prefixed ctx type-expr))
                  ((none) "void*"))))))
        (else "void*"))))

  (fn prescan-is-param-mode ((items (List (Ptr SExpr))))
    (@intent "Check if first element is a parameter mode during prescan")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym)
              (let ((name (. sym name)))
                (cond
                  ((string-eq name "in") true)
                  ((string-eq name "mut") true)
                  ((string-eq name "ref") true)
                  ((string-eq name "out") true)
                  (else false))))
            (else false)))
        ((none) false))))

  (fn prescan-fn-result-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan function for Result type in @spec and register if found")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3))  ;; Start after name and params
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-spec-annotation item)
              (extract-result-type ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-spec-annotation ((expr (Ptr SExpr)))
    (@intent "Check if expression is an @spec annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (string-eq (. sym name) "@spec"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn extract-result-type ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract Result type from @spec and register it, also scan for List/Option generics")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((lst lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (when (>= (list-len items) 2)
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((lst body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (when (>= body-len 1)
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              ;; Scan return type for List/Option generics
                              (scan-type-for-generics ctx ret-type)
                              ;; Also check for Result type
                              (check-and-register-result-type ctx ret-type))
                            ((none) (do))))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn check-and-register-result-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Check if type is a Result and register it")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((lst lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (when (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (when (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with prefix if enabled
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      ;; Build result type name like slop_result_int64_t_TestError
                                      (result-name (build-result-type-name ctx ok-c-type err-c-type)))
                                  (ctx-register-result-type ctx ok-c-type err-c-type result-name)))
                              ((none) (do))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn build-result-type-name ((ctx (Ptr TranspileContext)) (ok-type String) (err-type String))
    (@intent "Build the C type name for a Result type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; Use type-to-identifier for consistent naming with ctype.slop
    (let ((arena (. (deref ctx) arena))
          (ok-id (type-to-identifier arena ok-type))
          (err-id (type-to-identifier arena err-type)))
      (ctx-str5 ctx "slop_result_" ok-id "_" err-id "")))

  ;; ============================================================
  ;; Struct Key Type Prescan
  ;;
  ;; Scan function bodies for map-new/set-new expressions and
  ;; register struct key types early so they can be emitted in header.
  ;; ============================================================

  (fn prescan-fn-for-struct-keys ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan function body for map-new/set-new with struct key types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Skip fn, name, params, annotations - scan the body
    (let ((len (list-len items))
          (mut i 3))  ;; Start after fn, name, params
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (prescan-expr-for-struct-keys ctx item))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn prescan-expr-for-struct-keys ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Recursively scan expression for map-new/set-new struct key types")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (when (>= len 1)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((name (. sym name)))
                      (cond
                        ;; (map-new arena KeyType ValueType)
                        ((string-eq name "map-new")
                          (when (>= len 3)
                            (match (list-get items 2)
                              ((some key-type-expr)
                                (prescan-register-struct-key-type ctx key-type-expr))
                              ((none) (do)))))
                        ;; (set-new arena ElemType)
                        ((string-eq name "set-new")
                          (when (>= len 3)
                            (match (list-get items 2)
                              ((some elem-type-expr)
                                (prescan-register-struct-key-type ctx elem-type-expr))
                              ((none) (do)))))
                        ;; Other - recursively scan children
                        (else
                          (let ((mut i 0))
                            (while (< i len)
                              (match (list-get items i)
                                ((some child)
                                  (prescan-expr-for-struct-keys ctx child))
                                ((none) (do)))
                              (set! i (+ i 1))))))))
                  ;; Not a symbol head - scan children
                  (else
                    (let ((mut i 0))
                      (while (< i len)
                        (match (list-get items i)
                          ((some child)
                            (prescan-expr-for-struct-keys ctx child))
                          ((none) (do)))
                        (set! i (+ i 1)))))))
              ((none) (do))))))
      ;; Non-list - nothing to scan
      (else (do))))

  (fn prescan-register-struct-key-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Register a struct type as a map/set key type if applicable")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((sym sym)
          (let ((name (. sym name)))
            ;; Skip builtin types - they don't need struct hash/eq
            (when (not (is-builtin-map-key-type name))
              ;; Look up the type
              (match (ctx-lookup-type ctx name)
                ((some type-entry)
                  (ctx-register-struct-key-type ctx (. type-entry c-name)))
                ;; Try with module prefix
                ((none)
                  (match (ctx-get-module ctx)
                    ((some mod)
                      (let ((prefixed (ctx-str3 ctx mod "_" name)))
                        (match (ctx-lookup-type ctx prefixed)
                          ((some type-entry)
                            (ctx-register-struct-key-type ctx (. type-entry c-name)))
                          ((none)
                            ;; Not found - register using converted name
                            (ctx-register-struct-key-type ctx (to-c-name arena name))))))
                    ((none)
                      ;; No module - register using converted name
                      (ctx-register-struct-key-type ctx (to-c-name arena name)))))))))
        ;; Complex type expression - skip for now
        (else (do)))))

  (fn is-builtin-map-key-type ((name String))
    (@intent "Check if type is a builtin that doesn't need struct hash/eq")
    (@spec ((String) -> Bool))
    (or (string-eq name "String")
        (or (string-eq name "Int")
            (or (string-eq name "I64")
                (or (string-eq name "I32")
                    (or (string-eq name "Uint")
                        (or (string-eq name "U64")
                            (or (string-eq name "U32")
                                (string-eq name "Symbol")))))))))

  (fn check-and-register-result-alias ((ctx (Ptr TranspileContext)) (alias-name String) (body-expr (Ptr SExpr)))
    (@intent "Check if type body is (Result OkType ErrType) and register alias if so")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((lst lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (when (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (when (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with prefix if enabled and build result name
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      (result-name (build-result-type-name ctx ok-c-type err-c-type)))
                                  ;; Register the type alias
                                  (ctx-register-result-type-alias ctx alias-name result-name)
                                  ;; Also register the Result type itself
                                  (ctx-register-result-type ctx ok-c-type err-c-type result-name)))
                              ((none) (do))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn prescan-ffi ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an FFI declaration - add header include and register functions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        ;; First item after 'ffi' is the header
        (match (list-get items 1)
          ((some header-expr)
            (match (deref header-expr)
              ((str str)
                (ctx-add-include ctx (. str value)))
              (else (do))))
          ((none) (do)))
        ;; Remaining items are function declarations: (func-name ((param Type)) ReturnType)
        (let ((mut i 2))
          (while (< i len)
            (match (list-get items i)
              ((some func-decl)
                (register-ffi-function ctx func-decl))
              ((none) (do)))
            (set! i (+ i 1)))))))

  (fn is-type-name ((name String))
    (@intent "Check if name looks like a type (starts with uppercase A-Z)")
    (@spec ((String) -> Bool))
    (if (< (string-len name) 1)
      false
      (let ((first-char (char-at name 0)))
        (and (>= first-char 65) (<= first-char 90)))))  ;; 'A' = 65, 'Z' = 90

  (fn prescan-import ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an import declaration - register imported types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Import form: (import module-name (symbols...))
    (when (>= (list-len items) 3)
      (match (list-get items 1)
        ((some mod-expr)
          (match (deref mod-expr)
            ((sym mod-sym)
              (let ((mod-name (. mod-sym name))
                    (arena (. (deref ctx) arena)))
                (ctx-add-import ctx mod-name)
                ;; Register known type variants for types module
                (when (string-eq mod-name "types")
                  (register-types-module-variants ctx))
                ;; Register file module variants
                (when (string-eq mod-name "file")
                  (register-file-module-variants ctx))
                ;; Parse the symbols list and register any types (capitalized names)
                (match (list-get items 2)
                  ((some symbols-expr)
                    (match (deref symbols-expr)
                      ((lst symbols-lst)
                        (let ((syms (. symbols-lst items))
                              (sym-len (list-len syms))
                              (mut j 0))
                          (while (< j sym-len)
                            (match (list-get syms j)
                              ((some sym-item)
                                (match (deref sym-item)
                                  ((sym s)
                                    (let ((sym-name (. s name))
                                          (c-mod-name (to-c-name arena mod-name))
                                          (c-sym-name (to-c-name arena sym-name)))
                                      (if (is-type-name sym-name)
                                        ;; Register type AND as variable (for constants like XSD_STRING)
                                        (let ((c-name (ctx-str3 ctx c-mod-name "_" c-sym-name)))
                                          (do
                                            (ctx-register-type ctx (TypeEntry sym-name c-name c-name false false false))
                                            (ctx-bind-var ctx (VarEntry sym-name c-name "auto" "" false false false "" ""))))
                                        ;; Register function with module prefix
                                        ;; Try to copy param-types from existing entry (if already processed)
                                        (let ((c-name (ctx-str3 ctx c-mod-name "_" c-sym-name))
                                              ;; Check if function was already registered (from processing imported module)
                                              (existing-func (ctx-lookup-func ctx sym-name))
                                              (param-types (match existing-func
                                                             ;; Found existing entry - copy its param-types
                                                             ((some entry) (. entry param-types))
                                                             ;; Not found - fall back to empty params
                                                             ((none) (list-new arena (Ptr FuncParamType)))))
                                              ;; Copy return-type from existing entry
                                              (ret-type (match existing-func
                                                          ((some entry) (. entry return-type))
                                                          ((none) "")))
                                              (slop-ret (match existing-func
                                                          ((some entry) (. entry slop-return-type))
                                                          ((none) "")))
                                              ;; Copy returns-pointer and returns-string from existing entry
                                              (ret-ptr (match existing-func
                                                         ((some entry) (. entry returns-pointer))
                                                         ((none) false)))
                                              (ret-str (match existing-func
                                                         ((some entry) (. entry returns-string))
                                                         ((none) false))))
                                          (ctx-register-func ctx (FuncEntry sym-name c-name ret-type slop-ret ret-ptr ret-str param-types))))))
                                  (else (do))))
                              ((none) (do)))
                            (set! j (+ j 1)))))
                      (else (do))))
                  ((none) (do)))))
            (else (do))))
        ((none) (do)))))

  (fn register-types-module-variants ((ctx (Ptr TranspileContext)))
    (@intent "Register SExpr union variants and types from the types module")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    ;; Register the types themselves so they're recognized as constructors
    ;; is_enum, is_record, is_union flags - use module-prefixed c-names
    (ctx-register-type ctx (TypeEntry "SExpr" "types_SExpr" "types_SExpr" false false true))
    (ctx-register-type ctx (TypeEntry "SExprSymbol" "types_SExprSymbol" "types_SExprSymbol" false true false))
    (ctx-register-type ctx (TypeEntry "SExprString" "types_SExprString" "types_SExprString" false true false))
    (ctx-register-type ctx (TypeEntry "SExprNumber" "types_SExprNumber" "types_SExprNumber" false true false))
    (ctx-register-type ctx (TypeEntry "SExprList" "types_SExprList" "types_SExprList" false true false))
    ;; The types module defines SExpr as a union with these variants:
    ;; (type SExpr (union (symbol SExprSymbol) (string SExprString) (number SExprNumber) (list SExprList)))
    ;; Use prefixed names since SExpr comes from types module
    (ctx-register-enum-variant ctx "sym" "types_SExpr")
    (ctx-register-enum-variant ctx "str" "types_SExpr")
    (ctx-register-enum-variant ctx "num" "types_SExpr")
    (ctx-register-enum-variant ctx "lst" "types_SExpr")
    ;; Option and Result variants are built-in and don't need module prefix
    (ctx-register-enum-variant ctx "some" "Option")
    (ctx-register-enum-variant ctx "none" "Option")
    (ctx-register-enum-variant ctx "ok" "Result")
    (ctx-register-enum-variant ctx "error" "Result"))

  (fn register-file-module-variants ((ctx (Ptr TranspileContext)))
    (@intent "Register FileMode and FileError variants from the file module")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    ;; Register FileMode enum variants
    (ctx-register-enum-variant ctx "read" "file_FileMode")
    (ctx-register-enum-variant ctx "write" "file_FileMode")
    (ctx-register-enum-variant ctx "append" "file_FileMode")
    (ctx-register-enum-variant ctx "read-write" "file_FileMode")
    (ctx-register-enum-variant ctx "write-read" "file_FileMode")
    (ctx-register-enum-variant ctx "append-read" "file_FileMode")
    ;; Register FileError enum variants
    (ctx-register-enum-variant ctx "not-found" "file_FileError")
    (ctx-register-enum-variant ctx "permission" "file_FileError")
    (ctx-register-enum-variant ctx "io-error" "file_FileError")
    (ctx-register-enum-variant ctx "eof" "file_FileError")
    (ctx-register-enum-variant ctx "invalid-mode" "file_FileError")
    (ctx-register-enum-variant ctx "closed" "file_FileError")
    ;; Register type entries for file types
    (ctx-register-type ctx (TypeEntry "FileMode" "file_FileMode" "file_FileMode" true false false))
    (ctx-register-type ctx (TypeEntry "FileError" "file_FileError" "file_FileError" true false false))
    (ctx-register-type ctx (TypeEntry "File" "file_File" "file_File" false true false)))

  (fn prescan-const ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a constant definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Constants don't need registration in prescan - just emit in order
    (do))

  (fn register-ffi-function ((ctx (Ptr TranspileContext)) (func-decl (Ptr SExpr)))
    (@intent "Register an FFI function declaration with optional :c-name alias")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {func-decl != nil})
    ;; FFI form: (func-name ((param Type)) ReturnType [:c-name actual_c_name])
    (let ((arena (. (deref ctx) arena)))
      (match (deref func-decl)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 1)
              ;; First item is function name
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym sym)
                      (let ((fn-name (. sym name))
                            ;; Look for :c-name keyword and extract actual C name
                            (c-name (extract-ffi-c-name ctx items fn-name))
                            ;; Extract param types from FFI declaration for typed none handling
                            (param-types (extract-ffi-param-types ctx items)))
                        ;; Register as external function with param types (FFI has no SLOP return type)
                        (ctx-register-func ctx (FuncEntry fn-name c-name "" "" true false param-types))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn extract-ffi-param-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Extract parameter types from an FFI function declaration")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr FuncParamType))))
    (@pre {ctx != nil})
    ;; FFI form: (func-name ((param1 Type1) (param2 Type2)) ReturnType ...)
    ;; items[1] is the param list
    (let ((arena (. (deref ctx) arena))
          (result (list-new arena (Ptr FuncParamType))))
      (when (>= (list-len items) 2)
        (match (list-get items 1)
          ((some params-expr)
            (match (deref params-expr)
              ((lst params-lst)
                (let ((params (. params-lst items))
                      (param-count (list-len params))
                      (mut i 0))
                  (while (< i param-count)
                    (match (list-get params i)
                      ((some param-expr)
                        (let ((c-type (prescan-get-param-c-type ctx param-expr))
                              (param-info (cast (Ptr FuncParamType) (arena-alloc arena 64))))
                          (set! (. (deref param-info) c-type) c-type)
                          (list-push result param-info)))
                      ((none) (do)))
                    (set! i (+ i 1)))))
              (else (do))))
          ((none) (do))))
      result))

  (fn extract-ffi-c-name ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (fn-name String))
    (@intent "Extract C name from FFI declaration - use :c-name value if present, else convert fn-name")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 0)
          (mut found-c-name false)
          (mut c-name ""))
      ;; Scan for :c-name keyword
      (while (< i len)
        (match (list-get items i)
          ((some item-expr)
            (match (deref item-expr)
              ((sym sym)
                (when (string-eq (. sym name) ":c-name")
                  ;; Next item is the actual C name
                  (match (list-get items (+ i 1))
                    ((some c-name-expr)
                      (match (deref c-name-expr)
                        ((sym c-sym)
                          (set! c-name (. c-sym name))
                          (set! found-c-name true))
                        (else (do))))
                    ((none) (do)))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Return found C name or convert from SLOP name
      (if found-c-name c-name (to-c-name arena fn-name))))

  (fn prescan-ffi-struct ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an FFI struct declaration with optional :c-name modifier")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Supports: (ffi-struct "header.h" name [:c-name "c_name"] fields...)
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        ;; Check if second item is a header string
        (let ((has-header (and (>= len 2) (is-ffi-string-item items 1)))
              (name-idx (if (and (>= len 2) (is-ffi-string-item items 1)) 2 1)))
          ;; Add header include if present
          (when has-header
            (match (list-get items 1)
              ((some header-expr)
                (match (deref header-expr)
                  ((str str)
                    (ctx-add-include ctx (. str value)))
                  (else (do))))
              ((none) (do))))
          ;; Register struct type
          (when (>= len (+ name-idx 1))
            (match (list-get items name-idx)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym)
                    (let ((type-name (. sym name))
                          ;; Check for :c-name modifier after the type name
                          (c-name (get-ffi-struct-c-name arena items name-idx type-name)))
                      ;; Register as external struct type with proper C name
                      (ctx-register-type ctx (TypeEntry type-name c-name c-name false true false))))
                  (else (do))))
              ((none) (do))))))))

  (fn get-ffi-struct-c-name ((arena Arena) (items (List (Ptr SExpr))) (name-idx Int) (default-name String))
    (@intent "Get the C name for FFI struct, checking for :c-name modifier")
    (@spec ((Arena (List (Ptr SExpr)) Int String) -> String))
    ;; Look for :c-name modifier after the name
    ;; Format: (ffi-struct "header" name :c-name "actual_c_name" ...)
    (let ((len (list-len items))
          (modifier-idx (+ name-idx 1)))
      (if (>= len (+ modifier-idx 2))
        ;; Check if next item is :c-name
        (match (list-get items modifier-idx)
          ((some mod-expr)
            (match (deref mod-expr)
              ((sym sym)
                (if (string-eq (. sym name) ":c-name")
                  ;; Get the C name string
                  (match (list-get items (+ modifier-idx 1))
                    ((some cname-expr)
                      (match (deref cname-expr)
                        ((str str)
                          ;; Apply heuristic: if ends with _t, use directly; otherwise add struct
                          (apply-struct-prefix-heuristic arena (. str value)))
                        (_ (apply-struct-prefix-heuristic arena default-name))))
                    ((none) (apply-struct-prefix-heuristic arena default-name)))
                  (apply-struct-prefix-heuristic arena default-name)))
              (_ (apply-struct-prefix-heuristic arena default-name))))
          ((none) (apply-struct-prefix-heuristic arena default-name)))
        (apply-struct-prefix-heuristic arena default-name))))

  (fn apply-struct-prefix-heuristic ((arena Arena) (name String))
    (@intent "Apply struct prefix heuristic: names ending in _t are typedefs, others need struct")
    (@spec ((Arena String) -> String))
    ;; Heuristic: types ending in _t are usually typedefs (no struct prefix)
    ;; Other types are usually C structs (need struct prefix)
    (if (string-ends-with name "_t")
      name
      (string-concat arena "struct " name)))

  (fn string-ends-with ((s String) (suffix String))
    (@intent "Check if string ends with given suffix")
    (@spec ((String String) -> Bool))
    (let ((s-len (string-len s))
          (suf-len (string-len suffix)))
      (if (< s-len suf-len)
        false
        ;; Compare last suf-len chars
        (let ((start (- (cast Int s-len) (cast Int suf-len)))
              (mut i 0)
              (mut matches true))
          (while (and matches (< i (cast Int suf-len)))
            (let ((s-char (@ (. s data) (+ start i)))
                  (suf-char (@ (. suffix data) i)))
              (when (!= s-char suf-char)
                (set! matches false)))
            (set! i (+ i 1)))
          matches))))

  (fn is-ffi-string-item ((items (List (Ptr SExpr))) (idx Int))
    (@intent "Check if item at index is a string")
    (@spec (((List (Ptr SExpr)) Int) -> Bool))
    (match (list-get items idx)
      ((some item)
        (match (deref item)
          ((str _) true)
          (else false)))
      ((none) false)))

  (fn is-enum-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is an enum")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((lst def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym) (string-eq (. sym name) "enum"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn is-record-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is a record")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((lst def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym) (string-eq (. sym name) "record"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn is-union-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is a union")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((lst def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym) (string-eq (. sym name) "union"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn get-array-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (default-c-type String))
    (@intent "Get c-type for type definition - returns element pointer type for arrays")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    ;; Check if items[2] (type body) is (Array T size)
    (if (< (list-len items) 3)
      default-c-type
      (match (list-get items 2)
        ((some body-expr)
          (match (deref body-expr)
            ((lst body-lst)
              (let ((body-items (. body-lst items)))
                (if (< (list-len body-items) 2)
                  default-c-type
                  (match (list-get body-items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym)
                          (if (string-eq (. sym name) "Array")
                            ;; Array type - get element type and return element pointer
                            (match (list-get body-items 1)
                              ((some elem-expr)
                                (let ((elem-c (to-c-type-prefixed ctx elem-expr)))
                                  (ctx-str ctx elem-c "*")))
                              ((none) default-c-type))
                            default-c-type))
                        (else default-c-type)))
                    ((none) default-c-type)))))
            (else default-c-type)))
        ((none) default-c-type))))

  ;; ============================================================
  ;; Process Imports/Exports
  ;; ============================================================

  (fn process-imports ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Process import declarations")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Imports are handled by the resolver in multi-module builds
    ;; Here we just need to ensure any required includes are added
    (do))

  (fn process-exports ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Process export declarations")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Exports are handled by the resolver
    (do))

  ;; ============================================================
  ;; Type Emission
  ;; ============================================================

  (fn emit-all-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit all type definitions in dependency order")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Two-pass emission: unions depend on their payload types, so emit non-unions first
    ;; Pass 1: Emit all non-union types (records, enums, type aliases)
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (not (is-union-type-def item)))
              (transpile-type ctx item)))
          ((none) (do)))
        (set! i (+ i 1))))
    ;; Pass 2: Emit all union types (which may depend on pass 1 types)
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-union-type-def item))
              (transpile-type ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-union-type-def ((item (Ptr SExpr)))
    (@intent "Check if item is a union type definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            ;; Check if third element starts with 'union'
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((lst def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((sym sym) (string-eq (. sym name) "union"))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-type-def ((item (Ptr SExpr)))
    (@intent "Check if item is a type definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (string-eq (. sym name) "type"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Function Emission
  ;; ============================================================

  (fn emit-all-functions ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit all function definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (transpile-function ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-fn-def ((item (Ptr SExpr)))
    (@intent "Check if item is a function definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (string-eq (. sym name) "fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Main Transpilation
  ;; ============================================================

  (fn transpile-module ((ctx (Ptr TranspileContext)) (module-expr (Ptr SExpr)))
    (@intent "Transpile a complete module")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {module-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref module-expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 2)
              ;; Get module name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym sym)
                      (ctx-set-module ctx (some (. sym name))))
                    (else (do))))
                ((none) (do)))
              ;; Get module body (skip module head and name)
              ;; Check for export list
              (let ((body-start (get-body-start items))
                    (exports (get-export-names arena items)))
                ;; Prescan for types and functions
                (prescan-module-body ctx items body-start)

                ;; ===== HEADER OUTPUT =====
                ;; Emit header guard opening
                (emit-header-guard-open ctx)
                ;; Emit standard includes to header
                (emit-header-standard-includes ctx)
                ;; Emit dependency includes for imports
                (emit-header-dependency-includes ctx)
                ;; Emit FFI includes to header
                (emit-ffi-includes-header ctx)
                (ctx-emit-header ctx "")
                ;; Emit type forward declarations to header (typedef struct X X;)
                (emit-forward-decls-header ctx items body-start)
                ;; Emit simple enums (no payload, no dependencies)
                (emit-simple-enums-header ctx items body-start)
                ;; Emit inline record types (used in Result types)
                (emit-inline-records-header ctx)
                ;; Emit pointer-element List types (only need forward decls)
                (emit-list-types-header ctx)
                ;; Emit pointer-element Option types (only need forward decls)
                (emit-option-types-header ctx)
                ;; Emit Chan types (require slop_thread.h)
                (emit-chan-types-header ctx)
                ;; Emit Thread types (require slop_thread.h)
                (emit-thread-types-header ctx)
                ;; Emit simple type aliases (range types, etc.) before struct types that may use them
                (emit-simple-type-aliases-header ctx items body-start)
                ;; Emit value-element List/Option types for primitives (String, Int, etc.)
                ;; These don't depend on any struct types, so emit them early
                (emit-primitive-list-types-header ctx)
                (emit-primitive-option-types-header ctx)
                ;; Emit value-element List/Option types for imported types
                ;; These depend on types from other modules (available via includes)
                (emit-imported-list-types-header ctx)
                (emit-imported-option-types-header ctx)
                ;; Emit value-element List types for type aliases (range types, etc.)
                ;; These depend on type aliases being defined first
                (emit-value-list-types-header ctx)
                ;; Emit all struct/union types in dependency order (topological sort)
                ;; This handles the ordering automatically: types are emitted only when
                ;; all their non-pointer field types are already emitted.
                ;; Option/List types for each struct/union are emitted immediately after.
                (emit-struct-union-types-sorted ctx items body-start)
                ;; Emit any remaining value-element List types (for complex struct elements)
                (emit-complex-value-list-types-header ctx)
                ;; Emit hash/eq functions and list types for struct map/set keys
                (emit-struct-key-types-header ctx)
                ;; Emit generated Result types
                (emit-result-types-header ctx)
                ;; Emit Result type aliases (after Result types so they can reference slop_result_*)
                (emit-type-aliases-header ctx items body-start)
                ;; Emit channel send/recv functions (after all types are defined)
                (emit-chan-funcs-header ctx)
                ;; Emit function forward declarations to header
                (emit-fn-forward-decls-header ctx items body-start)
                ;; Emit function C name aliases (for :c-name support)
                (emit-c-name-aliases ctx)
                ;; Emit exported constant declarations to header
                (emit-module-consts-header ctx items body-start exports)
                ;; Note: Header guard closing moved to after function transpilation
                ;; to allow late-registered option types to be emitted

                ;; ===== IMPL OUTPUT =====
                ;; Types, includes, and forward declarations are now in header
                ;; Implementation file only contains function bodies
                ;; (The CLI adds #include of the module's own header)
                ;; Emit constants first (before functions that use them)
                (emit-module-consts ctx items body-start exports)
                ;; Emit forward declarations for internal (non-exported) functions
                ;; This ensures functions can call each other regardless of definition order
                (emit-fn-forward-decls ctx items body-start)
                ;; Emit functions
                (emit-module-functions ctx items body-start)
                ;; Emit any late-registered option types to header (discovered during function transpilation)
                (emit-late-registered-option-types-header ctx)
                ;; Now close the header guard
                (emit-header-guard-close ctx)))))
        (else (ctx-emit ctx "/* invalid module */")))))

  (fn get-body-start ((items (List (Ptr SExpr))))
    (@intent "Get the starting index of module body (after exports)")
    (@spec (((List (Ptr SExpr))) -> Int))
    ;; Skip: (module name) or (module name (export ...))
    (if (< (list-len items) 3)
      2  ;; Just module and name
      (match (list-get items 2)
        ((some third)
          (match (deref third)
            ((lst lst)
              (let ((sub-items (. lst items)))
                (if (< (list-len sub-items) 1)
                  2
                  (match (list-get sub-items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym)
                          (if (string-eq (. sym name) "export")
                            3  ;; Skip export list
                            2))
                        (else 2)))
                    ((none) 2)))))
            (else 2)))
        ((none) 2))))

  (fn get-export-names ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Extract the list of exported symbol names from module items")
    (@spec ((Arena (List (Ptr SExpr))) -> (List String)))
    ;; Search for (export sym1 sym2 ...) in module items, return list of symbol names
    (let ((result (list-new arena String))
          (len (list-len items))
          (mut i 2))  ;; Start after module name
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((lst lst)
                (let ((sub-items (. lst items)))
                  (when (>= (list-len sub-items) 1)
                    (match (list-get sub-items 0)
                      ((some head)
                        (match (deref head)
                          ((sym sym)
                            (when (string-eq (. sym name) "export")
                              ;; Extract names from export form
                              (let ((export-len (list-len sub-items))
                                    (mut j 1))
                                (while (< j export-len)
                                  (match (list-get sub-items j)
                                    ((some name-expr)
                                      (match (deref name-expr)
                                        ((sym name-sym) (list-push result (. name-sym name)))
                                        (else (do))))
                                    ((none) (do)))
                                  (set! j (+ j 1))))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn list-contains-str ((lst (List String)) (needle String))
    (@intent "Check if a list of strings contains the given string")
    (@spec (((List String) String) -> Bool))
    (let ((len (list-len lst))
          (mut i 0)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get lst i)
          ((some s)
            (when (string-eq s needle)
              (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn prescan-module-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Prescan module body starting at given index")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (prescan-top-level ctx item))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Option/List Type Scanning
  ;; ============================================================

  (fn scan-type-for-generics ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Scan a type expression and register any Option/List types found")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 1)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (let ((op (. sym name)))
                        (cond
                          ;; Option type
                          ((string-eq op "Option")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some inner)
                                  ;; Use prefixed inner type and build container name from it
                                  (let ((inner-c (to-c-type-prefixed ctx inner))
                                        (inner-id (type-to-identifier arena inner-c))
                                        (c-name (ctx-str ctx "slop_option_" inner-id)))
                                    (ctx-register-option-type ctx inner-c c-name)
                                    ;; Recursively scan inner type
                                    (scan-type-for-generics ctx inner)))
                                ((none) (do)))))
                          ;; List type
                          ((string-eq op "List")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some elem)
                                  ;; Use prefixed element type and build container name from it
                                  (let ((elem-c (to-c-type-prefixed ctx elem))
                                        (elem-id (type-to-identifier arena elem-c))
                                        (c-name (ctx-str ctx "slop_list_" elem-id))
                                        (option-c-name (ctx-str ctx "slop_option_" elem-id)))
                                    (ctx-register-list-type ctx elem-c c-name)
                                    ;; Also register Option type for element since list-get returns Option<T>
                                    (ctx-register-option-type ctx elem-c option-c-name)
                                    ;; Recursively scan element type
                                    (scan-type-for-generics ctx elem)))
                                ((none) (do)))))
                          ;; Ptr type - scan inner
                          ((string-eq op "Ptr")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some inner) (scan-type-for-generics ctx inner))
                                ((none) (do)))))
                          ;; Result type - register and scan inner types
                          ((string-eq op "Result")
                            (when (>= len 3)
                              (match (list-get items 1)
                                ((some ok-type)
                                  (match (list-get items 2)
                                    ((some err-type)
                                      ;; Register the Result type
                                      (let ((ok-c (to-c-type-prefixed ctx ok-type))
                                            (err-c (to-c-type-prefixed ctx err-type))
                                            (ok-id (type-to-identifier arena ok-c))
                                            (err-id (type-to-identifier arena err-c))
                                            (c-name (ctx-str5 ctx "slop_result_" ok-id "_" err-id "")))
                                        (ctx-register-result-type ctx ok-c err-c c-name)
                                        ;; Recursively scan inner types for nested generics
                                        (scan-type-for-generics ctx ok-type)
                                        (scan-type-for-generics ctx err-type)))
                                    ((none) (do))))
                                ((none) (do)))))
                          ;; Chan type
                          ((string-eq op "Chan")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some elem)
                                  (let ((elem-c (to-c-type-prefixed ctx elem))
                                        (elem-id (type-to-identifier arena elem-c))
                                        (c-name (ctx-str ctx "slop_chan_" elem-id)))
                                    (ctx-register-chan-type ctx elem-c c-name)
                                    (scan-type-for-generics ctx elem)))
                                ((none) (do)))))
                          ;; Thread type
                          ((string-eq op "Thread")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some result)
                                  (let ((result-c (to-c-type-prefixed ctx result)))
                                    ;; Map void to int64_t (void can't be a struct field)
                                    (let ((actual-c (if (string-eq result-c "void") "int64_t" result-c))
                                          (result-id (type-to-identifier arena actual-c))
                                          (c-name (ctx-str ctx "slop_thread_" result-id)))
                                      (ctx-register-thread-type ctx actual-c c-name)
                                      (scan-type-for-generics ctx result))))
                                ((none) (do)))))
                          ;; Map type - register list type for key to support map-keys iteration
                          ((string-eq op "Map")
                            (when (>= len 3)
                              (match (list-get items 1)
                                ((some key-type)
                                  (let ((key-c (to-c-type-prefixed ctx key-type))
                                        (key-id (type-to-identifier arena key-c))
                                        (list-c-name (ctx-str ctx "slop_list_" key-id))
                                        (option-c-name (ctx-str ctx "slop_option_" key-id)))
                                    (ctx-register-list-type ctx key-c list-c-name)
                                    (ctx-register-option-type ctx key-c option-c-name)
                                    (scan-type-for-generics ctx key-type)
                                    ;; Also scan value type for nested generics
                                    (match (list-get items 2)
                                      ((some val-type) (scan-type-for-generics ctx val-type))
                                      ((none) (do)))))
                                ((none) (do)))))
                          ;; Set type - register list type for element to support set iteration
                          ((string-eq op "Set")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some elem-type)
                                  (let ((elem-c (to-c-type-prefixed ctx elem-type))
                                        (elem-id (type-to-identifier arena elem-c))
                                        (list-c-name (ctx-str ctx "slop_list_" elem-id))
                                        (option-c-name (ctx-str ctx "slop_option_" elem-id)))
                                    (ctx-register-list-type ctx elem-c list-c-name)
                                    (ctx-register-option-type ctx elem-c option-c-name)
                                    (scan-type-for-generics ctx elem-type)))
                                ((none) (do)))))
                          (else (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn scan-record-fields-for-generics ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Scan record fields for Option/List types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is like (record (field1 Type1) (field2 Type2) ...)
    (let ((len (list-len items))
          (mut i 1))  ;; Skip 'record' keyword
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 1)
                      ((some type-expr)
                        (scan-type-for-generics ctx type-expr))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-ffi-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit FFI header includes to impl")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((includes (ctx-get-includes ctx))
          (len (list-len includes))
          (mut i 0))
      (while (< i len)
        (match (list-get includes i)
          ((some header)
            (emit-include ctx header true))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-ffi-includes-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit FFI header includes to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((includes (ctx-get-includes ctx))
          (len (list-len includes))
          (mut i 0))
      (while (< i len)
        (match (list-get includes i)
          ((some header)
            (ctx-emit-header ctx (ctx-str3 ctx "#include <" header ">")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-header-guard-open ((ctx (Ptr TranspileContext)))
    (@intent "Emit opening header guard")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (ctx-get-module ctx)
        ((some mod-name)
          (let ((c-name (to-c-name arena mod-name))
                (guard (ctx-str3 ctx "SLOP_" c-name "_H")))
            (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard))
            (ctx-emit-header ctx (ctx-str ctx "#define " guard))
            (ctx-emit-header ctx "")))
        ((none) (do)))))

  (fn emit-header-guard-close ((ctx (Ptr TranspileContext)))
    (@intent "Emit closing header guard")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (ctx-emit-header ctx "")
    (ctx-emit-header ctx "#endif"))

  (fn emit-header-standard-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit standard includes to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (ctx-emit-header ctx "#include \"slop_runtime.h\"")
    (ctx-emit-header ctx "#include <stdint.h>")
    (ctx-emit-header ctx "#include <stdbool.h>"))

  (fn emit-header-dependency-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit dependency includes for imported modules")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (imports (ctx-get-imports ctx))
          (len (list-len imports))
          (mut i 0))
      (while (< i len)
        (match (list-get imports i)
          ((some mod-name)
            (let ((c-name (to-c-name arena mod-name)))
              (ctx-emit-header ctx (ctx-str3 ctx "#include \"slop_" c-name ".h\""))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-forward-decls ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit forward declarations for record/union types only")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (match (get-type-name item)
                ((some type-name)
                  (let ((c-name (to-c-name arena type-name)))
                    (ctx-emit ctx (ctx-str3 ctx "typedef struct " c-name (ctx-str ctx " " (ctx-str ctx c-name ";"))))
                    (set! emitted-any true)))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn is-struct-type-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a record or union (needs struct forward decl)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((lst def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((sym sym)
                                (let ((kind (. sym name)))
                                  (or (string-eq kind "record")
                                      (string-eq kind "union")
                                      ;; enum with payload variants is also a struct
                                      (and (string-eq kind "enum")
                                           (has-enum-payload-variants def-items)))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn has-enum-payload-variants ((items (List (Ptr SExpr))))
    (@intent "Check if enum has payload variants (making it a union)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len items))
          (mut i 1)  ;; Skip 'enum' keyword
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((lst _) (set! found true))  ;; List variant = payload
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-type-alias-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a simple type alias (not record/enum/union)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    ;; Type alias is: (type Name SimpleType) where SimpleType is a symbol or
    ;; a type expression that is NOT record/enum/union (e.g., range type, Int, Option, etc.)
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ;; Symbol body = simple alias like (type AsciiChar U8)
                  ((sym _) true)
                  ;; List body - check if it's NOT record/enum/union
                  ((lst def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((sym sym)
                                (let ((kind (. sym name)))
                                  ;; NOT record/enum/union means it's an alias (e.g., (Int 0 .. 100), (Option T))
                                  (and (not (string-eq kind "record"))
                                       (not (string-eq kind "enum"))
                                       (not (string-eq kind "union")))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-result-type-alias-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a Result type alias")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    ;; Result type alias is: (type Name (Result ...))
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((lst def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((sym sym)
                                (string-eq (. sym name) "Result"))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-type-alias-to-header ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit a type alias definition to header as typedef")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((lst lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 3)
              ;; (type TypeName body)
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym name-sym)
                      (let ((type-name (. name-sym name))
                            (base-c-name (to-c-name arena type-name))
                            ;; Add module prefix if enabled
                            (c-name (ctx-prefix-type ctx base-c-name)))
                        (match (list-get items 2)
                          ((some body-expr)
                            (cond
                              ;; Check if Array type - needs special handling
                              ((is-array-type-body body-expr)
                                (emit-array-typedef-to-header ctx c-name body-expr))
                              ;; Check if range type - needs _new constructor
                              ((is-range-type-body body-expr)
                                (emit-range-typedef-to-header ctx type-name c-name body-expr))
                              ;; Standard typedef
                              (else
                                (let ((c-type (to-c-type-prefixed ctx body-expr)))
                                  (ctx-emit-header ctx (ctx-str5 ctx "typedef " c-type " " c-name ";"))
                                  (ctx-emit-header ctx "")
                                  ;; Mark typedef as emitted for dependency tracking
                                  (ctx-mark-type-emitted ctx c-name)))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn is-array-type-body ((body-expr (Ptr SExpr)))
    (@intent "Check if type body is an Array type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {body-expr != nil})
    (match (deref body-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (string-eq (. sym name) "Array"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-array-typedef-to-header ((ctx (Ptr TranspileContext)) (c-name String) (body-expr (Ptr SExpr)))
    (@intent "Emit Array typedef to header: typedef T NAME[SIZE];")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; (Array T size)
            (if (< len 3)
              ;; Invalid array type, fall back to pointer
              (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";"))
              (match (list-get items 1)
                ((some elem-type-expr)
                  (match (list-get items 2)
                    ((some size-expr)
                      (let ((elem-c-type (to-c-type-prefixed ctx elem-type-expr))
                            (size-str (get-array-size-string size-expr)))
                        ;; Emit: typedef T NAME[SIZE];
                        (ctx-emit-header ctx (ctx-str5 ctx "typedef " elem-c-type " " c-name (ctx-str3 ctx "[" size-str "];")))
                        (ctx-emit-header ctx "")))
                    ((none)
                      (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";")))))
                ((none)
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";")))))))
        (else
          (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";"))))))

  (fn get-array-size-string ((expr (Ptr SExpr)))
    (@intent "Get number value as string for array size")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((num num)
        (. num raw))
      (else "0")))

  ;; ============================================================
  ;; Range Type Handling for Header
  ;; ============================================================

  (fn is-range-type-body ((body-expr (Ptr SExpr)))
    (@intent "Check if type body is a range type like (Int 0 .. 100)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {body-expr != nil})
    (match (deref body-expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items))
              (mut found-dots false)
              (mut i 0))
          ;; Look for '..' symbol in the items
          (while (and (< i len) (not found-dots))
            (match (list-get items i)
              ((some item)
                (match (deref item)
                  ((sym sym)
                    (when (string-eq (. sym name) "..")
                      (set! found-dots true)))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          found-dots))
      (else false)))

  (type RangeBoundsHeader (record
    (min Int)
    (max Int)
    (has-min Bool)
    (has-max Bool)))

  (fn parse-range-bounds-header ((body-expr (Ptr SExpr)))
    (@intent "Parse range bounds from type like (Int 0 .. 100)")
    (@spec (((Ptr SExpr)) -> RangeBoundsHeader))
    (@pre {body-expr != nil})
    (let ((mut min-val 0)
          (mut max-val 0)
          (mut has-min false)
          (mut has-max false)
          (mut found-dots false))
      (match (deref body-expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 1))  ;; Skip the base type (first item)
            (while (< i len)
              (match (list-get items i)
                ((some item)
                  (match (deref item)
                    ((num num)
                      (if (not found-dots)
                        ;; Number before '..' is min
                        (do
                          (set! min-val (string-to-int-header (. num raw)))
                          (set! has-min true))
                        ;; Number after '..' is max
                        (do
                          (set! max-val (string-to-int-header (. num raw)))
                          (set! has-max true))))
                    ((sym sym)
                      (when (string-eq (. sym name) "..")
                        (set! found-dots true)))
                    (else (do))))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))
      (RangeBoundsHeader min-val max-val has-min has-max)))

  (fn string-to-int-header ((s String))
    (@intent "Convert string to integer")
    (@spec ((String) -> Int))
    (let ((len (cast Int (string-len s)))
          (mut result 0)
          (mut i 0)
          (mut negative false))
      ;; Handle negative sign
      (when (and (> len 0) (== (@ (. s data) 0) 45))  ;; '-' = 45
        (set! negative true)
        (set! i 1))
      (while (< i len)
        (let ((c (@ (. s data) i)))
          (when (and (>= c 48) (<= c 57))  ;; '0'-'9' = 48-57
            (set! result (+ (* result 10) (- (cast Int c) 48)))))
        (set! i (+ i 1)))
      (if negative (- 0 result) result)))

  (fn select-smallest-c-type-header ((min-val Int) (max-val Int) (has-min Bool) (has-max Bool))
    (@intent "Select smallest C type that fits the range")
    (@spec ((Int Int Bool Bool) -> String))
    (cond
      ;; Both bounds specified - can optimize
      ((and has-min has-max)
        (cond
          ;; uint8_t: 0 to 255
          ((and (>= min-val 0) (<= max-val 255))
            "uint8_t")
          ;; uint16_t: 0 to 65535
          ((and (>= min-val 0) (<= max-val 65535))
            "uint16_t")
          ;; int8_t: -128 to 127
          ((and (>= min-val (- 0 128)) (<= max-val 127))
            "int8_t")
          ;; int16_t: -32768 to 32767
          ((and (>= min-val (- 0 32768)) (<= max-val 32767))
            "int16_t")
          ;; Default to int64_t
          (else "int64_t")))
      ;; Default to int64_t for unbounded ranges
      (else "int64_t")))

  (fn emit-range-typedef-to-header ((ctx (Ptr TranspileContext)) (raw-name String) (c-name String) (body-expr (Ptr SExpr)))
    (@intent "Emit typedef and _new constructor for range type to header")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (bounds RangeBoundsHeader (parse-range-bounds-header body-expr))
          (min-val Int (. bounds min))
          (max-val Int (. bounds max))
          (has-min Bool (. bounds has-min))
          (has-max Bool (. bounds has-max))
          (c-type (select-smallest-c-type-header min-val max-val has-min has-max)))
      ;; Emit typedef
      (ctx-emit-header ctx (ctx-str5 ctx "typedef " c-type " " c-name ";"))
      (ctx-emit-header ctx "")
      ;; Mark the type as emitted for dependency tracking
      (ctx-mark-type-emitted ctx c-name)
      ;; Emit _new constructor
      (ctx-emit-header ctx (ctx-str5 ctx "static inline " c-name " " c-name "_new(int64_t v) {"))
      (ctx-indent ctx)
      ;; Emit bounds check using SLOP_PRE
      (cond
        ;; Both bounds
        ((and has-min has-max)
          (let ((min-str (int-to-string arena min-val))
                (max-str (int-to-string arena max-val)))
            (ctx-emit-header ctx (ctx-str ctx "SLOP_PRE(v >= " (ctx-str ctx min-str (ctx-str ctx " && v <= " (ctx-str ctx max-str (ctx-str ctx ", \"" (ctx-str ctx c-name (ctx-str ctx " in range " (ctx-str ctx min-str (ctx-str ctx ".." (ctx-str ctx max-str "\");")))))))))))))
        ;; Only min bound
        (has-min
          (let ((min-str (int-to-string arena min-val)))
            (ctx-emit-header ctx (ctx-str ctx "SLOP_PRE(v >= " (ctx-str ctx min-str (ctx-str ctx ", \"" (ctx-str ctx c-name (ctx-str ctx " >= " (ctx-str ctx min-str "\");")))))))))
        ;; Only max bound
        (has-max
          (let ((max-str (int-to-string arena max-val)))
            (ctx-emit-header ctx (ctx-str ctx "SLOP_PRE(v <= " (ctx-str ctx max-str (ctx-str ctx ", \"" (ctx-str ctx c-name (ctx-str ctx " <= " (ctx-str ctx max-str "\");")))))))))
        (else (do)))
      ;; Emit return
      (ctx-emit-header ctx (ctx-str ctx "return (" (ctx-str ctx c-name ")v;")))
      (ctx-dedent ctx)
      (ctx-emit-header ctx "}")
      (ctx-emit-header ctx "")
      ;; Register as type alias so hash/eq generation can detect range types
      (ctx-register-type-alias ctx raw-name (pretty-print arena body-expr))))

  (fn emit-forward-decls-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit forward declarations for types to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (match (get-type-name item)
                ((some type-name)
                  (let ((base-name (to-c-name arena type-name))
                        ;; Add module prefix if prefixing is enabled
                        (c-name (if (ctx-prefixing-enabled ctx)
                                  (match (ctx-get-module ctx)
                                    ((some mod-name)
                                      (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                    ((none) base-name))
                                  base-name)))
                    (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name (ctx-str ctx " " (ctx-str ctx c-name ";"))))
                    (set! emitted-any true)))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit-header ctx ""))))

  (fn emit-fn-forward-decls ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit function forward declarations to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (emit-forward-declaration ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-fn-forward-decls-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit function forward declarations to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (emit-fn-forward-decl-header ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit-header ctx ""))))

  (fn emit-c-name-aliases ((ctx (Ptr TranspileContext)))
    (@intent "Emit #define aliases for functions with :c-name")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((aliases (ctx-get-c-name-aliases ctx))
          (len (list-len aliases))
          (mut i 0))
      (when (> len 0)
        (ctx-emit-header ctx "/* Function name aliases for C interop */")
        (while (< i len)
          (match (list-get aliases i)
            ((some alias)
              ;; Emit: #define mangled_name clean_name
              (ctx-emit-header ctx (ctx-str ctx "#define "
                (ctx-str ctx (. alias mangled-name)
                  (ctx-str ctx " " (. alias clean-name))))))
            ((none) (do)))
          (set! i (+ i 1)))
        (ctx-emit-header ctx ""))))

  (fn emit-fn-forward-decl-header ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit a single function forward declaration to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix EXCEPT for main function
                            (mangled-name (if (string-eq base-name "main")
                                            base-name
                                            (ctx-prefix-type ctx base-name)))
                            ;; Check for :c-name override
                            (fn-name (extract-fn-c-name arena items mangled-name)))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            ;; Check for Result type first
                            (let ((result-type-opt (get-result-type-name ctx items))
                                  (raw-return (get-return-type ctx items)))
                              (let ((return-type String (match result-type-opt
                                                          ((some result-name) result-name)
                                                          ((none) raw-return)))
                                    ;; Special case: main returns int
                                    (actual-return (if (string-eq base-name "main") "int" return-type))
                                    (param-str (build-param-str ctx params-expr)))
                                (ctx-emit-header ctx (ctx-str5 ctx actual-return " " fn-name "("
                                                (ctx-str ctx (if (string-eq param-str "") "void" param-str) ");"))))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn get-type-name ((item (Ptr SExpr)))
    (@intent "Get the name from a type definition")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym) (some (. sym name)))
                  (else none)))
              ((none) none)))))
      (else none)))

  (fn emit-module-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all type definitions from module to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-type-def item)
              (transpile-type ctx item)
              (ctx-emit ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-type-aliases ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit type aliases (non-struct, non-enum types)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-type-alias-def item))
              (transpile-type ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-enum-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple enum type definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (transpile-type ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-struct-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit struct (record/union) type definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (transpile-type ctx item)
              (ctx-emit ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-result-types ((ctx (Ptr TranspileContext)))
    (@intent "Emit all registered Result type definitions to impl")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((result-types (ctx-get-result-types ctx))
          (len (list-len result-types))
          (mut i 0))
      (while (< i len)
        (match (list-get result-types i)
          ((some rt)
            (emit-single-result-type ctx rt))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-result-type ((ctx (Ptr TranspileContext)) (rt ResultType))
    (@intent "Emit a single Result type struct definition to impl")
    (@spec (((Ptr TranspileContext) ResultType) -> Unit))
    (@pre {ctx != nil})
    (let ((ok-type (. rt ok-type))
          (err-type (. rt err-type))
          (c-name (. rt c-name))
          ;; Create guard macro name from c-name (uppercase)
          (guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
      ;; #ifndef GUARD_DEFINED
      (ctx-emit ctx (ctx-str ctx "#ifndef " guard-name))
      ;; #define GUARD_DEFINED
      (ctx-emit ctx (ctx-str ctx "#define " guard-name))
      ;; typedef struct { bool is_ok; union { ok_type ok; err_type err; } data; } NAME;
      ;; Note: C doesn't allow void in a union, so we use uint8_t as placeholder
      (let ((part1 "typedef struct { bool is_ok; union { ")
            (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type))
            (part2 (ctx-str3 ctx actual-ok-type " ok; " err-type))
            (part3 (ctx-str3 ctx " err; } data; } " c-name ";")))
        (ctx-emit ctx (ctx-str3 ctx part1 part2 part3)))
      ;; #endif
      (ctx-emit ctx "#endif")
      (ctx-emit ctx "")))

  (fn emit-result-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit all registered Result type definitions to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((result-types (ctx-get-result-types ctx))
          (len (list-len result-types))
          (mut i 0))
      (while (< i len)
        (match (list-get result-types i)
          ((some rt)
            (emit-single-result-type-header ctx rt))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-result-type-header ((ctx (Ptr TranspileContext)) (rt ResultType))
    (@intent "Emit a single Result type struct definition to header")
    (@spec (((Ptr TranspileContext) ResultType) -> Unit))
    (@pre {ctx != nil})
    (let ((ok-type (. rt ok-type))
          (err-type (. rt err-type))
          (c-name (. rt c-name))
          ;; Create guard macro name from c-name (uppercase)
          (guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
      ;; #ifndef GUARD_DEFINED
      (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
      ;; #define GUARD_DEFINED
      (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
      ;; typedef struct { bool is_ok; union { ok_type ok; err_type err; } data; } NAME;
      ;; Note: C doesn't allow void in a union, so we use uint8_t as placeholder
      (let ((part1 "typedef struct { bool is_ok; union { ")
            (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type))
            (part2 (ctx-str3 ctx actual-ok-type " ok; " err-type))
            (part3 (ctx-str3 ctx " err; } data; } " c-name ";")))
        (ctx-emit-header ctx (ctx-str3 ctx part1 part2 part3)))
      ;; #endif
      (ctx-emit-header ctx "#endif")
      (ctx-emit-header ctx "")))

  (fn emit-inline-records-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit inline record types to header (used in Result types)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((inline-records (ctx-get-inline-records ctx))
          (len (list-len inline-records))
          (mut i 0))
      (while (< i len)
        (match (list-get inline-records i)
          ((some ir)
            (let ((type-name (. ir type-name))
                  (field-body (. ir field-body))
                  (guard-name (ctx-str3 ctx (uppercase-name ctx type-name) "_DEFINED" "")))
              ;; #ifndef GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
              ;; #define GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
              ;; typedef struct { fields } name;
              (ctx-emit-header ctx (ctx-str5 ctx "typedef struct { " field-body "} " type-name ";"))
              ;; #endif
              (ctx-emit-header ctx "#endif")
              (ctx-emit-header ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit pointer-element Option types to header (value-element options need struct defs)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit pointer-element options here
            (when (is-pointer-elem-type (. ot inner-type))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-value-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element Option types for simple structs (inner type already emitted)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit value-element options whose inner type is already emitted
            ;; This handles Options of simple structs; complex struct options come later
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (is-type-emitted-or-primitive ctx (. ot inner-type)))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-complex-value-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element Option types for complex structs (after complex struct definitions)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Emit value-element options that weren't emitted before (complex struct inner types)
            ;; At this point, complex structs are emitted, so is-type-emitted-or-primitive will be true
            (when (not (is-pointer-elem-type (. ot inner-type)))
              ;; emit-single will skip if already emitted due to #ifndef guard
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-option-type-header ((ctx (Ptr TranspileContext)) (ot OptionType))
    (@intent "Emit a single Option type using SLOP_OPTION_DEFINE macro")
    (@spec (((Ptr TranspileContext) OptionType) -> Unit))
    (@pre {ctx != nil})
    (let ((inner-type (. ot inner-type))
          (c-name (. ot c-name)))
      ;; Skip types already defined in slop_runtime.h
      (when (not (is-runtime-option-type c-name))
        (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
          ;; #ifndef GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
          ;; #define GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
          ;; If inner-type is a set type (set_*), emit typedef first
          (when (starts-with inner-type "set_")
            (let ((set-guard (ctx-str3 ctx (uppercase-name ctx inner-type) "_DEFINED" "")))
              (ctx-emit-header ctx (ctx-str ctx "#ifndef " set-guard))
              (ctx-emit-header ctx (ctx-str ctx "#define " set-guard))
              (ctx-emit-header ctx (ctx-str ctx "typedef slop_map* " (ctx-str ctx inner-type ";")))
              (ctx-emit-header ctx "#endif")))
          ;; SLOP_OPTION_DEFINE(inner_type, c_name)
          (ctx-emit-header ctx (ctx-str5 ctx "SLOP_OPTION_DEFINE(" inner-type ", " c-name ")"))
          ;; #endif
          (ctx-emit-header ctx "#endif")
          (ctx-emit-header ctx "")
          ;; Mark this Option type as emitted for dependency tracking
          (ctx-mark-type-emitted ctx c-name)))))

  (fn emit-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit pointer-element List types to header (value-element lists need struct defs)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit pointer-element lists here
            (when (is-pointer-elem-type (. lt elem-type))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-primitive-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element List types for primitives (String, Int, etc.)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit value-element lists whose elem type is a primitive or slop_* type
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (is-primitive-or-runtime-type (. lt elem-type)))
              (emit-single-list-type-header ctx lt)
              ;; Also emit Option<List<T>> if registered
              (emit-option-for-inner-type ctx (. lt c-name))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-primitive-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element Option types for primitives (String, Int, etc.)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit value-element options whose inner type is a primitive or slop_* type
            ;; (but not if it's a slop_list_* type - those are handled by emit-primitive-list-types-header)
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (is-primitive-or-runtime-type (. ot inner-type))
                       (not (starts-with (. ot inner-type) "slop_list_")))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-primitive-or-runtime-type ((type-name String))
    (@intent "Check if a type is primitive or a slop_* or set_* runtime type")
    (@spec ((String) -> Bool))
    (or (is-primitive-type type-name)
        (or (starts-with type-name "slop_")
            (starts-with type-name "set_"))))

  (fn emit-imported-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element List types for imported types (from other modules)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Emit value-element lists whose elem type is imported (from another module)
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (not (is-primitive-or-runtime-type (. lt elem-type)))
                       (is-imported-type ctx (. lt elem-type)))
              (emit-single-list-type-header ctx lt)
              ;; Also emit Option<List<T>> if registered
              (emit-option-for-inner-type ctx (. lt c-name))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-imported-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element Option types for imported types (from other modules)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Emit value-element options whose inner type is imported
            ;; (but not slop_list_* types - those are handled by emit-imported-list-types-header)
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (not (is-primitive-or-runtime-type (. ot inner-type)))
                       (not (starts-with (. ot inner-type) "slop_list_"))
                       (is-imported-type ctx (. ot inner-type)))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-late-registered-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit option types registered during function transpilation (e.g. set_* types)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Emit any option types not yet emitted (relies on #ifndef guard in emit-single)
            ;; This catches set_* types registered during map-get transpilation
            (emit-single-option-type-header ctx ot))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-value-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element List types for simple structs (elem type already emitted)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit value-element lists whose elem type is already emitted
            ;; This handles Lists of simple structs; complex struct lists come later
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (is-type-emitted-or-primitive ctx (. lt elem-type)))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-complex-value-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element List types for complex structs (after complex struct definitions)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Emit value-element lists that weren't emitted before (complex struct elem types)
            ;; At this point, complex structs are emitted
            ;; Skip if already emitted by emit-value-list-types-header
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (not (ctx-is-type-emitted ctx (. lt c-name))))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Field-by-Field Struct Hash/Eq Generation
  ;;
  ;; These functions generate proper hash and equality functions
  ;; that compare struct fields individually, handling pointer
  ;; types (like String) correctly instead of using memcmp.
  ;; ============================================================

  (fn emit-struct-hash-eq ((ctx (Ptr TranspileContext)) (c-type String))
    (@intent "Generate field-by-field hash and equality functions for a struct or union type")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Check if this is a union type
    (let ((union-variants (ctx-get-union-variants ctx c-type)))
      (if (> (list-len union-variants) 0)
        ;; Union type: first emit hash/eq for variant payload types, then the union itself
        (do
          ;; Emit hash/eq for each variant's payload type (if it's a record type)
          (emit-union-payload-hash-eq ctx union-variants)
          ;; Now emit the union's own hash/eq
          (emit-union-hash-fn ctx c-type union-variants)
          (emit-union-eq-fn ctx c-type union-variants))
        ;; Record type: use field-by-field approach
        (let ((fields (ctx-get-fields-for-type ctx c-type)))
          (if (== (list-len fields) 0)
            ;; Fallback to memcmp-based macro if no fields registered
            (ctx-emit-header ctx (ctx-str3 ctx "SLOP_STRUCT_HASH_EQ_DEFINE(" c-type ")"))
            (do
              ;; Generate hash function
              (emit-struct-hash-fn ctx c-type fields)
              ;; Generate equality function
              (emit-struct-eq-fn ctx c-type fields)))))))

  (fn emit-union-payload-hash-eq ((ctx (Ptr TranspileContext)) (variants (List UnionVariantEntry)))
    (@intent "Emit hash/eq functions for union variant payload types")
    (@spec (((Ptr TranspileContext) (List UnionVariantEntry)) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len variants))
          (mut i 0))
      (while (< i len)
        (match (list-get variants i)
          ((some variant)
            (let ((slop-type (. variant slop-type))
                  (c-payload-type (. variant c-type)))
              ;; Skip empty payloads and primitive types
              (when (and (> (string-len slop-type) 0)
                         (not (is-primitive-slop-type slop-type)))
                ;; Check if this payload type has fields (is a record type)
                (let ((fields (ctx-get-fields-for-type ctx c-payload-type)))
                  (when (> (list-len fields) 0)
                    ;; Build guard name for this type
                    (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-payload-type) "_HASH_EQ_DEFINED" "")))
                      ;; Only emit if not already defined
                      (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
                      (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
                      (emit-struct-hash-fn ctx c-payload-type fields)
                      (emit-struct-eq-fn ctx c-payload-type fields)
                      (ctx-emit-header ctx "#endif")))))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-primitive-slop-type ((slop-type String))
    (@intent "Check if a SLOP type is a primitive (doesn't need custom hash/eq)")
    (@spec ((String) -> Bool))
    (cond
      ((string-eq slop-type "String") true)
      ((string-eq slop-type "Int") true)
      ((string-eq slop-type "I64") true)
      ((string-eq slop-type "I32") true)
      ((string-eq slop-type "I16") true)
      ((string-eq slop-type "I8") true)
      ((string-eq slop-type "U64") true)
      ((string-eq slop-type "U32") true)
      ((string-eq slop-type "U16") true)
      ((string-eq slop-type "U8") true)
      ((string-eq slop-type "Bool") true)
      ((starts-with slop-type "(Ptr") true)
      ;; Range types like (Int 0 ..) or (U8 0 .. 255) are primitives
      ((starts-with slop-type "(Int") true)
      ((starts-with slop-type "(I64") true)
      ((starts-with slop-type "(I32") true)
      ((starts-with slop-type "(I16") true)
      ((starts-with slop-type "(I8") true)
      ((starts-with slop-type "(U64") true)
      ((starts-with slop-type "(U32") true)
      ((starts-with slop-type "(U16") true)
      ((starts-with slop-type "(U8") true)
      (else false)))

  (fn is-range-type-alias ((ctx (Ptr TranspileContext)) (slop-type String))
    (@intent "Check if a slop-type is a type alias for a range type")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    (match (ctx-lookup-type-alias ctx slop-type)
      ((some underlying)
        ;; Check if the underlying type is a range type
        (cond
          ((starts-with underlying "(Int") true)
          ((starts-with underlying "(I64") true)
          ((starts-with underlying "(I32") true)
          ((starts-with underlying "(I16") true)
          ((starts-with underlying "(I8") true)
          ((starts-with underlying "(U64") true)
          ((starts-with underlying "(U32") true)
          ((starts-with underlying "(U16") true)
          ((starts-with underlying "(U8") true)
          (else false)))
      ((none) false)))

  (fn emit-union-hash-fn ((ctx (Ptr TranspileContext)) (c-type String) (variants (List UnionVariantEntry)))
    (@intent "Generate hash function for union using switch on tag")
    (@spec (((Ptr TranspileContext) String (List UnionVariantEntry)) -> Unit))
    (@pre {ctx != nil})
    ;; static inline uint64_t slop_hash_TypeName(const void* key) {
    ;;     const TypeName* _k = (const TypeName*)key;
    ;;     switch (_k->tag) {
    ;;         case TypeName_variant: return hash_for_payload;
    ;;         ...
    ;;     }
    ;;     return 0;
    ;; }
    (ctx-emit-header ctx (ctx-str3 ctx "static inline uint64_t slop_hash_" c-type "(const void* key) {"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _k = (const " c-type) "*)key;"))
    (ctx-emit-header ctx "    switch (_k->tag) {")
    ;; For each variant, emit case
    (let ((len (list-len variants))
          (mut i 0))
      (while (< i len)
        (match (list-get variants i)
          ((some variant)
            (emit-union-variant-hash ctx c-type variant))
          ((none) (do)))
        (set! i (+ i 1))))
    (ctx-emit-header ctx "    }")
    (ctx-emit-header ctx "    return 0;")
    (ctx-emit-header ctx "}"))

  (fn emit-union-variant-hash ((ctx (Ptr TranspileContext)) (union-name String) (variant UnionVariantEntry))
    (@intent "Emit hash code for a single union variant")
    (@spec (((Ptr TranspileContext) String UnionVariantEntry) -> Unit))
    (@pre {ctx != nil})
    (let ((c-variant-name (. variant c-variant-name))
          (slop-type (. variant slop-type))
          (c-payload-type (. variant c-type))
          (tag-const (ctx-str3 ctx union-name "_" c-variant-name)))
      ;; case UnionName_variant:
      (ctx-emit-header ctx (ctx-str ctx "        case " (ctx-str ctx tag-const ":")))
      (if (string-eq slop-type "")
        ;; No payload - just hash the tag
        (ctx-emit-header ctx (ctx-str ctx "            return (uint64_t)" (ctx-str ctx tag-const ";")))
        ;; Has payload - hash based on type
        (cond
          ;; String payload
          ((string-eq slop-type "String")
            (ctx-emit-header ctx (ctx-str3 ctx "            return slop_hash_string(&_k->data." c-variant-name ");")))
          ;; Int/I64 payload
          ((or (string-eq slop-type "Int") (string-eq slop-type "I64"))
            (ctx-emit-header ctx (ctx-str3 ctx "            return slop_hash_int(&_k->data." c-variant-name ");")))
          ;; Unsigned integers
          ((or (string-eq slop-type "U64") (or (string-eq slop-type "U32") (or (string-eq slop-type "U16") (string-eq slop-type "U8"))))
            (ctx-emit-header ctx (ctx-str3 ctx "            { uint64_t _tmp = (uint64_t)_k->data." c-variant-name "; return slop_hash_uint(&_tmp); }")))
          ;; Smaller signed integers
          ((or (string-eq slop-type "I32") (or (string-eq slop-type "I16") (string-eq slop-type "I8")))
            (ctx-emit-header ctx (ctx-str3 ctx "            { int64_t _tmp = (int64_t)_k->data." c-variant-name "; return slop_hash_int(&_tmp); }")))
          ;; Bool
          ((string-eq slop-type "Bool")
            (ctx-emit-header ctx (ctx-str3 ctx "            return (uint64_t)_k->data." c-variant-name ";")))
          ;; Pointer types
          ((starts-with slop-type "(Ptr")
            (ctx-emit-header ctx (ctx-str3 ctx "            return slop_hash_ptr(&_k->data." c-variant-name ");")))
          ;; Range types (Int 0 ..) or (I64 min .. max) - use int hash
          ((or (starts-with slop-type "(Int") (or (starts-with slop-type "(I64") (starts-with slop-type "(I32")))
            (ctx-emit-header ctx (ctx-str3 ctx "            { int64_t _tmp = (int64_t)_k->data." c-variant-name "; return slop_hash_int(&_tmp); }")))
          ;; Smaller signed range types
          ((or (starts-with slop-type "(I16") (starts-with slop-type "(I8"))
            (ctx-emit-header ctx (ctx-str3 ctx "            { int64_t _tmp = (int64_t)_k->data." c-variant-name "; return slop_hash_int(&_tmp); }")))
          ;; Unsigned range types
          ((or (starts-with slop-type "(U64") (or (starts-with slop-type "(U32") (or (starts-with slop-type "(U16") (starts-with slop-type "(U8"))))
            (ctx-emit-header ctx (ctx-str3 ctx "            { uint64_t _tmp = (uint64_t)_k->data." c-variant-name "; return slop_hash_uint(&_tmp); }")))
          ;; Record/struct type - call its hash function
          (else
            (ctx-emit-header ctx (ctx-str ctx (ctx-str3 ctx "            return slop_hash_" c-payload-type "(&_k->data.") (ctx-str ctx c-variant-name ");"))))))))

  (fn emit-union-eq-fn ((ctx (Ptr TranspileContext)) (c-type String) (variants (List UnionVariantEntry)))
    (@intent "Generate equality function for union")
    (@spec (((Ptr TranspileContext) String (List UnionVariantEntry)) -> Unit))
    (@pre {ctx != nil})
    ;; static inline bool slop_eq_TypeName(const void* a, const void* b) {
    ;;     const TypeName* _a = (const TypeName*)a;
    ;;     const TypeName* _b = (const TypeName*)b;
    ;;     if (_a->tag != _b->tag) return false;
    ;;     switch (_a->tag) {
    ;;         case TypeName_variant: return eq_for_payload;
    ;;         ...
    ;;     }
    ;;     return false;
    ;; }
    (ctx-emit-header ctx (ctx-str3 ctx "static inline bool slop_eq_" c-type "(const void* a, const void* b) {"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _a = (const " c-type) "*)a;"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _b = (const " c-type) "*)b;"))
    (ctx-emit-header ctx "    if (_a->tag != _b->tag) return false;")
    (ctx-emit-header ctx "    switch (_a->tag) {")
    ;; For each variant, emit case
    (let ((len (list-len variants))
          (mut i 0))
      (while (< i len)
        (match (list-get variants i)
          ((some variant)
            (emit-union-variant-eq ctx c-type variant))
          ((none) (do)))
        (set! i (+ i 1))))
    (ctx-emit-header ctx "    }")
    (ctx-emit-header ctx "    return false;")
    (ctx-emit-header ctx "}"))

  (fn emit-union-variant-eq ((ctx (Ptr TranspileContext)) (union-name String) (variant UnionVariantEntry))
    (@intent "Emit equality comparison for a single union variant")
    (@spec (((Ptr TranspileContext) String UnionVariantEntry) -> Unit))
    (@pre {ctx != nil})
    (let ((c-variant-name (. variant c-variant-name))
          (slop-type (. variant slop-type))
          (c-payload-type (. variant c-type))
          (tag-const (ctx-str3 ctx union-name "_" c-variant-name)))
      ;; case UnionName_variant:
      (ctx-emit-header ctx (ctx-str ctx "        case " (ctx-str ctx tag-const ":")))
      (if (string-eq slop-type "")
        ;; No payload - tags already match, so equal
        (ctx-emit-header ctx "            return true;")
        ;; Has payload - compare based on type
        (cond
          ;; String payload
          ((string-eq slop-type "String")
            (ctx-emit-header ctx (ctx-str ctx (ctx-str3 ctx "            return slop_eq_string(&_a->data." c-variant-name ", &_b->data.") (ctx-str ctx c-variant-name ");"))))
          ;; Numeric types - direct comparison
          ((or (string-eq slop-type "Int") (or (string-eq slop-type "I64") (or (string-eq slop-type "I32")
               (or (string-eq slop-type "I16") (or (string-eq slop-type "I8") (or (string-eq slop-type "U64")
               (or (string-eq slop-type "U32") (or (string-eq slop-type "U16") (string-eq slop-type "U8")))))))))
            (ctx-emit-header ctx (ctx-str5 ctx "            return _a->data." c-variant-name " == _b->data." c-variant-name ";")))
          ;; Bool
          ((string-eq slop-type "Bool")
            (ctx-emit-header ctx (ctx-str5 ctx "            return _a->data." c-variant-name " == _b->data." c-variant-name ";")))
          ;; Pointer types
          ((starts-with slop-type "(Ptr")
            (ctx-emit-header ctx (ctx-str5 ctx "            return _a->data." c-variant-name " == _b->data." c-variant-name ";")))
          ;; Range types (Int 0 ..) etc - direct comparison
          ((or (starts-with slop-type "(Int") (or (starts-with slop-type "(I64") (or (starts-with slop-type "(I32")
               (or (starts-with slop-type "(I16") (or (starts-with slop-type "(I8") (or (starts-with slop-type "(U64")
               (or (starts-with slop-type "(U32") (or (starts-with slop-type "(U16") (starts-with slop-type "(U8")))))))))
            (ctx-emit-header ctx (ctx-str5 ctx "            return _a->data." c-variant-name " == _b->data." c-variant-name ";")))
          ;; Record/struct type - call its eq function
          (else
            (ctx-emit-header ctx (ctx-str ctx (ctx-str5 ctx "            return slop_eq_" c-payload-type "(&_a->data." c-variant-name ", &_b->data.") (ctx-str ctx c-variant-name ");"))))))))

  (fn emit-struct-hash-fn ((ctx (Ptr TranspileContext)) (c-type String) (fields (List FieldEntry)))
    (@intent "Generate hash function for struct using FNV-1a")
    (@spec (((Ptr TranspileContext) String (List FieldEntry)) -> Unit))
    (@pre {ctx != nil})
    ;; static inline uint64_t slop_hash_TypeName(const void* key) {
    ;;     const TypeName* _k = (const TypeName*)key;
    ;;     uint64_t hash = 14695981039346656037ULL;
    ;;     hash ^= ...; hash *= 1099511628211ULL;
    ;;     return hash;
    ;; }
    (ctx-emit-header ctx (ctx-str3 ctx "static inline uint64_t slop_hash_" c-type "(const void* key) {"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _k = (const " c-type) "*)key;"))
    (ctx-emit-header ctx "    uint64_t hash = 14695981039346656037ULL;")
    ;; For each field, emit appropriate hash
    (let ((len (list-len fields))
          (mut i 0))
      (while (< i len)
        (match (list-get fields i)
          ((some field)
            (emit-field-hash ctx field))
          ((none) (do)))
        (set! i (+ i 1))))
    (ctx-emit-header ctx "    return hash;")
    (ctx-emit-header ctx "}"))

  (fn emit-field-hash ((ctx (Ptr TranspileContext)) (field FieldEntry))
    (@intent "Emit hash code for a single struct field")
    (@spec (((Ptr TranspileContext) FieldEntry) -> Unit))
    (@pre {ctx != nil})
    (let ((field-name (. field field-name))
          (slop-type (. field slop-type))
          (c-field-name (to-c-name (. (deref ctx) arena) field-name)))
      (cond
        ;; String fields use slop_hash_string
        ((string-eq slop-type "String")
          (ctx-emit-header ctx (ctx-str3 ctx "    hash ^= slop_hash_string(&_k->" c-field-name "); hash *= 1099511628211ULL;")))
        ;; Int/I64 use slop_hash_int
        ((or (string-eq slop-type "Int") (string-eq slop-type "I64"))
          (ctx-emit-header ctx (ctx-str3 ctx "    hash ^= slop_hash_int(&_k->" c-field-name "); hash *= 1099511628211ULL;")))
        ;; Smaller signed integers - cast to int64_t for consistent hashing
        ((or (string-eq slop-type "I32") (or (string-eq slop-type "I16") (string-eq slop-type "I8")))
          (ctx-emit-header ctx (ctx-str3 ctx "    { int64_t _tmp = (int64_t)_k->" c-field-name "; hash ^= slop_hash_int(&_tmp); hash *= 1099511628211ULL; }")))
        ;; Unsigned integers use slop_hash_uint
        ((or (string-eq slop-type "U64") (or (string-eq slop-type "U32") (or (string-eq slop-type "U16") (string-eq slop-type "U8"))))
          (ctx-emit-header ctx (ctx-str3 ctx "    { uint64_t _tmp = (uint64_t)_k->" c-field-name "; hash ^= slop_hash_uint(&_tmp); hash *= 1099511628211ULL; }")))
        ;; Bool - simple byte hash
        ((string-eq slop-type "Bool")
          (ctx-emit-header ctx (ctx-str3 ctx "    hash ^= (uint64_t)_k->" c-field-name "; hash *= 1099511628211ULL;")))
        ;; Pointer types - check if slop-type starts with "(Ptr"
        ((starts-with slop-type "(Ptr")
          (ctx-emit-header ctx (ctx-str3 ctx "    hash ^= slop_hash_ptr(&_k->" c-field-name "); hash *= 1099511628211ULL;")))
        ;; Complex container types (List, Map, Set, Option, Result) - use byte-level hash
        ((or (starts-with slop-type "(List")
             (or (starts-with slop-type "(Map")
                 (or (starts-with slop-type "(Set")
                     (or (starts-with slop-type "(Option")
                         (starts-with slop-type "(Result")))))
          (let ((c-type (. field c-type)))
            (ctx-emit-header ctx (ctx-str5 ctx "    { const uint8_t* _b = (const uint8_t*)&_k->" c-field-name "; for(size_t _i=0; _i<sizeof(_k->" c-field-name "); _i++) { hash ^= _b[_i]; hash *= 1099511628211ULL; } }"))))
        ;; Range type aliases (e.g., BlankNodeId -> (Int 0 ..)) - use int hash
        ((is-range-type-alias ctx slop-type)
          (ctx-emit-header ctx (ctx-str3 ctx "    { int64_t _tmp = (int64_t)_k->" c-field-name "; hash ^= slop_hash_int(&_tmp); hash *= 1099511628211ULL; }")))
        ;; Nested struct types - call their hash function
        (else
          ;; For other types (nested structs), call slop_hash_TypeName
          (let ((nested-c-type (. field c-type)))
            ;; Remove * suffix if present (for pointer types we missed)
            (if (is-pointer-elem-type nested-c-type)
              (ctx-emit-header ctx (ctx-str3 ctx "    hash ^= slop_hash_ptr(&_k->" c-field-name "); hash *= 1099511628211ULL;"))
              (ctx-emit-header ctx (ctx-str5 ctx "    hash ^= slop_hash_" nested-c-type "(&_k->" c-field-name "); hash *= 1099511628211ULL;"))))))))

  (fn emit-struct-eq-fn ((ctx (Ptr TranspileContext)) (c-type String) (fields (List FieldEntry)))
    (@intent "Generate equality function for struct")
    (@spec (((Ptr TranspileContext) String (List FieldEntry)) -> Unit))
    (@pre {ctx != nil})
    ;; static inline bool slop_eq_TypeName(const void* a, const void* b) {
    ;;     const TypeName* _a = (const TypeName*)a;
    ;;     const TypeName* _b = (const TypeName*)b;
    ;;     return field1_eq && field2_eq && ...;
    ;; }
    (ctx-emit-header ctx (ctx-str3 ctx "static inline bool slop_eq_" c-type "(const void* a, const void* b) {"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _a = (const " c-type) "*)a;"))
    (ctx-emit-header ctx (ctx-str ctx (ctx-str4 ctx "    const " c-type "* _b = (const " c-type) "*)b;"))
    ;; Build return expression with all field comparisons
    (let ((len (list-len fields)))
      (if (== len 0)
        (ctx-emit-header ctx "    return true;")
        (do
          (ctx-emit-header ctx "    return true")
          (let ((mut i 0))
            (while (< i len)
              (match (list-get fields i)
                ((some field)
                  (emit-field-eq ctx field))
                ((none) (do)))
              (set! i (+ i 1))))
          (ctx-emit-header ctx "    ;"))))
    (ctx-emit-header ctx "}"))

  (fn emit-field-eq ((ctx (Ptr TranspileContext)) (field FieldEntry))
    (@intent "Emit equality comparison for a single struct field")
    (@spec (((Ptr TranspileContext) FieldEntry) -> Unit))
    (@pre {ctx != nil})
    (let ((field-name (. field field-name))
          (slop-type (. field slop-type))
          (c-field-name (to-c-name (. (deref ctx) arena) field-name)))
      (cond
        ;; String fields use slop_eq_string
        ((string-eq slop-type "String")
          (ctx-emit-header ctx (ctx-str5 ctx "        && slop_eq_string(&_a->" c-field-name ", &_b->" c-field-name ")")))
        ;; Numeric types use direct comparison
        ((or (string-eq slop-type "Int") (or (string-eq slop-type "I64") (or (string-eq slop-type "I32")
             (or (string-eq slop-type "I16") (or (string-eq slop-type "I8") (or (string-eq slop-type "U64")
             (or (string-eq slop-type "U32") (or (string-eq slop-type "U16") (string-eq slop-type "U8")))))))))
          (ctx-emit-header ctx (ctx-str4 ctx "        && _a->" c-field-name " == _b->" c-field-name)))
        ;; Bool - direct comparison
        ((string-eq slop-type "Bool")
          (ctx-emit-header ctx (ctx-str4 ctx "        && _a->" c-field-name " == _b->" c-field-name)))
        ;; Pointer types - direct pointer comparison
        ((starts-with slop-type "(Ptr")
          (ctx-emit-header ctx (ctx-str4 ctx "        && _a->" c-field-name " == _b->" c-field-name)))
        ;; Complex container types (List, Map, Set, Option, Result) - use memcmp
        ((or (starts-with slop-type "(List")
             (or (starts-with slop-type "(Map")
                 (or (starts-with slop-type "(Set")
                     (or (starts-with slop-type "(Option")
                         (starts-with slop-type "(Result")))))
          (let ((c-type (. field c-type)))
            (ctx-emit-header ctx (ctx-str ctx (ctx-str ctx (ctx-str5 ctx "        && memcmp(&_a->" c-field-name ", &_b->" c-field-name ", sizeof(_a->") c-field-name) ")) == 0"))))
        ;; Range type aliases (e.g., BlankNodeId -> (Int 0 ..)) - direct comparison
        ((is-range-type-alias ctx slop-type)
          (ctx-emit-header ctx (ctx-str4 ctx "        && _a->" c-field-name " == _b->" c-field-name)))
        ;; Nested struct types - call their eq function
        (else
          (let ((nested-c-type (. field c-type)))
            ;; If it's a pointer type, use direct comparison
            (if (is-pointer-elem-type nested-c-type)
              (ctx-emit-header ctx (ctx-str4 ctx "        && _a->" c-field-name " == _b->" c-field-name))
              (ctx-emit-header ctx (ctx-str ctx (ctx-str5 ctx "        && slop_eq_" nested-c-type "(&_a->" c-field-name ", &_b->") (ctx-str ctx c-field-name ")")))))))))

  (fn emit-struct-key-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit hash/eq functions and SLOP_LIST_DEFINE for struct key types")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((struct-key-types (ctx-get-struct-key-types ctx))
          (len (list-len struct-key-types))
          (mut i 0))
      (when (> len 0)
        (ctx-emit-header ctx "")
        (ctx-emit-header ctx "/* Hash/eq functions and list types for struct map/set keys */"))
      (while (< i len)
        (match (list-get struct-key-types i)
          ((some c-type)
            (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-type) "_HASH_EQ_DEFINED" ""))
                  (list-c-name (ctx-str ctx "slop_list_" c-type)))
              ;; #ifndef GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
              ;; #define GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
              ;; Generate field-by-field hash/eq functions (or fallback to macro)
              (emit-struct-hash-eq ctx c-type)
              ;; Only emit SLOP_LIST_DEFINE if list type wasn't already emitted
              (when (not (ctx-is-type-emitted ctx list-c-name))
                (ctx-emit-header ctx (ctx-str5 ctx "SLOP_LIST_DEFINE(" c-type ", " list-c-name ")"))
                (ctx-mark-type-emitted ctx list-c-name))
              ;; #endif
              (ctx-emit-header ctx "#endif")
              (ctx-emit-header ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-pointer-elem-type ((elem-type String))
    (@intent "Check if element type is a pointer type (ends with *)")
    (@spec ((String) -> Bool))
    (let ((len (cast Int (. elem-type len))))
      (if (<= len 0)
        false
        (let ((data (. elem-type data))
              (last-char (@ data (- len 1))))
          (== last-char (cast U8 42))))))

  (fn emit-single-list-type-header ((ctx (Ptr TranspileContext)) (lt ListType))
    (@intent "Emit a single List type using SLOP_LIST_DEFINE macro")
    (@spec (((Ptr TranspileContext) ListType) -> Unit))
    (@pre {ctx != nil})
    (let ((elem-type (. lt elem-type))
          (c-name (. lt c-name)))
      ;; Skip types already defined in slop_runtime.h
      (when (not (is-runtime-list-type c-name))
        (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
          ;; #ifndef GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
          ;; #define GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
          ;; SLOP_LIST_DEFINE(elem_type, c_name)
          (ctx-emit-header ctx (ctx-str5 ctx "SLOP_LIST_DEFINE(" elem-type ", " c-name ")"))
          ;; #endif
          (ctx-emit-header ctx "#endif")
          (ctx-emit-header ctx "")
          ;; Mark this List type as emitted for dependency tracking
          (ctx-mark-type-emitted ctx c-name)))))

  (fn is-runtime-option-type ((name String))
    (@intent "Check if Option type is already defined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_option_int")
        (or (string-eq name "slop_option_float")
            (or (string-eq name "slop_option_string")
                (or (string-eq name "slop_option_ptr")
                    (string-eq name "slop_option_bool"))))))

  (fn is-runtime-list-type ((name String))
    (@intent "Check if List type is already defined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_list_int")
        (or (string-eq name "slop_list_float")
            (or (string-eq name "slop_list_string")
                (string-eq name "slop_list_ptr")))))

  (fn emit-chan-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit Chan types to header with direct struct definitions")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((chan-types (ctx-get-chan-types ctx))
          (len (list-len chan-types))
          (mut i 0))
      (while (< i len)
        (match (list-get chan-types i)
          ((some ct)
            (let ((elem-type (. ct elem-type))
                  (c-name (. ct c-name)))
              ;; Skip runtime built-in types
              (when (not (is-runtime-chan-type c-name))
                (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
                  ;; #ifndef GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
                  ;; #define GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
                  ;; Emit channel state struct directly
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name " {"))
                  (ctx-emit-header ctx "    uint8_t mutex[64];       /* pthread_mutex_t storage */")
                  (ctx-emit-header ctx "    uint8_t not_empty[64];   /* pthread_cond_t storage */")
                  (ctx-emit-header ctx "    uint8_t not_full[64];    /* pthread_cond_t storage */")
                  (ctx-emit-header ctx (ctx-str3 ctx "    " elem-type "* buffer;         /* Ring buffer */"))
                  (ctx-emit-header ctx "    size_t capacity;         /* Buffer capacity (0 = unbuffered) */")
                  (ctx-emit-header ctx "    size_t count;            /* Current item count */")
                  (ctx-emit-header ctx "    size_t head;             /* Read index */")
                  (ctx-emit-header ctx "    size_t tail;             /* Write index */")
                  (ctx-emit-header ctx "    bool closed;             /* Channel closed flag */")
                  (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
                  ;; #endif
                  (ctx-emit-header ctx "#endif")
                  (ctx-emit-header ctx "")))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-chan-funcs-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit type-specific send/recv functions for channel types (must be called after all types are defined)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((chan-types (ctx-get-chan-types ctx))
          (len (list-len chan-types))
          (mut i 0))
      (while (< i len)
        (match (list-get chan-types i)
          ((some ct)
            (let ((elem-type (. ct elem-type))
                  (c-name (. ct c-name)))
              ;; Skip runtime built-in types and default int channel
              (when (and (not (is-runtime-chan-type c-name))
                         (not (is-default-chan-type c-name)))
                (emit-chan-send-recv-funcs ctx c-name elem-type))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-chan-send-recv-funcs ((ctx (Ptr TranspileContext)) (c-name String) (elem-type String))
    (@intent "Emit type-specific send and recv functions for a channel type")
    (@spec (((Ptr TranspileContext) String String) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. ctx arena))
          (elem-id (type-to-identifier arena elem-type)))
      ;; Forward declare send Result type (void/Unit for send)
      (ctx-emit-header ctx "#ifndef SLOP_RESULT_VOID_THREAD_CHANERROR_DEFINED")
      (ctx-emit-header ctx "#define SLOP_RESULT_VOID_THREAD_CHANERROR_DEFINED")
      (ctx-emit-header ctx "typedef struct slop_result_void_thread_ChanError {")
      (ctx-emit-header ctx "    bool is_ok;")
      (ctx-emit-header ctx "    union { uint8_t ok; thread_ChanError err; } data;")
      (ctx-emit-header ctx "} slop_result_void_thread_ChanError;")
      (ctx-emit-header ctx "#endif")
      (ctx-emit-header ctx "")
      ;; Forward declare recv Result type (elem-type for recv)
      (let ((recv-result-type (ctx-str3 ctx "slop_result_" elem-id "_thread_ChanError"))
            (recv-guard (ctx-str3 ctx "SLOP_RESULT_" (uppercase-name ctx elem-id) "_THREAD_CHANERROR_DEFINED")))
        (ctx-emit-header ctx (ctx-str ctx "#ifndef " recv-guard))
        (ctx-emit-header ctx (ctx-str ctx "#define " recv-guard))
        (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " recv-result-type " {"))
        (ctx-emit-header ctx "    bool is_ok;")
        (let ((union-line (ctx-str ctx "    union { " (ctx-str ctx elem-type " ok; thread_ChanError err; } data;"))))
          (ctx-emit-header ctx union-line))
        (ctx-emit-header ctx (ctx-str3 ctx "} " recv-result-type ";"))
        (ctx-emit-header ctx "#endif")
        (ctx-emit-header ctx "")
        (let ((send-name (ctx-str ctx "thread_send_" c-name))
              (recv-name (ctx-str ctx "thread_recv_" c-name))
              (send-result-type "slop_result_void_thread_ChanError")
              ;; Pre-build common return statements for send
              (ret-ok (ctx-str3 ctx "        return (" send-result-type "){.is_ok = 1};"))
              (ret-closed (ctx-str3 ctx "        return (" send-result-type "){.is_ok = 0, .data.err = thread_ChanError_send_on_closed};"))
              (ret-closed12 (ctx-str3 ctx "            return (" send-result-type "){.is_ok = 0, .data.err = thread_ChanError_send_on_closed};"))
              ;; Pre-build return statements for recv
              (ret-err-closed (ctx-str3 ctx "        return (" recv-result-type "){.is_ok = 0, .data.err = thread_ChanError_closed};")))
          ;; Build send function signature
          (let ((send-sig-1 (ctx-str3 ctx "static " send-result-type " "))
                (send-sig-2 (ctx-str ctx send-sig-1 send-name))
                (send-sig-3 (ctx-str ctx send-sig-2 "("))
                (send-sig-4 (ctx-str ctx send-sig-3 c-name))
                (send-sig-5 (ctx-str ctx send-sig-4 "* ch, "))
                (send-sig-6 (ctx-str ctx send-sig-5 elem-type))
                (send-sig (ctx-str ctx send-sig-6 " value) {")))
            (ctx-emit-header ctx send-sig))
          (ctx-emit-header ctx "    pthread_mutex_lock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "    if (ch->closed) {")
          (ctx-emit-header ctx "        pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-closed)
          (ctx-emit-header ctx "    }")
          (ctx-emit-header ctx "    if (ch->capacity == 0) {")
          (ctx-emit-header ctx "        /* Unbuffered: synchronous handoff */")
          (ctx-emit-header ctx "        while (ch->count > 0 && !ch->closed)")
          (ctx-emit-header ctx "            pthread_cond_wait((pthread_cond_t*)ch->not_full, (pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "        if (ch->closed) {")
          (ctx-emit-header ctx "            pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-closed12)
          (ctx-emit-header ctx "        }")
          (ctx-emit-header ctx "        /* Store value in single-element inline storage */")
          (ctx-emit-header ctx (ctx-str3 ctx "        if (!ch->buffer) ch->buffer = malloc(sizeof(" elem-type "));"))
          (ctx-emit-header ctx "        ch->buffer[0] = value;")
          (ctx-emit-header ctx "        ch->count = 1;")
          (ctx-emit-header ctx "        pthread_cond_signal((pthread_cond_t*)ch->not_empty);")
          (ctx-emit-header ctx "        /* Wait for receiver to take it */")
          (ctx-emit-header ctx "        while (ch->count > 0 && !ch->closed)")
          (ctx-emit-header ctx "            pthread_cond_wait((pthread_cond_t*)ch->not_full, (pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "        pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-ok)
          (ctx-emit-header ctx "    } else {")
          (ctx-emit-header ctx "        /* Buffered: enqueue to ring buffer */")
          (ctx-emit-header ctx "        while (ch->count >= ch->capacity && !ch->closed)")
          (ctx-emit-header ctx "            pthread_cond_wait((pthread_cond_t*)ch->not_full, (pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "        if (ch->closed) {")
          (ctx-emit-header ctx "            pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-closed12)
          (ctx-emit-header ctx "        }")
          (ctx-emit-header ctx "        ch->buffer[ch->tail] = value;")
          (ctx-emit-header ctx "        ch->tail = (ch->tail + 1) % ch->capacity;")
          (ctx-emit-header ctx "        ch->count++;")
          (ctx-emit-header ctx "        pthread_cond_signal((pthread_cond_t*)ch->not_empty);")
          (ctx-emit-header ctx "        pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-ok)
          (ctx-emit-header ctx "    }")
          (ctx-emit-header ctx "}")
          (ctx-emit-header ctx "")
          ;; Build recv function signature - returns Result directly (no output pointer)
          (let ((recv-sig-1 (ctx-str3 ctx "static " recv-result-type " "))
                (recv-sig-2 (ctx-str ctx recv-sig-1 recv-name))
                (recv-sig-3 (ctx-str ctx recv-sig-2 "("))
                (recv-sig-4 (ctx-str ctx recv-sig-3 c-name))
                (recv-sig (ctx-str ctx recv-sig-4 "* ch) {")))
            (ctx-emit-header ctx recv-sig))
          ;; Declare local for result value
          (ctx-emit-header ctx (ctx-str3 ctx "    " elem-type " _value;"))
          (ctx-emit-header ctx "    pthread_mutex_lock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "    while (ch->count == 0 && !ch->closed)")
          (ctx-emit-header ctx "        pthread_cond_wait((pthread_cond_t*)ch->not_empty, (pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx "    if (ch->count == 0 && ch->closed) {")
          (ctx-emit-header ctx "        pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx ret-err-closed)
          (ctx-emit-header ctx "    }")
          (ctx-emit-header ctx "    if (ch->capacity == 0) {")
          (ctx-emit-header ctx "        /* Unbuffered */")
          (ctx-emit-header ctx "        _value = ch->buffer[0];")
          (ctx-emit-header ctx "        ch->count = 0;")
          (ctx-emit-header ctx "        pthread_cond_signal((pthread_cond_t*)ch->not_full);")
          (ctx-emit-header ctx "    } else {")
          (ctx-emit-header ctx "        /* Buffered */")
          (ctx-emit-header ctx "        _value = ch->buffer[ch->head];")
          (ctx-emit-header ctx "        ch->head = (ch->head + 1) % ch->capacity;")
          (ctx-emit-header ctx "        ch->count--;")
          (ctx-emit-header ctx "        pthread_cond_signal((pthread_cond_t*)ch->not_full);")
          (ctx-emit-header ctx "    }")
          (ctx-emit-header ctx "    pthread_mutex_unlock((pthread_mutex_t*)ch->mutex);")
          (ctx-emit-header ctx (ctx-str3 ctx "    return (" recv-result-type "){.is_ok = 1, .data.ok = _value};"))
          (ctx-emit-header ctx "}")
          (ctx-emit-header ctx "")))))

  (fn emit-thread-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit Thread types to header with direct struct definitions and trampoline")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((thread-types (ctx-get-thread-types ctx))
          (len (list-len thread-types))
          (mut i 0))
      (while (< i len)
        (match (list-get thread-types i)
          ((some tt)
            (let ((result-type (. tt result-type))
                  (c-name (. tt c-name)))
              ;; Skip runtime built-in types
              (when (not (is-runtime-thread-type c-name))
                (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" ""))
                      (entry-name (ctx-str ctx c-name "_entry")))
                  ;; #ifndef GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
                  ;; #define GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
                  ;; Emit thread state struct directly
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name " {"))
                  (ctx-emit-header ctx "    pthread_t id;            /* pthread handle */")
                  (ctx-emit-header ctx (ctx-str3 ctx "    " result-type " result;          /* Thread return value */"))
                  (ctx-emit-header ctx "    void* func;              /* Function pointer */")
                  (ctx-emit-header ctx "    void* env;               /* Closure environment */")
                  (ctx-emit-header ctx "    bool done;               /* Completion flag */")
                  (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
                  ;; Emit trampoline function - handles both closures and regular functions
                  (ctx-emit-header ctx (ctx-str3 ctx "static void* " entry-name "(void* arg) {"))
                  (ctx-emit-header ctx (ctx-str5 ctx "    " c-name "* s = (" c-name "*)arg;"))
                  ;; Check if closure (env != NULL) or regular function
                  (ctx-emit-header ctx "    if (s->env) {")
                  ;; Closure: pass env as first argument
                  (ctx-emit-header ctx (ctx-str3 ctx "        s->result = ((" result-type "(*)(void*))(s->func))(s->env);"))
                  (ctx-emit-header ctx "    } else {")
                  ;; Regular function: no arguments
                  (ctx-emit-header ctx (ctx-str3 ctx "        s->result = ((" result-type "(*)(void))(s->func))();"))
                  (ctx-emit-header ctx "    }")
                  (ctx-emit-header ctx "    s->done = true;")
                  (ctx-emit-header ctx "    return NULL;")
                  (ctx-emit-header ctx "}")
                  ;; #endif
                  (ctx-emit-header ctx "#endif")
                  (ctx-emit-header ctx "")))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-runtime-chan-type ((name String))
    (@intent "Check if Chan type is already defined in slop_thread.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_chan_int64_t")
        (or (string-eq name "slop_chan_double")
            (string-eq name "slop_chan_ptr"))))

  (fn is-default-chan-type ((name String))
    (@intent "Check if Chan type uses the default thread_send/recv functions")
    (@spec ((String) -> Bool))
    ;; slop_chan_int is the default type handled by thread module's send/recv
    (string-eq name "slop_chan_int"))

  (fn is-runtime-thread-type ((name String))
    (@intent "Check if Thread type is already defined in slop_thread.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_thread_int64_t")
        (or (string-eq name "slop_thread_double")
            (string-eq name "slop_thread_ptr"))))

  (fn uppercase-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert name to uppercase for use in guard macros")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (. name len)))
          (data (. name data))
          (buf (arena-alloc arena (+ len 1)))
          (mut i 0))
      (while (< i len)
        (let ((c (cast Int (@ data i))))
          ;; Convert lowercase a-z to uppercase A-Z
          (if (and (>= c 97) (<= c 122))
            (set! (@ buf i) (cast U8 (- c 32)))
            (set! (@ buf i) (cast U8 c))))
        (set! i (+ i 1)))
      (set! (@ buf len) 0)
      (String buf (cast U64 len))))

  (fn is-simple-enum-def ((item (Ptr SExpr)))
    (@intent "Check if type is a simple enum (no payload variants)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((lst def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((sym sym)
                                (and (string-eq (. sym name) "enum")
                                     (not (has-enum-payload-variants def-items))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-module-types-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all type definitions from module to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start))
      ;; First emit type aliases (simple typedefs like (type AsciiChar U8))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-type-alias-def item))
              (emit-type-alias-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Then emit enums (simple types)
      (set! i start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Then emit struct/union types
      (set! i start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-simple-type-aliases-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple (non-Result) type aliases to header - called before struct types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            ;; Emit type aliases that are NOT Result aliases
            (when (and (is-type-def item)
                       (is-type-alias-def item)
                       (not (is-result-type-alias-def item)))
              (emit-type-alias-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-type-aliases-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit Result type aliases to header - called after Result types are emitted")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            ;; Only emit Result type aliases here (simple aliases already emitted)
            (when (and (is-type-def item)
                       (is-type-alias-def item)
                       (is-result-type-alias-def item))
              (emit-type-alias-to-header ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-simple-enums-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple enum types to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-union-types-sorted ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all struct/union types in dependency order via topological sort")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    ;; Topological sort: iteratively emit types whose dependencies are met.
    ;; A type can be emitted when all its non-pointer field types are already emitted.
    ;; After emitting a type, also emit any Option/List types for it.
    (let ((len (list-len items))
          (arena (. (deref ctx) arena))
          ;; Track which indices have been emitted
          (mut emitted (List Int) (list-new arena Int))
          (mut prev-count -1)
          (mut current-count 0))
      ;; Keep iterating until no progress is made
      (while (!= prev-count current-count)
        (set! prev-count current-count)
        (let ((mut i start))
          (while (< i len)
            (when (not (index-in-list emitted i))
              (match (list-get items i)
                ((some item)
                  (when (and (is-type-def item) (is-struct-type-def item))
                    ;; Check if all dependencies are met
                    (when (type-deps-satisfied ctx item)
                      ;; Emit the type
                      (emit-type-to-header ctx item)
                      ;; Mark as emitted
                      (list-push emitted i)
                      (set! current-count (+ current-count 1))
                      ;; Emit any Option/List types that depend on this type
                      (emit-option-list-for-type ctx item))))
                ((none) (do))))
            (set! i (+ i 1)))))))

  (fn index-in-list ((lst (List Int)) (idx Int))
    (@intent "Check if an index is in the list")
    (@spec (((List Int) Int) -> Bool))
    (let ((len (list-len lst))
          (mut i 0)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get lst i)
          ((some v) (when (== v idx) (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn type-deps-satisfied ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Check if all non-pointer field type dependencies are satisfied")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; Get field types and check each one
    (let ((field-types (get-type-field-types ctx type-def))
          (len (list-len field-types))
          (mut i 0)
          (mut all-satisfied true))
      (while (and (< i len) all-satisfied)
        (match (list-get field-types i)
          ((some field-type)
            (when (not (type-is-available ctx field-type))
              (set! all-satisfied false)))
          ((none) (do)))
        (set! i (+ i 1)))
      all-satisfied))

  (fn type-is-available ((ctx (Ptr TranspileContext)) (type-name String))
    (@intent "Check if a type is available (emitted, primitive, or pointer)")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    ;; A type is available if:
    ;; 1. It's a primitive/builtin (Int, Bool, String, etc.)
    ;; 2. It starts with "Ptr " or "(Ptr" (pointer type - only needs forward decl)
    ;; 3. It's a slop_* runtime type (but NOT generated list/option types)
    ;; 4. It's a runtime Option/List type (from slop_runtime.h)
    ;; 5. It's been emitted (in emitted-types list)
    ;; 6. It's an imported type (from another module)
    (or (is-primitive-type type-name)
        (starts-with type-name "Ptr ")
        (starts-with type-name "(Ptr")
        (is-slop-runtime-type type-name)
        (is-runtime-option-type type-name)
        (is-runtime-list-type type-name)
        (is-type-emitted-or-primitive ctx type-name)
        (is-imported-type ctx type-name)))

  (fn is-slop-runtime-type ((type-name String))
    (@intent "Check if type is a slop runtime type (not generated list/option)")
    (@spec ((String) -> Bool))
    ;; slop_list_* and slop_option_* are generated and need to be emitted
    ;; Other slop_* types (slop_string, slop_arena*, etc.) are from runtime
    (and (starts-with type-name "slop_")
         (not (starts-with type-name "slop_list_"))
         (not (starts-with type-name "slop_option_"))))

  (fn is-primitive-type ((type-name String))
    (@intent "Check if a type name is a primitive/builtin type")
    (@spec ((String) -> Bool))
    (or (string-eq type-name "Int")
        (string-eq type-name "Bool")
        (string-eq type-name "String")
        (string-eq type-name "Unit")
        (string-eq type-name "U8")
        (string-eq type-name "U16")
        (string-eq type-name "U32")
        (string-eq type-name "U64")
        (string-eq type-name "I8")
        (string-eq type-name "I16")
        (string-eq type-name "I32")
        (string-eq type-name "I64")
        (string-eq type-name "Float")
        (string-eq type-name "Double")
        (string-eq type-name "Char")
        (string-eq type-name "Arena")
        ;; C type names
        (string-eq type-name "int64_t")
        (string-eq type-name "uint8_t")
        (string-eq type-name "uint16_t")
        (string-eq type-name "uint32_t")
        (string-eq type-name "uint64_t")
        (string-eq type-name "int8_t")
        (string-eq type-name "int16_t")
        (string-eq type-name "int32_t")
        (string-eq type-name "bool")
        (string-eq type-name "void")))

  (fn get-type-field-types ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Extract non-pointer field type names from a record/union definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (List String)))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((arena (. (deref ctx) arena))
          (mut result (list-new arena String)))
      (match (deref type-def)
        ((lst lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 3)
              (match (list-get items 2)
                ((some def-expr)
                  (match (deref def-expr)
                    ((lst def-lst)
                      (let ((def-items (. def-lst items))
                            (def-len (list-len def-items)))
                        (when (> def-len 0)
                          (match (list-get def-items 0)
                            ((some head)
                              (match (deref head)
                                ((sym sym)
                                  (let ((kind (. sym name)))
                                    (cond
                                      ((string-eq kind "record")
                                        ;; Record fields: (field-name Type) pairs starting at index 1
                                        (set! result (extract-record-field-types ctx def-items)))
                                      ((string-eq kind "union")
                                        ;; Union variants: (variant-name Type) pairs starting at index 1
                                        (set! result (extract-union-variant-types ctx def-items)))
                                      (else (do)))))
                                (else (do))))
                            ((none) (do))))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))
      result))

  (fn extract-record-field-types ((ctx (Ptr TranspileContext)) (def-items (List (Ptr SExpr))))
    (@intent "Extract field type names from record definition items")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List String)))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (mut result (list-new arena String))
          (len (list-len def-items))
          (mut i 1))  ;; Skip 'record' keyword
      (while (< i len)
        (match (list-get def-items i)
          ((some field-expr)
            (match (deref field-expr)
              ((lst field-lst)
                ;; Field is (name Type) - get the type at index 1
                (when (>= (list-len (. field-lst items)) 2)
                  (match (list-get (. field-lst items) 1)
                    ((some type-expr)
                      (let ((type-str (get-field-type-string ctx type-expr)))
                        (when (not (string-eq type-str ""))
                          (list-push result type-str))))
                    ((none) (do)))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn extract-union-variant-types ((ctx (Ptr TranspileContext)) (def-items (List (Ptr SExpr))))
    (@intent "Extract variant payload type names from union definition items")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List String)))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (mut result (list-new arena String))
          (len (list-len def-items))
          (mut i 1))  ;; Skip 'union' keyword
      (while (< i len)
        (match (list-get def-items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((lst variant-lst)
                ;; Variant is (name Type) - get the type at index 1
                (when (>= (list-len (. variant-lst items)) 2)
                  (match (list-get (. variant-lst items) 1)
                    ((some type-expr)
                      (let ((type-str (get-field-type-string ctx type-expr)))
                        (when (not (string-eq type-str ""))
                          (list-push result type-str))))
                    ((none) (do)))))
              ;; Simple variant without payload - no dependency
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn get-field-type-string ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Get the type name string from a type expression, resolving to C name")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((sym sym)
          ;; Simple type name - look up C name or convert to C type
          (let ((name (. sym name)))
            (match (ctx-lookup-type ctx name)
              ((some entry) (. entry c-name))
              ;; Not found - convert to C type (handles primitives like String -> slop_string)
              ((none) (to-c-type arena type-expr)))))
        ((lst lst)
          ;; Complex type like (Ptr X), (Option X), (List X)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              ""
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((sym sym)
                      (let ((kind (. sym name)))
                        (cond
                          ;; Pointer types don't create dependencies (forward decl is enough)
                          ((string-eq kind "Ptr") "")
                          ;; Option and List types - return the generated type name
                          ((string-eq kind "Option")
                            (if (>= (list-len items) 2)
                              (match (list-get items 1)
                                ((some inner)
                                  (let ((inner-str (get-field-type-string ctx inner)))
                                    (if (string-eq inner-str "")
                                      ""
                                      (ctx-str ctx "slop_option_" (type-to-identifier arena inner-str)))))
                                ((none) ""))
                              ""))
                          ((string-eq kind "List")
                            (if (>= (list-len items) 2)
                              (match (list-get items 1)
                                ((some inner)
                                  (let ((inner-str (get-field-type-string ctx inner)))
                                    (if (string-eq inner-str "")
                                      ""
                                      (ctx-str ctx "slop_list_" (type-to-identifier arena inner-str)))))
                                ((none) ""))
                              ""))
                          ;; Other complex types - return empty (no dependency tracking)
                          (else ""))))
                    (else "")))
                ((none) "")))))
        (else ""))))

  (fn emit-option-list-for-type ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit Option/List types that use this newly-emitted type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; Get the C name of this type
    (let ((c-name (get-type-c-name ctx type-def)))
      (when (not (string-eq c-name ""))
        ;; Emit Option type for this type if registered
        (emit-option-for-inner-type ctx c-name)
        ;; Emit List type for this type if registered
        (emit-list-for-elem-type ctx c-name))))

  (fn get-type-c-name ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Get the C name of a type definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (match (deref type-def)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            ""
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym)
                    (let ((name (. sym name)))
                      (match (ctx-lookup-type ctx name)
                        ((some entry) (. entry c-name))
                        ((none) ""))))
                  (else "")))
              ((none) "")))))
      (else "")))

  (fn emit-option-for-inner-type ((ctx (Ptr TranspileContext)) (inner-c-name String))
    (@intent "Emit Option type for a specific inner type if registered")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Check if this Option's inner type matches and it's not a pointer type
            (when (and (string-eq (. ot inner-type) inner-c-name)
                       (not (is-pointer-elem-type (. ot inner-type))))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-list-for-elem-type ((ctx (Ptr TranspileContext)) (elem-c-name String))
    (@intent "Emit List type for a specific element type if registered, then emit Option<List<T>>")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Check if this List's element type matches and it's not a pointer type
            (when (and (string-eq (. lt elem-type) elem-c-name)
                       (not (is-pointer-elem-type (. lt elem-type))))
              (emit-single-list-type-header ctx lt)
              ;; After emitting List<T>, emit Option<List<T>> if registered
              ;; The List's c-name is now a valid inner type for Option
              (emit-option-for-inner-type ctx (. lt c-name))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn struct-uses-value-list-or-option ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Check if struct uses any value List or Option types in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; Check all registered List types
    (let ((list-types (ctx-get-list-types ctx))
          (option-types (ctx-get-option-types ctx))
          (mut found false))
      ;; Check List types
      (let ((len (list-len list-types))
            (mut i 0))
        (while (and (< i len) (not found))
          (match (list-get list-types i)
            ((some lt)
              (when (and (not (is-pointer-elem-type (. lt elem-type)))
                         (struct-uses-list-type ctx type-def (. lt c-name)))
                (set! found true)))
            ((none) (do)))
          (set! i (+ i 1))))
      ;; Check Option types if no List found
      (when (not found)
        (let ((len2 (list-len option-types))
              (mut j 0))
          (while (and (< j len2) (not found))
            (match (list-get option-types j)
              ((some ot)
                (when (and (not (is-pointer-elem-type (. ot inner-type)))
                           (struct-uses-option-type ctx type-def (. ot c-name)))
                  (set! found true)))
              ((none) (do)))
            (set! j (+ j 1)))))
      found))

  (fn emit-struct-dependent-list-types ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element List types that a struct's fields depend on")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit value-element list types (not pointer types)
            ;; Check if this struct uses this list type
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (struct-uses-list-type ctx type-def (. lt c-name)))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-option-types ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element Option types that a struct's fields depend on")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit value-element option types (not pointer types)
            ;; Check if this struct uses this option type
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (struct-uses-option-type ctx type-def (. ot c-name)))
              ;; If the Option's inner type is a List type, emit that List type first
              (emit-list-type-if-needed ctx (. ot inner-type))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-list-types-safe ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element List types only if element type is already emitted")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit if: not pointer type, struct uses it, AND element type is emitted
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (struct-uses-list-type ctx type-def (. lt c-name)))
              ;; Check if element type is already emitted (or is a primitive/string)
              (when (is-type-emitted-or-primitive ctx (. lt elem-type))
                (emit-single-list-type-header ctx lt))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-option-types-safe ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element Option types only if inner type is already emitted")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit if: not pointer type, struct uses it, AND inner type is emitted
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (struct-uses-option-type ctx type-def (. ot c-name)))
              ;; Check if inner type is already emitted (or is a list/primitive)
              (when (is-type-emitted-or-primitive ctx (. ot inner-type))
                ;; If the Option's inner type is a List type, emit that first
                (emit-list-type-if-needed-safe ctx (. ot inner-type))
                (emit-single-option-type-header ctx ot))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-type-emitted-or-primitive ((ctx (Ptr TranspileContext)) (type-name String))
    (@intent "Check if a type is already emitted, a primitive, or an imported type")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    ;; Primitives and basic types are always available
    (if (or (string-eq type-name "int64_t")
            (or (string-eq type-name "uint8_t")
                (or (string-eq type-name "int8_t")
                    (or (string-eq type-name "int16_t")
                        (or (string-eq type-name "int32_t")
                            (or (string-eq type-name "uint16_t")
                                (or (string-eq type-name "uint32_t")
                                    (or (string-eq type-name "uint64_t")
                                        (or (string-eq type-name "double")
                                            (or (string-eq type-name "float")
                                                (string-eq type-name "slop_string")))))))))))
      true
      ;; Check if it's an imported type (different module prefix)
      (if (is-imported-type ctx type-name)
        true
        ;; Check if in emitted-types list (includes List, Option, struct types)
        (ctx-is-type-emitted ctx type-name))))

  (fn is-imported-type ((ctx (Ptr TranspileContext)) (type-name String))
    (@intent "Check if a type is from another module (imported)")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    ;; An imported type has a module prefix that differs from current module
    ;; e.g., "types_Diagnostic" when current module is "env"
    ;; NOTE: Generated types like slop_list_* and slop_option_* are NOT imported -
    ;; they are generated in this module and need to be emitted here
    (if (or (starts-with type-name "slop_list_")
            (starts-with type-name "slop_option_"))
      false  ;; Generated types are never "imported"
      (match (ctx-get-module ctx)
        ((some current-mod)
          ;; Convert module name to C-style (replace - with _) before comparing
          ;; Module names use hyphens (type-extract) but C types use underscores (type_extract_)
          (let ((arena (. (deref ctx) arena))
                (c-mod (to-c-name arena current-mod))
                (current-prefix (ctx-str ctx c-mod "_")))
            ;; If type has an underscore but doesn't start with current module prefix,
            ;; it's an imported type (from a different module's header)
            (let ((underscore-pos (find-char type-name (cast U8 95))))  ;; 95 is ASCII for '_'
              (if (> underscore-pos 0)
                ;; Has underscore - check if it starts with current module prefix
                (not (starts-with type-name current-prefix))
                ;; No underscore - not a prefixed type, treat as local
                false))))
        ((none) false))))

  (fn find-char ((s String) (ch U8))
    (@intent "Find position of first occurrence of character in string, -1 if not found")
    (@spec ((String U8) -> Int))
    (let ((data (. s data))
          (len (cast Int (. s len)))
          (mut i 0)
          (mut result -1))
      (while (and (< i len) (< result 0))
        (if (== (@ data i) ch)
          (set! result i)
          (set! i (+ i 1))))
      result))

  (fn emit-list-type-if-needed-safe ((ctx (Ptr TranspileContext)) (inner-type String))
    (@intent "Emit a List type if inner-type refers to one and elem is emitted")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Check if inner-type starts with "slop_list_"
    (when (starts-with inner-type "slop_list_")
      ;; Find this List type and check if its element is emitted
      (let ((list-types (ctx-get-list-types ctx))
            (len (list-len list-types))
            (mut i 0))
        (while (< i len)
          (match (list-get list-types i)
            ((some lt)
              (when (and (string-eq (. lt c-name) inner-type)
                         (is-type-emitted-or-primitive ctx (. lt elem-type)))
                (emit-single-list-type-header ctx lt)))
            ((none) (do)))
          (set! i (+ i 1))))))

  (fn emit-list-type-if-needed ((ctx (Ptr TranspileContext)) (inner-type String))
    (@intent "Emit a List type if inner-type refers to one")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Check if inner-type starts with "slop_list_"
    (when (starts-with inner-type "slop_list_")
      ;; Find and emit this List type
      (let ((list-types (ctx-get-list-types ctx))
            (len (list-len list-types))
            (mut i 0))
        (while (< i len)
          (match (list-get list-types i)
            ((some lt)
              (when (string-eq (. lt c-name) inner-type)
                (emit-single-list-type-header ctx lt)))
            ((none) (do)))
          (set! i (+ i 1))))))

  (fn struct-uses-list-type ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)) (list-type-name String))
    (@intent "Check if a struct uses a particular List type in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; For now, just check if the list type name appears in the struct's field types
    ;; A more precise check would parse field types
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((lst lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 3)
              false
              (match (list-get items 2)
                ((some body-expr)
                  (type-body-uses-typename ctx body-expr list-type-name))
                ((none) false)))))
        (else false))))

  (fn struct-uses-option-type ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)) (option-type-name String))
    (@intent "Check if a struct uses a particular Option type in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (struct-uses-list-type ctx type-def option-type-name))

  (fn type-body-uses-typename ((ctx (Ptr TranspileContext)) (body-expr (Ptr SExpr)) (typename String))
    (@intent "Check if a type body uses a particular type name")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut found false)
                (mut i 1))  ;; Skip record/union keyword
            (while (and (< i len) (not found))
              (match (list-get items i)
                ((some field-expr)
                  (when (field-uses-typename ctx field-expr typename)
                    (set! found true)))
                ((none) (do)))
              (set! i (+ i 1)))
            found))
        (else false))))

  (fn field-uses-typename ((ctx (Ptr TranspileContext)) (field-expr (Ptr SExpr)) (typename String))
    (@intent "Check if a field definition uses a particular type name")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    (match (deref field-expr)
      ((lst lst)
        (let ((items (. lst items)))
          ;; Field is (name type)
          (if (< (list-len items) 2)
            false
            (match (list-get items 1)
              ((some type-expr)
                ;; Convert to C type with prefixing and check if it matches
                (let ((c-type (to-c-type-prefixed ctx type-expr)))
                  (string-eq c-type typename)))
              ((none) false)))))
      (else false)))

  (fn emit-type-to-header ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit a type definition to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; (type TypeName body)
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym name-sym)
                      (let ((type-name (. name-sym name))
                            (base-name (to-c-name arena type-name))
                            ;; Add module prefix if prefixing is enabled
                            (c-name (if (ctx-prefixing-enabled ctx)
                                      (match (ctx-get-module ctx)
                                        ((some mod-name)
                                          (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                        ((none) base-name))
                                      base-name)))
                        (match (list-get items 2)
                          ((some body-expr)
                            (emit-type-body-to-header ctx type-name c-name body-expr)
                            ;; Mark this type as emitted so dependent types know it's safe
                            (ctx-mark-type-emitted ctx c-name))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-type-body-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-name String) (body-expr (Ptr SExpr)))
    (@intent "Emit type body to header based on kind")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((lst lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              (do)
              (match (list-get items 0)
                ((some kind-expr)
                  (match (deref kind-expr)
                    ((sym kind-sym)
                      (let ((kind (. kind-sym name)))
                        (cond
                          ((string-eq kind "enum")
                            (emit-enum-to-header ctx c-name items))
                          ((string-eq kind "record")
                            (emit-struct-to-header ctx raw-type-name c-name items))
                          ((string-eq kind "union")
                            (emit-union-to-header ctx c-name items))
                          (else (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-enum-to-header ((ctx (Ptr TranspileContext)) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit simple enum definition to header")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 1))  ;; Skip 'enum' keyword
      (ctx-emit-header ctx "typedef enum {")
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((sym variant-sym)
                (let ((variant-name (. variant-sym name))
                      (c-variant (ctx-str3 ctx c-name "_" (to-c-name arena variant-name)))
                      (is-last (== i (- len 1))))
                  (if is-last
                    (ctx-emit-header ctx (ctx-str ctx "    " c-variant))
                    (ctx-emit-header ctx (ctx-str3 ctx "    " c-variant ",")))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
      (ctx-emit-header ctx "")
      ;; Mark enum as emitted for dependency tracking
      (ctx-mark-type-emitted ctx c-name)))

  (fn emit-struct-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit struct (record) definition to header and register field types")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 1))  ;; Skip 'record' keyword
      (ctx-emit-header ctx (ctx-str3 ctx "struct " c-name " {"))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (emit-field-to-header ctx raw-type-name c-name field-expr))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-emit-header ctx "};")
      (ctx-emit-header ctx (ctx-str4 ctx "typedef struct " c-name " " (ctx-str ctx c-name ";")))
      (ctx-emit-header ctx "")))

  (fn emit-field-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-type-name String) (field-expr (Ptr SExpr)))
    (@intent "Emit a struct field to header and register field type")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref field-expr)
        ((lst lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym name-sym)
                      (let ((field-name (. name-sym name))
                            (c-field-name (to-c-name arena field-name)))
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr))
                                  (slop-type-str (pretty-print arena type-expr))
                                  (is-ptr (is-pointer-type-expr-header type-expr)))
                              ;; Emit the field
                              (ctx-emit-header ctx (ctx-str4 ctx "    " c-type " " (ctx-str ctx c-field-name ";")))
                              ;; Register field type for both raw and qualified type names
                              (ctx-register-field-type ctx raw-type-name field-name c-type slop-type-str is-ptr)
                              (ctx-register-field-type ctx c-type-name field-name c-type slop-type-str is-ptr)))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn is-pointer-type-expr-header ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type (for field registration)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (string-eq (. sym name) "Ptr"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-union-to-header ((ctx (Ptr TranspileContext)) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit union (tagged union) definition to header")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; For tagged unions, emit tag enum + data union + wrapper struct
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (tag-name (ctx-str ctx c-name "_tag")))
      ;; Emit tag enum
      (ctx-emit-header ctx "typedef enum {")
      (let ((mut i 1))
        (while (< i len)
          (match (list-get items i)
            ((some variant-expr)
              (let ((variant-name (get-variant-name variant-expr))
                    (c-variant (ctx-str3 ctx c-name "_" (to-c-name arena variant-name)))
                    (is-last (== i (- len 1))))
                (if is-last
                  (ctx-emit-header ctx (ctx-str ctx "    " c-variant))
                  (ctx-emit-header ctx (ctx-str3 ctx "    " c-variant ",")))))
            ((none) (do)))
          (set! i (+ i 1))))
      (ctx-emit-header ctx (ctx-str3 ctx "} " tag-name ";"))
      (ctx-emit-header ctx "")
      ;; Emit wrapper struct with tag and data union
      (ctx-emit-header ctx (ctx-str3 ctx "struct " c-name " {"))
      (ctx-emit-header ctx (ctx-str ctx "    " (ctx-str ctx tag-name " tag;")))
      (ctx-emit-header ctx "    union {")
      (let ((mut i 1))
        (while (< i len)
          (match (list-get items i)
            ((some variant-expr)
              (emit-union-variant-to-header ctx variant-expr))
            ((none) (do)))
          (set! i (+ i 1))))
      (ctx-emit-header ctx "    } data;")
      (ctx-emit-header ctx "};")
      (ctx-emit-header ctx (ctx-str4 ctx "typedef struct " c-name " " (ctx-str ctx c-name ";")))
      (ctx-emit-header ctx "")))

  (fn get-variant-name ((variant-expr (Ptr SExpr)))
    (@intent "Get variant name from union variant")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {variant-expr != nil})
    (match (deref variant-expr)
      ((sym sym) (. sym name))
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "unknown"
            (match (list-get items 0)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym name-sym) (. name-sym name))
                  (else "unknown")))
              ((none) "unknown")))))
      (else "unknown")))

  (fn emit-union-variant-to-header ((ctx (Ptr TranspileContext)) (variant-expr (Ptr SExpr)))
    (@intent "Emit a single union variant to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {variant-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref variant-expr)
        ((sym sym)
          ;; No payload - don't emit field
          (do))
        ((lst lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((sym name-sym)
                      (let ((variant-name (. name-sym name))
                            (c-field (to-c-name arena variant-name)))
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr)))
                              ;; Use int for void (Unit) type since void can't be a struct field
                              (let ((actual-type (if (string-eq c-type "void") "int" c-type)))
                                (ctx-emit-header ctx (ctx-str4 ctx "        " actual-type " " (ctx-str ctx c-field ";"))))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-module-consts ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int) (exports (List String)))
    (@intent "Emit all constant definitions from module to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int (List String)) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-const-def item)
              (let ((const-name (get-const-name item))
                    (is-exported (list-contains-str exports const-name)))
                (transpile-const ctx item is-exported))
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn get-const-name ((item (Ptr SExpr)))
    (@intent "Extract the name from a const definition")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {item != nil})
    ;; (const NAME Type value) - extract NAME
    (match (deref item)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            ""
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym) (. sym name))
                  (else "")))
              ((none) "")))))
      (else "")))

  (fn emit-module-consts-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int) (exports (List String)))
    (@intent "Emit declarations for exported constants to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int (List String)) -> Unit))
    (@pre {ctx != nil})
    ;; For each exported constant, emit declaration to header:
    ;;   Integer types: #define NAME (value)
    ;;   Other types: extern const TYPE NAME;
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-const-def item)
              (when (emit-const-header-if-exported ctx item exports)
                (set! emitted-any true))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit-header ctx ""))))


  (fn emit-const-header-if-exported ((ctx (Ptr TranspileContext)) (item (Ptr SExpr)) (exports (List String)))
    (@intent "Emit header declaration for constant if it's exported")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) (List String)) -> Bool))
    (@pre {ctx != nil})
    (@pre {item != nil})
    ;; Extract (const NAME Type value) components
    (match (deref item)
      ((lst lst)
        (let ((const-items (. lst items)))
          (if (< (list-len const-items) 4)
            false
            (match (list-get const-items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym name-sym)
                    (let ((raw-name (. name-sym name)))
                      (if (not (list-contains-str exports raw-name))
                        false  ;; Not exported
                        (match (list-get const-items 2)
                          ((some type-expr)
                            (emit-const-header-decl ctx raw-name type-expr
                              (match (list-get const-items 3)
                                ((some v) v)
                                ((none) nil)))
                            true)
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-const-header-decl ((ctx (Ptr TranspileContext)) (raw-name String) (type-expr (Ptr SExpr)) (value-expr (Ptr SExpr)))
    (@intent "Emit constant declaration to header based on type")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (c-type (to-c-type-prefixed ctx type-expr))
          (base-name (to-c-name arena raw-name))
          (c-name (ctx-prefix-type ctx base-name))
          (type-name (get-type-name-str type-expr)))
      (if (is-const-int-type type-name)
        ;; Integer type: #define NAME (value) in header
        (when (!= value-expr nil)
          (let ((value-c (eval-const-value ctx value-expr)))
            (ctx-emit-header ctx (ctx-str4 ctx "#define " c-name " (" (ctx-str ctx value-c ")")))))
        ;; Non-integer type: extern const TYPE NAME;
        (ctx-emit-header ctx (ctx-str4 ctx "extern const " c-type " " (ctx-str ctx c-name ";"))))))

  (fn is-const-int-type ((type-name String))
    (@intent "Check if type name is an integer type for const handling")
    (@spec ((String) -> Bool))
    (or (string-eq type-name "Int")
        (string-eq type-name "I8")
        (string-eq type-name "I16")
        (string-eq type-name "I32")
        (string-eq type-name "I64")
        (string-eq type-name "U8")
        (string-eq type-name "U16")
        (string-eq type-name "U32")
        (string-eq type-name "U64")))

  (fn is-const-def ((item (Ptr SExpr)))
    (@intent "Check if item is a constant definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (is-const-form item))

  (fn emit-module-functions ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all function definitions from module")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    ;; Two-phase emission: collect function output while transpiling,
    ;; then emit lambdas first, then function output.
    (let ((len (list-len items))
          (mut i start))
      ;; Phase 1: Transpile all functions (output goes to function buffer)
      (ctx-start-function-buffer ctx)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (transpile-function ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-stop-function-buffer ctx)
      ;; Phase 2: Emit all accumulated lambdas to main output
      (emit-all-lambdas ctx)
      ;; Phase 3: Copy function output to main output
      (ctx-flush-function-buffer ctx)))

  (fn emit-all-lambdas ((ctx (Ptr TranspileContext)))
    (@intent "Emit all deferred lambda functions to main output")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((lambdas (ctx-get-deferred-lambdas ctx))
          (count (list-len lambdas))
          (mut i 0))
      (when (> count 0)
        (while (< i count)
          (match (list-get lambdas i)
            ((some lambda-code)
              (ctx-emit ctx lambda-code)
              (ctx-emit ctx ""))
            ((none) (do)))
          (set! i (+ i 1)))
        (ctx-clear-deferred-lambdas ctx))))

  ;; ============================================================
  ;; Output Generation
  ;; ============================================================

  (fn generate-c-output ((ctx (Ptr TranspileContext)))
    (@intent "Generate final C output from context")
    (@spec (((Ptr TranspileContext)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (output-lines (ctx-get-output ctx))
          (len (list-len output-lines))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (match (list-get output-lines i)
          ((some line)
            (set! result (ctx-str3 ctx result line "\n")))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  ;; ============================================================
  ;; File-level Transpilation
  ;; ============================================================

  (fn transpile-file ((ctx (Ptr TranspileContext)) (exprs (List (Ptr SExpr))))
    (@intent "Transpile a file (list of top-level expressions)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len exprs))
          (mut i 0))
      ;; Check if first expression is a module
      (if (and (> len 0) (is-module-expr exprs))
        ;; Module-based transpilation
        (match (list-get exprs 0)
          ((some module-expr)
            (transpile-module ctx module-expr))
          ((none) (do)))
        ;; Non-module (script) transpilation
        (do
          (emit-standard-includes ctx)
          (ctx-emit ctx "")
          ;; Prescan all top-level forms
          (prescan-module ctx exprs)
          ;; Emit types
          (emit-all-types ctx exprs)
          ;; Emit functions
          (emit-all-functions ctx exprs)))))

  (fn is-module-expr ((exprs (List (Ptr SExpr))))
    (@intent "Check if first expression is a module declaration")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len exprs) 1)
      false
      (match (list-get exprs 0)
        ((some first)
          (match (deref first)
            ((lst lst)
              (let ((items (. lst items)))
                (if (< (list-len items) 1)
                  false
                  (match (list-get items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym) (string-eq (. sym name) "module"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

) ;; end module
