;; ============================================================
;; SLOP Native Transpiler - Main Orchestration Module
;;
;; Coordinates the transpilation of SLOP programs to C.
;; ============================================================

(module transpiler
  (export
    ;; Main entry points
    transpile-module transpile-file
    ;; Module processing
    prescan-module process-imports process-exports
    emit-all-types emit-all-functions
    ;; Output generation
    generate-c-output
    ;; Result type helpers (for defn.slop)
    build-result-type-name)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import context (TranspileContext context-new ctx-emit ctx-emit-header ctx-get-output ctx-get-header
                   ctx-indent ctx-dedent ctx-push-scope ctx-pop-scope
                   ctx-register-type ctx-register-func ctx-lookup-type ctx-set-module ctx-get-module ctx-set-prefixing ctx-prefixing-enabled ctx-prefix-type
                   ctx-add-include ctx-get-includes ctx-register-enum-variant
                   ctx-register-result-type ctx-has-result-type ctx-get-result-types ResultType
                   ctx-set-current-result-type ctx-get-current-result-type ctx-clear-current-result-type
                   ctx-register-option-type ctx-has-option-type ctx-get-option-types OptionType
                   ctx-register-list-type ctx-has-list-type ctx-get-list-types ListType
                   ctx-register-chan-type ctx-has-chan-type ctx-get-chan-types ChanType
                   ctx-register-thread-type ctx-has-thread-type ctx-get-thread-types ThreadType
                   ctx-register-result-type-alias ctx-lookup-result-type-alias ResultTypeAlias
                   ctx-get-inline-records InlineRecord
                   ctx-add-import ctx-get-imports
                   ctx-str ctx-str3 ctx-str4 ctx-str5 TypeEntry FuncEntry FuncParamType
                   to-c-type-prefixed
                   ctx-mark-type-emitted ctx-is-type-emitted
                   ctx-register-field-type))
  (import ctype (to-c-type to-c-name type-to-identifier is-builtin-c-type))
  (import emit (emit-standard-includes emit-include))
  (import defn (transpile-type transpile-function transpile-const is-const-form emit-forward-declaration
                is-ffi-form is-ffi-struct-form transpile-ffi transpile-ffi-struct
                get-return-type get-result-type-name build-param-str))
  (import stmt (transpile-stmt))
  (import expr (transpile-expr))
  (import match (transpile-match))
  (import strlib (starts-with substring char-at))

  ;; ============================================================
  ;; Module Prescan
  ;; ============================================================

  (fn prescan-module ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan module for types and function signatures")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (prescan-top-level ctx item))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn prescan-top-level ((ctx (Ptr TranspileContext)) (item (Ptr SExpr)))
    (@intent "Prescan a top-level form")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (when (>= (list-len items) 1)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((name (. sym name)))
                      (cond
                        ((string-eq name "type")
                          (prescan-type ctx items))
                        ((string-eq name "fn")
                          (prescan-fn ctx items))
                        ((string-eq name "const")
                          (prescan-const ctx items))
                        ((string-eq name "ffi")
                          (prescan-ffi ctx items))
                        ((string-eq name "ffi-struct")
                          (prescan-ffi-struct ctx items))
                        ((string-eq name "import")
                          (prescan-import ctx items))
                        (else (do)))))
                  (else (do))))
              ((none) (do))))))
      (else (do))))

  (fn prescan-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a type definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (when (>= (list-len items) 2)
        (match (list-get items 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (let ((type-name (. sym name))
                      (base-c-name (to-c-name arena type-name))
                      ;; Add module prefix if prefixing is enabled
                      (c-name (if (ctx-prefixing-enabled ctx)
                                (match (ctx-get-module ctx)
                                  ((some mod-name)
                                    (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-c-name)))
                                  ((none) base-c-name))
                                base-c-name)))
                  ;; Determine type kind
                  (let ((is-enum (is-enum-def items))
                        (is-record (is-record-def items))
                        (is-union (is-union-def items))
                        ;; For array types, get element pointer type for c-type
                        (c-type (get-array-c-type ctx items c-name)))
                    (ctx-register-type ctx (TypeEntry type-name c-name c-type is-enum is-record is-union))
                    ;; Register enum variants for quote operator (use prefixed c-name)
                    (when is-enum
                      (register-enum-variants ctx c-name items))
                    ;; Register union variants for pattern matching (use prefixed c-name)
                    (when is-union
                      (register-union-variants ctx c-name items))
                    ;; Scan record/union fields for Option/List types
                    (when (or is-record is-union)
                      (when (>= (list-len items) 3)
                        (match (list-get items 2)
                          ((some def-expr)
                            (match (deref def-expr)
                              ((list def-lst)
                                (scan-record-fields-for-generics ctx (. def-lst items)))
                              (else (do))))
                          ((none) (do)))))
                    ;; Check if this is a type alias to Result and register it
                    (when (>= (list-len items) 3)
                      (match (list-get items 2)
                        ((some body-expr)
                          (check-and-register-result-alias ctx type-name body-expr))
                        ((none) (do)))))))
              (else (do))))
          ((none) (do))))))

  (fn register-enum-variants ((ctx (Ptr TranspileContext)) (enum-name String) (items (List (Ptr SExpr))))
    (@intent "Register all variants of an enum for quote operator lookup")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is (type EnumName (enum variant1 variant2 ...))
    (when (>= (list-len items) 3)
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((list def-lst)
              (let ((def-items (. def-lst items))
                    (len (list-len def-items))
                    (mut i 1))  ;; Skip 'enum' keyword
                (while (< i len)
                  (match (list-get def-items i)
                    ((some variant-expr)
                      (match (deref variant-expr)
                        ((symbol sym)
                          ;; Simple variant
                          (ctx-register-enum-variant ctx (. sym name) enum-name))
                        ((list variant-lst)
                          ;; Variant with payload - first item is name
                          (when (> (list-len (. variant-lst items)) 0)
                            (match (list-get (. variant-lst items) 0)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((symbol name-sym)
                                    (ctx-register-enum-variant ctx (. name-sym name) enum-name))
                                  (else (do))))
                              ((none) (do)))))
                        (else (do))))
                    ((none) (do)))
                  (set! i (+ i 1)))))
            (else (do))))
        ((none) (do)))))

  (fn register-union-variants ((ctx (Ptr TranspileContext)) (union-name String) (items (List (Ptr SExpr))))
    (@intent "Register all variants of a union for pattern matching")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is (type UnionName (union (variant1 Type) (variant2 Type) ...))
    (when (>= (list-len items) 3)
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((list def-lst)
              (let ((def-items (. def-lst items))
                    (len (list-len def-items))
                    (mut i 1))  ;; Skip 'union' keyword
                (while (< i len)
                  (match (list-get def-items i)
                    ((some variant-expr)
                      (match (deref variant-expr)
                        ((symbol sym)
                          ;; Simple variant without payload
                          (ctx-register-enum-variant ctx (. sym name) union-name))
                        ((list variant-lst)
                          ;; Variant with payload - first item is name
                          (when (> (list-len (. variant-lst items)) 0)
                            (match (list-get (. variant-lst items) 0)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((symbol name-sym)
                                    (ctx-register-enum-variant ctx (. name-sym name) union-name))
                                  (else (do))))
                              ((none) (do)))))
                        (else (do))))
                    ((none) (do)))
                  (set! i (+ i 1)))))
            (else (do))))
        ((none) (do)))))

  (fn prescan-fn ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a function definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (when (>= (list-len items) 2)
        (match (list-get items 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (let ((fn-name (. sym name))
                      (base-name (to-c-name arena fn-name))
                      ;; Add module prefix EXCEPT for main function
                      (c-name (if (string-eq base-name "main")
                                base-name
                                (ctx-prefix-type ctx base-name)))
                      ;; Check if function returns String
                      (returns-str (fn-returns-string items))
                      ;; Get full return type from @spec
                      (return-type (fn-return-type ctx items))
                      ;; Collect parameter types for typed none handling
                      (param-types (prescan-collect-param-types ctx items)))
                  (ctx-register-func ctx (FuncEntry fn-name c-name return-type false returns-str param-types))
                  ;; Scan param types for List/Option generics
                  (prescan-fn-params ctx items)
                  ;; Check for Result type and other generics in @spec
                  (prescan-fn-result-type ctx items)))
              (else (do))))
          ((none) (do))))))

  (fn fn-returns-string ((items (List (Ptr SExpr))))
    (@intent "Check if function returns String by examining @spec annotation")
    (@spec (((List (Ptr SExpr))) -> Bool))
    ;; Look for @spec annotation and check if return type is String
    (let ((len (list-len items))
          (mut i 3)  ;; Start after fn, name, params
          (mut result false))
      (while (and (< i len) (not result))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((list lst)
                (let ((sub-items (. lst items)))
                  (when (>= (list-len sub-items) 2)
                    (match (list-get sub-items 0)
                      ((some head)
                        (match (deref head)
                          ((symbol sym)
                            (when (string-eq (. sym name) "@spec")
                              ;; Found @spec, check return type
                              (match (list-get sub-items 1)
                                ((some spec-body)
                                  (match (deref spec-body)
                                    ((list body-lst)
                                      (let ((body-items (. body-lst items))
                                            (body-len (list-len body-items)))
                                        ;; Return type is last element
                                        (when (>= body-len 1)
                                          (match (list-get body-items (- body-len 1))
                                            ((some ret-type)
                                              (match (deref ret-type)
                                                ((symbol ret-sym)
                                                  (set! result (string-eq (. ret-sym name) "String")))
                                                (else (do))))
                                            ((none) (do))))))
                                    (else (do))))
                                ((none) (do)))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn fn-return-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Get full C return type from @spec annotation")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    ;; Look for @spec annotation and extract return type, convert to C type
    (let ((len (list-len items))
          (mut i 3)  ;; Start after fn, name, params
          (mut result ""))
      (while (and (< i len) (string-eq result ""))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((list lst)
                (let ((sub-items (. lst items)))
                  (when (>= (list-len sub-items) 2)
                    (match (list-get sub-items 0)
                      ((some head)
                        (match (deref head)
                          ((symbol sym)
                            (when (string-eq (. sym name) "@spec")
                              ;; Found @spec, extract return type
                              (match (list-get sub-items 1)
                                ((some spec-body)
                                  (match (deref spec-body)
                                    ((list body-lst)
                                      (let ((body-items (. body-lst items))
                                            (body-len (list-len body-items)))
                                        ;; Return type is last element
                                        (when (>= body-len 1)
                                          (match (list-get body-items (- body-len 1))
                                            ((some ret-type)
                                              ;; Convert SLOP type to C type
                                              (set! result (to-c-type-prefixed ctx ret-type)))
                                            ((none) (do))))))
                                    (else (do))))
                                ((none) (do)))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn prescan-fn-params ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan function parameter types for List/Option generics")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items[2] is the param list: ((param1 Type1) (param2 Type2) ...)
    (when (>= (list-len items) 3)
      (match (list-get items 2)
        ((some params-expr)
          (match (deref params-expr)
            ((list params-lst)
              (let ((params (. params-lst items))
                    (param-count (list-len params))
                    (mut i 0))
                (while (< i param-count)
                  (match (list-get params i)
                    ((some param-expr)
                      ;; Each param is (name Type)
                      (match (deref param-expr)
                        ((list param-lst)
                          (let ((param-items (. param-lst items)))
                            (when (>= (list-len param-items) 2)
                              (match (list-get param-items 1)
                                ((some type-expr)
                                  (scan-type-for-generics ctx type-expr))
                                ((none) (do))))))
                        (else (do))))
                    ((none) (do)))
                  (set! i (+ i 1)))))
            (else (do))))
        ((none) (do)))))

  (fn prescan-collect-param-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Collect C types of all parameters during prescan for typed none handling")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr FuncParamType))))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (result (list-new arena (Ptr FuncParamType))))
      ;; items[2] is the param list: ((param1 Type1) (param2 Type2) ...)
      (when (>= (list-len items) 3)
        (match (list-get items 2)
          ((some params-expr)
            (match (deref params-expr)
              ((list params-lst)
                (let ((params (. params-lst items))
                      (param-count (list-len params))
                      (mut i 0))
                  (while (< i param-count)
                    (match (list-get params i)
                      ((some param-expr)
                        (let ((c-type (prescan-get-param-c-type ctx param-expr))
                              (param-info (cast (Ptr FuncParamType) (arena-alloc arena 64))))
                          (set! (. (deref param-info) c-type) c-type)
                          (list-push result param-info)))
                      ((none) (do)))
                    (set! i (+ i 1)))))
              (else (do))))
          ((none) (do))))
      result))

  (fn prescan-get-param-c-type ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Extract C type string from a parameter expression during prescan")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "void*"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (prescan-is-param-mode items)))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items type-idx)
                  ((some type-expr)
                    (to-c-type-prefixed ctx type-expr))
                  ((none) "void*"))))))
        (else "void*"))))

  (fn prescan-is-param-mode ((items (List (Ptr SExpr))))
    (@intent "Check if first element is a parameter mode during prescan")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((symbol sym)
              (let ((name (. sym name)))
                (or (string-eq name "mut")
                    (or (string-eq name "ref")
                        (string-eq name "out")))))
            (else false)))
        ((none) false))))

  (fn prescan-fn-result-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan function for Result type in @spec and register if found")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3))  ;; Start after name and params
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-spec-annotation item)
              (extract-result-type ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-spec-annotation ((expr (Ptr SExpr)))
    (@intent "Check if expression is an @spec annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@spec"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn extract-result-type ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract Result type from @spec and register it, also scan for List/Option generics")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (when (>= (list-len items) 2)
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((list body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (when (>= body-len 1)
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              ;; Scan return type for List/Option generics
                              (scan-type-for-generics ctx ret-type)
                              ;; Also check for Result type
                              (check-and-register-result-type ctx ret-type))
                            ((none) (do))))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn check-and-register-result-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Check if type is a Result and register it")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (when (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (when (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with prefix if enabled
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      ;; Build result type name like slop_result_int64_t_TestError
                                      (result-name (build-result-type-name ctx ok-c-type err-c-type)))
                                  (ctx-register-result-type ctx ok-c-type err-c-type result-name)))
                              ((none) (do))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn build-result-type-name ((ctx (Ptr TranspileContext)) (ok-type String) (err-type String))
    (@intent "Build the C type name for a Result type")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    ;; Use type-to-identifier for consistent naming with ctype.slop
    (let ((arena (. (deref ctx) arena))
          (ok-id (type-to-identifier arena ok-type))
          (err-id (type-to-identifier arena err-type)))
      (ctx-str5 ctx "slop_result_" ok-id "_" err-id "")))

  (fn check-and-register-result-alias ((ctx (Ptr TranspileContext)) (alias-name String) (body-expr (Ptr SExpr)))
    (@intent "Check if type body is (Result OkType ErrType) and register alias if so")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (when (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (when (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with prefix if enabled and build result name
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      (result-name (build-result-type-name ctx ok-c-type err-c-type)))
                                  ;; Register the type alias
                                  (ctx-register-result-type-alias ctx alias-name result-name)
                                  ;; Also register the Result type itself
                                  (ctx-register-result-type ctx ok-c-type err-c-type result-name)))
                              ((none) (do))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn prescan-ffi ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an FFI declaration - add header include and register functions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        ;; First item after 'ffi' is the header
        (match (list-get items 1)
          ((some header-expr)
            (match (deref header-expr)
              ((string str)
                (ctx-add-include ctx (. str value)))
              (else (do))))
          ((none) (do)))
        ;; Remaining items are function declarations: (func-name ((param Type)) ReturnType)
        (let ((mut i 2))
          (while (< i len)
            (match (list-get items i)
              ((some func-decl)
                (register-ffi-function ctx func-decl))
              ((none) (do)))
            (set! i (+ i 1)))))))

  (fn is-type-name ((name String))
    (@intent "Check if name looks like a type (starts with uppercase A-Z)")
    (@spec ((String) -> Bool))
    (if (< (string-len name) 1)
      false
      (let ((first-char (char-at name 0)))
        (and (>= first-char 65) (<= first-char 90)))))  ;; 'A' = 65, 'Z' = 90

  (fn prescan-import ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an import declaration - register imported types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Import form: (import module-name (symbols...))
    (when (>= (list-len items) 3)
      (match (list-get items 1)
        ((some mod-expr)
          (match (deref mod-expr)
            ((symbol mod-sym)
              (let ((mod-name (. mod-sym name))
                    (arena (. (deref ctx) arena)))
                (ctx-add-import ctx mod-name)
                ;; Register known type variants for types module
                (when (string-eq mod-name "types")
                  (register-types-module-variants ctx))
                ;; Register file module variants
                (when (string-eq mod-name "file")
                  (register-file-module-variants ctx))
                ;; Parse the symbols list and register any types (capitalized names)
                (match (list-get items 2)
                  ((some symbols-expr)
                    (match (deref symbols-expr)
                      ((list symbols-lst)
                        (let ((syms (. symbols-lst items))
                              (sym-len (list-len syms))
                              (mut j 0))
                          (while (< j sym-len)
                            (match (list-get syms j)
                              ((some sym-item)
                                (match (deref sym-item)
                                  ((symbol s)
                                    (let ((sym-name (. s name))
                                          (c-mod-name (to-c-name arena mod-name))
                                          (c-sym-name (to-c-name arena sym-name)))
                                      (if (is-type-name sym-name)
                                        ;; Register type
                                        (let ((c-name (ctx-str3 ctx c-mod-name "_" c-sym-name)))
                                          (ctx-register-type ctx (TypeEntry sym-name c-name c-name false false false)))
                                        ;; Register function with module prefix (no param types for imports)
                                        (let ((c-name (ctx-str3 ctx c-mod-name "_" c-sym-name))
                                              (empty-params (list-new arena (Ptr FuncParamType))))
                                          (ctx-register-func ctx (FuncEntry sym-name c-name "" false false empty-params))))))
                                  (else (do))))
                              ((none) (do)))
                            (set! j (+ j 1)))))
                      (else (do))))
                  ((none) (do)))))
            (else (do))))
        ((none) (do)))))

  (fn register-types-module-variants ((ctx (Ptr TranspileContext)))
    (@intent "Register SExpr union variants and types from the types module")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    ;; Register the types themselves so they're recognized as constructors
    ;; is_enum, is_record, is_union flags - use module-prefixed c-names
    (ctx-register-type ctx (TypeEntry "SExpr" "types_SExpr" "types_SExpr" false false true))
    (ctx-register-type ctx (TypeEntry "SExprSymbol" "types_SExprSymbol" "types_SExprSymbol" false true false))
    (ctx-register-type ctx (TypeEntry "SExprString" "types_SExprString" "types_SExprString" false true false))
    (ctx-register-type ctx (TypeEntry "SExprNumber" "types_SExprNumber" "types_SExprNumber" false true false))
    (ctx-register-type ctx (TypeEntry "SExprList" "types_SExprList" "types_SExprList" false true false))
    ;; The types module defines SExpr as a union with these variants:
    ;; (type SExpr (union (symbol SExprSymbol) (string SExprString) (number SExprNumber) (list SExprList)))
    ;; Use prefixed names since SExpr comes from types module
    (ctx-register-enum-variant ctx "symbol" "types_SExpr")
    (ctx-register-enum-variant ctx "string" "types_SExpr")
    (ctx-register-enum-variant ctx "number" "types_SExpr")
    (ctx-register-enum-variant ctx "list" "types_SExpr")
    ;; Option and Result variants are built-in and don't need module prefix
    (ctx-register-enum-variant ctx "some" "Option")
    (ctx-register-enum-variant ctx "none" "Option")
    (ctx-register-enum-variant ctx "ok" "Result")
    (ctx-register-enum-variant ctx "error" "Result"))

  (fn register-file-module-variants ((ctx (Ptr TranspileContext)))
    (@intent "Register FileMode and FileError variants from the file module")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    ;; Register FileMode enum variants
    (ctx-register-enum-variant ctx "read" "file_FileMode")
    (ctx-register-enum-variant ctx "write" "file_FileMode")
    (ctx-register-enum-variant ctx "append" "file_FileMode")
    (ctx-register-enum-variant ctx "read-write" "file_FileMode")
    (ctx-register-enum-variant ctx "write-read" "file_FileMode")
    (ctx-register-enum-variant ctx "append-read" "file_FileMode")
    ;; Register FileError enum variants
    (ctx-register-enum-variant ctx "not-found" "file_FileError")
    (ctx-register-enum-variant ctx "permission" "file_FileError")
    (ctx-register-enum-variant ctx "io-error" "file_FileError")
    (ctx-register-enum-variant ctx "eof" "file_FileError")
    (ctx-register-enum-variant ctx "invalid-mode" "file_FileError")
    (ctx-register-enum-variant ctx "closed" "file_FileError")
    ;; Register type entries for file types
    (ctx-register-type ctx (TypeEntry "FileMode" "file_FileMode" "file_FileMode" true false false))
    (ctx-register-type ctx (TypeEntry "FileError" "file_FileError" "file_FileError" true false false))
    (ctx-register-type ctx (TypeEntry "File" "file_File" "file_File" false true false)))

  (fn prescan-const ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan a constant definition")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Constants don't need registration in prescan - just emit in order
    (do))

  (fn register-ffi-function ((ctx (Ptr TranspileContext)) (func-decl (Ptr SExpr)))
    (@intent "Register an FFI function declaration with optional :c-name alias")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {func-decl != nil})
    ;; FFI form: (func-name ((param Type)) ReturnType [:c-name actual_c_name])
    (let ((arena (. (deref ctx) arena)))
      (match (deref func-decl)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 1)
              ;; First item is function name
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol sym)
                      (let ((fn-name (. sym name))
                            ;; Look for :c-name keyword and extract actual C name
                            (c-name (extract-ffi-c-name ctx items fn-name))
                            (empty-params (list-new arena (Ptr FuncParamType))))
                        ;; Register as external function (no param types for FFI)
                        (ctx-register-func ctx (FuncEntry fn-name c-name "" true false empty-params))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn extract-ffi-c-name ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (fn-name String))
    (@intent "Extract C name from FFI declaration - use :c-name value if present, else convert fn-name")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 0)
          (mut found-c-name false)
          (mut c-name ""))
      ;; Scan for :c-name keyword
      (while (< i len)
        (match (list-get items i)
          ((some item-expr)
            (match (deref item-expr)
              ((symbol sym)
                (when (string-eq (. sym name) ":c-name")
                  ;; Next item is the actual C name
                  (match (list-get items (+ i 1))
                    ((some c-name-expr)
                      (match (deref c-name-expr)
                        ((symbol c-sym)
                          (set! c-name (. c-sym name))
                          (set! found-c-name true))
                        (else (do))))
                    ((none) (do)))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Return found C name or convert from SLOP name
      (if found-c-name c-name (to-c-name arena fn-name))))

  (fn prescan-ffi-struct ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Prescan an FFI struct declaration with optional :c-name modifier")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Supports: (ffi-struct "header.h" name [:c-name "c_name"] fields...)
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (when (>= len 2)
        ;; Check if second item is a header string
        (let ((has-header (and (>= len 2) (is-ffi-string-item items 1)))
              (name-idx (if (and (>= len 2) (is-ffi-string-item items 1)) 2 1)))
          ;; Add header include if present
          (when has-header
            (match (list-get items 1)
              ((some header-expr)
                (match (deref header-expr)
                  ((string str)
                    (ctx-add-include ctx (. str value)))
                  (else (do))))
              ((none) (do))))
          ;; Register struct type
          (when (>= len (+ name-idx 1))
            (match (list-get items name-idx)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol sym)
                    (let ((type-name (. sym name))
                          ;; Check for :c-name modifier after the type name
                          (c-name (get-ffi-struct-c-name arena items name-idx type-name)))
                      ;; Register as external struct type with proper C name
                      (ctx-register-type ctx (TypeEntry type-name c-name c-name false true false))))
                  (else (do))))
              ((none) (do))))))))

  (fn get-ffi-struct-c-name ((arena Arena) (items (List (Ptr SExpr))) (name-idx Int) (default-name String))
    (@intent "Get the C name for FFI struct, checking for :c-name modifier")
    (@spec ((Arena (List (Ptr SExpr)) Int String) -> String))
    ;; Look for :c-name modifier after the name
    ;; Format: (ffi-struct "header" name :c-name "actual_c_name" ...)
    (let ((len (list-len items))
          (modifier-idx (+ name-idx 1)))
      (if (>= len (+ modifier-idx 2))
        ;; Check if next item is :c-name
        (match (list-get items modifier-idx)
          ((some mod-expr)
            (match (deref mod-expr)
              ((symbol sym)
                (if (string-eq (. sym name) ":c-name")
                  ;; Get the C name string
                  (match (list-get items (+ modifier-idx 1))
                    ((some cname-expr)
                      (match (deref cname-expr)
                        ((string str)
                          ;; Apply heuristic: if ends with _t, use directly; otherwise add struct
                          (apply-struct-prefix-heuristic arena (. str value)))
                        (_ (apply-struct-prefix-heuristic arena default-name))))
                    ((none) (apply-struct-prefix-heuristic arena default-name)))
                  (apply-struct-prefix-heuristic arena default-name)))
              (_ (apply-struct-prefix-heuristic arena default-name))))
          ((none) (apply-struct-prefix-heuristic arena default-name)))
        (apply-struct-prefix-heuristic arena default-name))))

  (fn apply-struct-prefix-heuristic ((arena Arena) (name String))
    (@intent "Apply struct prefix heuristic: names ending in _t are typedefs, others need struct")
    (@spec ((Arena String) -> String))
    ;; Heuristic: types ending in _t are usually typedefs (no struct prefix)
    ;; Other types are usually C structs (need struct prefix)
    (if (string-ends-with name "_t")
      name
      (string-concat arena "struct " name)))

  (fn string-ends-with ((s String) (suffix String))
    (@intent "Check if string ends with given suffix")
    (@spec ((String String) -> Bool))
    (let ((s-len (string-len s))
          (suf-len (string-len suffix)))
      (if (< s-len suf-len)
        false
        ;; Compare last suf-len chars
        (let ((start (- (cast Int s-len) (cast Int suf-len)))
              (mut i 0)
              (mut matches true))
          (while (and matches (< i (cast Int suf-len)))
            (let ((s-char (@ (. s data) (+ start i)))
                  (suf-char (@ (. suffix data) i)))
              (when (!= s-char suf-char)
                (set! matches false)))
            (set! i (+ i 1)))
          matches))))

  (fn is-ffi-string-item ((items (List (Ptr SExpr))) (idx Int))
    (@intent "Check if item at index is a string")
    (@spec (((List (Ptr SExpr)) Int) -> Bool))
    (match (list-get items idx)
      ((some item)
        (match (deref item)
          ((string _) true)
          (else false)))
      ((none) false)))

  (fn is-enum-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is an enum")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((list def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym) (string-eq (. sym name) "enum"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn is-record-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is a record")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((list def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym) (string-eq (. sym name) "record"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn is-union-def ((items (List (Ptr SExpr))))
    (@intent "Check if type definition is a union")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 3)
      false
      (match (list-get items 2)
        ((some def-expr)
          (match (deref def-expr)
            ((list def-lst)
              (let ((def-items (. def-lst items)))
                (if (< (list-len def-items) 1)
                  false
                  (match (list-get def-items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym) (string-eq (. sym name) "union"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

  (fn get-array-c-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (default-c-type String))
    (@intent "Get c-type for type definition - returns element pointer type for arrays")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) String) -> String))
    (@pre {ctx != nil})
    ;; Check if items[2] (type body) is (Array T size)
    (if (< (list-len items) 3)
      default-c-type
      (match (list-get items 2)
        ((some body-expr)
          (match (deref body-expr)
            ((list body-lst)
              (let ((body-items (. body-lst items)))
                (if (< (list-len body-items) 2)
                  default-c-type
                  (match (list-get body-items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym)
                          (if (string-eq (. sym name) "Array")
                            ;; Array type - get element type and return element pointer
                            (match (list-get body-items 1)
                              ((some elem-expr)
                                (let ((elem-c (to-c-type-prefixed ctx elem-expr)))
                                  (ctx-str ctx elem-c "*")))
                              ((none) default-c-type))
                            default-c-type))
                        (else default-c-type)))
                    ((none) default-c-type)))))
            (else default-c-type)))
        ((none) default-c-type))))

  ;; ============================================================
  ;; Process Imports/Exports
  ;; ============================================================

  (fn process-imports ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Process import declarations")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Imports are handled by the resolver in multi-module builds
    ;; Here we just need to ensure any required includes are added
    (do))

  (fn process-exports ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Process export declarations")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Exports are handled by the resolver
    (do))

  ;; ============================================================
  ;; Type Emission
  ;; ============================================================

  (fn emit-all-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit all type definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-type-def item)
              (transpile-type ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-type-def ((item (Ptr SExpr)))
    (@intent "Check if item is a type definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "type"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Function Emission
  ;; ============================================================

  (fn emit-all-functions ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit all function definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (transpile-function ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-fn-def ((item (Ptr SExpr)))
    (@intent "Check if item is a function definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Main Transpilation
  ;; ============================================================

  (fn transpile-module ((ctx (Ptr TranspileContext)) (module-expr (Ptr SExpr)))
    (@intent "Transpile a complete module")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {module-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref module-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 2)
              ;; Get module name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol sym)
                      (ctx-set-module ctx (some (. sym name))))
                    (else (do))))
                ((none) (do)))
              ;; Get module body (skip module head and name)
              ;; Check for export list
              (let ((body-start (get-body-start items)))
                ;; Prescan for types and functions
                (prescan-module-body ctx items body-start)

                ;; ===== HEADER OUTPUT =====
                ;; Emit header guard opening
                (emit-header-guard-open ctx)
                ;; Emit standard includes to header
                (emit-header-standard-includes ctx)
                ;; Emit dependency includes for imports
                (emit-header-dependency-includes ctx)
                ;; Emit FFI includes to header
                (emit-ffi-includes-header ctx)
                (ctx-emit-header ctx "")
                ;; Emit type forward declarations to header (typedef struct X X;)
                (emit-forward-decls-header ctx items body-start)
                ;; Emit simple enums (no payload, no dependencies)
                (emit-simple-enums-header ctx items body-start)
                ;; Emit inline record types (used in Result types)
                (emit-inline-records-header ctx)
                ;; Emit pointer-element List types (only need forward decls)
                (emit-list-types-header ctx)
                ;; Emit pointer-element Option types (only need forward decls)
                (emit-option-types-header ctx)
                ;; Emit Chan types (require slop_thread.h)
                (emit-chan-types-header ctx)
                ;; Emit Thread types (require slop_thread.h)
                (emit-thread-types-header ctx)
                ;; Emit simple type aliases (range types, etc.) before struct types that may use them
                (emit-simple-type-aliases-header ctx items body-start)
                ;; Emit simple struct/union types (those without value List/Option fields)
                (emit-struct-types-header ctx items body-start)
                ;; Emit value-element List types (need complete struct definitions)
                (emit-value-list-types-header ctx)
                ;; Emit value-element Option types (need complete struct definitions)
                (emit-value-option-types-header ctx)
                ;; Emit complex struct types (those with value List/Option fields)
                (emit-complex-struct-types-header ctx items body-start)
                ;; Emit generated Result types
                (emit-result-types-header ctx)
                ;; Emit Result type aliases (after Result types so they can reference slop_result_*)
                (emit-type-aliases-header ctx items body-start)
                ;; Emit function forward declarations to header
                (emit-fn-forward-decls-header ctx items body-start)
                ;; Emit header guard closing
                (emit-header-guard-close ctx)

                ;; ===== IMPL OUTPUT =====
                ;; Types, includes, and forward declarations are now in header
                ;; Implementation file only contains function bodies
                ;; (The CLI adds #include of the module's own header)
                ;; Emit constants first (before functions that use them)
                (emit-module-consts ctx items body-start)
                ;; Emit functions
                (emit-module-functions ctx items body-start)))))
        (else (ctx-emit ctx "/* invalid module */")))))

  (fn get-body-start ((items (List (Ptr SExpr))))
    (@intent "Get the starting index of module body (after exports)")
    (@spec (((List (Ptr SExpr))) -> Int))
    ;; Skip: (module name) or (module name (export ...))
    (if (< (list-len items) 3)
      2  ;; Just module and name
      (match (list-get items 2)
        ((some third)
          (match (deref third)
            ((list lst)
              (let ((sub-items (. lst items)))
                (if (< (list-len sub-items) 1)
                  2
                  (match (list-get sub-items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym)
                          (if (string-eq (. sym name) "export")
                            3  ;; Skip export list
                            2))
                        (else 2)))
                    ((none) 2)))))
            (else 2)))
        ((none) 2))))

  (fn prescan-module-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Prescan module body starting at given index")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (prescan-top-level ctx item))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Option/List Type Scanning
  ;; ============================================================

  (fn scan-type-for-generics ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Scan a type expression and register any Option/List types found")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 1)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (let ((op (. sym name)))
                        (cond
                          ;; Option type
                          ((string-eq op "Option")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some inner)
                                  ;; Use prefixed inner type and build container name from it
                                  (let ((inner-c (to-c-type-prefixed ctx inner))
                                        (inner-id (type-to-identifier arena inner-c))
                                        (c-name (ctx-str ctx "slop_option_" inner-id)))
                                    (ctx-register-option-type ctx inner-c c-name)
                                    ;; Recursively scan inner type
                                    (scan-type-for-generics ctx inner)))
                                ((none) (do)))))
                          ;; List type
                          ((string-eq op "List")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some elem)
                                  ;; Use prefixed element type and build container name from it
                                  (let ((elem-c (to-c-type-prefixed ctx elem))
                                        (elem-id (type-to-identifier arena elem-c))
                                        (c-name (ctx-str ctx "slop_list_" elem-id))
                                        (option-c-name (ctx-str ctx "slop_option_" elem-id)))
                                    (ctx-register-list-type ctx elem-c c-name)
                                    ;; Also register Option type for element since list-get returns Option<T>
                                    (ctx-register-option-type ctx elem-c option-c-name)
                                    ;; Recursively scan element type
                                    (scan-type-for-generics ctx elem)))
                                ((none) (do)))))
                          ;; Ptr type - scan inner
                          ((string-eq op "Ptr")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some inner) (scan-type-for-generics ctx inner))
                                ((none) (do)))))
                          ;; Result type - already handled elsewhere, but scan types
                          ((string-eq op "Result")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some ok) (scan-type-for-generics ctx ok))
                                ((none) (do))))
                            (when (>= len 3)
                              (match (list-get items 2)
                                ((some err) (scan-type-for-generics ctx err))
                                ((none) (do)))))
                          ;; Chan type
                          ((string-eq op "Chan")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some elem)
                                  (let ((elem-c (to-c-type-prefixed ctx elem))
                                        (elem-id (type-to-identifier arena elem-c))
                                        (c-name (ctx-str ctx "slop_chan_" elem-id)))
                                    (ctx-register-chan-type ctx elem-c c-name)
                                    (scan-type-for-generics ctx elem)))
                                ((none) (do)))))
                          ;; Thread type
                          ((string-eq op "Thread")
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some result)
                                  (let ((result-c (to-c-type-prefixed ctx result))
                                        (result-id (type-to-identifier arena result-c))
                                        (c-name (ctx-str ctx "slop_thread_" result-id)))
                                    (ctx-register-thread-type ctx result-c c-name)
                                    (scan-type-for-generics ctx result)))
                                ((none) (do)))))
                          (else (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn scan-record-fields-for-generics ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Scan record fields for Option/List types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; items is like (record (field1 Type1) (field2 Type2) ...)
    (let ((len (list-len items))
          (mut i 1))  ;; Skip 'record' keyword
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (match (deref field-expr)
              ((list field-lst)
                (let ((field-items (. field-lst items)))
                  (when (>= (list-len field-items) 2)
                    (match (list-get field-items 1)
                      ((some type-expr)
                        (scan-type-for-generics ctx type-expr))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-ffi-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit FFI header includes to impl")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((includes (ctx-get-includes ctx))
          (len (list-len includes))
          (mut i 0))
      (while (< i len)
        (match (list-get includes i)
          ((some header)
            (emit-include ctx header true))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-ffi-includes-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit FFI header includes to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((includes (ctx-get-includes ctx))
          (len (list-len includes))
          (mut i 0))
      (while (< i len)
        (match (list-get includes i)
          ((some header)
            (ctx-emit-header ctx (ctx-str3 ctx "#include <" header ">")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-header-guard-open ((ctx (Ptr TranspileContext)))
    (@intent "Emit opening header guard")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (ctx-get-module ctx)
        ((some mod-name)
          (let ((c-name (to-c-name arena mod-name))
                (guard (ctx-str3 ctx "SLOP_" c-name "_H")))
            (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard))
            (ctx-emit-header ctx (ctx-str ctx "#define " guard))
            (ctx-emit-header ctx "")))
        ((none) (do)))))

  (fn emit-header-guard-close ((ctx (Ptr TranspileContext)))
    (@intent "Emit closing header guard")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (ctx-emit-header ctx "")
    (ctx-emit-header ctx "#endif"))

  (fn emit-header-standard-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit standard includes to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (ctx-emit-header ctx "#include \"slop_runtime.h\"")
    (ctx-emit-header ctx "#include <stdint.h>")
    (ctx-emit-header ctx "#include <stdbool.h>"))

  (fn emit-header-dependency-includes ((ctx (Ptr TranspileContext)))
    (@intent "Emit dependency includes for imported modules")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (imports (ctx-get-imports ctx))
          (len (list-len imports))
          (mut i 0))
      (while (< i len)
        (match (list-get imports i)
          ((some mod-name)
            (let ((c-name (to-c-name arena mod-name)))
              (ctx-emit-header ctx (ctx-str3 ctx "#include \"slop_" c-name ".h\""))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-forward-decls ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit forward declarations for record/union types only")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (match (get-type-name item)
                ((some type-name)
                  (let ((c-name (to-c-name arena type-name)))
                    (ctx-emit ctx (ctx-str3 ctx "typedef struct " c-name (ctx-str ctx " " (ctx-str ctx c-name ";"))))
                    (set! emitted-any true)))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn is-struct-type-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a record or union (needs struct forward decl)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((list def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((symbol sym)
                                (let ((kind (. sym name)))
                                  (or (string-eq kind "record")
                                      (string-eq kind "union")
                                      ;; enum with payload variants is also a struct
                                      (and (string-eq kind "enum")
                                           (has-enum-payload-variants def-items)))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn has-enum-payload-variants ((items (List (Ptr SExpr))))
    (@intent "Check if enum has payload variants (making it a union)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len items))
          (mut i 1)  ;; Skip 'enum' keyword
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((list _) (set! found true))  ;; List variant = payload
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  (fn is-type-alias-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a simple type alias (not record/enum/union)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    ;; Type alias is: (type Name SimpleType) where SimpleType is a symbol or
    ;; a type expression that is NOT record/enum/union (e.g., range type, Int, Option, etc.)
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ;; Symbol body = simple alias like (type AsciiChar U8)
                  ((symbol _) true)
                  ;; List body - check if it's NOT record/enum/union
                  ((list def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((symbol sym)
                                (let ((kind (. sym name)))
                                  ;; NOT record/enum/union means it's an alias (e.g., (Int 0 .. 100), (Option T))
                                  (and (not (string-eq kind "record"))
                                       (not (string-eq kind "enum"))
                                       (not (string-eq kind "union")))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-result-type-alias-def ((item (Ptr SExpr)))
    (@intent "Check if type definition is a Result type alias")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    ;; Result type alias is: (type Name (Result ...))
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((list def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((symbol sym)
                                (string-eq (. sym name) "Result"))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-type-alias-to-header ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit a type alias definition to header as typedef")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((list lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 3)
              ;; (type TypeName body)
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((type-name (. name-sym name))
                            (base-c-name (to-c-name arena type-name))
                            ;; Add module prefix if enabled
                            (c-name (ctx-prefix-type ctx base-c-name)))
                        (match (list-get items 2)
                          ((some body-expr)
                            ;; Check if Array type - needs special handling
                            (if (is-array-type-body body-expr)
                              (emit-array-typedef-to-header ctx c-name body-expr)
                              ;; Get the C type for the body (with prefixing)
                              (let ((c-type (to-c-type-prefixed ctx body-expr)))
                                (ctx-emit-header ctx (ctx-str5 ctx "typedef " c-type " " c-name ";"))
                                (ctx-emit-header ctx ""))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn is-array-type-body ((body-expr (Ptr SExpr)))
    (@intent "Check if type body is an Array type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {body-expr != nil})
    (match (deref body-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Array"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-array-typedef-to-header ((ctx (Ptr TranspileContext)) (c-name String) (body-expr (Ptr SExpr)))
    (@intent "Emit Array typedef to header: typedef T NAME[SIZE];")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; (Array T size)
            (if (< len 3)
              ;; Invalid array type, fall back to pointer
              (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";"))
              (match (list-get items 1)
                ((some elem-type-expr)
                  (match (list-get items 2)
                    ((some size-expr)
                      (let ((elem-c-type (to-c-type-prefixed ctx elem-type-expr))
                            (size-str (get-array-size-string size-expr)))
                        ;; Emit: typedef T NAME[SIZE];
                        (ctx-emit-header ctx (ctx-str5 ctx "typedef " elem-c-type " " c-name (ctx-str3 ctx "[" size-str "];")))
                        (ctx-emit-header ctx "")))
                    ((none)
                      (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";")))))
                ((none)
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";")))))))
        (else
          (ctx-emit-header ctx (ctx-str3 ctx "typedef void* " c-name ";"))))))

  (fn get-array-size-string ((expr (Ptr SExpr)))
    (@intent "Get number value as string for array size")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((number num)
        (. num raw))
      (else "0")))

  (fn emit-forward-decls-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit forward declarations for types to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (match (get-type-name item)
                ((some type-name)
                  (let ((base-name (to-c-name arena type-name))
                        ;; Add module prefix if prefixing is enabled
                        (c-name (if (ctx-prefixing-enabled ctx)
                                  (match (ctx-get-module ctx)
                                    ((some mod-name)
                                      (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                    ((none) base-name))
                                  base-name)))
                    (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name (ctx-str ctx " " (ctx-str ctx c-name ";"))))
                    (set! emitted-any true)))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit-header ctx ""))))

  (fn emit-fn-forward-decls ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit function forward declarations to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (emit-forward-declaration ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-fn-forward-decls-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit function forward declarations to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (emit-fn-forward-decl-header ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit-header ctx ""))))

  (fn emit-fn-forward-decl-header ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit a single function forward declaration to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix EXCEPT for main function
                            (fn-name (if (string-eq base-name "main")
                                       base-name
                                       (ctx-prefix-type ctx base-name))))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            ;; Check for Result type first
                            (let ((result-type-opt (get-result-type-name ctx items))
                                  (raw-return (get-return-type ctx items)))
                              (let ((return-type String (match result-type-opt
                                                          ((some result-name) result-name)
                                                          ((none) raw-return)))
                                    ;; Special case: main returns int
                                    (actual-return (if (string-eq base-name "main") "int" return-type))
                                    (param-str (build-param-str ctx params-expr)))
                                (ctx-emit-header ctx (ctx-str5 ctx actual-return " " fn-name "("
                                                (ctx-str ctx (if (string-eq param-str "") "void" param-str) ");"))))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn get-type-name ((item (Ptr SExpr)))
    (@intent "Get the name from a type definition")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol sym) (some (. sym name)))
                  (else none)))
              ((none) none)))))
      (else none)))

  (fn emit-module-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all type definitions from module to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-type-def item)
              (transpile-type ctx item)
              (ctx-emit ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-type-aliases ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit type aliases (non-struct, non-enum types)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-type-alias-def item))
              (transpile-type ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-enum-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple enum type definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (transpile-type ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-struct-types ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit struct (record/union) type definitions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (transpile-type ctx item)
              (ctx-emit ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-result-types ((ctx (Ptr TranspileContext)))
    (@intent "Emit all registered Result type definitions to impl")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((result-types (ctx-get-result-types ctx))
          (len (list-len result-types))
          (mut i 0))
      (while (< i len)
        (match (list-get result-types i)
          ((some rt)
            (emit-single-result-type ctx rt))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-result-type ((ctx (Ptr TranspileContext)) (rt ResultType))
    (@intent "Emit a single Result type struct definition to impl")
    (@spec (((Ptr TranspileContext) ResultType) -> Unit))
    (@pre {ctx != nil})
    (let ((ok-type (. rt ok-type))
          (err-type (. rt err-type))
          (c-name (. rt c-name))
          ;; Create guard macro name from c-name (uppercase)
          (guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
      ;; #ifndef GUARD_DEFINED
      (ctx-emit ctx (ctx-str ctx "#ifndef " guard-name))
      ;; #define GUARD_DEFINED
      (ctx-emit ctx (ctx-str ctx "#define " guard-name))
      ;; typedef struct { bool is_ok; union { ok_type ok; err_type err; } data; } NAME;
      ;; Note: C doesn't allow void in a union, so we use uint8_t as placeholder
      (let ((part1 "typedef struct { bool is_ok; union { ")
            (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type))
            (part2 (ctx-str3 ctx actual-ok-type " ok; " err-type))
            (part3 (ctx-str3 ctx " err; } data; } " c-name ";")))
        (ctx-emit ctx (ctx-str3 ctx part1 part2 part3)))
      ;; #endif
      (ctx-emit ctx "#endif")
      (ctx-emit ctx "")))

  (fn emit-result-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit all registered Result type definitions to header")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((result-types (ctx-get-result-types ctx))
          (len (list-len result-types))
          (mut i 0))
      (while (< i len)
        (match (list-get result-types i)
          ((some rt)
            (emit-single-result-type-header ctx rt))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-result-type-header ((ctx (Ptr TranspileContext)) (rt ResultType))
    (@intent "Emit a single Result type struct definition to header")
    (@spec (((Ptr TranspileContext) ResultType) -> Unit))
    (@pre {ctx != nil})
    (let ((ok-type (. rt ok-type))
          (err-type (. rt err-type))
          (c-name (. rt c-name))
          ;; Create guard macro name from c-name (uppercase)
          (guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
      ;; #ifndef GUARD_DEFINED
      (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
      ;; #define GUARD_DEFINED
      (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
      ;; typedef struct { bool is_ok; union { ok_type ok; err_type err; } data; } NAME;
      ;; Note: C doesn't allow void in a union, so we use uint8_t as placeholder
      (let ((part1 "typedef struct { bool is_ok; union { ")
            (actual-ok-type (if (string-eq ok-type "void") "uint8_t" ok-type))
            (part2 (ctx-str3 ctx actual-ok-type " ok; " err-type))
            (part3 (ctx-str3 ctx " err; } data; } " c-name ";")))
        (ctx-emit-header ctx (ctx-str3 ctx part1 part2 part3)))
      ;; #endif
      (ctx-emit-header ctx "#endif")
      (ctx-emit-header ctx "")))

  (fn emit-inline-records-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit inline record types to header (used in Result types)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((inline-records (ctx-get-inline-records ctx))
          (len (list-len inline-records))
          (mut i 0))
      (while (< i len)
        (match (list-get inline-records i)
          ((some ir)
            (let ((type-name (. ir type-name))
                  (field-body (. ir field-body))
                  (guard-name (ctx-str3 ctx (uppercase-name ctx type-name) "_DEFINED" "")))
              ;; #ifndef GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
              ;; #define GUARD_DEFINED
              (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
              ;; typedef struct { fields } name;
              (ctx-emit-header ctx (ctx-str5 ctx "typedef struct { " field-body "} " type-name ";"))
              ;; #endif
              (ctx-emit-header ctx "#endif")
              (ctx-emit-header ctx "")))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit pointer-element Option types to header (value-element options need struct defs)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit pointer-element options here
            (when (is-pointer-elem-type (. ot inner-type))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-value-option-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element Option types to header (after struct definitions)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit value-element options here (not pointer types)
            (when (not (is-pointer-elem-type (. ot inner-type)))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-single-option-type-header ((ctx (Ptr TranspileContext)) (ot OptionType))
    (@intent "Emit a single Option type using SLOP_OPTION_DEFINE macro")
    (@spec (((Ptr TranspileContext) OptionType) -> Unit))
    (@pre {ctx != nil})
    (let ((inner-type (. ot inner-type))
          (c-name (. ot c-name)))
      ;; Skip types already defined in slop_runtime.h
      (when (not (is-runtime-option-type c-name))
        (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
          ;; #ifndef GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
          ;; #define GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
          ;; SLOP_OPTION_DEFINE(inner_type, c_name)
          (ctx-emit-header ctx (ctx-str5 ctx "SLOP_OPTION_DEFINE(" inner-type ", " c-name ")"))
          ;; #endif
          (ctx-emit-header ctx "#endif")
          (ctx-emit-header ctx "")))))

  (fn emit-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit pointer-element List types to header (value-element lists need struct defs)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit pointer-element lists here
            (when (is-pointer-elem-type (. lt elem-type))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-value-list-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit value-element List types to header (after struct definitions)")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit value-element lists here (not pointer types)
            (when (not (is-pointer-elem-type (. lt elem-type)))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-pointer-elem-type ((elem-type String))
    (@intent "Check if element type is a pointer type (ends with *)")
    (@spec ((String) -> Bool))
    (let ((len (cast Int (. elem-type len))))
      (if (<= len 0)
        false
        (let ((data (. elem-type data))
              (last-char (@ data (- len 1))))
          (== last-char (cast U8 42))))))

  (fn emit-single-list-type-header ((ctx (Ptr TranspileContext)) (lt ListType))
    (@intent "Emit a single List type using SLOP_LIST_DEFINE macro")
    (@spec (((Ptr TranspileContext) ListType) -> Unit))
    (@pre {ctx != nil})
    (let ((elem-type (. lt elem-type))
          (c-name (. lt c-name)))
      ;; Skip types already defined in slop_runtime.h
      (when (not (is-runtime-list-type c-name))
        (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
          ;; #ifndef GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
          ;; #define GUARD_DEFINED
          (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
          ;; SLOP_LIST_DEFINE(elem_type, c_name)
          (ctx-emit-header ctx (ctx-str5 ctx "SLOP_LIST_DEFINE(" elem-type ", " c-name ")"))
          ;; #endif
          (ctx-emit-header ctx "#endif")
          (ctx-emit-header ctx "")))))

  (fn is-runtime-option-type ((name String))
    (@intent "Check if Option type is already defined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_option_int")
        (or (string-eq name "slop_option_float")
            (or (string-eq name "slop_option_string")
                (or (string-eq name "slop_option_ptr")
                    (string-eq name "slop_option_bool"))))))

  (fn is-runtime-list-type ((name String))
    (@intent "Check if List type is already defined in slop_runtime.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_list_int")
        (or (string-eq name "slop_list_float")
            (or (string-eq name "slop_list_string")
                (string-eq name "slop_list_ptr")))))

  (fn emit-chan-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit Chan types to header with direct struct definitions")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((chan-types (ctx-get-chan-types ctx))
          (len (list-len chan-types))
          (mut i 0))
      (while (< i len)
        (match (list-get chan-types i)
          ((some ct)
            (let ((elem-type (. ct elem-type))
                  (c-name (. ct c-name)))
              ;; Skip runtime built-in types
              (when (not (is-runtime-chan-type c-name))
                (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" "")))
                  ;; #ifndef GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
                  ;; #define GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
                  ;; Emit channel state struct directly
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name " {"))
                  (ctx-emit-header ctx "    uint8_t mutex[64];       /* pthread_mutex_t storage */")
                  (ctx-emit-header ctx "    uint8_t not_empty[64];   /* pthread_cond_t storage */")
                  (ctx-emit-header ctx "    uint8_t not_full[64];    /* pthread_cond_t storage */")
                  (ctx-emit-header ctx (ctx-str3 ctx "    " elem-type "* buffer;         /* Ring buffer */"))
                  (ctx-emit-header ctx "    size_t capacity;         /* Buffer capacity (0 = unbuffered) */")
                  (ctx-emit-header ctx "    size_t count;            /* Current item count */")
                  (ctx-emit-header ctx "    size_t head;             /* Read index */")
                  (ctx-emit-header ctx "    size_t tail;             /* Write index */")
                  (ctx-emit-header ctx "    bool closed;             /* Channel closed flag */")
                  (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
                  ;; #endif
                  (ctx-emit-header ctx "#endif")
                  (ctx-emit-header ctx "")))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-thread-types-header ((ctx (Ptr TranspileContext)))
    (@intent "Emit Thread types to header with direct struct definitions and trampoline")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((thread-types (ctx-get-thread-types ctx))
          (len (list-len thread-types))
          (mut i 0))
      (while (< i len)
        (match (list-get thread-types i)
          ((some tt)
            (let ((result-type (. tt result-type))
                  (c-name (. tt c-name)))
              ;; Skip runtime built-in types
              (when (not (is-runtime-thread-type c-name))
                (let ((guard-name (ctx-str3 ctx (uppercase-name ctx c-name) "_DEFINED" ""))
                      (entry-name (ctx-str ctx c-name "_entry")))
                  ;; #ifndef GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#ifndef " guard-name))
                  ;; #define GUARD_DEFINED
                  (ctx-emit-header ctx (ctx-str ctx "#define " guard-name))
                  ;; Emit thread state struct directly
                  (ctx-emit-header ctx (ctx-str3 ctx "typedef struct " c-name " {"))
                  (ctx-emit-header ctx "    pthread_t id;            /* pthread handle */")
                  (ctx-emit-header ctx (ctx-str3 ctx "    " result-type " result;          /* Thread return value */"))
                  (ctx-emit-header ctx "    void* func;              /* Function pointer */")
                  (ctx-emit-header ctx "    bool done;               /* Completion flag */")
                  (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
                  ;; Emit trampoline function
                  (ctx-emit-header ctx (ctx-str3 ctx "static void* " entry-name "(void* arg) {"))
                  ;; "    slop_thread_int* s = (slop_thread_int*)arg;"
                  (ctx-emit-header ctx (ctx-str5 ctx "    " c-name "* s = (" c-name "*)arg;"))
                  ;; "    s->result = ((int64_t(*)(void))(s->func))();"
                  (ctx-emit-header ctx (ctx-str3 ctx "    s->result = ((" result-type "(*)(void))(s->func))();"))
                  (ctx-emit-header ctx "    s->done = true;")
                  (ctx-emit-header ctx "    return NULL;")
                  (ctx-emit-header ctx "}")
                  ;; #endif
                  (ctx-emit-header ctx "#endif")
                  (ctx-emit-header ctx "")))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-runtime-chan-type ((name String))
    (@intent "Check if Chan type is already defined in slop_thread.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_chan_int64_t")
        (or (string-eq name "slop_chan_double")
            (string-eq name "slop_chan_ptr"))))

  (fn is-runtime-thread-type ((name String))
    (@intent "Check if Thread type is already defined in slop_thread.h")
    (@spec ((String) -> Bool))
    (or (string-eq name "slop_thread_int64_t")
        (or (string-eq name "slop_thread_double")
            (string-eq name "slop_thread_ptr"))))

  (fn uppercase-name ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Convert name to uppercase for use in guard macros")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (cast Int (. name len)))
          (data (. name data))
          (buf (arena-alloc arena (+ len 1)))
          (mut i 0))
      (while (< i len)
        (let ((c (cast Int (@ data i))))
          ;; Convert lowercase a-z to uppercase A-Z
          (if (and (>= c 97) (<= c 122))
            (set! (@ buf i) (cast U8 (- c 32)))
            (set! (@ buf i) (cast U8 c))))
        (set! i (+ i 1)))
      (set! (@ buf len) 0)
      (String buf (cast U64 len))))

  (fn is-simple-enum-def ((item (Ptr SExpr)))
    (@intent "Check if type is a simple enum (no payload variants)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (match (deref item)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 3)
            false
            (match (list-get items 2)
              ((some def-expr)
                (match (deref def-expr)
                  ((list def-lst)
                    (let ((def-items (. def-lst items)))
                      (if (< (list-len def-items) 1)
                        false
                        (match (list-get def-items 0)
                          ((some head)
                            (match (deref head)
                              ((symbol sym)
                                (and (string-eq (. sym name) "enum")
                                     (not (has-enum-payload-variants def-items))))
                              (else false)))
                          ((none) false)))))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-module-types-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all type definitions from module to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start))
      ;; First emit type aliases (simple typedefs like (type AsciiChar U8))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-type-alias-def item))
              (emit-type-alias-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Then emit enums (simple types)
      (set! i start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Then emit struct/union types
      (set! i start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-struct-type-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-simple-type-aliases-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple (non-Result) type aliases to header - called before struct types")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            ;; Emit type aliases that are NOT Result aliases
            (when (and (is-type-def item)
                       (is-type-alias-def item)
                       (not (is-result-type-alias-def item)))
              (emit-type-alias-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-type-aliases-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit Result type aliases to header - called after Result types are emitted")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            ;; Only emit Result type aliases here (simple aliases already emitted)
            (when (and (is-type-def item)
                       (is-type-alias-def item)
                       (is-result-type-alias-def item))
              (emit-type-alias-to-header ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-simple-enums-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit simple enum types to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item) (is-simple-enum-def item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-types-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit struct/union types to header - simple structs first, then List/Option, then complex")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    ;; Two-pass approach to handle dependencies:
    ;; Pass 1: Emit "simple" structs (those with no value List/Option fields)
    ;; Then value List/Option types are emitted by emit-value-list-types-header
    ;; Pass 2: Emit "complex" structs (those with value List/Option fields)
    (let ((len (list-len items))
          (mut i start))
      ;; Pass 1: Simple structs only
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item)
                       (is-struct-type-def item)
                       (not (struct-uses-value-list-or-option ctx item)))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-complex-struct-types-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit complex struct types (those with value List/Option fields) - pass 2")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    ;; This is called AFTER all value List/Option types have been emitted
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (and (is-type-def item)
                       (is-struct-type-def item)
                       (struct-uses-value-list-or-option ctx item))
              (emit-type-to-header ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn struct-uses-value-list-or-option ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Check if struct uses any value List or Option types in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; Check all registered List types
    (let ((list-types (ctx-get-list-types ctx))
          (option-types (ctx-get-option-types ctx))
          (mut found false))
      ;; Check List types
      (let ((len (list-len list-types))
            (mut i 0))
        (while (and (< i len) (not found))
          (match (list-get list-types i)
            ((some lt)
              (when (and (not (is-pointer-elem-type (. lt elem-type)))
                         (struct-uses-list-type ctx type-def (. lt c-name)))
                (set! found true)))
            ((none) (do)))
          (set! i (+ i 1))))
      ;; Check Option types if no List found
      (when (not found)
        (let ((len2 (list-len option-types))
              (mut j 0))
          (while (and (< j len2) (not found))
            (match (list-get option-types j)
              ((some ot)
                (when (and (not (is-pointer-elem-type (. ot inner-type)))
                           (struct-uses-option-type ctx type-def (. ot c-name)))
                  (set! found true)))
              ((none) (do)))
            (set! j (+ j 1)))))
      found))

  (fn emit-struct-dependent-list-types ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element List types that a struct's fields depend on")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit value-element list types (not pointer types)
            ;; Check if this struct uses this list type
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (struct-uses-list-type ctx type-def (. lt c-name)))
              (emit-single-list-type-header ctx lt)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-option-types ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element Option types that a struct's fields depend on")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit value-element option types (not pointer types)
            ;; Check if this struct uses this option type
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (struct-uses-option-type ctx type-def (. ot c-name)))
              ;; If the Option's inner type is a List type, emit that List type first
              (emit-list-type-if-needed ctx (. ot inner-type))
              (emit-single-option-type-header ctx ot)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-list-types-safe ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element List types only if element type is already emitted")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((list-types (ctx-get-list-types ctx))
          (len (list-len list-types))
          (mut i 0))
      (while (< i len)
        (match (list-get list-types i)
          ((some lt)
            ;; Only emit if: not pointer type, struct uses it, AND element type is emitted
            (when (and (not (is-pointer-elem-type (. lt elem-type)))
                       (struct-uses-list-type ctx type-def (. lt c-name)))
              ;; Check if element type is already emitted (or is a primitive/string)
              (when (is-type-emitted-or-primitive ctx (. lt elem-type))
                (emit-single-list-type-header ctx lt))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-struct-dependent-option-types-safe ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit value-element Option types only if inner type is already emitted")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((option-types (ctx-get-option-types ctx))
          (len (list-len option-types))
          (mut i 0))
      (while (< i len)
        (match (list-get option-types i)
          ((some ot)
            ;; Only emit if: not pointer type, struct uses it, AND inner type is emitted
            (when (and (not (is-pointer-elem-type (. ot inner-type)))
                       (struct-uses-option-type ctx type-def (. ot c-name)))
              ;; Check if inner type is already emitted (or is a list/primitive)
              (when (is-type-emitted-or-primitive ctx (. ot inner-type))
                ;; If the Option's inner type is a List type, emit that first
                (emit-list-type-if-needed-safe ctx (. ot inner-type))
                (emit-single-option-type-header ctx ot))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn is-type-emitted-or-primitive ((ctx (Ptr TranspileContext)) (type-name String))
    (@intent "Check if a type is already emitted, a primitive, or a list type")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    ;; Primitives and basic types are always available
    (if (or (string-eq type-name "int64_t")
            (or (string-eq type-name "uint8_t")
                (or (string-eq type-name "int8_t")
                    (or (string-eq type-name "int16_t")
                        (or (string-eq type-name "int32_t")
                            (or (string-eq type-name "uint16_t")
                                (or (string-eq type-name "uint32_t")
                                    (or (string-eq type-name "uint64_t")
                                        (or (string-eq type-name "double")
                                            (or (string-eq type-name "float")
                                                (or (string-eq type-name "slop_string")
                                                    (starts-with type-name "slop_list_"))))))))))))
      true
      ;; Check if in emitted-types list
      (ctx-is-type-emitted ctx type-name)))

  (fn emit-list-type-if-needed-safe ((ctx (Ptr TranspileContext)) (inner-type String))
    (@intent "Emit a List type if inner-type refers to one and elem is emitted")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Check if inner-type starts with "slop_list_"
    (when (starts-with inner-type "slop_list_")
      ;; Find this List type and check if its element is emitted
      (let ((list-types (ctx-get-list-types ctx))
            (len (list-len list-types))
            (mut i 0))
        (while (< i len)
          (match (list-get list-types i)
            ((some lt)
              (when (and (string-eq (. lt c-name) inner-type)
                         (is-type-emitted-or-primitive ctx (. lt elem-type)))
                (emit-single-list-type-header ctx lt)))
            ((none) (do)))
          (set! i (+ i 1))))))

  (fn emit-list-type-if-needed ((ctx (Ptr TranspileContext)) (inner-type String))
    (@intent "Emit a List type if inner-type refers to one")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Check if inner-type starts with "slop_list_"
    (when (starts-with inner-type "slop_list_")
      ;; Find and emit this List type
      (let ((list-types (ctx-get-list-types ctx))
            (len (list-len list-types))
            (mut i 0))
        (while (< i len)
          (match (list-get list-types i)
            ((some lt)
              (when (string-eq (. lt c-name) inner-type)
                (emit-single-list-type-header ctx lt)))
            ((none) (do)))
          (set! i (+ i 1))))))

  (fn struct-uses-list-type ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)) (list-type-name String))
    (@intent "Check if a struct uses a particular List type in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    ;; For now, just check if the list type name appears in the struct's field types
    ;; A more precise check would parse field types
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((list lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 3)
              false
              (match (list-get items 2)
                ((some body-expr)
                  (type-body-uses-typename ctx body-expr list-type-name))
                ((none) false)))))
        (else false))))

  (fn struct-uses-option-type ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)) (option-type-name String))
    (@intent "Check if a struct uses a particular Option type in its fields")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (struct-uses-list-type ctx type-def option-type-name))

  (fn type-body-uses-typename ((ctx (Ptr TranspileContext)) (body-expr (Ptr SExpr)) (typename String))
    (@intent "Check if a type body uses a particular type name")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut found false)
                (mut i 1))  ;; Skip record/union keyword
            (while (and (< i len) (not found))
              (match (list-get items i)
                ((some field-expr)
                  (when (field-uses-typename ctx field-expr typename)
                    (set! found true)))
                ((none) (do)))
              (set! i (+ i 1)))
            found))
        (else false))))

  (fn field-uses-typename ((ctx (Ptr TranspileContext)) (field-expr (Ptr SExpr)) (typename String))
    (@intent "Check if a field definition uses a particular type name")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> Bool))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    (match (deref field-expr)
      ((list lst)
        (let ((items (. lst items)))
          ;; Field is (name type)
          (if (< (list-len items) 2)
            false
            (match (list-get items 1)
              ((some type-expr)
                ;; Convert to C type with prefixing and check if it matches
                (let ((c-type (to-c-type-prefixed ctx type-expr)))
                  (string-eq c-type typename)))
              ((none) false)))))
      (else false)))

  (fn emit-type-to-header ((ctx (Ptr TranspileContext)) (type-def (Ptr SExpr)))
    (@intent "Emit a type definition to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-def)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; (type TypeName body)
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((type-name (. name-sym name))
                            (base-name (to-c-name arena type-name))
                            ;; Add module prefix if prefixing is enabled
                            (c-name (if (ctx-prefixing-enabled ctx)
                                      (match (ctx-get-module ctx)
                                        ((some mod-name)
                                          (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                        ((none) base-name))
                                      base-name)))
                        (match (list-get items 2)
                          ((some body-expr)
                            (emit-type-body-to-header ctx type-name c-name body-expr)
                            ;; Mark this type as emitted so dependent types know it's safe
                            (ctx-mark-type-emitted ctx c-name))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-type-body-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-name String) (body-expr (Ptr SExpr)))
    (@intent "Emit type body to header based on kind")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((list lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              (do)
              (match (list-get items 0)
                ((some kind-expr)
                  (match (deref kind-expr)
                    ((symbol kind-sym)
                      (let ((kind (. kind-sym name)))
                        (cond
                          ((string-eq kind "enum")
                            (emit-enum-to-header ctx c-name items))
                          ((string-eq kind "record")
                            (emit-struct-to-header ctx raw-type-name c-name items))
                          ((string-eq kind "union")
                            (emit-union-to-header ctx c-name items))
                          (else (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-enum-to-header ((ctx (Ptr TranspileContext)) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit simple enum definition to header")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 1))  ;; Skip 'enum' keyword
      (ctx-emit-header ctx "typedef enum {")
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((symbol variant-sym)
                (let ((variant-name (. variant-sym name))
                      (c-variant (ctx-str3 ctx c-name "_" (to-c-name arena variant-name)))
                      (is-last (== i (- len 1))))
                  (if is-last
                    (ctx-emit-header ctx (ctx-str ctx "    " c-variant))
                    (ctx-emit-header ctx (ctx-str3 ctx "    " c-variant ",")))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-emit-header ctx (ctx-str3 ctx "} " c-name ";"))
      (ctx-emit-header ctx "")))

  (fn emit-struct-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit struct (record) definition to header and register field types")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 1))  ;; Skip 'record' keyword
      (ctx-emit-header ctx (ctx-str3 ctx "struct " c-name " {"))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (emit-field-to-header ctx raw-type-name c-name field-expr))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-emit-header ctx "};")
      (ctx-emit-header ctx (ctx-str4 ctx "typedef struct " c-name " " (ctx-str ctx c-name ";")))
      (ctx-emit-header ctx "")))

  (fn emit-field-to-header ((ctx (Ptr TranspileContext)) (raw-type-name String) (c-type-name String) (field-expr (Ptr SExpr)))
    (@intent "Emit a struct field to header and register field type")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {field-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref field-expr)
        ((list lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((field-name (. name-sym name))
                            (c-field-name (to-c-name arena field-name)))
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr))
                                  (is-ptr (is-pointer-type-expr-header type-expr)))
                              ;; Emit the field
                              (ctx-emit-header ctx (ctx-str4 ctx "    " c-type " " (ctx-str ctx c-field-name ";")))
                              ;; Register field type for both raw and qualified type names
                              (ctx-register-field-type ctx raw-type-name field-name c-type is-ptr)
                              (ctx-register-field-type ctx c-type-name field-name c-type is-ptr)))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn is-pointer-type-expr-header ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a pointer type (for field registration)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Ptr"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-union-to-header ((ctx (Ptr TranspileContext)) (c-name String) (items (List (Ptr SExpr))))
    (@intent "Emit union (tagged union) definition to header")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; For tagged unions, emit tag enum + data union + wrapper struct
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (tag-name (ctx-str ctx c-name "_tag")))
      ;; Emit tag enum
      (ctx-emit-header ctx "typedef enum {")
      (let ((mut i 1))
        (while (< i len)
          (match (list-get items i)
            ((some variant-expr)
              (let ((variant-name (get-variant-name variant-expr))
                    (c-variant (ctx-str3 ctx c-name "_" (to-c-name arena variant-name)))
                    (is-last (== i (- len 1))))
                (if is-last
                  (ctx-emit-header ctx (ctx-str ctx "    " c-variant))
                  (ctx-emit-header ctx (ctx-str3 ctx "    " c-variant ",")))))
            ((none) (do)))
          (set! i (+ i 1))))
      (ctx-emit-header ctx (ctx-str3 ctx "} " tag-name ";"))
      (ctx-emit-header ctx "")
      ;; Emit wrapper struct with tag and data union
      (ctx-emit-header ctx (ctx-str3 ctx "struct " c-name " {"))
      (ctx-emit-header ctx (ctx-str ctx "    " (ctx-str ctx tag-name " tag;")))
      (ctx-emit-header ctx "    union {")
      (let ((mut i 1))
        (while (< i len)
          (match (list-get items i)
            ((some variant-expr)
              (emit-union-variant-to-header ctx variant-expr))
            ((none) (do)))
          (set! i (+ i 1))))
      (ctx-emit-header ctx "    } data;")
      (ctx-emit-header ctx "};")
      (ctx-emit-header ctx (ctx-str4 ctx "typedef struct " c-name " " (ctx-str ctx c-name ";")))
      (ctx-emit-header ctx "")))

  (fn get-variant-name ((variant-expr (Ptr SExpr)))
    (@intent "Get variant name from union variant")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {variant-expr != nil})
    (match (deref variant-expr)
      ((symbol sym) (. sym name))
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            "unknown"
            (match (list-get items 0)
              ((some name-expr)
                (match (deref name-expr)
                  ((symbol name-sym) (. name-sym name))
                  (else "unknown")))
              ((none) "unknown")))))
      (else "unknown")))

  (fn emit-union-variant-to-header ((ctx (Ptr TranspileContext)) (variant-expr (Ptr SExpr)))
    (@intent "Emit a single union variant to header")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {variant-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref variant-expr)
        ((symbol sym)
          ;; No payload - don't emit field
          (do))
        ((list lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((variant-name (. name-sym name))
                            (c-field (to-c-name arena variant-name)))
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr)))
                              (ctx-emit-header ctx (ctx-str4 ctx "        " c-type " " (ctx-str ctx c-field ";")))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn emit-module-consts ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all constant definitions from module to impl")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start)
          (mut emitted-any false))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-const-def item)
              (transpile-const ctx item)
              (set! emitted-any true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when emitted-any
        (ctx-emit ctx ""))))

  (fn emit-module-consts-header ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all constant definitions from module to header")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    ;; Constants go to impl for now - they're available there
    (do))


  (fn is-const-def ((item (Ptr SExpr)))
    (@intent "Check if item is a constant definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {item != nil})
    (is-const-form item))

  (fn emit-module-functions ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int))
    (@intent "Emit all function definitions from module")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-fn-def item)
              (transpile-function ctx item)))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Output Generation
  ;; ============================================================

  (fn generate-c-output ((ctx (Ptr TranspileContext)))
    (@intent "Generate final C output from context")
    (@spec (((Ptr TranspileContext)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (output-lines (ctx-get-output ctx))
          (len (list-len output-lines))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (match (list-get output-lines i)
          ((some line)
            (set! result (ctx-str3 ctx result line "\n")))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  ;; ============================================================
  ;; File-level Transpilation
  ;; ============================================================

  (fn transpile-file ((ctx (Ptr TranspileContext)) (exprs (List (Ptr SExpr))))
    (@intent "Transpile a file (list of top-level expressions)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len exprs))
          (mut i 0))
      ;; Check if first expression is a module
      (if (and (> len 0) (is-module-expr exprs))
        ;; Module-based transpilation
        (match (list-get exprs 0)
          ((some module-expr)
            (transpile-module ctx module-expr))
          ((none) (do)))
        ;; Non-module (script) transpilation
        (do
          (emit-standard-includes ctx)
          (ctx-emit ctx "")
          ;; Prescan all top-level forms
          (prescan-module ctx exprs)
          ;; Emit types
          (emit-all-types ctx exprs)
          ;; Emit functions
          (emit-all-functions ctx exprs)))))

  (fn is-module-expr ((exprs (List (Ptr SExpr))))
    (@intent "Check if first expression is a module declaration")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len exprs) 1)
      false
      (match (list-get exprs 0)
        ((some first)
          (match (deref first)
            ((list lst)
              (let ((items (. lst items)))
                (if (< (list-len items) 1)
                  false
                  (match (list-get items 0)
                    ((some head)
                      (match (deref head)
                        ((symbol sym) (string-eq (. sym name) "module"))
                        (else false)))
                    ((none) false)))))
            (else false)))
        ((none) false))))

) ;; end module
