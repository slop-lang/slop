;; ============================================================
;; SLOP Native Transpiler - Main Transpiler Logic
;;
;; Coordinates transpilation of SLOP AST to C code.
;; Handles modules, types, functions, statements, expressions.
;; Produces separate .h and .c output per module.
;; ============================================================

(module transpiler
  (export
    ;; Main entry points
    transpile-module transpile-modules
    ;; Error type
    TranspileError TranspileResult ModuleOutput)

  (import types (SExpr SExprList SExprSymbol SExprNumber SExprString
                 ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo RangeBounds))
  (import context (TranspileContext VarEntry context-new
                   ctx-register-type ctx-lookup-type
                   ctx-register-func ctx-lookup-func
                   ctx-push-scope ctx-pop-scope ctx-bind-var ctx-lookup-var
                   ctx-set-module ctx-get-module ctx-enable-prefixing
                   ctx-emit ctx-emit-header ctx-get-output ctx-get-header
                   ctx-indent ctx-dedent ctx-add-include ctx-get-includes
                   ctx-mark-type-emitted ctx-is-type-emitted
                   ctx-str ctx-str3 ctx-str4 ctx-str5))
  (import ctype (slop-type-to-c primitive-to-c range-to-c-int
                 mangle-identifier mangle-type-name mangle-fn-name
                 qualified-type-name qualified-fn-name
                 is-primitive-type is-builtin-type))
  (import emit (emit-record-def emit-enum-def emit-union-def emit-typedef
                emit-fn-decl emit-fn-def-start emit-fn-def-end
                emit-block-start emit-block-end
                emit-if emit-while emit-for emit-return
                emit-var-decl emit-assignment
                emit-call emit-field-access emit-index
                emit-binary-op emit-unary-op emit-literal emit-cast
                emit-match-start emit-match-case emit-match-end
                emit-comment emit-blank-line
                emit-include emit-guard-start emit-guard-end
                emit-forward-decl))

  ;; ============================================================
  ;; Error and Result Types
  ;; ============================================================

  (type TranspileError (record
    (message String)
    (line Int)
    (col Int)))

  (type ModuleOutput (record
    (name String)
    (header String)
    (impl String)))

  (type TranspileResult (Result (List ModuleOutput) TranspileError))

  ;; ============================================================
  ;; Helper Functions
  ;; ============================================================

  (fn make-error ((msg String) (line Int) (col Int))
    (@intent "Create a TranspileError")
    (@spec ((String Int Int) -> TranspileError))
    (@pure)
    (TranspileError msg line col))

  (fn sexpr-get-head ((expr (Ptr SExpr)))
    (@intent "Get the first element of a list expression")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pure)
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (> (list-len items) 0)
            (list-get items 0)
            (none))))
      (else (none))))

  (fn sexpr-get-symbol-name ((expr (Ptr SExpr)))
    (@intent "Get the symbol name from an expression")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pure)
    (@pre {expr != nil})
    (match (deref expr)
      ((symbol sym) (some (. sym name)))
      (else (none))))

  (fn sexpr-is-form ((expr (Ptr SExpr)) (name String))
    (@intent "Check if expression is a list starting with given symbol")
    (@spec (((Ptr SExpr) String) -> Bool))
    (@pure)
    (@pre {expr != nil})
    (match (sexpr-get-head expr)
      ((some head)
        (match (sexpr-get-symbol-name head)
          ((some sym-name) (string-eq sym-name name))
          ((none) false)))
      ((none) false)))

  (fn list-item ((expr (Ptr SExpr)) (idx Int))
    (@intent "Get item at index from list expression")
    (@spec (((Ptr SExpr) Int) -> (Option (Ptr SExpr))))
    (@pure)
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (list-get (. lst items) idx))
      (else (none))))

  (fn list-items-count ((expr (Ptr SExpr)))
    (@intent "Get number of items in a list expression")
    (@spec (((Ptr SExpr)) -> Int))
    (@pure)
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst) (list-len (. lst items)))
      (else 0)))

  ;; ============================================================
  ;; Main Entry Points
  ;; ============================================================

  (fn transpile-modules ((arena Arena) (modules (List (Ptr SExpr))))
    (@intent "Transpile multiple SLOP modules to C, handling cross-module imports")
    (@spec ((Arena (List (Ptr SExpr))) -> TranspileResult))
    (@alloc arena)
    (@pre {(list-len modules) > 0})
    (let ((ctx (context-new arena))
          (mut results (list-new arena ModuleOutput))
          (len (list-len modules))
          (mut i 0)
          (mut has-error false)
          (mut error-val TranspileError (TranspileError "" 0 0)))
      ;; Transpile each module
      (while (and (< i len) (not has-error))
        (match (list-get modules i)
          ((some module-ast)
            (match (transpile-module ctx module-ast)
              ((ok output)
                (list-push results output))
              ((error e)
                (do
                  (set! has-error true)
                  (set! error-val e)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (if has-error
        (error error-val)
        (ok results))))

  (fn transpile-module ((ctx (Ptr TranspileContext)) (module-ast (Ptr SExpr)))
    (@intent "Transpile a single SLOP module to C header and implementation")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result ModuleOutput TranspileError)))
    (@pre {ctx != nil})
    (@pre {module-ast != nil})
    ;; Check if this is a module form
    (if (not (sexpr-is-form module-ast "module"))
      (error (make-error "Expected module form" 0 0))
      ;; Extract module name
      (match (list-item module-ast 1)
        ((none) (error (make-error "Module missing name" 0 0)))
        ((some name-expr)
          (match (sexpr-get-symbol-name name-expr)
            ((none) (error (make-error "Module name must be a symbol" 0 0)))
            ((some mod-name)
              (do
                ;; Set module context
                (ctx-set-module ctx (some mod-name))
                ;; Emit header guards
                (let ((guard-name (ctx-str ctx (mangle-identifier ctx mod-name) "_H")))
                  (emit-guard-start ctx guard-name)
                  (emit-blank-line ctx)
                  ;; Emit standard includes
                  (emit-include ctx "stdint.h" true)
                  (emit-include ctx "stddef.h" true)
                  (emit-blank-line ctx)
                  ;; Transpile all forms in module body
                  (let ((count (list-items-count module-ast))
                        (mut i 2)  ;; Skip 'module' and name
                        (mut has-err false)
                        (mut err-val TranspileError (TranspileError "" 0 0)))
                    (while (and (< i count) (not has-err))
                      (match (list-item module-ast i)
                        ((some form)
                          ;; Skip export and import forms
                          (when (not (or (sexpr-is-form form "export")
                                         (sexpr-is-form form "import")))
                            (match (transpile-top-level ctx form)
                              ((ok _) (do))
                              ((error e)
                                (do
                                  (set! has-err true)
                                  (set! err-val e))))))
                        ((none) (do)))
                      (set! i (+ i 1)))
                    (if has-err
                      (error err-val)
                      (do
                        ;; Emit header guard end
                        (emit-blank-line ctx)
                        (emit-guard-end ctx guard-name)
                        ;; Return module output
                        (ok (ModuleOutput
                          mod-name
                          (ctx-get-header ctx)
                          (ctx-get-output ctx))))))))))))))

  ;; ============================================================
  ;; Top-Level Form Transpilation
  ;; ============================================================

  (fn transpile-top-level ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a top-level form (type, fn, const, ffi, import)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result Unit TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    (cond
      ((sexpr-is-form form "type")
        (transpile-type-def ctx form))
      ((sexpr-is-form form "fn")
        (transpile-fn-def ctx form))
      ((sexpr-is-form form "const")
        (transpile-const ctx form))
      ((sexpr-is-form form "ffi")
        (transpile-ffi ctx form))
      (else
        (ok (do)))))  ;; Ignore unknown forms

  (fn transpile-type-def ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a type definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result Unit TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (type Name body)
    (match (list-item form 1)
      ((none) (error (make-error "Type missing name" 0 0)))
      ((some name-expr)
        (match (sexpr-get-symbol-name name-expr)
          ((none) (error (make-error "Type name must be a symbol" 0 0)))
          ((some type-name)
            (match (list-item form 2)
              ((none) (error (make-error "Type missing body" 0 0)))
              ((some body)
                (let ((c-name (qualified-type-name ctx type-name)))
                  (cond
                    ;; Record type: (type Name (record (field Type) ...))
                    ((sexpr-is-form body "record")
                      (do
                        (emit-comment ctx (ctx-str ctx "Record: " type-name))
                        ;; For now emit a placeholder - full implementation would parse fields
                        (ctx-emit-header ctx (ctx-str5 ctx "typedef struct " c-name " " c-name ";"))
                        (ok (do))))
                    ;; Enum type: (type Name (enum val1 val2 ...))
                    ((sexpr-is-form body "enum")
                      (do
                        (emit-comment ctx (ctx-str ctx "Enum: " type-name))
                        (ctx-emit-header ctx (ctx-str3 ctx "typedef uint8_t " c-name ";"))
                        (ok (do))))
                    ;; Union type: (type Name (union (variant Payload) ...))
                    ((sexpr-is-form body "union")
                      (do
                        (emit-comment ctx (ctx-str ctx "Union: " type-name))
                        (emit-forward-decl ctx c-name)
                        (ok (do))))
                    ;; Range type or alias
                    (else
                      (do
                        (emit-typedef ctx c-name "int64_t")
                        (ok (do)))))))))))))

  (fn transpile-fn-def ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a function definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result Unit TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (fn name ((param Type) ...) annotations... body)
    (match (list-item form 1)
      ((none) (error (make-error "Function missing name" 0 0)))
      ((some name-expr)
        (match (sexpr-get-symbol-name name-expr)
          ((none) (error (make-error "Function name must be a symbol" 0 0)))
          ((some fn-name)
            (let ((c-name (qualified-fn-name ctx fn-name)))
              ;; Get params (item 2)
              (match (list-item form 2)
                ((none) (error (make-error "Function missing parameters" 0 0)))
                ((some params-expr)
                  (let ((params-str (transpile-params ctx params-expr))
                        (ret-type "int64_t"))  ;; Default return type
                    ;; Emit declaration to header
                    (emit-fn-decl ctx c-name params-str ret-type)
                    ;; Find body (skip annotations)
                    (let ((count (list-items-count form))
                          (mut body-idx 3)
                          (mut found-body false))
                      ;; Skip annotations
                      (while (and (< body-idx count) (not found-body))
                        (match (list-item form body-idx)
                          ((some item)
                            (if (sexpr-is-form item "@intent")
                              (set! body-idx (+ body-idx 1))
                              (if (sexpr-is-form item "@spec")
                                (set! body-idx (+ body-idx 1))
                                (if (sexpr-is-form item "@pre")
                                  (set! body-idx (+ body-idx 1))
                                  (if (sexpr-is-form item "@post")
                                    (set! body-idx (+ body-idx 1))
                                    (if (sexpr-is-form item "@pure")
                                      (set! body-idx (+ body-idx 1))
                                      (if (sexpr-is-form item "@alloc")
                                        (set! body-idx (+ body-idx 1))
                                        (if (sexpr-is-form item "@example")
                                          (set! body-idx (+ body-idx 1))
                                          ;; Found body - stop scanning
                                          (set! found-body true)))))))))
                          ((none) (set! found-body true))))
                      ;; Emit function definition
                      (emit-fn-def-start ctx c-name params-str ret-type)
                      (ctx-push-scope ctx)
                      ;; Transpile all body expressions
                      ;; All but last are statements, last is return value
                      (let ((mut i body-idx))
                        (while (< i count)
                          (match (list-item form i)
                            ((some expr)
                              (if (== i (- count 1))
                                ;; Last expression - emit as return
                                (match (transpile-expr ctx expr)
                                  ((ok result-expr)
                                    (emit-return ctx result-expr))
                                  ((error e)
                                    (emit-return ctx "0")))
                                ;; Not last - emit as statement
                                (match (transpile-expr ctx expr)
                                  ((ok stmt-expr)
                                    (ctx-emit ctx (ctx-str ctx "    " (ctx-str ctx stmt-expr ";"))))
                                  ((error e) (do)))))
                            ((none) (do)))
                          (set! i (+ i 1))))
                      (ctx-pop-scope ctx)
                      (emit-fn-def-end ctx)
                      (emit-blank-line ctx)
                      (ok (do))))))))))))

  (fn transpile-params ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Transpile function parameters to C parameter list string")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((count (list-items-count params-expr))
          (mut result "")
          (mut i 0))
      (if (== count 0)
        "void"
        (do
          (while (< i count)
            (match (list-item params-expr i)
              ((some param)
                ;; Each param is ((mode)? name Type) or (name Type)
                (let ((param-count (list-items-count param)))
                  (if (>= param-count 2)
                    (let ((name-idx (if (== param-count 3) 1 0))
                          (type-idx (if (== param-count 3) 2 1)))
                      (match (list-item param name-idx)
                        ((some name-expr)
                          (match (sexpr-get-symbol-name name-expr)
                            ((some param-name)
                              (match (list-item param type-idx)
                                ((some type-expr)
                                  (match (sexpr-get-symbol-name type-expr)
                                    ((some type-name)
                                      (let ((c-type (primitive-to-c type-name))
                                            (c-name (mangle-identifier ctx param-name)))
                                        (when (> i 0)
                                          (set! result (ctx-str ctx result ", ")))
                                        (set! result (ctx-str4 ctx result c-type " " c-name))))
                                    ((none) (do))))
                                ((none) (do))))
                            ((none) (do))))
                        ((none) (do))))
                    (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          result))))

  (fn transpile-const ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a constant definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result Unit TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (const NAME Type value)
    (match (list-item form 1)
      ((none) (error (make-error "Const missing name" 0 0)))
      ((some name-expr)
        (match (sexpr-get-symbol-name name-expr)
          ((none) (error (make-error "Const name must be a symbol" 0 0)))
          ((some const-name)
            (match (list-item form 3)
              ((none) (error (make-error "Const missing value" 0 0)))
              ((some value-expr)
                (let ((c-name (mangle-identifier ctx const-name)))
                  (match (deref value-expr)
                    ((number n)
                      (do
                        (ctx-emit-header ctx (ctx-str4 ctx "#define " c-name " " (. n raw)))
                        (ok (do))))
                    (else
                      (do
                        (ctx-emit-header ctx (ctx-str3 ctx "static const int64_t " c-name " = 0;"))
                        (ok (do)))))))))))))

  (fn transpile-ffi ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile an FFI declaration")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result Unit TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (ffi "header.h" (func-name ...))
    (match (list-item form 1)
      ((none) (error (make-error "FFI missing header" 0 0)))
      ((some header-expr)
        (match (deref header-expr)
          ((string s)
            (do
              (ctx-add-include ctx (. s value))
              (emit-include ctx (. s value) true)
              (ok (do))))
          (else
            (error (make-error "FFI header must be a string" 0 0)))))))

  ;; ============================================================
  ;; Statement Transpilation
  ;; ============================================================

  (fn transpile-stmt ((ctx (Ptr TranspileContext)) (stmt (Ptr SExpr)))
    (@intent "Transpile a statement")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {stmt != nil})
    (cond
      ((sexpr-is-form stmt "let")
        (transpile-let ctx stmt))
      ((sexpr-is-form stmt "if")
        (transpile-if ctx stmt))
      ((sexpr-is-form stmt "cond")
        (transpile-cond ctx stmt))
      ((sexpr-is-form stmt "while")
        (transpile-while ctx stmt))
      ((sexpr-is-form stmt "for")
        (transpile-for ctx stmt))
      ((sexpr-is-form stmt "match")
        (transpile-match ctx stmt))
      ((sexpr-is-form stmt "set!")
        (transpile-set ctx stmt))
      ((sexpr-is-form stmt "do")
        (transpile-do ctx stmt))
      (else
        (transpile-expr ctx stmt))))

  (fn transpile-let ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a let binding")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (let ((var val) ...) body)
    (ctx-push-scope ctx)
    (match (list-item form 1)
      ((none)
        (do
          (ctx-pop-scope ctx)
          (error (make-error "Let missing bindings" 0 0))))
      ((some bindings)
        (let ((bind-count (list-items-count bindings))
              (mut i 0)
              (mut has-err false)
              (mut err-val TranspileError (TranspileError "" 0 0)))
          ;; Process each binding
          (while (and (< i bind-count) (not has-err))
            (match (list-item bindings i)
              ((some binding)
                ;; Binding is (var val) or (mut var Type val) or (var Type val)
                (let ((is-mut (sexpr-is-form binding "mut"))
                      (var-idx (if is-mut 1 0))
                      (val-idx (- (list-items-count binding) 1)))
                  (match (list-item binding var-idx)
                    ((some var-expr)
                      (match (sexpr-get-symbol-name var-expr)
                        ((some var-name)
                          (match (list-item binding val-idx)
                            ((some val-expr)
                              (match (transpile-expr ctx val-expr)
                                ((ok val-str)
                                  (let ((c-name (mangle-identifier ctx var-name)))
                                    (emit-var-decl ctx "int64_t" c-name (some val-str))
                                    (ctx-bind-var ctx (VarEntry var-name c-name "int64_t" false is-mut))))
                                ((error e)
                                  (do
                                    (set! has-err true)
                                    (set! err-val e)))))
                            ((none)
                              (do
                                (set! has-err true)
                                (set! err-val (make-error "Binding missing value" 0 0))))))
                        ((none)
                          (do
                            (set! has-err true)
                            (set! err-val (make-error "Binding var must be symbol" 0 0))))))
                    ((none)
                      (do
                        (set! has-err true)
                        (set! err-val (make-error "Invalid binding" 0 0)))))))
              ((none) (do)))
            (set! i (+ i 1)))
          ;; Process body
          (if has-err
            (do
              (ctx-pop-scope ctx)
              (error err-val))
            (match (list-item form 2)
              ((none)
                (do
                  (ctx-pop-scope ctx)
                  (ok "0")))
              ((some body)
                (let ((result (transpile-stmt ctx body)))
                  (ctx-pop-scope ctx)
                  result))))))))

  (fn transpile-if ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile an if expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (if cond then else)
    (match (list-item form 1)
      ((none) (error (make-error "If missing condition" 0 0)))
      ((some cond-expr)
        (match (transpile-expr ctx cond-expr)
          ((error e) (error e))
          ((ok cond-str)
            (match (list-item form 2)
              ((none) (error (make-error "If missing then branch" 0 0)))
              ((some then-expr)
                (match (transpile-expr ctx then-expr)
                  ((error e) (error e))
                  ((ok then-str)
                    (match (list-item form 3)
                      ((none)
                        ;; No else branch - use 0
                        (ok (ctx-str5 ctx "(" cond-str " ? " then-str " : 0)")))
                      ((some else-expr)
                        (match (transpile-expr ctx else-expr)
                          ((error e) (error e))
                          ((ok else-str)
                            (ok (ctx-str5 ctx "(" cond-str " ? " (ctx-str3 ctx then-str " : " else-str) ")")))))))))))))))

  (fn transpile-cond ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a cond expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; Convert to nested ternary
    (ok "0"))  ;; Simplified - full impl would handle all branches

  (fn transpile-while ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a while loop")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (while cond body...)
    (match (list-item form 1)
      ((none) (error (make-error "While missing condition" 0 0)))
      ((some cond-expr)
        (match (transpile-expr ctx cond-expr)
          ((error e) (error e))
          ((ok cond-str)
            (do
              (emit-while ctx cond-str)
              ;; Transpile body statements
              (let ((count (list-items-count form))
                    (mut i 2))
                (while (< i count)
                  (match (list-item form i)
                    ((some body-stmt)
                      (match (transpile-stmt ctx body-stmt)
                        ((ok _) (do))
                        ((error _) (do))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              (emit-block-end ctx)
              (ok "0")))))))

  (fn transpile-for ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a for loop")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (for (var start end) body...)
    (match (list-item form 1)
      ((none) (error (make-error "For missing range" 0 0)))
      ((some range-expr)
        (match (list-item range-expr 0)
          ((none) (error (make-error "For missing var" 0 0)))
          ((some var-expr)
            (match (sexpr-get-symbol-name var-expr)
              ((none) (error (make-error "For var must be symbol" 0 0)))
              ((some var-name)
                (let ((c-var (mangle-identifier ctx var-name)))
                  (match (list-item range-expr 1)
                    ((none) (error (make-error "For missing start" 0 0)))
                    ((some start-expr)
                      (match (transpile-expr ctx start-expr)
                        ((error e) (error e))
                        ((ok start-str)
                          (match (list-item range-expr 2)
                            ((none) (error (make-error "For missing end" 0 0)))
                            ((some end-expr)
                              (match (transpile-expr ctx end-expr)
                                ((error e) (error e))
                                ((ok end-str)
                                  (do
                                    (ctx-push-scope ctx)
                                    (ctx-bind-var ctx (VarEntry var-name c-var "int64_t" false false))
                                    (emit-for ctx
                                      (ctx-str4 ctx "int64_t " c-var " = " start-str)
                                      (ctx-str3 ctx c-var " < " end-str)
                                      (ctx-str ctx c-var "++"))
                                    ;; Transpile body
                                    (let ((count (list-items-count form))
                                          (mut i 2))
                                      (while (< i count)
                                        (match (list-item form i)
                                          ((some body-stmt)
                                            (match (transpile-stmt ctx body-stmt)
                                              ((ok _) (do))
                                              ((error _) (do))))
                                          ((none) (do)))
                                        (set! i (+ i 1))))
                                    (emit-block-end ctx)
                                    (ctx-pop-scope ctx)
                                    (ok "0"))))))))))))))))))

  (fn transpile-match ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a match expression on union type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (match expr ((variant binding) body) ...)
    (match (list-item form 1)
      ((none) (error (make-error "Match missing expression" 0 0)))
      ((some match-expr)
        (match (transpile-expr ctx match-expr)
          ((error e) (error e))
          ((ok expr-str)
            (do
              (emit-match-start ctx expr-str "tag")
              ;; Process cases
              (let ((count (list-items-count form))
                    (mut i 2))
                (while (< i count)
                  (match (list-item form i)
                    ((some case-form)
                      (match (list-item case-form 0)
                        ((some pattern)
                          (match (sexpr-get-head pattern)
                            ((some variant-expr)
                              (match (sexpr-get-symbol-name variant-expr)
                                ((some variant-name)
                                  (do
                                    (emit-match-case ctx (ctx-str4 ctx expr-str "_" variant-name "_TAG"))
                                    (ctx-push-scope ctx)
                                    (match (list-item case-form 1)
                                      ((some body)
                                        (match (transpile-stmt ctx body)
                                          ((ok result)
                                            (ctx-emit ctx (ctx-str3 ctx "__result = " result ";")))
                                          ((error _) (do))))
                                      ((none) (do)))
                                    (ctx-emit ctx "break;")
                                    (ctx-pop-scope ctx)
                                    (emit-block-end ctx)))
                                ((none) (do))))
                            ((none) (do))))
                        ((none) (do))))
                    ((none) (do)))
                  (set! i (+ i 1))))
              (emit-match-end ctx)
              (ok "__result")))))))

  (fn transpile-set ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a set! mutation")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (set! target value)
    (match (list-item form 1)
      ((none) (error (make-error "Set! missing target" 0 0)))
      ((some target-expr)
        (match (list-item form 2)
          ((none) (error (make-error "Set! missing value" 0 0)))
          ((some value-expr)
            (match (transpile-expr ctx target-expr)
              ((error e) (error e))
              ((ok target-str)
                (match (transpile-expr ctx value-expr)
                  ((error e) (error e))
                  ((ok value-str)
                    (do
                      (emit-assignment ctx target-str value-str)
                      (ok target-str)))))))))))

  (fn transpile-do ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile a do block (sequence)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (do stmt1 stmt2 ... stmtN)
    (let ((count (list-items-count form))
          (mut i 1)
          (mut last-result "0")
          (mut has-err false)
          (mut err-val TranspileError (TranspileError "" 0 0)))
      (while (and (< i count) (not has-err))
        (match (list-item form i)
          ((some stmt)
            (match (transpile-stmt ctx stmt)
              ((ok result)
                (set! last-result result))
              ((error e)
                (do
                  (set! has-err true)
                  (set! err-val e)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (if has-err
        (error err-val)
        (ok last-result))))

  ;; ============================================================
  ;; Expression Transpilation
  ;; ============================================================

  (fn transpile-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile an expression to C code string")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ;; Symbol - variable reference
      ((symbol sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some entry)
              (ok (. entry c-name)))
            ((none)
              ;; Could be a function or constant
              (ok (mangle-identifier ctx name))))))
      ;; Number literal
      ((number n)
        (ok (. n raw)))
      ;; String literal
      ((string s)
        (ok (ctx-str3 ctx "\"" (. s value) "\"")))
      ;; List - function call or special form
      ((list lst)
        (transpile-list-expr ctx expr))))

  (fn transpile-list-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a list expression (call, operator, special form)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (sexpr-get-head expr)
      ((none) (ok "0"))
      ((some head)
        (match (sexpr-get-symbol-name head)
          ((none)
            ;; Head is not a symbol - invalid
            (error (make-error "Invalid expression" 0 0)))
          ((some op-name)
            (cond
              ;; Quote (enum literal)
              ((string-eq op-name "quote")
                (transpile-quote ctx expr))
              ;; Binary operators
              ((string-eq op-name "+")
                (transpile-binary-op ctx "+" expr))
              ((string-eq op-name "-")
                (transpile-binary-op ctx "-" expr))
              ((string-eq op-name "*")
                (transpile-binary-op ctx "*" expr))
              ((string-eq op-name "/")
                (transpile-binary-op ctx "/" expr))
              ((string-eq op-name "%")
                (transpile-binary-op ctx "%" expr))
              ((string-eq op-name "<")
                (transpile-binary-op ctx "<" expr))
              ((string-eq op-name ">")
                (transpile-binary-op ctx ">" expr))
              ((string-eq op-name "<=")
                (transpile-binary-op ctx "<=" expr))
              ((string-eq op-name ">=")
                (transpile-binary-op ctx ">=" expr))
              ((string-eq op-name "==")
                (transpile-binary-op ctx "==" expr))
              ((string-eq op-name "!=")
                (transpile-binary-op ctx "!=" expr))
              ((string-eq op-name "and")
                (transpile-binary-op ctx "&&" expr))
              ((string-eq op-name "or")
                (transpile-binary-op ctx "||" expr))
              ;; Unary operators
              ((string-eq op-name "not")
                (match (list-item expr 1)
                  ((none) (error (make-error "Not missing operand" 0 0)))
                  ((some operand)
                    (match (transpile-expr ctx operand)
                      ((error e) (error e))
                      ((ok op-str)
                        (ok (emit-unary-op ctx "!" op-str)))))))
              ;; Field access
              ((string-eq op-name ".")
                (transpile-field-access ctx expr))
              ;; Cast
              ((string-eq op-name "cast")
                (transpile-cast ctx expr))
              ;; Deref
              ((string-eq op-name "deref")
                (transpile-deref ctx expr))
              ;; Addr
              ((string-eq op-name "addr")
                (transpile-addr ctx expr))
              ;; If expression (ternary)
              ((string-eq op-name "if")
                (transpile-if ctx expr))
              ;; Let expression
              ((string-eq op-name "let")
                (transpile-let ctx expr))
              ;; Print/println
              ((string-eq op-name "println")
                (transpile-println ctx expr true))
              ((string-eq op-name "print")
                (transpile-println ctx expr false))
              ;; Function call
              (else
                (transpile-call ctx expr))))))))

  (fn transpile-field-access ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile field access expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (. obj field)
    (match (list-item form 1)
      ((none) (error (make-error "Field access missing object" 0 0)))
      ((some obj-expr)
        (match (transpile-expr ctx obj-expr)
          ((error e) (error e))
          ((ok obj-str)
            (match (list-item form 2)
              ((none) (error (make-error "Field access missing field" 0 0)))
              ((some field-expr)
                (match (sexpr-get-symbol-name field-expr)
                  ((none) (error (make-error "Field must be a symbol" 0 0)))
                  ((some field-name)
                    ;; Determine if pointer access
                    (let ((is-ptr false))  ;; Would need type info
                      (ok (emit-field-access ctx obj-str (mangle-identifier ctx field-name) is-ptr))))))))))))

  (fn transpile-call ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile function call expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    (match (list-item form 0)
      ((none) (error (make-error "Call missing function" 0 0)))
      ((some fn-expr)
        (match (sexpr-get-symbol-name fn-expr)
          ((none) (error (make-error "Function must be a symbol" 0 0)))
          ((some fn-name)
            (let ((c-name (mangle-fn-name ctx fn-name))
                  (count (list-items-count form))
                  (mut args (list-new (. (deref ctx) arena) String))
                  (mut i 1)
                  (mut has-err false)
                  (mut err-val TranspileError (TranspileError "" 0 0)))
              ;; Transpile arguments
              (while (and (< i count) (not has-err))
                (match (list-item form i)
                  ((some arg-expr)
                    (match (transpile-expr ctx arg-expr)
                      ((ok arg-str)
                        (list-push args arg-str))
                      ((error e)
                        (do
                          (set! has-err true)
                          (set! err-val e)))))
                  ((none) (do)))
                (set! i (+ i 1)))
              (if has-err
                (error err-val)
                (ok (emit-call ctx c-name args)))))))))

  (fn transpile-println ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)) (newline Bool))
    (@intent "Transpile print/println expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    (match (list-item form 1)
      ((none) (error (make-error "print requires argument" 0 0)))
      ((some arg-expr)
        (match (transpile-expr ctx arg-expr)
          ((error e) (error e))
          ((ok arg-str)
            ;; For string literals, use printf with %s
            ;; The newline suffix depends on the newline parameter
            (if newline
              (ok (ctx-str3 ctx "printf(\"%s\\n\", " arg-str ")"))
              (ok (ctx-str3 ctx "printf(\"%s\", " arg-str ")"))))))))

  (fn transpile-binary-op ((ctx (Ptr TranspileContext)) (op String) (form (Ptr SExpr)))
    (@intent "Transpile binary operator expression")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    (match (list-item form 1)
      ((none) (error (make-error "Binary op missing left operand" 0 0)))
      ((some left-expr)
        (match (transpile-expr ctx left-expr)
          ((error e) (error e))
          ((ok left-str)
            (match (list-item form 2)
              ((none) (error (make-error "Binary op missing right operand" 0 0)))
              ((some right-expr)
                (match (transpile-expr ctx right-expr)
                  ((error e) (error e))
                  ((ok right-str)
                    (ok (emit-binary-op ctx left-str op right-str)))))))))))

  (fn transpile-cast ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile cast expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (cast Type expr)
    (match (list-item form 1)
      ((none) (error (make-error "Cast missing type" 0 0)))
      ((some type-expr)
        (match (sexpr-get-symbol-name type-expr)
          ((none) (error (make-error "Cast type must be symbol" 0 0)))
          ((some type-name)
            (match (list-item form 2)
              ((none) (error (make-error "Cast missing expression" 0 0)))
              ((some val-expr)
                (match (transpile-expr ctx val-expr)
                  ((error e) (error e))
                  ((ok val-str)
                    (let ((c-type (primitive-to-c type-name)))
                      (ok (emit-cast ctx c-type val-str))))))))))))

  (fn transpile-quote ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile quote expression (enum literal)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; 'symbol or (quote symbol)
    (match (list-item form 1)
      ((none) (error (make-error "Quote missing symbol" 0 0)))
      ((some sym-expr)
        (match (sexpr-get-symbol-name sym-expr)
          ((none) (error (make-error "Quote must contain symbol" 0 0)))
          ((some sym-name)
            (ok (mangle-identifier ctx sym-name)))))))

  (fn transpile-addr ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile addr (address-of) expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (addr expr)
    (match (list-item form 1)
      ((none) (error (make-error "Addr missing expression" 0 0)))
      ((some inner-expr)
        (match (transpile-expr ctx inner-expr)
          ((error e) (error e))
          ((ok inner-str)
            (ok (ctx-str ctx "&" inner-str)))))))

  (fn transpile-deref ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile deref expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (deref expr)
    (match (list-item form 1)
      ((none) (error (make-error "Deref missing expression" 0 0)))
      ((some inner-expr)
        (match (transpile-expr ctx inner-expr)
          ((error e) (error e))
          ((ok inner-str)
            (ok (ctx-str3 ctx "(*" inner-str ")")))))))

  (fn transpile-record-literal ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile record constructor expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (TypeName field1 field2 ...)
    (match (list-item form 0)
      ((none) (error (make-error "Record literal missing type" 0 0)))
      ((some type-expr)
        (match (sexpr-get-symbol-name type-expr)
          ((none) (error (make-error "Record type must be symbol" 0 0)))
          ((some type-name)
            (let ((c-name (qualified-type-name ctx type-name))
                  (count (list-items-count form))
                  (mut fields "")
                  (mut i 1)
                  (mut has-err false)
                  (mut err-val TranspileError (TranspileError "" 0 0)))
              (while (and (< i count) (not has-err))
                (match (list-item form i)
                  ((some field-expr)
                    (match (transpile-expr ctx field-expr)
                      ((ok field-str)
                        (do
                          (when (> i 1)
                            (set! fields (ctx-str ctx fields ", ")))
                          (set! fields (ctx-str ctx fields field-str))))
                      ((error e)
                        (do
                          (set! has-err true)
                          (set! err-val e)))))
                  ((none) (do)))
                (set! i (+ i 1)))
              (if has-err
                (error err-val)
                (ok (ctx-str5 ctx "(" c-name "){" fields "}")))))))))

  (fn transpile-union-new ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Transpile union-new constructor expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Result String TranspileError)))
    (@pre {ctx != nil})
    (@pre {form != nil})
    ;; (union-new Type variant payload)
    (match (list-item form 1)
      ((none) (error (make-error "Union-new missing type" 0 0)))
      ((some type-expr)
        (match (sexpr-get-symbol-name type-expr)
          ((none) (error (make-error "Union type must be symbol" 0 0)))
          ((some type-name)
            (let ((c-name (qualified-type-name ctx type-name)))
              (match (list-item form 2)
                ((none) (error (make-error "Union-new missing variant" 0 0)))
                ((some variant-expr)
                  (match (sexpr-get-symbol-name variant-expr)
                    ((none) (error (make-error "Variant must be symbol" 0 0)))
                    ((some variant-name)
                      (let ((tag-name (ctx-str4 ctx c-name "_" variant-name "_TAG")))
                        (match (list-item form 3)
                          ((none)
                            ;; No payload
                            (ok (ctx-str5 ctx "(" c-name "){.tag = " tag-name "}")))
                          ((some payload-expr)
                            (match (transpile-expr ctx payload-expr)
                              ((error e) (error e))
                              ((ok payload-str)
                                (let ((variant-c-name (mangle-identifier ctx variant-name)))
                                  (ok (ctx-str5 ctx "(" c-name "){.tag = " tag-name
                                       (ctx-str5 ctx ", .data." variant-c-name " = " payload-str "}")))))))))))))))))))
)
