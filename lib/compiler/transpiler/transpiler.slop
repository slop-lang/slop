;; ============================================================
;; SLOP Transpiler - Main Driver
;;
;; Orchestrates the multi-pass transpilation pipeline from
;; SLOP source to C code.
;; ============================================================

(module transpiler
  (export
    ;; Main entry points
    transpile transpile-ast
    ;; Error types
    TranspileError UnfilledHoleError
    ;; Result type
    TranspileResult)

  (import parser (parse find-holes SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col))
  (import context (TranspileContext context-new
                   ctx-add-include ctx-get-includes
                   ctx-set-module ctx-set-prefixing
                   ctx-register-type ctx-register-function))
  (import transpiler-types (CTypeInfo FuncEntry))
  (import emit (Emitter emitter-new emitter-output
                emit-line emit-blank emit-include emit-comment))
  (import defn (transpile-function transpile-type transpile-const
                register-ffi register-ffi-struct emit-forward-decl
                extract-return-type))
  (import generic (emit-generated-types))
  (import ctype (to-c-type))
  (import names (to-c-name to-qualified-name))
  (import strlib (string-eq string-concat))

  ;; ============================================================
  ;; Error Types
  ;; ============================================================

  (type TranspileError (record
    (message String)
    (line (Int 0 ..))
    (col (Int 0 ..))))

  (type UnfilledHoleError (record
    (count (Int 1 ..))
    (first-line (Int 0 ..))
    (first-col (Int 0 ..))))

  (type TranspileResult (Result String TranspileError))

  ;; ============================================================
  ;; Form Categories
  ;; ============================================================

  (type FormCategories (record
    (modules (List (Ptr SExpr)))
    (ffis (List (Ptr SExpr)))
    (ffi-structs (List (Ptr SExpr)))
    (constants (List (Ptr SExpr)))
    (types (List (Ptr SExpr)))
    (functions (List (Ptr SExpr)))))

  ;; ============================================================
  ;; Main Entry Point
  ;; ============================================================

  (fn transpile ((arena Arena) (source String))
    (@intent "Transpile SLOP source code to C code")
    (@spec ((Arena String) -> TranspileResult))
    (@alloc arena)
    ;; 1. Parse source to AST
    (match (parse arena source)
      ((error e)
        (error (TranspileError (. e message) (. e line) (. e col))))
      ((ok ast)
        ;; 2. Check for unfilled holes
        (let ((holes (collect-all-holes arena ast)))
          (if (> (list-len holes) 0)
            ;; Report first unfilled hole
            (hole (Result String TranspileError)
              "Get first hole from list, return error with its location"
              :complexity tier-1
              :context (holes)
              :required (sexpr-line sexpr-col))
            ;; 3. Transpile AST
            (transpile-ast arena ast))))))

  (fn transpile-ast ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Transpile parsed AST to C code")
    (@spec ((Arena (List (Ptr SExpr))) -> TranspileResult))
    (@alloc arena)
    (@pre (> (list-len ast) 0))
    (let ((ctx (context-new arena))
          (em (emitter-new arena)))

      ;; ========================================
      ;; Pass 0: Categorize forms
      ;; ========================================
      (let ((forms (categorize-forms arena ast)))

        ;; ========================================
        ;; Pass 1: Register FFI declarations
        ;; ========================================
        (for-each (ffi-form (. forms ffis))
          (register-ffi ctx ffi-form))
        (for-each (ffi-struct-form (. forms ffi-structs))
          (register-ffi-struct ctx ffi-struct-form))

        ;; ========================================
        ;; Pass 2: Emit header
        ;; ========================================
        (emit-comment em "Generated by SLOP transpiler")
        (emit-comment em "Do not edit - regenerate from .slop source")
        (emit-blank em)

        ;; FFI includes
        (for-each (header (ctx-get-includes ctx))
          (emit-include em header true))

        ;; Standard includes
        (emit-include em "stdint.h" true)
        (emit-include em "stdbool.h" true)
        (emit-include em "stddef.h" true)

        ;; Runtime include
        (emit-include em "slop_runtime.h" false)
        (emit-blank em)

        ;; ========================================
        ;; Pass 3: Emit constants
        ;; ========================================
        (when (> (list-len (. forms constants)) 0)
          (emit-comment em "Constants")
          (for-each (const-form (. forms constants))
            (transpile-const ctx em const-form))
          (emit-blank em))

        ;; ========================================
        ;; Pass 4: Pre-scan types for generic registration
        ;; ========================================
        (for-each (type-form (. forms types))
          (scan-type-for-generics ctx type-form))

        ;; ========================================
        ;; Pass 5: Pre-scan functions for return types
        ;; ========================================
        (for-each (fn-form (. forms functions))
          (scan-function-signature ctx fn-form))

        ;; ========================================
        ;; Pass 6: Emit generated types (Option, Result, List, Map)
        ;; ========================================
        (emit-generated-types ctx em)

        ;; ========================================
        ;; Pass 7: Emit type definitions
        ;; ========================================
        (when (> (list-len (. forms types)) 0)
          (emit-comment em "Type definitions")
          (for-each (type-form (. forms types))
            (transpile-type ctx em type-form))
          (emit-blank em))

        ;; ========================================
        ;; Pass 8: Emit forward declarations
        ;; ========================================
        (when (> (list-len (. forms functions)) 0)
          (emit-comment em "Forward declarations")
          (for-each (fn-form (. forms functions))
            (emit-forward-decl ctx em fn-form))
          (emit-blank em))

        ;; ========================================
        ;; Pass 9: Emit function implementations
        ;; ========================================
        (when (> (list-len (. forms functions)) 0)
          (emit-comment em "Function implementations")
          (for-each (fn-form (. forms functions))
            (transpile-function ctx em fn-form))))

      ;; Return generated C code
      (ok (emitter-output em))))

  ;; ============================================================
  ;; Form Categorization
  ;; ============================================================

  (fn categorize-forms ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Categorize AST forms by type for ordered processing")
    (@spec ((Arena (List (Ptr SExpr))) -> FormCategories))
    (@alloc arena)
    (@pure)
    (let ((modules (list-new arena (Ptr SExpr)))
          (ffis (list-new arena (Ptr SExpr)))
          (ffi-structs (list-new arena (Ptr SExpr)))
          (constants (list-new arena (Ptr SExpr)))
          (types (list-new arena (Ptr SExpr)))
          (functions (list-new arena (Ptr SExpr))))
      (for-each (form ast)
        (cond
          ((is-form form "module")
            (list-push modules form))
          ((is-form form "ffi")
            (list-push ffis form))
          ((is-form form "ffi-struct")
            (list-push ffi-structs form))
          ((is-form form "const")
            (list-push constants form))
          ((is-form form "type")
            (list-push types form))
          ((is-form form "fn")
            (list-push functions form))
          (else
            ;; Ignore other forms (imports handled at module level)
            (do))))
      (FormCategories modules ffis ffi-structs constants types functions)))

  ;; ============================================================
  ;; Hole Collection
  ;; ============================================================

  (fn collect-all-holes ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Collect all unfilled holes from entire AST")
    (@spec ((Arena (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (@alloc arena)
    (@pure)
    (let ((all-holes (list-new arena (Ptr SExpr))))
      (for-each (form ast)
        (let ((form-holes (find-holes arena form)))
          (for-each (h form-holes)
            (list-push all-holes h))))
      all-holes))

  ;; ============================================================
  ;; Type Scanning (for generic type registration)
  ;; ============================================================

  (fn scan-type-for-generics ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Scan type definition to register any generic types used")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= form nil))
    ;; This traverses the type expression looking for Option, Result,
    ;; List, Map types and registers them for later emission
    (hole Unit
      "Traverse type expression, call to-c-type to trigger registration"
      :complexity tier-2
      :context (ctx form)
      :required (to-c-type is-form)))

  ;; ============================================================
  ;; Function Signature Scanning
  ;; ============================================================

  (fn scan-function-signature ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Pre-scan function to register signature for call resolution")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= form nil))
    (hole Unit
      "Extract name, params, return type; register FuncEntry"
      :complexity tier-2
      :context (ctx form)
      :required (extract-return-type to-c-type to-qualified-name ctx-register-function)))

  ;; ============================================================
  ;; Module Handling
  ;; ============================================================

  (fn transpile-module ((ctx (Ptr TranspileContext)) (em (Ptr Emitter))
                        (form (Ptr SExpr)))
    (@intent "Transpile module definition")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (@pre (!= form nil))
    (@pre (is-form form "module"))
    ;; (module name (export ...) forms...)
    ;; Sets module context and enables prefixing
    (hole Unit
      "Set module name, enable prefixing, process module contents"
      :complexity tier-3
      :context (ctx em form)
      :required (ctx-set-module ctx-set-prefixing categorize-forms))))
