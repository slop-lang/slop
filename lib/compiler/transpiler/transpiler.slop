;; ============================================================
;; SLOP Transpiler - Split Mode Driver
;;
;; Transpiles SLOP modules to separate .h and .c files per module.
;; Output is JSON: {"mod": {"header": "...", "impl": "..."}, ...}
;; ============================================================

(module transpiler
  (export
    ;; Main entry point
    transpile-modules
    ;; Error types
    TranspileError
    ;; Result types
    TranspileResult ModuleOutput)

  (import parser (parse find-holes SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col))
  (import context (TranspileContext context-new
                   ctx-add-include ctx-get-includes ctx-clear-includes
                   ctx-set-module ctx-set-prefixing ctx-get-module
                   ctx-register-type ctx-register-function
                   ctx-register-import ctx-clear-import-map ctx-register-type-def
                   ctx-register-fn-module ctx-lookup-fn-module
                   ctx-lookup-type-module
                   ctx-set-type-env))
  (import names (make-type-c-name to-c-name))
  (import env (TypeEnv env-new))
  (import collect (collect-module))
  (import transpiler-types (CTypeInfo FuncEntry))
  (import emit (Emitter emitter-new emitter-output
                emit-line emit-blank emit-include emit-comment))
  (import defn (transpile-function transpile-type transpile-const
                register-ffi register-ffi-struct emit-forward-decl
                extract-return-type))
  (import generic (emit-generated-types emit-all-types-sorted))
  (import ctype (to-c-type))

  ;; ============================================================
  ;; Types
  ;; ============================================================

  (type TranspileError (record
    (message String)
    (line (Int 0 ..))
    (col (Int 0 ..))))

  (type ModuleOutput (record
    (name String)
    (header String)
    (impl String)))

  (type TranspileResult (Result (List ModuleOutput) TranspileError))

  ;; Per-module form categories
  (type ModuleForms (record
    (name String)
    (imports (List (Ptr SExpr)))
    (ffis (List (Ptr SExpr)))
    (ffi-structs (List (Ptr SExpr)))
    (constants (List (Ptr SExpr)))
    (types (List (Ptr SExpr)))
    (functions (List (Ptr SExpr)))))

  ;; ============================================================
  ;; Main Entry Point
  ;; ============================================================

  (fn transpile-modules ((arena Arena) (module-asts (List (List (Ptr SExpr)))))
    (@intent "Transpile multiple modules to separate header/impl pairs")
    (@spec ((Arena (List (List (Ptr SExpr)))) -> TranspileResult))
    (@alloc arena)
    ;; module-asts is a list of ASTs, one per module file, in dependency order
    (let ((ctx (context-new arena))
          (results (list-new arena ModuleOutput))
          (type-env (env-new arena))
          (mut had-error false)
          (mut error-result (TranspileError "" 0 0)))

      ;; First pass: collect all types/functions into type environment
      (for-each (ast module-asts)
        (collect-module type-env ast))
      (ctx-set-type-env ctx type-env)

      ;; Second pass: extract per-module forms
      (let ((all-modules (list-new arena ModuleForms)))
        (for-each (ast module-asts)
          (let ((mod-forms (extract-module-forms arena ast)))
            (when (> (string-len (. mod-forms name)) 0)
              (list-push all-modules mod-forms))))

        ;; Third pass: process each module in order
        (for-each (mod-forms all-modules)
          (when (not had-error)
            ;; Set up module context
            (ctx-set-module ctx (some (. mod-forms name)))
            (ctx-set-prefixing ctx true)
            (ctx-clear-includes ctx)

            ;; Register imports for this module
            (for-each (import-form (. mod-forms imports))
              (process-import ctx arena import-form))

            ;; Register FFI
            (for-each (ffi-form (. mod-forms ffis))
              (register-ffi ctx ffi-form))
            (for-each (ffi-struct-form (. mod-forms ffi-structs))
              (register-ffi-struct ctx ffi-struct-form))

            ;; Register type and function module mappings
            (for-each (type-form (. mod-forms types))
              (register-type-module ctx arena type-form (. mod-forms name)))
            (for-each (fn-form (. mod-forms functions))
              (ctx-register-fn-module ctx arena (cast Int fn-form) (. mod-forms name)))

            ;; Pre-scan types for generic registration
            (for-each (type-form (. mod-forms types))
              (scan-type-for-generics ctx type-form))

            ;; Pre-scan functions for return types
            (for-each (fn-form (. mod-forms functions))
              (scan-function-signature ctx fn-form))

            ;; Generate header
            (let ((header (generate-header arena ctx mod-forms all-modules)))
              ;; Generate implementation
              (let ((impl (generate-impl arena ctx mod-forms)))
                ;; Add to results
                (list-push results (ModuleOutput (. mod-forms name) header impl)))))))

      (if had-error
        (error error-result)
        (ok results))))

  ;; ============================================================
  ;; Module Form Extraction
  ;; ============================================================

  (fn extract-module-forms ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Extract forms from a module AST")
    (@spec ((Arena (List (Ptr SExpr))) -> ModuleForms))
    (@alloc arena)
    (let ((name "")
          (imports (list-new arena (Ptr SExpr)))
          (ffis (list-new arena (Ptr SExpr)))
          (ffi-structs (list-new arena (Ptr SExpr)))
          (constants (list-new arena (Ptr SExpr)))
          (types (list-new arena (Ptr SExpr)))
          (functions (list-new arena (Ptr SExpr))))
      ;; Find the module form
      (for-each (form ast)
        (when (is-form form "module")
          (match (deref form)
            ((list mod-lst)
              ;; Extract module name
              (match (list-get (. mod-lst items) 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol sym) (set! name (. sym name)))
                    (_ (do))))
                ((none) (do)))
              ;; Extract body forms
              (let ((items (. mod-lst items))
                    (len (list-len items)))
                (for (i 2 len)
                  (match (list-get items i)
                    ((some f)
                      (cond
                        ((is-form f "import") (list-push imports f))
                        ((is-form f "export") (do))  ;; Skip exports
                        ((is-form f "ffi") (list-push ffis f))
                        ((is-form f "ffi-struct") (list-push ffi-structs f))
                        ((is-form f "const") (list-push constants f))
                        ((is-form f "type") (list-push types f))
                        ((is-form f "fn") (list-push functions f))
                        (else (do))))
                    ((none) (do))))))
            (_ (do)))))
      (ModuleForms name imports ffis ffi-structs constants types functions)))

  ;; ============================================================
  ;; Import Processing
  ;; ============================================================

  (fn process-import ((ctx (Ptr TranspileContext)) (arena Arena) (import-form (Ptr SExpr)))
    (@intent "Process import statement and register imported names")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr)) -> Unit))
    (match (deref import-form)
      ((list import-lst)
        (let ((items (. import-lst items)))
          ;; Get module name from index 1
          (match (list-get items 1)
            ((some mod-name-expr)
              (match (deref mod-name-expr)
                ((symbol mod-sym)
                  (let ((mod-name (. mod-sym name))
                        (mod-c-name (to-c-name arena mod-name)))
                    ;; Get symbols list from index 2
                    (match (list-get items 2)
                      ((some syms-expr)
                        (match (deref syms-expr)
                          ((list syms-lst)
                            (let ((syms-items (. syms-lst items))
                                  (syms-len (list-len syms-items)))
                              (for (si 0 syms-len)
                                (match (list-get syms-items si)
                                  ((some sym-ptr)
                                    (match (deref sym-ptr)
                                      ((symbol s)
                                        (let ((local-name (. s name))
                                              (qualified (string-concat arena
                                                           (string-concat arena mod-c-name "_")
                                                           (to-c-name arena local-name))))
                                          (ctx-register-import ctx local-name qualified)))
                                      (_ (do))))
                                  ((none) (do))))))
                          (_ (do))))
                      ((none) (do)))))
                (_ (do))))
            ((none) (do)))))
      (_ (do))))

  ;; ============================================================
  ;; Header Generation
  ;; ============================================================

  (fn generate-header ((arena Arena) (ctx (Ptr TranspileContext))
                       (mod ModuleForms) (all-modules (List ModuleForms)))
    (@intent "Generate header file for a module")
    (@spec ((Arena (Ptr TranspileContext) ModuleForms (List ModuleForms)) -> String))
    (@alloc arena)
    (let ((em (emitter-new arena))
          (c-mod-name (to-c-name arena (. mod name)))
          (guard-name (string-concat arena "SLOP_"
                        (string-concat arena (string-to-upper arena c-mod-name) "_H"))))
      ;; Include guard
      (emit-line em (string-concat arena "#ifndef " guard-name))
      (emit-line em (string-concat arena "#define " guard-name))
      (emit-blank em)

      ;; Standard includes
      (emit-include em "slop_runtime.h" false)
      (emit-include em "stdint.h" true)
      (emit-include em "stdbool.h" true)

      ;; FFI includes
      (for-each (header (ctx-get-includes ctx))
        (emit-include em header true))

      ;; Dependency headers
      (for-each (import-form (. mod imports))
        (match (deref import-form)
          ((list import-lst)
            (match (list-get (. import-lst items) 1)
              ((some mod-name-expr)
                (match (deref mod-name-expr)
                  ((symbol mod-sym)
                    (let ((dep-c-name (to-c-name arena (. mod-sym name))))
                      (emit-line em (string-concat arena "#include \"slop_"
                                      (string-concat arena dep-c-name ".h\"")))))
                  (_ (do))))
              ((none) (do))))
          (_ (do))))

      (emit-blank em)

      ;; Type definitions (forward decls, enums, records, unions)
      (when (> (list-len (. mod types)) 0)
        (emit-all-types-sorted ctx em (. mod types))
        (emit-blank em))

      ;; Generated generic types (Option, Result, List, Map used in signatures)
      (emit-generated-types ctx em)

      ;; Constants
      (when (> (list-len (. mod constants)) 0)
        (for-each (const-form (. mod constants))
          (transpile-const ctx em const-form))
        (emit-blank em))

      ;; Function declarations
      (when (> (list-len (. mod functions)) 0)
        (for-each (fn-form (. mod functions))
          (emit-forward-decl ctx em fn-form))
        (emit-blank em))

      ;; End include guard
      (emit-line em (string-concat arena "#endif // " guard-name))

      (emitter-output em)))

  ;; ============================================================
  ;; Implementation Generation
  ;; ============================================================

  (fn generate-impl ((arena Arena) (ctx (Ptr TranspileContext)) (mod ModuleForms))
    (@intent "Generate implementation file for a module")
    (@spec ((Arena (Ptr TranspileContext) ModuleForms) -> String))
    (@alloc arena)
    (let ((em (emitter-new arena))
          (c-mod-name (to-c-name arena (. mod name))))
      ;; Include own header
      (emit-line em (string-concat arena "#include \"slop_"
                      (string-concat arena c-mod-name ".h\"")))
      (emit-blank em)

      ;; Function implementations
      (when (> (list-len (. mod functions)) 0)
        (for-each (fn-form (. mod functions))
          (transpile-function ctx em fn-form)))

      (emitter-output em)))

  ;; ============================================================
  ;; Type Registration
  ;; ============================================================

  (fn register-type-module ((ctx (Ptr TranspileContext)) (arena Arena)
                            (type-form (Ptr SExpr)) (mod-name String))
    (@intent "Register a type with its module")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr) String) -> Unit))
    (match (deref type-form)
      ((list lst)
        (match (list-get (. lst items) 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (let ((type-name (. sym name))
                      (c-name (make-type-c-name arena type-name mod-name)))
                  (ctx-register-type-def ctx arena (cast Int type-form) c-name mod-name)))
              (_ (do))))
          ((none) (do))))
      (_ (do))))

  ;; ============================================================
  ;; Type Scanning for Generics
  ;; ============================================================

  (fn scan-type-for-generics ((ctx (Ptr TranspileContext)) (type-form (Ptr SExpr)))
    (@intent "Pre-scan type to register any generic types it uses")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    ;; Extract type expression from (type Name TypeExpr)
    (match (deref type-form)
      ((list lst)
        (match (list-get (. lst items) 2)
          ((some type-expr)
            ;; Call to-c-type to trigger generic registration
            (to-c-type ctx type-expr)
            (do))
          ((none) (do))))
      (_ (do))))

  ;; ============================================================
  ;; Function Signature Scanning
  ;; ============================================================

  (fn scan-function-signature ((ctx (Ptr TranspileContext)) (fn-form (Ptr SExpr)))
    (@intent "Pre-scan function to register return type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (match (extract-return-type fn-form)
      ((some ret-type)
        ;; Call to-c-type to trigger generic registration
        (to-c-type ctx ret-type)
        (do))
      ((none) (do))))

  ;; ============================================================
  ;; String Utilities
  ;; ============================================================

  (fn string-to-upper ((arena Arena) (s String))
    (@intent "Convert string to uppercase")
    (@spec ((Arena String) -> String))
    (@alloc arena)
    (let ((len (string-len s))
          (buf (arena-alloc arena (+ len 1))))
      (for (i 0 (cast Int len))
        (let ((c (cast Int (@ (. s data) i))))
          (if (and (>= c 97) (<= c 122))
            (set! (@ buf i) (cast U8 (- c 32)))
            (set! (@ buf i) (cast U8 c)))))
      (set! (@ buf (cast Int len)) (cast U8 0))
      (String (cast (Ptr U8) buf) (cast U64 len))))

)
