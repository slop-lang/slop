;; ============================================================
;; SLOP Transpiler - Main Driver
;;
;; Orchestrates the multi-pass transpilation pipeline from
;; SLOP source to C code.
;; ============================================================

(module transpiler
  (export
    ;; Main entry points
    transpile transpile-ast
    ;; Error types
    TranspileError UnfilledHoleError
    ;; Result type
    TranspileResult)

  (import parser (parse find-holes SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col))
  (import context (TranspileContext context-new
                   ctx-add-include ctx-get-includes
                   ctx-set-module ctx-set-prefixing ctx-get-module
                   ctx-register-type ctx-register-function
                   ctx-register-import ctx-clear-import-map ctx-register-type-def
                   ctx-register-fn-module ctx-lookup-fn-module
                   ctx-lookup-type-module
                   ctx-set-type-env))
  (import names (make-type-c-name))
  ;; Import type checker for type inference
  (import env (TypeEnv env-new))
  (import collect (collect-module))
  (import transpiler-types (CTypeInfo FuncEntry))
  (import emit (Emitter emitter-new emitter-output emitter-line-count
                emit-line emit-blank emit-include emit-comment))
  (import defn (transpile-function transpile-type transpile-const
                register-ffi register-ffi-struct emit-forward-decl
                extract-return-type))
  (import generic (emit-generated-types emit-all-types-sorted))
  (import ctype (to-c-type))
  (import names (to-c-name to-qualified-name))

  ;; ============================================================
  ;; Error Types
  ;; ============================================================

  (type TranspileError (record
    (message String)
    (line (Int 0 ..))
    (col (Int 0 ..))))

  (type UnfilledHoleError (record
    (count (Int 1 ..))
    (first-line (Int 0 ..))
    (first-col (Int 0 ..))))

  (type TranspileResult (Result String TranspileError))

  ;; ============================================================
  ;; Form Categories
  ;; ============================================================

  (type FormCategories (record
    (modules (List (Ptr SExpr)))
    (ffis (List (Ptr SExpr)))
    (ffi-structs (List (Ptr SExpr)))
    (constants (List (Ptr SExpr)))
    (types (List (Ptr SExpr)))
    (functions (List (Ptr SExpr)))))

  ;; ============================================================
  ;; Main Entry Point
  ;; ============================================================

  (fn transpile ((arena Arena) (source String))
    (@intent "Transpile SLOP source code to C code")
    (@spec ((Arena String) -> TranspileResult))
    (@alloc arena)
    ;; 1. Parse source to AST
    (match (parse arena source)
      ((error e)
        (error (TranspileError (. e message) (. e line) (. e col))))
      ((ok ast)
        ;; 2. Check for unfilled holes
        (let ((holes (collect-all-holes arena ast)))
          (if (> (list-len holes) 0)
            ;; Report first unfilled hole
            (match (list-get holes 0)
              ((some first-hole)
                (error (TranspileError "Unfilled hole" (sexpr-line first-hole) (sexpr-col first-hole))))
              ((none)
                (error (TranspileError "No holes found" 0 0))))
            ;; 3. Transpile AST
            (transpile-ast arena ast))))))

  (fn transpile-ast ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Transpile parsed AST to C code")
    (@spec ((Arena (List (Ptr SExpr))) -> TranspileResult))
    (@alloc arena)
    (@pre (> (list-len ast) 0))
    (let ((ctx (context-new arena))
          (em (emitter-new arena))
          ;; Create type environment and run type checker
          (type-env (env-new arena)))
      ;; Collect types and functions into type environment
      (collect-module type-env ast)
      ;; Make type environment available to transpiler
      (ctx-set-type-env ctx type-env)

      ;; ========================================
      ;; Pass 0: Categorize forms (with module expansion)
      ;; ========================================
      (let ((forms (categorize-forms-with-modules arena ctx ast)))

        ;; ========================================
        ;; Pass 1: Register FFI declarations
        ;; ========================================
        (for-each (ffi-form (. forms ffis))
          (register-ffi ctx ffi-form))
        (for-each (ffi-struct-form (. forms ffi-structs))
          (register-ffi-struct ctx ffi-struct-form))

        ;; ========================================
        ;; Pass 2: Emit header
        ;; ========================================
        (emit-comment em "Generated by SLOP transpiler")
        (emit-comment em "Do not edit - regenerate from .slop source")
        (emit-blank em)

        ;; FFI includes
        (for-each (header (ctx-get-includes ctx))
          (emit-include em header true))

        ;; Standard includes
        (emit-include em "stdint.h" true)
        (emit-include em "stdbool.h" true)
        (emit-include em "stddef.h" true)

        ;; Runtime include
        (emit-include em "slop_runtime.h" false)
        (emit-blank em)

        ;; ========================================
        ;; Pass 3: Emit constants
        ;; ========================================
        (when (> (list-len (. forms constants)) 0)
          (emit-comment em "Constants")
          (for-each (const-form (. forms constants))
            (transpile-const ctx em const-form))
          (emit-blank em))

        ;; ========================================
        ;; Pass 4: Pre-scan types for generic registration
        ;; Set module context before scanning each type
        ;; ========================================
        (for-each (type-form (. forms types))
          (do
            (match (ctx-lookup-type-module ctx arena (cast Int type-form))
              ((some mod-name)
                (ctx-set-module ctx (some mod-name))
                (ctx-set-prefixing ctx true))
              ((none) ()))
            (scan-type-for-generics ctx type-form)))

        ;; ========================================
        ;; Pass 5: Pre-scan functions for return types
        ;; Set module context before scanning each function
        ;; ========================================
        (for-each (fn-form (. forms functions))
          (do
            (match (ctx-lookup-fn-module ctx arena (cast Int fn-form))
              ((some mod-name)
                (ctx-set-module ctx (some mod-name))
                (ctx-set-prefixing ctx true))
              ((none) ()))
            (scan-function-signature ctx fn-form)))

        ;; ========================================
        ;; Pass 6: Emit ALL types in topologically sorted order
        ;; This handles mutual dependencies between records and generated types
        ;; ========================================
        (emit-all-types-sorted ctx em (. forms types))

        ;; ========================================
        ;; Pass 7: Emit forward declarations
        ;; ========================================
        (when (> (list-len (. forms functions)) 0)
          (emit-comment em "Forward declarations")
          (for-each (fn-form (. forms functions))
            (do
              (match (ctx-lookup-fn-module ctx arena (cast Int fn-form))
                ((some mod-name)
                  (ctx-set-module ctx (some mod-name))
                  (ctx-set-prefixing ctx true))
                ((none) ()))
              (emit-forward-decl ctx em fn-form)))
          (emit-blank em))

        ;; ========================================
        ;; Pass 8: Emit function implementations
        ;; ========================================
        (when (> (list-len (. forms functions)) 0)
          (emit-comment em "Function implementations")
          (for-each (fn-form (. forms functions))
            (do
              (match (ctx-lookup-fn-module ctx arena (cast Int fn-form))
                ((some mod-name)
                  (ctx-set-module ctx (some mod-name))
                  (ctx-set-prefixing ctx true))
                ((none) ()))
              (transpile-function ctx em fn-form)))))

      ;; Return generated C code
      (ok (emitter-output em))))

  ;; ============================================================
  ;; Form Categorization
  ;; ============================================================

  (fn categorize-forms ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Categorize AST forms by type for ordered processing")
    (@spec ((Arena (List (Ptr SExpr))) -> FormCategories))
    (@alloc arena)
    (@pure)
    (let ((modules (list-new arena (Ptr SExpr)))
          (ffis (list-new arena (Ptr SExpr)))
          (ffi-structs (list-new arena (Ptr SExpr)))
          (constants (list-new arena (Ptr SExpr)))
          (types (list-new arena (Ptr SExpr)))
          (functions (list-new arena (Ptr SExpr))))
      (for-each (form ast)
        (cond
          ((is-form form "module")
            (list-push modules form))
          ((is-form form "ffi")
            (list-push ffis form))
          ((is-form form "ffi-struct")
            (list-push ffi-structs form))
          ((is-form form "const")
            (list-push constants form))
          ((is-form form "type")
            (list-push types form))
          ((is-form form "fn")
            (list-push functions form))
          (else
            ;; Ignore other forms (imports handled at module level)
            (do))))
      (FormCategories modules ffis ffi-structs constants types functions)))

  ;; ============================================================
  ;; Form Categorization with Module Expansion
  ;; ============================================================

  (fn categorize-forms-with-modules ((arena Arena) (ctx (Ptr TranspileContext))
                                     (ast (List (Ptr SExpr))))
    (@intent "Categorize forms, expanding module bodies into the main categories")
    (@spec ((Arena (Ptr TranspileContext) (List (Ptr SExpr))) -> FormCategories))
    (@alloc arena)
    ;; First do basic categorization
    (let ((initial (categorize-forms arena ast)))
      ;; If there are modules, expand their contents
      (if (> (list-len (. initial modules)) 0)
        ;; Process each module and merge its forms
        (let ((ffis (list-new arena (Ptr SExpr)))
              (ffi-structs (list-new arena (Ptr SExpr)))
              (constants (list-new arena (Ptr SExpr)))
              (types (list-new arena (Ptr SExpr)))
              (functions (list-new arena (Ptr SExpr))))
          (do
            ;; Copy any top-level forms (outside modules)
            (for-each (f (. initial ffis)) (list-push ffis f))
            (for-each (f (. initial ffi-structs)) (list-push ffi-structs f))
            (for-each (f (. initial constants)) (list-push constants f))
            (for-each (f (. initial types)) (list-push types f))
            (for-each (f (. initial functions)) (list-push functions f))
            ;; Process each module
            (for-each (mod-form (. initial modules))
              (match (deref mod-form)
                ((list mod-lst)
                  ;; Extract module name and set context
                  (match (list-get (. mod-lst items) 1)
                    ((some name-expr)
                      (match (deref name-expr)
                        ((symbol sym)
                          (do
                            (ctx-set-module ctx (some (. sym name)))
                            (ctx-set-prefixing ctx true)
                            ;; NOTE: We do NOT clear import-map here. Imports accumulate across modules.
                            ;; This is safe because:
                            ;; 1. Each module registers its own imports with qualified names
                            ;; 2. In collect-all-types (Pass 6), we set current_module per type
                            ;; 3. If a type is imported, import_map has the correct qualified name
                            ;; 4. If a type is local, current_module provides the correct prefix
                            ;; Process imports to register qualified names
                            (process-module-imports arena ctx mod-form)))
                        (_ (do))))
                    ((none) (do)))
                  ;; Extract body forms (skip: module, name, export)
                  (let ((body (extract-module-body arena mod-form)))
                    ;; Categorize module body and merge
                    (let ((mod-forms (categorize-forms arena body))
                          (mod-name (match (ctx-get-module ctx)
                                      ((some n) n)
                                      ((none) ""))))
                      (do
                        (for-each (f (. mod-forms ffis)) (list-push ffis f))
                        (for-each (f (. mod-forms ffi-structs)) (list-push ffi-structs f))
                        (for-each (f (. mod-forms constants)) (list-push constants f))
                        (for-each (f (. mod-forms types))
                          (do
                            ;; Register type definition with its C name
                            (register-type-module ctx arena f mod-name)
                            (list-push types f)))
                        (for-each (f (. mod-forms functions))
                          (do
                            ;; Register function's module
                            (ctx-register-fn-module ctx arena (cast Int f) mod-name)
                            (list-push functions f)))))))
                (_ (do))))
            ;; Return merged categories (modules list left empty since processed)
            (FormCategories (list-new arena (Ptr SExpr)) ffis ffi-structs
                           constants types functions)))
        ;; No modules, return as-is
        initial)))

  (fn extract-module-body ((arena Arena) (mod-form (Ptr SExpr)))
    (@intent "Extract body forms from a module, skipping name, export, and import")
    (@spec ((Arena (Ptr SExpr)) -> (List (Ptr SExpr))))
    (@alloc arena)
    (@pre (!= mod-form nil))
    (let ((body (list-new arena (Ptr SExpr))))
      (match (deref mod-form)
        ((list mod-lst)
          (let ((items (. mod-lst items))
                (len (list-len items)))
            ;; Iterate from index 2 onwards (skip 'module' and name)
            ;; Collect all forms except export and import
            (for (i 2 len)
              (match (list-get items i)
                ((some form)
                  (when (not (or (is-form form "export") (is-form form "import")))
                    (list-push body form)))
                ((none) (do))))))
        (_ (do)))
      body))

  (fn register-type-module ((ctx (Ptr TranspileContext)) (arena Arena)
                            (type-form (Ptr SExpr)) (mod-name String))
    (@intent "Register a type name with its module-qualified C name")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr) String) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= type-form nil))
    ;; Extract type name from (type Name ...) form
    (match (deref type-form)
      ((list lst)
        (match (list-get (. lst items) 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (let ((type-name (. sym name))
                      (c-name (make-type-c-name arena type-name mod-name)))
                  ;; Register type definition keyed by form pointer
                  (ctx-register-type-def ctx arena (cast Int type-form) c-name mod-name)))
              (_ (do))))
          ((none) (do))))
      (_ (do))))

  (fn process-module-imports ((arena Arena) (ctx (Ptr TranspileContext))
                              (mod-form (Ptr SExpr)))
    (@intent "Process import statements in a module and register imported names")
    (@spec ((Arena (Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= mod-form nil))
    ;; Find and process all (import module-name (sym1 sym2 ...)) forms
    (match (deref mod-form)
      ((list mod-lst)
        (let ((items (. mod-lst items))
              (len (list-len items)))
          ;; Iterate through module body looking for import forms
          (for (i 2 len)
            (match (list-get items i)
              ((some form)
                (when (is-form form "import")
                  ;; (import module-name (sym1 sym2 ...))
                  (match (deref form)
                    ((list import-lst)
                      (let ((import-items (. import-lst items)))
                        ;; Get module name from index 1
                        (match (list-get import-items 1)
                          ((some mod-name-expr)
                            (match (deref mod-name-expr)
                              ((symbol mod-sym)
                                (let ((mod-name (. mod-sym name))
                                      (mod-c-name (to-c-name arena mod-name)))
                                  ;; Get symbols list from index 2
                                  (match (list-get import-items 2)
                                    ((some syms-expr)
                                      (match (deref syms-expr)
                                        ((list syms-lst)
                                          ;; Register each imported symbol
                                          (let ((sym-items (. syms-lst items))
                                                (sym-len (list-len sym-items)))
                                            (for (j 0 sym-len)
                                              (match (list-get sym-items j)
                                                ((some sym-expr)
                                                  (match (deref sym-expr)
                                                    ((symbol s)
                                                      (let ((local-name (. s name))
                                                            (local-c-name (to-c-name arena local-name))
                                                            (qualified (string-concat arena mod-c-name
                                                                        (string-concat arena "_" local-c-name))))
                                                        (ctx-register-import ctx local-name qualified)))
                                                    (_ (do))))
                                                ((none) (do))))))
                                        (_ (do))))
                                    ((none) (do)))))
                              (_ (do))))
                          ((none) (do)))))
                    (_ (do)))))
              ((none) (do))))))
      (_ (do))))

  ;; ============================================================
  ;; Hole Collection
  ;; ============================================================

  (fn collect-all-holes ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Collect all unfilled holes from entire AST")
    (@spec ((Arena (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (@alloc arena)
    (@pure)
    (let ((all-holes (list-new arena (Ptr SExpr))))
      (for-each (form ast)
        (let ((form-holes (find-holes arena form)))
          (for-each (h form-holes)
            (list-push all-holes h))))
      all-holes))

  ;; ============================================================
  ;; Type Scanning (for generic type registration)
  ;; ============================================================

  (fn scan-type-for-generics ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Scan type definition to register any generic types used")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= form nil))
    ;; This traverses the type expression looking for Option, Result,
    ;; List, Map types and registers them for later emission
    (when (is-form form "type")
      (match (deref form)
        ((list lst)
          (match (list-get (. lst items) 2)
            ((some type-expr)
              (do
                (to-c-type ctx type-expr)
                (do)))
            ((none) (do))))
        (_ (do)))))

  ;; ============================================================
  ;; Function Signature Scanning
  ;; ============================================================

  (fn scan-function-signature ((ctx (Ptr TranspileContext)) (form (Ptr SExpr)))
    (@intent "Pre-scan function to register signature for call resolution")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= form nil))
    (match (deref form)
      ((list lst)
        (match (list-get (. lst items) 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (let ((fn-name (. sym name))
                      (return-type-opt (extract-return-type form))
                      (arena (. (deref ctx) arena)))
                  (match return-type-opt
                    ((some return-type-expr)
                      (let ((c-return-type (to-c-type ctx return-type-expr))
                            (c-name (to-qualified-name arena ctx fn-name)))
                        (ctx-register-function ctx
                          (FuncEntry fn-name c-name c-return-type false false false))))
                    ((none) (do)))))
              (_ (do))))
          ((none) (do))))
      (_ (do))))

  ;; ============================================================
  ;; Module Handling
  ;; ============================================================

  (fn transpile-module ((ctx (Ptr TranspileContext)) (em (Ptr Emitter))
                        (form (Ptr SExpr)))
    (@intent "Transpile module definition")
    (@spec (((Ptr TranspileContext) (Ptr Emitter) (Ptr SExpr)) -> Unit))
    (@pre (!= ctx nil))
    (@pre (!= em nil))
    (@pre (!= form nil))
    (@pre (is-form form "module"))
    ;; (module name (export ...) forms...)
    ;; Sets module context and enables prefixing
    (match (deref form)
      ((list lst)
        (match (list-get (. lst items) 1)
          ((some name-expr)
            (match (deref name-expr)
              ((symbol sym)
                (do
                  (ctx-set-module ctx (some (. sym name)))
                  (ctx-set-prefixing ctx true)
                  (let ((arena (. (deref ctx) arena))
                        (items (. lst items))
                        (body (list-new arena (Ptr SExpr))))
                    (for (i 3 (list-len items))
                      (match (list-get items i)
                        ((some form-item) (list-push body form-item))
                        ((none) (do))))
                    (let ((_ (categorize-forms arena body)))
                      (do)))))
              (_ (do))))
          ((none) (do))))
      (_ (do)))))
