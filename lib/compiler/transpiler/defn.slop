;; ============================================================
;; SLOP Native Transpiler - Definition Module
;;
;; Handles type definitions (record, enum, union) and
;; function definitions.
;; ============================================================

(module defn
  (export
    ;; Type definitions
    transpile-type transpile-record transpile-enum transpile-union
    ;; Constant definitions
    transpile-const is-const-form
    ;; Function definitions
    transpile-function emit-forward-declaration
    ;; FFI definitions
    transpile-ffi transpile-ffi-struct is-ffi-form is-ffi-struct-form
    ;; Helpers
    is-type-form is-function-form get-return-type get-result-type-name build-param-str)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber RangeBounds))
  (import context (TranspileContext ctx-emit ctx-emit ctx-indent ctx-dedent
                   ctx-register-type ctx-register-func ctx-register-field-type
                   ctx-str ctx-str3 ctx-str4 ctx-str5
                   ctx-set-current-result-type ctx-clear-current-result-type
                   ctx-set-current-return-type ctx-get-current-return-type ctx-clear-current-return-type
                   ctx-set-capture-retval ctx-is-capture-retval
                   ctx-lookup-result-type-alias ctx-lookup-type
                   ctx-push-scope ctx-pop-scope ctx-bind-var
                   ctx-prefixing-enabled ctx-get-module ctx-prefix-type
                   TypeEntry FuncEntry FuncParamType VarEntry
                   to-c-type-prefixed))
  (import ctype (to-c-type to-c-name type-to-identifier is-builtin-c-type))
  (import stmt (transpile-stmt))
  (import expr (transpile-expr))
  (import strlib (starts-with ends-with substring replace))
  (import parser (pretty-print))

  ;; ============================================================
  ;; Form Detection
  ;; ============================================================

  (fn is-type-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a type definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "type"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-function-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a function definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-const-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a constant definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "const"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-ffi-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is an FFI declaration")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "ffi"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-ffi-struct-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is an FFI struct declaration")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "ffi-struct"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Type Expression Helpers
  ;; ============================================================

  (fn is-pointer-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if a type expression represents a pointer type (Ptr T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Constant Definition
  ;; ============================================================

  (fn transpile-const ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile constant definition: (const NAME Type value)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; (const NAME Type value)
    ;; Integers emit as #define, others as static const
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 4)
              (ctx-emit ctx "/* invalid const: need name, type, value */")
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (c-name (to-c-name arena raw-name)))
                        (match (list-get items 2)
                          ((some type-expr)
                            (match (list-get items 3)
                              ((some value-expr)
                                (emit-const-def ctx c-name type-expr value-expr))
                              ((none) (ctx-emit ctx "/* missing const value */"))))
                          ((none) (ctx-emit ctx "/* missing const type */")))))
                    (else (ctx-emit ctx "/* const name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing const name */"))))))
        (else (ctx-emit ctx "/* invalid const form */")))))

  (fn emit-const-def ((ctx (Ptr TranspileContext)) (c-name String) (type-expr (Ptr SExpr)) (value-expr (Ptr SExpr)))
    (@intent "Emit constant definition based on type")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (@pre {value-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (c-type (to-c-type-prefixed ctx type-expr))
          (type-name (get-type-name-str type-expr)))
      ;; Check if it's an integer type
      (if (is-int-type type-name)
        ;; Integer type -> #define
        (let ((value-c (eval-const-value ctx value-expr)))
          (ctx-emit ctx (ctx-str4 ctx "#define " c-name " (" (ctx-str ctx value-c ")"))))
        ;; String or other type -> static const
        (if (string-eq type-name "String")
          (match (deref value-expr)
            ((string str)
              (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                              (ctx-str3 ctx " = SLOP_STR(\"" (. str value) "\");"))))
            (else
              (let ((value-c (eval-const-value ctx value-expr)))
                (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                                (ctx-str3 ctx " = " value-c ";"))))))
          (let ((value-c (eval-const-value ctx value-expr)))
            (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                            (ctx-str3 ctx " = " value-c ";"))))))))

  (fn get-type-name-str ((type-expr (Ptr SExpr)))
    (@intent "Get simple type name as string")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((symbol sym) (. sym name))
      (else "")))

  (fn is-int-type ((type-name String))
    (@intent "Check if type name is an integer type")
    (@spec ((String) -> Bool))
    (or (string-eq type-name "Int")
        (string-eq type-name "I8")
        (string-eq type-name "I16")
        (string-eq type-name "I32")
        (string-eq type-name "I64")
        (string-eq type-name "U8")
        (string-eq type-name "U16")
        (string-eq type-name "U32")
        (string-eq type-name "U64")))

  (fn eval-const-value ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Evaluate constant expression to C code")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((number num)
          (. num raw))
        ((string str)
          (ctx-str3 ctx "\"" (. str value) "\""))
        ((symbol sym)
          (to-c-name arena (. sym name)))
        ((list lst)
          ;; Could be arithmetic expression - use transpile-expr
          (transpile-expr ctx expr)))))

  ;; ============================================================
  ;; FFI Declarations
  ;; ============================================================

  (fn transpile-ffi ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile FFI declaration: (ffi \"header.h\" (func args ret) ...)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; FFI declarations just register functions for use
    ;; Header includes are handled separately in prescan
    ;; Function declarations don't need to be emitted - C header provides them
    (do))

  (fn transpile-ffi-struct ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile FFI struct: (ffi-struct \"header.h\" name (field type) ...)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; FFI structs are defined in C headers, we just need to register the type
    ;; The header include provides the actual struct definition
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; Determine name position (skip optional header string)
            (let ((name-idx (if (and (>= len 2) (is-string-expr items 1)) 2 1)))
              (when (>= len (+ name-idx 1))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol sym)
                        (let ((type-name (. sym name))
                              (c-name (to-c-name arena type-name)))
                          ;; Register as a known type
                          ;; Use struct prefix for non-typedef names
                          (let ((actual-c-name (if (ends-with-t type-name) c-name (ctx-str ctx "struct " c-name))))
                            (ctx-register-type ctx (TypeEntry type-name c-name actual-c-name false true false)))))
                      (else (do))))
                  ((none) (do)))))))
        (else (do)))))

  (fn is-string-expr ((items (List (Ptr SExpr))) (idx Int))
    (@intent "Check if item at index is a string expression")
    (@spec (((List (Ptr SExpr)) Int) -> Bool))
    (match (list-get items idx)
      ((some item)
        (match (deref item)
          ((string _) true)
          (else false)))
      ((none) false)))

  (fn ends-with-t ((name String))
    (@intent "Check if name ends with _t (typedef convention)")
    (@spec ((String) -> Bool))
    (ends-with name "_t"))

  ;; ============================================================
  ;; Type Definition Dispatcher
  ;; ============================================================

  (fn transpile-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a type definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 3)
              (ctx-emit ctx "/* invalid type: need name and definition */")
              ;; Get type name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix if prefixing is enabled
                            (qualified-name (if (ctx-prefixing-enabled ctx)
                                              (match (ctx-get-module ctx)
                                                ((some mod-name)
                                                  (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                                ((none) base-name))
                                              base-name)))
                        ;; Get type definition
                        (match (list-get items 2)
                          ((some type-def)
                            (dispatch-type-def ctx raw-name qualified-name type-def))
                          ((none) (ctx-emit ctx "/* missing type definition */")))))
                    (else (ctx-emit ctx "/* type name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing type name */"))))))
        (else (ctx-emit ctx "/* invalid type form */")))))

  (fn dispatch-type-def ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (type-def (Ptr SExpr)))
    (@intent "Dispatch to appropriate type definition handler")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (match (deref type-def)
      ((list def-lst)
        (let ((items (. def-lst items)))
          (if (< (list-len items) 1)
            (ctx-emit ctx "/* empty type definition */")
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((kind (. sym name)))
                      (cond
                        ((string-eq kind "record")
                          (transpile-record ctx raw-name qualified-name type-def))
                        ((string-eq kind "enum")
                          ;; Check if it's a tagged union (has list variants)
                          (if (has-payload-variants items)
                            (transpile-union ctx raw-name qualified-name type-def)
                            (transpile-enum ctx raw-name qualified-name type-def)))
                        ((string-eq kind "union")
                          (transpile-union ctx raw-name qualified-name type-def))
                        ;; Default: treat as type alias
                        (else
                          (transpile-type-alias ctx raw-name qualified-name type-def)))))
                  (else (ctx-emit ctx "/* invalid type definition head */"))))
              ((none) (ctx-emit ctx "/* empty type definition */"))))))
      ;; Simple type (symbol) - could be alias or range
      ((symbol sym)
        (transpile-type-alias ctx raw-name qualified-name type-def))
      (else (ctx-emit ctx "/* invalid type definition form */"))))

  (fn has-payload-variants ((items (List (Ptr SExpr))))
    (@intent "Check if enum has payload variants (making it a union)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len items))
          (mut i 1)  ;; Skip 'enum' keyword
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((list _) (set! found true))  ;; List variant = payload
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  ;; ============================================================
  ;; Record (Struct) Definition
  ;; ============================================================

  (fn transpile-record ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile record to C struct")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Emit struct definition to main output
            (ctx-emit ctx (ctx-str3 ctx "struct " qualified-name " {"))
            ;; Emit fields and register their types
            (emit-record-fields ctx raw-name qualified-name items 1)  ;; Start at index 1 to skip 'record'
            (ctx-emit ctx "};")
            ;; Emit typedef
            (ctx-emit ctx (ctx-str5 ctx "typedef struct " qualified-name " " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name false true false))))
        (else (ctx-emit ctx "/* invalid record form */")))))

  (fn emit-record-fields ((ctx (Ptr TranspileContext)) (raw-type-name String) (qualified-type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit struct fields and register their types")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (emit-record-field ctx raw-type-name qualified-type-name field-expr))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-record-field ((ctx (Ptr TranspileContext)) (raw-type-name String) (qualified-type-name String) (field (Ptr SExpr)))
    (@intent "Emit a single struct field and register its type")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {field != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref field)
        ((list field-lst)
          (let ((items (. field-lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-emit ctx "    /* invalid field */")
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (match (list-get items 1)
                        ((some type-expr)
                          (let ((raw-field-name (. name-sym name))
                                (field-name (to-c-name arena raw-field-name))
                                (field-type (to-c-type-prefixed ctx type-expr))
                                (is-ptr (is-pointer-type-expr type-expr)))
                            ;; Emit the field
                            (ctx-emit ctx (ctx-str5 ctx "    " field-type " " field-name ";"))
                            ;; Register field type for both raw and qualified type names
                            (ctx-register-field-type ctx raw-type-name raw-field-name field-type is-ptr)
                            (ctx-register-field-type ctx qualified-type-name raw-field-name field-type is-ptr)))
                        ((none) (ctx-emit ctx "    /* missing field type */"))))
                    (else (ctx-emit ctx "    /* field name must be symbol */"))))
                ((none) (ctx-emit ctx "    /* missing field name */"))))))
        (else (ctx-emit ctx "    /* field must be a list */")))))

  ;; ============================================================
  ;; Enum Definition
  ;; ============================================================

  (fn transpile-enum ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile simple enum")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; Emit enum definition
            (ctx-emit ctx "typedef enum {")
            ;; Emit values
            (emit-enum-values ctx qualified-name items 1 len)
            (ctx-emit ctx (ctx-str3 ctx "} " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name true false false))))
        (else (ctx-emit ctx "/* invalid enum form */")))))

  (fn emit-enum-values ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int) (len Int))
    (@intent "Emit enum values")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some val-expr)
            (match (deref val-expr)
              ((symbol sym)
                (let ((val-name (to-c-name arena (. sym name)))
                      (full-name (ctx-str3 ctx type-name "_" val-name))
                      (is-last (== i (- len 1))))
                  (if is-last
                    (ctx-emit ctx (ctx-str ctx "    " full-name))
                    (ctx-emit ctx (ctx-str3 ctx "    " full-name ",")))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Union (Tagged Union) Definition
  ;; ============================================================

  (fn transpile-union ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile tagged union")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Emit struct with tag and union
            (ctx-emit ctx (ctx-str3 ctx "struct " qualified-name " {"))
            (ctx-emit ctx "    uint8_t tag;")
            (ctx-emit ctx "    union {")
            ;; Emit variant fields
            (emit-union-variants ctx items 1)
            (ctx-emit ctx "    } data;")
            (ctx-emit ctx "};")
            ;; Emit typedef
            (ctx-emit ctx (ctx-str5 ctx "typedef struct " qualified-name " " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Emit tag constants
            (emit-tag-constants ctx qualified-name items 1)
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name false false true))))
        (else (ctx-emit ctx "/* invalid union form */")))))

  (fn emit-union-variants ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit union variant fields")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((list var-lst)
                (let ((var-items (. var-lst items))
                      (var-len (list-len var-items)))
                  (when (>= var-len 1)
                    (match (list-get var-items 0)
                      ((some tag-expr)
                        (match (deref tag-expr)
                          ((symbol tag-sym)
                            (let ((tag-name (. tag-sym name)))
                              ;; If variant has payload
                              (when (>= var-len 2)
                                (match (list-get var-items 1)
                                  ((some type-expr)
                                    (let ((c-type (to-c-type-prefixed ctx type-expr)))
                                      (ctx-emit ctx (ctx-str5 ctx "        " c-type " " tag-name ";"))))
                                  ((none) (do))))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-tag-constants ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit tag constant defines")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx)
          (mut tag-idx 0))
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((list var-lst)
                (let ((var-items (. var-lst items)))
                  (when (>= (list-len var-items) 1)
                    (match (list-get var-items 0)
                      ((some tag-expr)
                        (match (deref tag-expr)
                          ((symbol tag-sym)
                            (let ((tag-name (. tag-sym name))
                                  (define-name (ctx-str4 ctx type-name "_" tag-name "_TAG")))
                              ;; Emit #define TYPE_tag_TAG idx
                              (ctx-emit ctx (ctx-str4 ctx "#define " define-name " " (int-to-string arena tag-idx)))))
                          (else (do))))
                      ((none) (do))))
                  (set! tag-idx (+ tag-idx 1))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Type Alias
  ;; ============================================================

  (fn transpile-type-alias ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (type-expr (Ptr SExpr)))
    (@intent "Transpile type alias")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Check if it's an Array type - requires special handling
      (cond
        ((is-array-type type-expr)
          (emit-array-typedef ctx qualified-name type-expr))
        ;; Check if it's a range type like (Int 0 .. 100)
        ((is-range-type type-expr)
          (emit-range-typedef ctx raw-name qualified-name type-expr))
        ;; Standard typedef
        (else
          (let ((c-type (to-c-type-prefixed ctx type-expr)))
            (ctx-emit ctx (ctx-str5 ctx "typedef " c-type " " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name c-type false false false)))))))

  (fn is-array-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is an Array type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Array"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-array-typedef ((ctx (Ptr TranspileContext)) (qualified-name String) (type-expr (Ptr SExpr)))
    (@intent "Emit typedef for Array type: typedef T NAME[SIZE];")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; (Array T size)
            (if (< len 3)
              ;; Invalid array type, fall back to pointer
              (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";")))
              (match (list-get items 1)
                ((some elem-type-expr)
                  (match (list-get items 2)
                    ((some size-expr)
                      (let ((elem-c-type (to-c-type-prefixed ctx elem-type-expr))
                            (size-str (get-number-as-string size-expr)))
                        ;; Emit: typedef T NAME[SIZE];
                        (ctx-emit ctx (ctx-str ctx "typedef " (ctx-str ctx elem-c-type (ctx-str ctx " " (ctx-str ctx qualified-name (ctx-str3 ctx "[" size-str "];"))))))
                        (ctx-emit ctx "")
                        ;; Register as pointer type for usage (arrays decay to pointers)
                        (let ((ptr-type (ctx-str ctx elem-c-type "*")))
                          (ctx-register-type ctx (TypeEntry qualified-name qualified-name ptr-type false false false)))))
                    ((none)
                      (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";"))))))
                ((none)
                  (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";"))))))))
        (else
          (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";")))))))

  (fn get-number-as-string ((expr (Ptr SExpr)))
    (@intent "Get number value as string")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((number num)
        (. num raw))
      (else "0")))

  ;; ============================================================
  ;; Range Type Handling
  ;; ============================================================

  (fn is-range-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a range type like (Int 0 .. 100)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items))
              (mut found-dots false)
              (mut i 0))
          ;; Look for '..' symbol in the items
          (while (and (< i len) (not found-dots))
            (match (list-get items i)
              ((some item)
                (match (deref item)
                  ((symbol sym)
                    (when (string-eq (. sym name) "..")
                      (set! found-dots true)))
                  (else (do))))
              ((none) (do)))
            (set! i (+ i 1)))
          found-dots))
      (else false)))

  (fn parse-range-bounds ((type-expr (Ptr SExpr)))
    (@intent "Parse range bounds from type like (Int 0 .. 100)")
    (@spec (((Ptr SExpr)) -> RangeBounds))
    (@pre {type-expr != nil})
    (let ((mut min-val 0)
          (mut max-val 0)
          (mut has-min false)
          (mut has-max false)
          (mut found-dots false))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 1))  ;; Skip the base type (first item)
            (while (< i len)
              (match (list-get items i)
                ((some item)
                  (match (deref item)
                    ((number num)
                      (if (not found-dots)
                        ;; Number before '..' is min
                        (do
                          (set! min-val (string-to-int (. num raw)))
                          (set! has-min true))
                        ;; Number after '..' is max
                        (do
                          (set! max-val (string-to-int (. num raw)))
                          (set! has-max true))))
                    ((symbol sym)
                      (when (string-eq (. sym name) "..")
                        (set! found-dots true)))
                    (else (do))))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))
      ;; Return record - field order: has-min, has-max, min-val, max-val
      (RangeBounds has-min has-max min-val max-val)))

  (fn string-to-int ((s String))
    (@intent "Convert string to integer")
    (@spec ((String) -> Int))
    (let ((len (cast Int (string-len s)))
          (mut result 0)
          (mut i 0)
          (mut negative false))
      ;; Handle negative sign
      (when (and (> len 0) (== (@ (. s data) 0) 45))  ;; '-' = 45
        (set! negative true)
        (set! i 1))
      (while (< i len)
        (let ((c (@ (. s data) i)))
          (when (and (>= c 48) (<= c 57))  ;; '0'-'9' = 48-57
            (set! result (+ (* result 10) (- (cast Int c) 48)))))
        (set! i (+ i 1)))
      (if negative (- 0 result) result)))

  (fn select-smallest-c-type ((min-val I64) (max-val I64) (has-min Bool) (has-max Bool))
    (@intent "Select smallest C type that fits the range")
    (@spec ((I64 I64 Bool Bool) -> String))
    (cond
      ;; Both bounds specified - can optimize
      ((and has-min has-max)
        (cond
          ;; uint8_t: 0 to 255
          ((and (>= min-val 0) (<= max-val 255))
            "uint8_t")
          ;; uint16_t: 0 to 65535
          ((and (>= min-val 0) (<= max-val 65535))
            "uint16_t")
          ;; int8_t: -128 to 127
          ((and (>= min-val (- 0 128)) (<= max-val 127))
            "int8_t")
          ;; int16_t: -32768 to 32767
          ((and (>= min-val (- 0 32768)) (<= max-val 32767))
            "int16_t")
          ;; Default to int64_t
          (else "int64_t")))
      ;; Default to int64_t for unbounded ranges
      (else "int64_t")))

  (fn emit-range-typedef ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (type-expr (Ptr SExpr)))
    (@intent "Emit typedef and _new constructor for range type")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (bounds RangeBounds (parse-range-bounds type-expr))
          (min-val I64 (. bounds min-val))
          (max-val I64 (. bounds max-val))
          (has-min Bool (. bounds has-min))
          (has-max Bool (. bounds has-max))
          (c-type (select-smallest-c-type min-val max-val has-min has-max)))
      ;; Emit typedef
      (ctx-emit ctx (ctx-str5 ctx "typedef " c-type " " qualified-name ";"))
      (ctx-emit ctx "")
      ;; Emit _new constructor
      (ctx-emit ctx (ctx-str5 ctx "static inline " qualified-name " " qualified-name "_new(int64_t v) {"))
      (ctx-indent ctx)
      ;; Emit bounds check using SLOP_PRE
      (cond
        ;; Both bounds
        ((and has-min has-max)
          (let ((min-str (int-to-string arena min-val))
                (max-str (int-to-string arena max-val)))
            (ctx-emit ctx (ctx-str ctx "SLOP_PRE(v >= " (ctx-str ctx min-str (ctx-str ctx " && v <= " (ctx-str ctx max-str (ctx-str ctx ", \"" (ctx-str ctx qualified-name (ctx-str ctx " in range " (ctx-str ctx min-str (ctx-str ctx ".." (ctx-str ctx max-str "\");")))))))))))))
        ;; Only min bound
        (has-min
          (let ((min-str (int-to-string arena min-val)))
            (ctx-emit ctx (ctx-str ctx "SLOP_PRE(v >= " (ctx-str ctx min-str (ctx-str ctx ", \"" (ctx-str ctx qualified-name (ctx-str ctx " >= " (ctx-str ctx min-str "\");")))))))))
        ;; Only max bound
        (has-max
          (let ((max-str (int-to-string arena max-val)))
            (ctx-emit ctx (ctx-str ctx "SLOP_PRE(v <= " (ctx-str ctx max-str (ctx-str ctx ", \"" (ctx-str ctx qualified-name (ctx-str ctx " <= " (ctx-str ctx max-str "\");")))))))))
        (else (do)))
      ;; Emit return
      (ctx-emit ctx (ctx-str ctx "return (" (ctx-str ctx qualified-name ")v;")))
      (ctx-dedent ctx)
      (ctx-emit ctx "}")
      (ctx-emit ctx "")
      ;; Register type
      (ctx-register-type ctx (TypeEntry raw-name qualified-name c-type false false false))))

  ;; ============================================================
  ;; Function Definition
  ;; ============================================================

  (fn transpile-function ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile function definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 3)
              (ctx-emit ctx "/* invalid fn: need name and params */")
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix EXCEPT for main function
                            (fn-name (if (string-eq base-name "main")
                                       base-name
                                       (ctx-prefix-type ctx base-name))))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            (emit-function-def ctx raw-name fn-name params-expr items))
                          ((none) (ctx-emit ctx "/* missing params */")))))
                    (else (ctx-emit ctx "/* function name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing function name */"))))))
        (else (ctx-emit ctx "/* invalid fn form */")))))

  (fn emit-function-def ((ctx (Ptr TranspileContext)) (raw-name String) (fn-name String) (params-expr (Ptr SExpr)) (items (List (Ptr SExpr))))
    (@intent "Emit function definition")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          ;; Check for Result type first - if so, use the prefixed Result type name
          (result-type-opt (get-result-type-name ctx items))
          ;; Get raw return type
          (raw-return (get-return-type ctx items))
          ;; Collect contract annotations
          (preconditions (collect-preconditions arena items))
          (postconditions (collect-postconditions arena items))
          (assumptions (collect-assumptions arena items)))
      ;; Determine actual return type, preferring Result type name if available
      (let ((return-type String (match result-type-opt
                                  ((some result-name) result-name)
                                  ((none) raw-return)))
            ;; Special case: main returns int
            (actual-return (if (string-eq fn-name "main") "int" return-type))
            ;; Build parameter string
            (param-str (build-param-str ctx params-expr))
            ;; Check if we need _retval (has postconditions/assumptions and non-void return)
            (has-post (or (> (list-len postconditions) 0) (> (list-len assumptions) 0)))
            (needs-retval (and has-post (not (string-eq actual-return "void")))))
        ;; Set current return type for typed none in return statements
        (ctx-set-current-return-type ctx actual-return)
        ;; Set current result type if present, otherwise clear any previous
        (match result-type-opt
          ((some result-name)
            (ctx-set-current-result-type ctx result-name))
          ((none)
            (ctx-clear-current-result-type ctx)))
        ;; Emit function signature
        (ctx-emit ctx (ctx-str5 ctx actual-return " " fn-name "(" (ctx-str ctx (if (string-eq param-str "") "void" param-str) ") {")))
        (ctx-indent ctx)
        ;; Push new scope and bind parameters
        (ctx-push-scope ctx)
        (bind-params-to-scope ctx params-expr)
        ;; Emit preconditions
        (emit-preconditions ctx preconditions)
        ;; Declare _retval if needed for postconditions
        (when needs-retval
          (ctx-emit ctx (ctx-str ctx actual-return " _retval;")))
        ;; Set capture mode if we need _retval
        (when needs-retval
          (ctx-set-capture-retval ctx true))
        ;; Emit body (skip name, params, and annotations)
        (emit-function-body ctx items)
        ;; Clear capture mode
        (when needs-retval
          (ctx-set-capture-retval ctx false))
        ;; Emit postconditions and assumptions
        (emit-postconditions ctx postconditions)
        (emit-assumptions ctx assumptions)
        ;; Emit return _retval if we captured it
        (when needs-retval
          (ctx-emit ctx "return _retval;"))
        ;; Pop scope
        (ctx-pop-scope ctx)
        (ctx-dedent ctx)
        (ctx-emit ctx "}")
        (ctx-emit ctx "")
        ;; Register function with parameter types for typed none handling
        (let ((param-types (collect-param-types ctx params-expr)))
          (ctx-register-func ctx (FuncEntry raw-name fn-name actual-return false (string-eq actual-return "slop_string") param-types)))
        ;; Clear current result type and return type
        (ctx-clear-current-result-type ctx)
        (ctx-clear-current-return-type ctx))))

  ;; ============================================================
  ;; Parameter Binding
  ;; ============================================================

  (fn bind-params-to-scope ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Bind function parameters to the current scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (bind-single-param ctx param))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))))

  (fn bind-single-param ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Bind a single parameter to the scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 2)
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (name-idx (if has-mode 1 0))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol name-sym)
                        (match (list-get items type-idx)
                          ((some type-expr)
                            (let ((param-name (. name-sym name))
                                  (c-name (to-c-name arena param-name))
                                  (c-type (to-c-type-prefixed ctx type-expr))
                                  (is-ptr (is-pointer-type type-expr)))
                              (ctx-bind-var ctx (VarEntry param-name c-name c-type is-ptr false))))
                          ((none) (do))))
                      (else (do))))
                  ((none) (do)))))))
        (else (do)))))

  (fn is-pointer-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type is a pointer type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Ptr"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn collect-param-types ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Collect C types of all parameters for typed none handling")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (List (Ptr FuncParamType))))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (result (list-new arena (Ptr FuncParamType))))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (let ((c-type (get-param-c-type ctx param))
                        (param-info (cast (Ptr FuncParamType) (arena-alloc arena 64))))
                    (set! (. (deref param-info) c-type) c-type)
                    (list-push result param-info)))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))
      result))

  (fn get-param-c-type ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Extract C type string from a parameter expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "void*"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items type-idx)
                  ((some type-expr)
                    (to-c-type-prefixed ctx type-expr))
                  ((none) "void*"))))))
        (else "void*"))))

  ;; ============================================================
  ;; Function Forward Declaration
  ;; ============================================================

  (fn emit-forward-declaration ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit function forward declaration")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix to function name
                            (fn-name (ctx-prefix-type ctx base-name)))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            ;; Check for Result type first
                            (let ((result-type-opt (get-result-type-name ctx items))
                                  (raw-return (get-return-type ctx items)))
                              (let ((return-type String (match result-type-opt
                                                          ((some result-name) result-name)
                                                          ((none) raw-return)))
                                    ;; Special case: main returns int
                                    (actual-return (if (string-eq base-name "main") "int" return-type))
                                    (param-str (build-param-str ctx params-expr)))
                                (ctx-emit ctx (ctx-str5 ctx actual-return " " fn-name "("
                                                (ctx-str ctx (if (string-eq param-str "") "void" param-str) ");"))))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn get-return-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Extract return type from @spec annotation")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (mut result "void"))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-spec-form item)
              (set! result (extract-spec-return-type ctx item))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn is-spec-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is @spec annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@spec"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn extract-spec-return-type ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract return type from @spec")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (if (< (list-len items) 2)
              "void"
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((list body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (if (< body-len 1)
                          "void"
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              (to-c-type-prefixed ctx ret-type))
                            ((none) "void")))))
                    (else "void")))
                ((none) "void")))))
        (else "void"))))

  (fn get-result-type-name ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Extract Result type name from @spec if return type is a Result")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (Option String)))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (mut result (Option String) none))
      (while (and (< i len) (match result ((none) true) ((some _) false)))
        (match (list-get items i)
          ((some item)
            (when (is-spec-form item)
              (set! result (extract-result-type-name ctx item))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn extract-result-type-name ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract Result type name from @spec if it's a Result type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (if (< (list-len items) 2)
              none
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((list body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (if (< body-len 1)
                          none
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              (check-result-type ctx ret-type))
                            ((none) none)))))
                    (else none)))
                ((none) none)))))
        (else none))))

  (fn check-result-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Check if type is a Result and return its name if so")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ;; Check for type alias (symbol)
        ((symbol sym)
          (let ((type-name (. sym name)))
            ;; First try result type alias lookup
            (match (ctx-lookup-result-type-alias ctx type-name)
              ((some alias-result) (some alias-result))
              ((none)
                ;; Alias not found - check if it's a registered type (imported Result typedef)
                ;; If registered, use its c-name as the result type
                (match (ctx-lookup-type ctx type-name)
                  ((some entry)
                    ;; Use the registered type's c-name
                    (some (. entry c-name)))
                  ((none) none))))))
        ;; Check for direct (Result OkType ErrType)
        ((list lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (if (< (list-len items) 3)
              none
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (if (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with proper module prefixes
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      (result-name (build-result-name arena ok-c-type err-c-type)))
                                  (some result-name)))
                              ((none) none)))
                          ((none) none))
                        none))
                    (else none)))
                ((none) none)))))
        (else none))))

  (fn build-result-name ((arena Arena) (ok-type String) (err-type String))
    (@intent "Build the C type name for a Result type")
    (@spec ((Arena String String) -> String))
    ;; Use type-to-identifier for consistent naming with ctype.slop
    (let ((ok-id (type-to-identifier arena ok-type))
          (err-id (type-to-identifier arena err-type)))
      (string-concat arena
        (string-concat arena
          (string-concat arena "slop_result_" ok-id)
          "_")
        err-id)))

  (fn build-param-str ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Build C parameter string from params list")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut result "")
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (let ((param-str (build-single-param ctx param)))
                    (if (string-eq result "")
                      (set! result param-str)
                      (set! result (ctx-str3 ctx result ", " param-str)))))
                ((none) (do)))
              (set! i (+ i 1)))
            result))
        (else ""))))

  (fn build-single-param ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Build C parameter from single param")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "/* invalid param */"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (name-idx (if (and (>= len 3) (is-param-mode items)) 1 0))
                    (type-idx (if (and (>= len 3) (is-param-mode items)) 2 1)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol name-sym)
                        (match (list-get items type-idx)
                          ((some type-expr)
                            (let ((param-name (to-c-name arena (. name-sym name))))
                              ;; Check if type is a function type (Fn ...)
                              (if (is-fn-type type-expr)
                                ;; Function pointer: emit as ret_type(*name)(args)
                                (emit-fn-param-type ctx type-expr param-name)
                                ;; Normal type: emit as type name
                                (let ((param-type (to-c-type-prefixed ctx type-expr)))
                                  (ctx-str3 ctx param-type " " param-name)))))
                          ((none) "/* missing param type */")))
                      (else "/* param name must be symbol */")))
                  ((none) "/* missing param name */"))))))
        (else "/* param must be a list */"))))

  (fn is-param-mode ((items (List (Ptr SExpr))))
    (@intent "Check if first item is a parameter mode")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((symbol sym)
              (let ((name (. sym name)))
                (or (string-eq name "in")
                    (string-eq name "out")
                    (string-eq name "mut"))))
            (else false)))
        ((none) false))))

  (fn is-fn-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a function type (Fn ...)")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some first)
                (match (deref first)
                  ((symbol sym) (string-eq (. sym name) "Fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-fn-param-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)) (param-name String))
    (@intent "Emit function pointer parameter with name inside: ret_type(*name)(args)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-str ctx "void* " param-name)
              ;; Get return type (last item)
              (let ((ret-type (match (list-get items (- len 1))
                                ((some ret) (to-c-type-prefixed ctx ret))
                                ((none) "void"))))
                (if (= len 2)
                  ;; (Fn RetType) - no args
                  (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name ")(void)"))
                  ;; (Fn (args...) RetType)
                  (match (list-get items 1)
                    ((some args-expr)
                      (let ((args-str (build-fn-args-str-for-param ctx args-expr)))
                        (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name (ctx-str ctx ")" args-str)))))
                    ((none) (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name ")(void)")))))))))
        (else (ctx-str ctx "void* " param-name)))))

  (fn build-fn-args-str-for-param ((ctx (Ptr TranspileContext)) (args-expr (Ptr SExpr)))
    (@intent "Build C function argument string for param type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref args-expr)
        ((list args-list)
          (let ((arg-items (. args-list items))
                (arg-count (list-len arg-items)))
            (if (= arg-count 0)
              "(void)"
              ;; Build comma-separated args
              (let ((mut result "(")
                    (mut i 0))
                (while (< i arg-count)
                  (match (list-get arg-items i)
                    ((some arg-expr)
                      (let ((arg-type (to-c-type-prefixed ctx arg-expr)))
                        (if (> i 0)
                          (set! result (ctx-str ctx result (ctx-str ctx ", " arg-type)))
                          (set! result (ctx-str ctx result arg-type)))))
                    ((none) ()))
                  (set! i (+ i 1)))
                (ctx-str ctx result ")")))))
        ;; Not a list - treat as void
        (_ "(void)"))))

  (fn emit-function-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit function body statements")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Check if function returns void - if so, don't emit implicit return
    (let ((is-void-fn (match (ctx-get-current-return-type ctx)
                        ((some ret-type) (string-eq ret-type "void"))
                        ((none) true)))  ;; Default to void if no return type set
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (body-start (find-body-start items)))
      ;; Emit body statements
      (set! i body-start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (let ((is-last (== i (- len 1)))
                  ;; Only treat last statement as return if function is non-void
                  (is-return (and is-last (not is-void-fn))))
              ;; Skip annotations
              (when (not (is-annotation item))
                (transpile-stmt ctx item is-return))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn find-body-start ((items (List (Ptr SExpr))))
    (@intent "Find index where function body starts (after annotations)")
    (@spec (((List (Ptr SExpr))) -> Int))
    (let ((len (list-len items))
          (mut i 3)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (if (is-annotation item)
              (set! i (+ i 1))
              (set! found true)))
          ((none) (set! found true))))
      i))

  (fn is-annotation ((expr (Ptr SExpr)))
    (@intent "Check if expression is an annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((name (. sym name)))
                      (or (string-eq name "@intent")
                          (string-eq name "@spec")
                          (string-eq name "@pre")
                          (string-eq name "@post")
                          (string-eq name "@assume")
                          (string-eq name "@alloc")
                          (string-eq name "@example")
                          (string-eq name "@pure"))))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Contract Annotation Extraction
  ;; ============================================================

  (fn is-pre-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a @pre annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@pre"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-post-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a @post annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@post"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-assume-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is an @assume annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@assume"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn get-annotation-condition ((expr (Ptr SExpr)))
    (@intent "Extract condition expression from @pre/@post/@assume annotation")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pre {expr != nil})
    ;; Annotation has form (@pre condition) or (@post condition)
    (let ((mut result (Option (Ptr SExpr)) none))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 1)
                ((some val) (set! result (some val)))
                ((none) (do))))))
        (else (do)))
      result))

  (fn collect-preconditions ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Collect all @pre conditions from function items")
    (@spec ((Arena (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (let ((result (list-new arena (Ptr SExpr)))
          (len (list-len items))
          (mut i 3))  ;; Start after name and params
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-pre-form item)
              (match (get-annotation-condition item)
                ((some cond) (list-push result cond))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn collect-postconditions ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Collect all @post conditions from function items")
    (@spec ((Arena (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (let ((result (list-new arena (Ptr SExpr)))
          (len (list-len items))
          (mut i 3))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-post-form item)
              (match (get-annotation-condition item)
                ((some cond) (list-push result cond))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn collect-assumptions ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Collect all @assume conditions from function items")
    (@spec ((Arena (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (let ((result (list-new arena (Ptr SExpr)))
          (len (list-len items))
          (mut i 3))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-assume-form item)
              (match (get-annotation-condition item)
                ((some cond) (list-push result cond))
                ((none) (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn has-postconditions ((items (List (Ptr SExpr))))
    (@intent "Check if function has any @post or @assume annotations")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len items))
          (mut i 3)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (when (or (is-post-form item) (is-assume-form item))
              (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  ;; ============================================================
  ;; Contract Emission
  ;; ============================================================

  (fn emit-preconditions ((ctx (Ptr TranspileContext)) (preconditions (List (Ptr SExpr))))
    (@intent "Emit SLOP_PRE macro calls for all preconditions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len preconditions))
          (mut i 0))
      (while (< i len)
        (match (list-get preconditions i)
          ((some cond-expr)
            ;; Transpile the condition to C
            (let ((cond-c (transpile-expr ctx cond-expr))
                  ;; Get the original expression as string for the error message
                  (expr-str (pretty-print arena cond-expr))
                  ;; Escape double quotes in the string
                  (escaped-str (escape-for-c-string arena expr-str)))
              (ctx-emit ctx (ctx-str5 ctx "SLOP_PRE((" cond-c "), \"" escaped-str "\");"))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-postconditions ((ctx (Ptr TranspileContext)) (postconditions (List (Ptr SExpr))))
    (@intent "Emit SLOP_POST macro calls for all postconditions")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len postconditions))
          (mut i 0))
      (while (< i len)
        (match (list-get postconditions i)
          ((some cond-expr)
            ;; Transpile the condition to C
            (let ((cond-c-raw (transpile-expr ctx cond-expr))
                  ;; Replace $result and _result with _retval
                  (cond-c (replace arena (replace arena cond-c-raw "_result" "_retval") "$result" "_retval"))
                  ;; Get the original expression as string for the error message
                  (expr-str (pretty-print arena cond-expr))
                  ;; Escape double quotes in the string
                  (escaped-str (escape-for-c-string arena expr-str)))
              (ctx-emit ctx (ctx-str5 ctx "SLOP_POST((" cond-c "), \"" escaped-str "\");"))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-assumptions ((ctx (Ptr TranspileContext)) (assumptions (List (Ptr SExpr))))
    (@intent "Emit SLOP_POST macro calls for all assumptions (same as postconditions)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len assumptions))
          (mut i 0))
      (while (< i len)
        (match (list-get assumptions i)
          ((some cond-expr)
            ;; Transpile the condition to C
            (let ((cond-c-raw (transpile-expr ctx cond-expr))
                  ;; Replace $result and _result with _retval
                  (cond-c (replace arena (replace arena cond-c-raw "_result" "_retval") "$result" "_retval"))
                  ;; Get the original expression as string for the error message
                  (expr-str (pretty-print arena cond-expr))
                  ;; Escape double quotes in the string
                  (escaped-str (escape-for-c-string arena expr-str)))
              (ctx-emit ctx (ctx-str5 ctx "SLOP_POST((" cond-c "), \"" escaped-str "\");"))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn escape-for-c-string ((arena Arena) (s String))
    (@intent "Escape special characters in string for C string literal")
    (@spec ((Arena String) -> String))
    (let ((len (cast Int (. s len)))
          ;; Allocate extra space for escapes
          (buf (cast (Ptr U8) (arena-alloc arena (+ (* len 2) 1))))
          (mut out-idx 0)
          (mut in-idx 0))
      (while (< in-idx len)
        (let ((c (@ (. s data) in-idx)))
          (cond
            ;; Backslash -> \\
            ((== c 92)
              (do
                (set! (@ buf out-idx) 92)
                (set! out-idx (+ out-idx 1))
                (set! (@ buf out-idx) 92)
                (set! out-idx (+ out-idx 1))))
            ;; Double quote -> \"
            ((== c 34)
              (do
                (set! (@ buf out-idx) 92)
                (set! out-idx (+ out-idx 1))
                (set! (@ buf out-idx) 34)
                (set! out-idx (+ out-idx 1))))
            ;; Newline -> \n
            ((== c 10)
              (do
                (set! (@ buf out-idx) 92)
                (set! out-idx (+ out-idx 1))
                (set! (@ buf out-idx) 110)
                (set! out-idx (+ out-idx 1))))
            ;; Tab -> \t
            ((== c 9)
              (do
                (set! (@ buf out-idx) 92)
                (set! out-idx (+ out-idx 1))
                (set! (@ buf out-idx) 116)
                (set! out-idx (+ out-idx 1))))
            ;; Other characters: copy as-is
            (else
              (do
                (set! (@ buf out-idx) c)
                (set! out-idx (+ out-idx 1))))))
        (set! in-idx (+ in-idx 1)))
      ;; Null terminate
      (set! (@ buf out-idx) 0)
      (String buf (cast U64 out-idx))))

) ;; end module
