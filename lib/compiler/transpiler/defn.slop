;; ============================================================
;; SLOP Native Transpiler - Definition Module
;;
;; Handles type definitions (record, enum, union) and
;; function definitions.
;; ============================================================

(module defn
  (export
    ;; Type definitions
    transpile-type transpile-record transpile-enum transpile-union
    ;; Constant definitions
    transpile-const is-const-form
    ;; Function definitions
    transpile-function emit-forward-declaration
    ;; FFI definitions
    transpile-ffi transpile-ffi-struct is-ffi-form is-ffi-struct-form
    ;; Helpers
    is-type-form is-function-form get-return-type get-result-type-name build-param-str)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import context (TranspileContext ctx-emit ctx-emit ctx-indent ctx-dedent
                   ctx-register-type ctx-register-func ctx-register-field-type
                   ctx-str ctx-str3 ctx-str4 ctx-str5
                   ctx-set-current-result-type ctx-clear-current-result-type
                   ctx-set-current-return-type ctx-get-current-return-type ctx-clear-current-return-type
                   ctx-lookup-result-type-alias ctx-lookup-type
                   ctx-push-scope ctx-pop-scope ctx-bind-var
                   ctx-prefixing-enabled ctx-get-module ctx-prefix-type
                   TypeEntry FuncEntry FuncParamType VarEntry
                   to-c-type-prefixed))
  (import ctype (to-c-type to-c-name type-to-identifier is-builtin-c-type))
  (import stmt (transpile-stmt))
  (import expr (transpile-expr))
  (import strlib (starts-with ends-with substring))

  ;; ============================================================
  ;; Form Detection
  ;; ============================================================

  (fn is-type-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a type definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "type"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-function-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a function definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-const-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is a constant definition")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "const"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-ffi-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is an FFI declaration")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "ffi"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn is-ffi-struct-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is an FFI struct declaration")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "ffi-struct"))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Type Expression Helpers
  ;; ============================================================

  (fn is-pointer-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if a type expression represents a pointer type (Ptr T)")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (or (string-eq (. sym name) "Ptr")
                        (string-eq (. sym name) "ScopedPtr")))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Constant Definition
  ;; ============================================================

  (fn transpile-const ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile constant definition: (const NAME Type value)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; (const NAME Type value)
    ;; Integers emit as #define, others as static const
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 4)
              (ctx-emit ctx "/* invalid const: need name, type, value */")
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (c-name (to-c-name arena raw-name)))
                        (match (list-get items 2)
                          ((some type-expr)
                            (match (list-get items 3)
                              ((some value-expr)
                                (emit-const-def ctx c-name type-expr value-expr))
                              ((none) (ctx-emit ctx "/* missing const value */"))))
                          ((none) (ctx-emit ctx "/* missing const type */")))))
                    (else (ctx-emit ctx "/* const name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing const name */"))))))
        (else (ctx-emit ctx "/* invalid const form */")))))

  (fn emit-const-def ((ctx (Ptr TranspileContext)) (c-name String) (type-expr (Ptr SExpr)) (value-expr (Ptr SExpr)))
    (@intent "Emit constant definition based on type")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (@pre {value-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (c-type (to-c-type-prefixed ctx type-expr))
          (type-name (get-type-name-str type-expr)))
      ;; Check if it's an integer type
      (if (is-int-type type-name)
        ;; Integer type -> #define
        (let ((value-c (eval-const-value ctx value-expr)))
          (ctx-emit ctx (ctx-str4 ctx "#define " c-name " (" (ctx-str ctx value-c ")"))))
        ;; String or other type -> static const
        (if (string-eq type-name "String")
          (match (deref value-expr)
            ((string str)
              (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                              (ctx-str3 ctx " = SLOP_STR(\"" (. str value) "\");"))))
            (else
              (let ((value-c (eval-const-value ctx value-expr)))
                (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                                (ctx-str3 ctx " = " value-c ";"))))))
          (let ((value-c (eval-const-value ctx value-expr)))
            (ctx-emit ctx (ctx-str5 ctx "static const " c-type " " c-name
                            (ctx-str3 ctx " = " value-c ";"))))))))

  (fn get-type-name-str ((type-expr (Ptr SExpr)))
    (@intent "Get simple type name as string")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((symbol sym) (. sym name))
      (else "")))

  (fn is-int-type ((type-name String))
    (@intent "Check if type name is an integer type")
    (@spec ((String) -> Bool))
    (or (string-eq type-name "Int")
        (string-eq type-name "I8")
        (string-eq type-name "I16")
        (string-eq type-name "I32")
        (string-eq type-name "I64")
        (string-eq type-name "U8")
        (string-eq type-name "U16")
        (string-eq type-name "U32")
        (string-eq type-name "U64")))

  (fn eval-const-value ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Evaluate constant expression to C code")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((number num)
          (. num raw))
        ((string str)
          (ctx-str3 ctx "\"" (. str value) "\""))
        ((symbol sym)
          (to-c-name arena (. sym name)))
        ((list lst)
          ;; Could be arithmetic expression - use transpile-expr
          (transpile-expr ctx expr)))))

  ;; ============================================================
  ;; FFI Declarations
  ;; ============================================================

  (fn transpile-ffi ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile FFI declaration: (ffi \"header.h\" (func args ret) ...)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; FFI declarations just register functions for use
    ;; Header includes are handled separately in prescan
    ;; Function declarations don't need to be emitted - C header provides them
    (do))

  (fn transpile-ffi-struct ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile FFI struct: (ffi-struct \"header.h\" name (field type) ...)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; FFI structs are defined in C headers, we just need to register the type
    ;; The header include provides the actual struct definition
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; Determine name position (skip optional header string)
            (let ((name-idx (if (and (>= len 2) (is-string-expr items 1)) 2 1)))
              (when (>= len (+ name-idx 1))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol sym)
                        (let ((type-name (. sym name))
                              (c-name (to-c-name arena type-name)))
                          ;; Register as a known type
                          ;; Use struct prefix for non-typedef names
                          (let ((actual-c-name (if (ends-with-t type-name) c-name (ctx-str ctx "struct " c-name))))
                            (ctx-register-type ctx (TypeEntry type-name c-name actual-c-name false true false)))))
                      (else (do))))
                  ((none) (do)))))))
        (else (do)))))

  (fn is-string-expr ((items (List (Ptr SExpr))) (idx Int))
    (@intent "Check if item at index is a string expression")
    (@spec (((List (Ptr SExpr)) Int) -> Bool))
    (match (list-get items idx)
      ((some item)
        (match (deref item)
          ((string _) true)
          (else false)))
      ((none) false)))

  (fn ends-with-t ((name String))
    (@intent "Check if name ends with _t (typedef convention)")
    (@spec ((String) -> Bool))
    (ends-with name "_t"))

  ;; ============================================================
  ;; Type Definition Dispatcher
  ;; ============================================================

  (fn transpile-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a type definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 3)
              (ctx-emit ctx "/* invalid type: need name and definition */")
              ;; Get type name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix if prefixing is enabled
                            (qualified-name (if (ctx-prefixing-enabled ctx)
                                              (match (ctx-get-module ctx)
                                                ((some mod-name)
                                                  (ctx-str ctx (to-c-name arena mod-name) (ctx-str ctx "_" base-name)))
                                                ((none) base-name))
                                              base-name)))
                        ;; Get type definition
                        (match (list-get items 2)
                          ((some type-def)
                            (dispatch-type-def ctx raw-name qualified-name type-def))
                          ((none) (ctx-emit ctx "/* missing type definition */")))))
                    (else (ctx-emit ctx "/* type name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing type name */"))))))
        (else (ctx-emit ctx "/* invalid type form */")))))

  (fn dispatch-type-def ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (type-def (Ptr SExpr)))
    (@intent "Dispatch to appropriate type definition handler")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-def != nil})
    (match (deref type-def)
      ((list def-lst)
        (let ((items (. def-lst items)))
          (if (< (list-len items) 1)
            (ctx-emit ctx "/* empty type definition */")
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((kind (. sym name)))
                      (cond
                        ((string-eq kind "record")
                          (transpile-record ctx raw-name qualified-name type-def))
                        ((string-eq kind "enum")
                          ;; Check if it's a tagged union (has list variants)
                          (if (has-payload-variants items)
                            (transpile-union ctx raw-name qualified-name type-def)
                            (transpile-enum ctx raw-name qualified-name type-def)))
                        ((string-eq kind "union")
                          (transpile-union ctx raw-name qualified-name type-def))
                        ;; Default: treat as type alias
                        (else
                          (transpile-type-alias ctx raw-name qualified-name type-def)))))
                  (else (ctx-emit ctx "/* invalid type definition head */"))))
              ((none) (ctx-emit ctx "/* empty type definition */"))))))
      ;; Simple type (symbol) - could be alias or range
      ((symbol sym)
        (transpile-type-alias ctx raw-name qualified-name type-def))
      (else (ctx-emit ctx "/* invalid type definition form */"))))

  (fn has-payload-variants ((items (List (Ptr SExpr))))
    (@intent "Check if enum has payload variants (making it a union)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len items))
          (mut i 1)  ;; Skip 'enum' keyword
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (match (deref item)
              ((list _) (set! found true))  ;; List variant = payload
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      found))

  ;; ============================================================
  ;; Record (Struct) Definition
  ;; ============================================================

  (fn transpile-record ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile record to C struct")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Emit struct definition to main output
            (ctx-emit ctx (ctx-str3 ctx "struct " qualified-name " {"))
            ;; Emit fields and register their types
            (emit-record-fields ctx raw-name qualified-name items 1)  ;; Start at index 1 to skip 'record'
            (ctx-emit ctx "};")
            ;; Emit typedef
            (ctx-emit ctx (ctx-str5 ctx "typedef struct " qualified-name " " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name false true false))))
        (else (ctx-emit ctx "/* invalid record form */")))))

  (fn emit-record-fields ((ctx (Ptr TranspileContext)) (raw-type-name String) (qualified-type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit struct fields and register their types")
    (@spec (((Ptr TranspileContext) String String (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some field-expr)
            (emit-record-field ctx raw-type-name qualified-type-name field-expr))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-record-field ((ctx (Ptr TranspileContext)) (raw-type-name String) (qualified-type-name String) (field (Ptr SExpr)))
    (@intent "Emit a single struct field and register its type")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {field != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref field)
        ((list field-lst)
          (let ((items (. field-lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-emit ctx "    /* invalid field */")
              (match (list-get items 0)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (match (list-get items 1)
                        ((some type-expr)
                          (let ((raw-field-name (. name-sym name))
                                (field-name (to-c-name arena raw-field-name))
                                (field-type (to-c-type-prefixed ctx type-expr))
                                (is-ptr (is-pointer-type-expr type-expr)))
                            ;; Emit the field
                            (ctx-emit ctx (ctx-str5 ctx "    " field-type " " field-name ";"))
                            ;; Register field type for both raw and qualified type names
                            (ctx-register-field-type ctx raw-type-name raw-field-name field-type is-ptr)
                            (ctx-register-field-type ctx qualified-type-name raw-field-name field-type is-ptr)))
                        ((none) (ctx-emit ctx "    /* missing field type */"))))
                    (else (ctx-emit ctx "    /* field name must be symbol */"))))
                ((none) (ctx-emit ctx "    /* missing field name */"))))))
        (else (ctx-emit ctx "    /* field must be a list */")))))

  ;; ============================================================
  ;; Enum Definition
  ;; ============================================================

  (fn transpile-enum ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile simple enum")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; Emit enum definition
            (ctx-emit ctx "typedef enum {")
            ;; Emit values
            (emit-enum-values ctx qualified-name items 1 len)
            (ctx-emit ctx (ctx-str3 ctx "} " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name true false false))))
        (else (ctx-emit ctx "/* invalid enum form */")))))

  (fn emit-enum-values ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int) (len Int))
    (@intent "Emit enum values")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some val-expr)
            (match (deref val-expr)
              ((symbol sym)
                (let ((val-name (to-c-name arena (. sym name)))
                      (full-name (ctx-str3 ctx type-name "_" val-name))
                      (is-last (== i (- len 1))))
                  (if is-last
                    (ctx-emit ctx (ctx-str ctx "    " full-name))
                    (ctx-emit ctx (ctx-str3 ctx "    " full-name ",")))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Union (Tagged Union) Definition
  ;; ============================================================

  (fn transpile-union ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (expr (Ptr SExpr)))
    (@intent "Transpile tagged union")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; Emit struct with tag and union
            (ctx-emit ctx (ctx-str3 ctx "struct " qualified-name " {"))
            (ctx-emit ctx "    uint8_t tag;")
            (ctx-emit ctx "    union {")
            ;; Emit variant fields
            (emit-union-variants ctx items 1)
            (ctx-emit ctx "    } data;")
            (ctx-emit ctx "};")
            ;; Emit typedef
            (ctx-emit ctx (ctx-str5 ctx "typedef struct " qualified-name " " qualified-name ";"))
            (ctx-emit ctx "")
            ;; Emit tag constants
            (emit-tag-constants ctx qualified-name items 1)
            (ctx-emit ctx "")
            ;; Register type
            (ctx-register-type ctx (TypeEntry raw-name qualified-name qualified-name false false true))))
        (else (ctx-emit ctx "/* invalid union form */")))))

  (fn emit-union-variants ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit union variant fields")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx))
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((list var-lst)
                (let ((var-items (. var-lst items))
                      (var-len (list-len var-items)))
                  (when (>= var-len 1)
                    (match (list-get var-items 0)
                      ((some tag-expr)
                        (match (deref tag-expr)
                          ((symbol tag-sym)
                            (let ((tag-name (. tag-sym name)))
                              ;; If variant has payload
                              (when (>= var-len 2)
                                (match (list-get var-items 1)
                                  ((some type-expr)
                                    (let ((c-type (to-c-type-prefixed ctx type-expr)))
                                      (ctx-emit ctx (ctx-str5 ctx "        " c-type " " tag-name ";"))))
                                  ((none) (do))))))
                          (else (do))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-tag-constants ((ctx (Ptr TranspileContext)) (type-name String) (items (List (Ptr SExpr))) (start-idx Int))
    (@intent "Emit tag constant defines")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Int) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i start-idx)
          (mut tag-idx 0))
      (while (< i len)
        (match (list-get items i)
          ((some variant-expr)
            (match (deref variant-expr)
              ((list var-lst)
                (let ((var-items (. var-lst items)))
                  (when (>= (list-len var-items) 1)
                    (match (list-get var-items 0)
                      ((some tag-expr)
                        (match (deref tag-expr)
                          ((symbol tag-sym)
                            (let ((tag-name (. tag-sym name))
                                  (define-name (ctx-str4 ctx type-name "_" tag-name "_TAG")))
                              ;; Emit #define TYPE_tag_TAG idx
                              (ctx-emit ctx (ctx-str4 ctx "#define " define-name " " (int-to-string arena tag-idx)))))
                          (else (do))))
                      ((none) (do))))
                  (set! tag-idx (+ tag-idx 1))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; Type Alias
  ;; ============================================================

  (fn transpile-type-alias ((ctx (Ptr TranspileContext)) (raw-name String) (qualified-name String) (type-expr (Ptr SExpr)))
    (@intent "Transpile type alias")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Check if it's an Array type - requires special handling
      (if (is-array-type type-expr)
        (emit-array-typedef ctx qualified-name type-expr)
        ;; Standard typedef
        (let ((c-type (to-c-type-prefixed ctx type-expr)))
          (ctx-emit ctx (ctx-str5 ctx "typedef " c-type " " qualified-name ";"))
          (ctx-emit ctx "")
          ;; Register type
          (ctx-register-type ctx (TypeEntry raw-name qualified-name c-type false false false))))))

  (fn is-array-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is an Array type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Array"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-array-typedef ((ctx (Ptr TranspileContext)) (qualified-name String) (type-expr (Ptr SExpr)))
    (@intent "Emit typedef for Array type: typedef T NAME[SIZE];")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; (Array T size)
            (if (< len 3)
              ;; Invalid array type, fall back to pointer
              (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";")))
              (match (list-get items 1)
                ((some elem-type-expr)
                  (match (list-get items 2)
                    ((some size-expr)
                      (let ((elem-c-type (to-c-type-prefixed ctx elem-type-expr))
                            (size-str (get-number-as-string size-expr)))
                        ;; Emit: typedef T NAME[SIZE];
                        (ctx-emit ctx (ctx-str ctx "typedef " (ctx-str ctx elem-c-type (ctx-str ctx " " (ctx-str ctx qualified-name (ctx-str3 ctx "[" size-str "];"))))))
                        (ctx-emit ctx "")
                        ;; Register as pointer type for usage (arrays decay to pointers)
                        (let ((ptr-type (ctx-str ctx elem-c-type "*")))
                          (ctx-register-type ctx (TypeEntry qualified-name qualified-name ptr-type false false false)))))
                    ((none)
                      (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";"))))))
                ((none)
                  (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";"))))))))
        (else
          (ctx-emit ctx (ctx-str ctx "typedef void* " (ctx-str ctx qualified-name ";")))))))

  (fn get-number-as-string ((expr (Ptr SExpr)))
    (@intent "Get number value as string")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((number num)
        (. num raw))
      (else "0")))

  ;; ============================================================
  ;; Function Definition
  ;; ============================================================

  (fn transpile-function ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile function definition")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 3)
              (ctx-emit ctx "/* invalid fn: need name and params */")
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix EXCEPT for main function
                            (fn-name (if (string-eq base-name "main")
                                       base-name
                                       (ctx-prefix-type ctx base-name))))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            (emit-function-def ctx raw-name fn-name params-expr items))
                          ((none) (ctx-emit ctx "/* missing params */")))))
                    (else (ctx-emit ctx "/* function name must be symbol */"))))
                ((none) (ctx-emit ctx "/* missing function name */"))))))
        (else (ctx-emit ctx "/* invalid fn form */")))))

  (fn emit-function-def ((ctx (Ptr TranspileContext)) (raw-name String) (fn-name String) (params-expr (Ptr SExpr)) (items (List (Ptr SExpr))))
    (@intent "Emit function definition")
    (@spec (((Ptr TranspileContext) String String (Ptr SExpr) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          ;; Check for Result type first - if so, use the prefixed Result type name
          (result-type-opt (get-result-type-name ctx items))
          ;; Get raw return type
          (raw-return (get-return-type ctx items)))
      ;; Determine actual return type, preferring Result type name if available
      (let ((return-type String (match result-type-opt
                                  ((some result-name) result-name)
                                  ((none) raw-return)))
            ;; Special case: main returns int
            (actual-return (if (string-eq fn-name "main") "int" return-type))
            ;; Build parameter string
            (param-str (build-param-str ctx params-expr)))
        ;; Set current return type for typed none in return statements
        (ctx-set-current-return-type ctx actual-return)
        ;; Set current result type if present, otherwise clear any previous
        (match result-type-opt
          ((some result-name)
            (ctx-set-current-result-type ctx result-name))
          ((none)
            (ctx-clear-current-result-type ctx)))
        ;; Emit function signature
        (ctx-emit ctx (ctx-str5 ctx actual-return " " fn-name "(" (ctx-str ctx (if (string-eq param-str "") "void" param-str) ") {")))
        (ctx-indent ctx)
        ;; Push new scope and bind parameters
        (ctx-push-scope ctx)
        (bind-params-to-scope ctx params-expr)
        ;; Emit body (skip name, params, and annotations)
        (emit-function-body ctx items)
        ;; Pop scope
        (ctx-pop-scope ctx)
        (ctx-dedent ctx)
        (ctx-emit ctx "}")
        (ctx-emit ctx "")
        ;; Register function with parameter types for typed none handling
        (let ((param-types (collect-param-types ctx params-expr)))
          (ctx-register-func ctx (FuncEntry raw-name fn-name actual-return false (string-eq actual-return "slop_string") param-types)))
        ;; Clear current result type and return type
        (ctx-clear-current-result-type ctx)
        (ctx-clear-current-return-type ctx))))

  ;; ============================================================
  ;; Parameter Binding
  ;; ============================================================

  (fn bind-params-to-scope ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Bind function parameters to the current scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (bind-single-param ctx param))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))))

  (fn bind-single-param ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Bind a single parameter to the scope")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 2)
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (name-idx (if has-mode 1 0))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol name-sym)
                        (match (list-get items type-idx)
                          ((some type-expr)
                            (let ((param-name (. name-sym name))
                                  (c-name (to-c-name arena param-name))
                                  (c-type (to-c-type-prefixed ctx type-expr))
                                  (is-ptr (is-pointer-type type-expr)))
                              (ctx-bind-var ctx (VarEntry param-name c-name c-type is-ptr false))))
                          ((none) (do))))
                      (else (do))))
                  ((none) (do)))))))
        (else (do)))))

  (fn is-pointer-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type is a pointer type")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {type-expr != nil})
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (string-eq (. sym name) "Ptr"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn collect-param-types ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Collect C types of all parameters for typed none handling")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (List (Ptr FuncParamType))))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena))
          (result (list-new arena (Ptr FuncParamType))))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (let ((c-type (get-param-c-type ctx param))
                        (param-info (cast (Ptr FuncParamType) (arena-alloc arena 64))))
                    (set! (. (deref param-info) c-type) c-type)
                    (list-push result param-info)))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))
      result))

  (fn get-param-c-type ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Extract C type string from a parameter expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "void*"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (type-idx (if has-mode 2 1)))
                (match (list-get items type-idx)
                  ((some type-expr)
                    (to-c-type-prefixed ctx type-expr))
                  ((none) "void*"))))))
        (else "void*"))))

  ;; ============================================================
  ;; Function Forward Declaration
  ;; ============================================================

  (fn emit-forward-declaration ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit function forward declaration")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (when (>= len 3)
              ;; Get function name
              (match (list-get items 1)
                ((some name-expr)
                  (match (deref name-expr)
                    ((symbol name-sym)
                      (let ((raw-name (. name-sym name))
                            (base-name (to-c-name arena raw-name))
                            ;; Add module prefix to function name
                            (fn-name (ctx-prefix-type ctx base-name)))
                        ;; Get params
                        (match (list-get items 2)
                          ((some params-expr)
                            ;; Check for Result type first
                            (let ((result-type-opt (get-result-type-name ctx items))
                                  (raw-return (get-return-type ctx items)))
                              (let ((return-type String (match result-type-opt
                                                          ((some result-name) result-name)
                                                          ((none) raw-return)))
                                    ;; Special case: main returns int
                                    (actual-return (if (string-eq base-name "main") "int" return-type))
                                    (param-str (build-param-str ctx params-expr)))
                                (ctx-emit ctx (ctx-str5 ctx actual-return " " fn-name "("
                                                (ctx-str ctx (if (string-eq param-str "") "void" param-str) ");"))))))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))))

  (fn get-return-type ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Extract return type from @spec annotation")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (mut result "void"))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (when (is-spec-form item)
              (set! result (extract-spec-return-type ctx item))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn is-spec-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is @spec annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "@spec"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn extract-spec-return-type ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract return type from @spec")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (if (< (list-len items) 2)
              "void"
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((list body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (if (< body-len 1)
                          "void"
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              (to-c-type-prefixed ctx ret-type))
                            ((none) "void")))))
                    (else "void")))
                ((none) "void")))))
        (else "void"))))

  (fn get-result-type-name ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Extract Result type name from @spec if return type is a Result")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (Option String)))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (mut result (Option String) none))
      (while (and (< i len) (match result ((none) true) ((some _) false)))
        (match (list-get items i)
          ((some item)
            (when (is-spec-form item)
              (set! result (extract-result-type-name ctx item))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn extract-result-type-name ((ctx (Ptr TranspileContext)) (spec-expr (Ptr SExpr)))
    (@intent "Extract Result type name from @spec if it's a Result type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {spec-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref spec-expr)
        ((list lst)
          (let ((items (. lst items)))
            ;; @spec has form (@spec ((ParamTypes) -> ReturnType))
            (if (< (list-len items) 2)
              none
              (match (list-get items 1)
                ((some spec-body)
                  (match (deref spec-body)
                    ((list body-lst)
                      (let ((body-items (. body-lst items))
                            (body-len (list-len body-items)))
                        ;; Return type is the last element
                        (if (< body-len 1)
                          none
                          (match (list-get body-items (- body-len 1))
                            ((some ret-type)
                              (check-result-type ctx ret-type))
                            ((none) none)))))
                    (else none)))
                ((none) none)))))
        (else none))))

  (fn check-result-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)))
    (@intent "Check if type is a Result and return its name if so")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {type-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ;; Check for type alias (symbol)
        ((symbol sym)
          (let ((type-name (. sym name)))
            ;; First try result type alias lookup
            (match (ctx-lookup-result-type-alias ctx type-name)
              ((some alias-result) (some alias-result))
              ((none)
                ;; Alias not found - check if it's a registered type (imported Result typedef)
                ;; If registered, use its c-name as the result type
                (match (ctx-lookup-type ctx type-name)
                  ((some entry)
                    ;; Use the registered type's c-name
                    (some (. entry c-name)))
                  ((none) none))))))
        ;; Check for direct (Result OkType ErrType)
        ((list lst)
          (let ((items (. lst items)))
            ;; Check for (Result OkType ErrType)
            (if (< (list-len items) 3)
              none
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (if (string-eq (. sym name) "Result")
                        (match (list-get items 1)
                          ((some ok-type-expr)
                            (match (list-get items 2)
                              ((some err-type-expr)
                                ;; Convert to C types with proper module prefixes
                                (let ((ok-c-type (to-c-type-prefixed ctx ok-type-expr))
                                      (err-c-type (to-c-type-prefixed ctx err-type-expr))
                                      (result-name (build-result-name arena ok-c-type err-c-type)))
                                  (some result-name)))
                              ((none) none)))
                          ((none) none))
                        none))
                    (else none)))
                ((none) none)))))
        (else none))))

  (fn build-result-name ((arena Arena) (ok-type String) (err-type String))
    (@intent "Build the C type name for a Result type")
    (@spec ((Arena String String) -> String))
    ;; Use type-to-identifier for consistent naming with ctype.slop
    (let ((ok-id (type-to-identifier arena ok-type))
          (err-id (type-to-identifier arena err-type)))
      (string-concat arena
        (string-concat arena
          (string-concat arena "slop_result_" ok-id)
          "_")
        err-id)))

  (fn build-param-str ((ctx (Ptr TranspileContext)) (params-expr (Ptr SExpr)))
    (@intent "Build C parameter string from params list")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {params-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref params-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items))
                (mut result "")
                (mut i 0))
            (while (< i len)
              (match (list-get items i)
                ((some param)
                  (let ((param-str (build-single-param ctx param)))
                    (if (string-eq result "")
                      (set! result param-str)
                      (set! result (ctx-str3 ctx result ", " param-str)))))
                ((none) (do)))
              (set! i (+ i 1)))
            result))
        (else ""))))

  (fn build-single-param ((ctx (Ptr TranspileContext)) (param (Ptr SExpr)))
    (@intent "Build C parameter from single param")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {param != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref param)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              "/* invalid param */"
              ;; Check for mode: (mode name Type) or (name Type)
              (let ((has-mode (and (>= len 3) (is-param-mode items)))
                    (name-idx (if (and (>= len 3) (is-param-mode items)) 1 0))
                    (type-idx (if (and (>= len 3) (is-param-mode items)) 2 1)))
                (match (list-get items name-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol name-sym)
                        (match (list-get items type-idx)
                          ((some type-expr)
                            (let ((param-name (to-c-name arena (. name-sym name))))
                              ;; Check if type is a function type (Fn ...)
                              (if (is-fn-type type-expr)
                                ;; Function pointer: emit as ret_type(*name)(args)
                                (emit-fn-param-type ctx type-expr param-name)
                                ;; Normal type: emit as type name
                                (let ((param-type (to-c-type-prefixed ctx type-expr)))
                                  (ctx-str3 ctx param-type " " param-name)))))
                          ((none) "/* missing param type */")))
                      (else "/* param name must be symbol */")))
                  ((none) "/* missing param name */"))))))
        (else "/* param must be a list */"))))

  (fn is-param-mode ((items (List (Ptr SExpr))))
    (@intent "Check if first item is a parameter mode")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((symbol sym)
              (let ((name (. sym name)))
                (or (string-eq name "in")
                    (string-eq name "out")
                    (string-eq name "mut"))))
            (else false)))
        ((none) false))))

  (fn is-fn-type ((type-expr (Ptr SExpr)))
    (@intent "Check if type expression is a function type (Fn ...)")
    (@spec (((Ptr SExpr)) -> Bool))
    (match (deref type-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some first)
                (match (deref first)
                  ((symbol sym) (string-eq (. sym name) "Fn"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn emit-fn-param-type ((ctx (Ptr TranspileContext)) (type-expr (Ptr SExpr)) (param-name String))
    (@intent "Emit function pointer parameter with name inside: ret_type(*name)(args)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref type-expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-str ctx "void* " param-name)
              ;; Get return type (last item)
              (let ((ret-type (match (list-get items (- len 1))
                                ((some ret) (to-c-type-prefixed ctx ret))
                                ((none) "void"))))
                (if (= len 2)
                  ;; (Fn RetType) - no args
                  (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name ")(void)"))
                  ;; (Fn (args...) RetType)
                  (match (list-get items 1)
                    ((some args-expr)
                      (let ((args-str (build-fn-args-str-for-param ctx args-expr)))
                        (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name (ctx-str ctx ")" args-str)))))
                    ((none) (ctx-str ctx (ctx-str ctx ret-type "(*") (ctx-str ctx param-name ")(void)")))))))))
        (else (ctx-str ctx "void* " param-name)))))

  (fn build-fn-args-str-for-param ((ctx (Ptr TranspileContext)) (args-expr (Ptr SExpr)))
    (@intent "Build C function argument string for param type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref args-expr)
        ((list args-list)
          (let ((arg-items (. args-list items))
                (arg-count (list-len arg-items)))
            (if (= arg-count 0)
              "(void)"
              ;; Build comma-separated args
              (let ((mut result "(")
                    (mut i 0))
                (while (< i arg-count)
                  (match (list-get arg-items i)
                    ((some arg-expr)
                      (let ((arg-type (to-c-type-prefixed ctx arg-expr)))
                        (if (> i 0)
                          (set! result (ctx-str ctx result (ctx-str ctx ", " arg-type)))
                          (set! result (ctx-str ctx result arg-type)))))
                    ((none) ()))
                  (set! i (+ i 1)))
                (ctx-str ctx result ")")))))
        ;; Not a list - treat as void
        (_ "(void)"))))

  (fn emit-function-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit function body statements")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; Check if function returns void - if so, don't emit implicit return
    (let ((is-void-fn (match (ctx-get-current-return-type ctx)
                        ((some ret-type) (string-eq ret-type "void"))
                        ((none) true)))  ;; Default to void if no return type set
          (len (list-len items))
          (mut i 3)  ;; Start after name and params
          (body-start (find-body-start items)))
      ;; Emit body statements
      (set! i body-start)
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (let ((is-last (== i (- len 1)))
                  ;; Only treat last statement as return if function is non-void
                  (is-return (and is-last (not is-void-fn))))
              ;; Skip annotations
              (when (not (is-annotation item))
                (transpile-stmt ctx item is-return))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn find-body-start ((items (List (Ptr SExpr))))
    (@intent "Find index where function body starts (after annotations)")
    (@spec (((List (Ptr SExpr))) -> Int))
    (let ((len (list-len items))
          (mut i 3)
          (mut found false))
      (while (and (< i len) (not found))
        (match (list-get items i)
          ((some item)
            (if (is-annotation item)
              (set! i (+ i 1))
              (set! found true)))
          ((none) (set! found true))))
      i))

  (fn is-annotation ((expr (Ptr SExpr)))
    (@intent "Check if expression is an annotation")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((name (. sym name)))
                      (or (string-eq name "@intent")
                          (string-eq name "@spec")
                          (string-eq name "@pre")
                          (string-eq name "@post")
                          (string-eq name "@assume")
                          (string-eq name "@alloc")
                          (string-eq name "@example")
                          (string-eq name "@pure"))))
                  (else false)))
              ((none) false)))))
      (else false)))

) ;; end module
