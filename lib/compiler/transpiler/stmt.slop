;; ============================================================
;; SLOP Native Transpiler - Statement Module
;;
;; Transpiles SLOP statements to C code.
;; ============================================================

(module stmt
  (export
    ;; Main entry point
    transpile-stmt
    ;; Individual statement handlers
    transpile-let transpile-if transpile-while
    transpile-set transpile-when transpile-do
    transpile-with-arena transpile-cond
    transpile-for transpile-for-each
    ;; Statement form detection
    is-stmt-form)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import parser (sexpr-get-symbol-name))
  (import context (TranspileContext ctx-emit ctx-indent ctx-dedent ctx-push-scope ctx-pop-scope
                   ctx-bind-var ctx-lookup-var ctx-lookup-type
                   ctx-str ctx-str3 ctx-str4 ctx-str5 VarEntry
                   ctx-get-current-return-type ctx-is-capture-retval
                   to-c-type-prefixed ctx-add-error ctx-add-error-at ctx-sexpr-line ctx-sexpr-col ctx-list-first-line ctx-list-first-col
                   LastLambdaInfo ctx-get-last-lambda-info ctx-clear-last-lambda-info))
  (import ctype (to-c-type to-c-name))
  (import expr (transpile-expr infer-expr-c-type infer-expr-slop-type infer-collection-element-slop-type c-type-to-option-type-name))
  (import strlib (starts-with ends-with))
  (import match (transpile-match))

  ;; ============================================================
  ;; Type SExpr to String Conversion (for slop-type field)
  ;; ============================================================

  (fn sexpr-to-type-string ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Convert type SExpr to string representation for slop-type field")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Simple type name
        (. sym name))
      ((lst lst)
        ;; Compound type like (Map K V), (Ptr T), etc.
        (let ((items (. lst items))
              (len (list-len items))
              (mut result "(")
              (mut i 0))
          (while (< i len)
            (match (list-get items i)
              ((some item-expr)
                (let ((item-str (sexpr-to-type-string arena item-expr)))
                  (if (> i 0)
                    (set! result (string-concat arena result (string-concat arena " " item-str)))
                    (set! result (string-concat arena result item-str)))))
              ((none) (do)))
            (set! i (+ i 1)))
          (string-concat arena result ")")))
      ;; Other forms shouldn't appear as types
      (_ "")))

  ;; ============================================================
  ;; Arena-alloc Pointer Type Detection
  ;; ============================================================

  (fn get-arena-alloc-ptr-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract pointer type from arena-alloc call: (arena-alloc arena (sizeof Type)) -> Some(Type*)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items)))
            (if (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((sym head-sym)
                      (if (string-eq (. head-sym name) "arena-alloc")
                        ;; Found arena-alloc, check size arg for sizeof
                        (match (list-get items 2)
                          ((some size-expr)
                            (extract-sizeof-type-opt ctx size-expr))
                          ((none) (none)))
                        (none)))
                    (_ (none))))
                ((none) (none)))
              (none))))
        (_ (none)))))

  (fn extract-sizeof-type-opt ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract type from (sizeof Type) or bare type symbol and return Some(Type*)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ;; Check for bare type symbol (arena-alloc arena TypeName)
        ((sym sym)
          (let ((type-name (. sym name)))
            (match (ctx-lookup-type ctx type-name)
              ((some entry)
                ;; Known type - return pointer type
                (some (ctx-str ctx (. entry c-name) "*")))
              ((none) (none)))))
        ;; Check for (sizeof Type) expression
        ((lst lst)
          (let ((items (. lst items)))
            (if (>= (list-len items) 2)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((sym head-sym)
                      (if (string-eq (. head-sym name) "sizeof")
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr)))
                              (some (ctx-str ctx c-type "*"))))
                          ((none) (none)))
                        (none)))
                    (_ (none))))
                ((none) (none)))
              (none))))
        (_ (none)))))

  ;; ============================================================
  ;; Statement Form Detection
  ;; ============================================================

  (fn is-stmt-form ((expr (Ptr SExpr)))
    (@intent "Check if expression should be transpiled as a statement")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (let ((name (. sym name)))
                      (or (string-eq name "let")
                          (string-eq name "let*")
                          (string-eq name "if")
                          (string-eq name "when")
                          (string-eq name "while")
                          (string-eq name "for")
                          (string-eq name "for-each")
                          (string-eq name "set!")
                          (string-eq name "do")
                          (string-eq name "match")
                          (string-eq name "cond")
                          (string-eq name "with-arena"))))
                  (else false)))
              ((none) false)))))
      (else false)))

  ;; ============================================================
  ;; Let Binding
  ;; ============================================================

  (fn transpile-let ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a let binding")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-add-error-at ctx "invalid let: missing bindings" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
              (do
                ;; Open new C block scope
                (ctx-emit ctx "{")
                (ctx-indent ctx)
                (ctx-push-scope ctx)
                ;; Get bindings list
                (match (list-get items 1)
                  ((some bindings-expr)
                    (match (deref bindings-expr)
                      ((lst bindings-lst)
                        ;; Process each binding
                        (transpile-bindings ctx (. bindings-lst items)))
                      (else (ctx-add-error-at ctx "invalid bindings" (ctx-sexpr-line bindings-expr) (ctx-sexpr-col bindings-expr)))))
                  ((none) (ctx-add-error-at ctx "missing bindings" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))
                ;; Process body statements
                (let ((mut i 2))
                  (while (< i len)
                    (match (list-get items i)
                      ((some body-expr)
                        (let ((is-last (== i (- len 1))))
                          (transpile-stmt ctx body-expr (and is-return is-last))))
                      ((none) (do)))
                    (set! i (+ i 1))))
                ;; Close scope
                (ctx-pop-scope ctx)
                (ctx-dedent ctx)
                (ctx-emit ctx "}")))))
        (else (ctx-add-error-at ctx "invalid let" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))

  (fn transpile-bindings ((ctx (Ptr TranspileContext)) (bindings (List (Ptr SExpr))))
    (@intent "Transpile let bindings")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len bindings))
          (mut i 0))
      (while (< i len)
        (match (list-get bindings i)
          ((some binding-expr)
            (transpile-single-binding ctx binding-expr))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn transpile-single-binding ((ctx (Ptr TranspileContext)) (binding (Ptr SExpr)))
    (@intent "Transpile a single let binding")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {binding != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref binding)
        ((lst binding-lst)
          (let ((items (. binding-lst items))
                (len (list-len items)))
            ;; Skip 'mut' keyword if present
            (let ((has-mut (binding-has-mut items))
                  (start-idx (if (binding-has-mut items) 1 0)))
              (if (< (- len start-idx) 2)
                (ctx-add-error-at ctx "invalid binding: need name and value" (ctx-sexpr-line binding) (ctx-sexpr-col binding))
                (match (list-get items start-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((sym name-sym)
                        (let ((raw-name (. name-sym name))
                              (var-name (to-c-name arena raw-name)))
                          ;; Check for typed binding: (name Type init) or (mut name Type init)
                          (if (>= (- len start-idx) 3)
                            ;; Typed binding
                            (match (list-get items (+ start-idx 1))
                              ((some type-expr)
                                (match (list-get items (+ start-idx 2))
                                  ((some init-expr)
                                    (let ((c-type (to-c-type-prefixed ctx type-expr)))
                                      ;; Special case: handle Option type initialization
                                      (let ((final-init
                                              (if (starts-with c-type "slop_option_")
                                                ;; Option type - check for special constructors
                                                (let ((some-val (get-some-value init-expr)))
                                                  (match some-val
                                                    ((some val-expr)
                                                      ;; (some value) - generate typed Option literal
                                                      (let ((val-c (transpile-expr ctx val-expr)))
                                                        (ctx-str5 ctx "(" c-type "){.has_value = 1, .value = " val-c "}")))
                                                    ((none)
                                                      ;; Not a some expression - check for none BEFORE transpiling
                                                      (if (is-none-form init-expr)
                                                        (ctx-str3 ctx "(" c-type "){.has_value = false}")
                                                        (transpile-expr ctx init-expr)))))
                                                ;; Not an Option type - regular transpilation
                                                (transpile-expr ctx init-expr))))
                                        ;; Emit declaration with type
                                        (ctx-emit ctx (ctx-str5 ctx c-type " " var-name " = " (ctx-str ctx final-init ";")))
                                        ;; Bind variable in scope with SLOP type for map-get inference
                                        (let ((slop-type-str (sexpr-to-type-string arena type-expr)))
                                          (ctx-bind-var ctx (VarEntry raw-name var-name c-type slop-type-str false has-mut false "" ""))))))
                                  ((none) (ctx-add-error-at ctx "missing init" (ctx-sexpr-line binding) (ctx-sexpr-col binding)))))
                              ((none) (ctx-add-error-at ctx "missing type" (ctx-sexpr-line binding) (ctx-sexpr-col binding))))
                            ;; Untyped binding: (name init)
                            (match (list-get items (+ start-idx 1))
                              ((some init-expr)
                                (let ((init-c (transpile-expr ctx init-expr))
                                      ;; Infer SLOP type for map/set key type propagation
                                      (inferred-slop-type (infer-expr-slop-type ctx init-expr))
                                      ;; Check if init is arena-alloc to get proper pointer type
                                      (ptr-type-opt (get-arena-alloc-ptr-type ctx init-expr)))
                                  (match ptr-type-opt
                                    ((some ptr-type)
                                      ;; Arena-alloc returns pointer - register as pointer type
                                      (ctx-emit ctx (ctx-str5 ctx "__auto_type " var-name " = " init-c ";"))
                                      (ctx-bind-var ctx (VarEntry raw-name var-name ptr-type inferred-slop-type true has-mut false "" "")))
                                    ((none)
                                      ;; Regular binding - infer type from init expression
                                      (let ((inferred-type (infer-expr-c-type ctx init-expr))
                                            (lambda-info (ctx-get-last-lambda-info ctx))
                                            ;; For mutable vars with simple primitive types, use explicit type
                                            ;; to avoid __auto_type mismatch in closures. Complex types (lists, etc)
                                            ;; still use __auto_type since type inference may be incorrect.
                                            (use-explicit-type (and has-mut (is-simple-primitive-c-type inferred-type)))
                                            (decl-type (if use-explicit-type (ctx-str ctx inferred-type " ") "__auto_type ")))
                                        (ctx-emit ctx (ctx-str5 ctx decl-type var-name " = " init-c ";"))
                                        ;; Check if this is a closure binding
                                        (if (. lambda-info is-closure)
                                          (do
                                            ;; Closure - record lambda info in VarEntry
                                            (ctx-bind-var ctx (VarEntry raw-name var-name "slop_closure_t" inferred-slop-type false has-mut true (. lambda-info env-type) (. lambda-info lambda-name)))
                                            (ctx-clear-last-lambda-info ctx))
                                          ;; Regular binding - check if inferred type is a pointer (ends with *)
                                          (ctx-bind-var ctx (VarEntry raw-name var-name inferred-type inferred-slop-type (ends-with inferred-type "*") has-mut false "" ""))))))))
                              ((none) (ctx-add-error-at ctx "missing init" (ctx-sexpr-line binding) (ctx-sexpr-col binding)))))))
                      (else (ctx-add-error-at ctx "binding name must be symbol" (ctx-sexpr-line name-expr) (ctx-sexpr-col name-expr)))))
                  ((none) (ctx-add-error-at ctx "missing binding name" (ctx-sexpr-line binding) (ctx-sexpr-col binding))))))))
        (else (ctx-add-error-at ctx "binding must be a list" (ctx-sexpr-line binding) (ctx-sexpr-col binding))))))

  (fn binding-has-mut ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with 'mut'")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((sym sym) (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn is-simple-primitive-c-type ((t String))
    (@intent "Check if type is a simple C primitive safe for explicit declaration")
    (@spec ((String) -> Bool))
    ;; Only use explicit types for primitives where __auto_type inference
    ;; from literals could cause type mismatches (e.g., int vs int64_t).
    ;; Excludes "Unknown" and complex types which should use __auto_type.
    (cond
      ((string-eq t "int64_t") true)
      ((string-eq t "int32_t") true)
      ((string-eq t "int16_t") true)
      ((string-eq t "int8_t") true)
      ((string-eq t "uint64_t") true)
      ((string-eq t "uint32_t") true)
      ((string-eq t "uint16_t") true)
      ((string-eq t "uint8_t") true)
      ((string-eq t "double") true)
      ((string-eq t "float") true)
      ((string-eq t "size_t") true)
      ((string-eq t "bool") true)
      ((string-eq t "int") true)
      (else false)))

  (fn get-some-value ((expr (Ptr SExpr)))
    (@intent "If expr is (some value), return the value expression")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pre {expr != nil})
    (let ((mut result (Option (Ptr SExpr)) none))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some head-expr)
                  (match (deref head-expr)
                    ((sym sym)
                      (when (string-eq (. sym name) "some")
                        (match (list-get items 1)
                          ((some val)
                            (set! result (some val)))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))
      result))

  (fn is-none-form ((expr (Ptr SExpr)))
    (@intent "Check if expression is none symbol or (none) list")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym) (string-eq (. sym name) "none"))
      ((lst lst)
        (let ((items (. lst items)))
          (if (== (list-len items) 1)
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (string-eq (. sym name) "none"))
                  (else false)))
              ((none) false))
            false)))
      (else false)))

  ;; ============================================================
  ;; If Statement
  ;; ============================================================

  (fn transpile-if ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile an if statement")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 3)
            (ctx-add-error-at ctx "invalid if: need condition and then-branch" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
            (do
              ;; Get condition
              (match (list-get items 1)
                ((some cond-expr)
                  (let ((cond-c (transpile-expr ctx cond-expr)))
                    ;; Emit if
                    (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                    (ctx-indent ctx)
                    ;; Emit then branch
                    (match (list-get items 2)
                      ((some then-expr)
                        (transpile-stmt ctx then-expr is-return))
                      ((none) (do)))
                    (ctx-dedent ctx)
                    ;; Emit else branch if present
                    (if (>= len 4)
                      (do
                        (ctx-emit ctx "} else {")
                        (ctx-indent ctx)
                        (match (list-get items 3)
                          ((some else-expr)
                            (transpile-stmt ctx else-expr is-return))
                          ((none) (do)))
                        (ctx-dedent ctx)
                        (ctx-emit ctx "}"))
                      (ctx-emit ctx "}"))))
                ((none) (ctx-add-error-at ctx "missing if condition" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))))
      (else (ctx-add-error-at ctx "invalid if" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))

  ;; ============================================================
  ;; When Statement
  ;; ============================================================

  (fn transpile-when ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a when statement (if without else)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 3)
            (ctx-add-error-at ctx "invalid when: need condition and body" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
            (match (list-get items 1)
              ((some cond-expr)
                (let ((cond-c (transpile-expr ctx cond-expr)))
                  (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                  (ctx-indent ctx)
                  ;; Process body statements
                  (let ((mut i 2))
                    (while (< i len)
                      (match (list-get items i)
                        ((some body-expr)
                          (transpile-stmt ctx body-expr false))
                        ((none) (do)))
                      (set! i (+ i 1))))
                  (ctx-dedent ctx)
                  (ctx-emit ctx "}")))
              ((none) (ctx-add-error-at ctx "missing when condition" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))))
      (else (ctx-add-error-at ctx "invalid when" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))

  ;; ============================================================
  ;; While Loop
  ;; ============================================================

  (fn transpile-while ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a while loop")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 3)
            (ctx-add-error-at ctx "invalid while: need condition and body" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
            (match (list-get items 1)
              ((some cond-expr)
                (let ((cond-c (transpile-expr ctx cond-expr)))
                  (ctx-emit ctx (ctx-str3 ctx "while (" cond-c ") {"))
                  (ctx-indent ctx)
                  ;; Process body statements
                  (let ((mut i 2))
                    (while (< i len)
                      (match (list-get items i)
                        ((some body-expr)
                          (transpile-stmt ctx body-expr false))
                        ((none) (do)))
                      (set! i (+ i 1))))
                  (ctx-dedent ctx)
                  (ctx-emit ctx "}")))
              ((none) (ctx-add-error-at ctx "missing while condition" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))))
      (else (ctx-add-error-at ctx "invalid while" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))

  ;; ============================================================
  ;; Set! Assignment
  ;; ============================================================

  (fn transpile-set ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a set! assignment")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (cond
              ;; 5-arg form: (set! target field Type value) - typed field assignment
              ((== len 5)
                (transpile-typed-field-set ctx items))
              ;; 4-arg form: (set! target field value) - field assignment
              ((== len 4)
                (transpile-field-set ctx items))
              ;; 3-arg form: (set! target value) - simple assignment
              ((== len 3)
                (match (list-get items 1)
                  ((some target-expr)
                    (match (list-get items 2)
                      ((some value-expr)
                        (let ((target-c (transpile-expr ctx target-expr))
                              (target-type-opt (get-var-c-type ctx target-expr)))
                          ;; Check if target is Option type and value is (some ...)
                          (match target-type-opt
                            ((some target-type)
                              (if (starts-with target-type "slop_option_")
                                ;; Option type - handle (some ...) and (none) specially
                                (let ((some-val-opt (get-some-value value-expr)))
                                  (match some-val-opt
                                    ((some val-expr)
                                      ;; (some value) - generate typed Option literal
                                      (let ((val-c (transpile-expr ctx val-expr)))
                                        (ctx-emit ctx (ctx-str ctx target-c (ctx-str5 ctx " = (" target-type "){.has_value = 1, .value = " val-c "};")))))
                                    ((none)
                                      ;; Check for none BEFORE transpiling
                                      (if (is-none-form value-expr)
                                        (ctx-emit ctx (ctx-str ctx target-c (ctx-str3 ctx " = (" target-type "){.has_value = false};")))
                                        (let ((value-c (transpile-expr ctx value-expr)))
                                          (ctx-emit ctx (ctx-str4 ctx target-c " = " value-c ";")))))))
                                ;; Not Option type - regular assignment
                                (let ((value-c (transpile-expr ctx value-expr)))
                                  (ctx-emit ctx (ctx-str4 ctx target-c " = " value-c ";")))))
                            ;; Couldn't get target type - try to infer from value
                            ((none)
                              (let ((some-val-opt (get-some-value value-expr)))
                                (match some-val-opt
                                  ((some inner-expr)
                                    ;; Value is (some x) - infer Option type from inner value
                                    (let ((inner-c (transpile-expr ctx inner-expr))
                                          (inner-type (infer-expr-c-type ctx inner-expr))
                                          (option-type (c-type-to-option-type-name ctx inner-type)))
                                      (ctx-emit ctx (ctx-str ctx target-c (ctx-str5 ctx " = (" option-type "){.has_value = 1, .value = " inner-c "};")))))
                                  ((none)
                                    ;; Check for (none) with return type context
                                    (if (is-none-form value-expr)
                                      (match (ctx-get-current-return-type ctx)
                                        ((some ret-type)
                                          (if (starts-with ret-type "slop_option_")
                                            (ctx-emit ctx (ctx-str ctx target-c (ctx-str3 ctx " = (" ret-type "){.has_value = false};")))
                                            (let ((value-c (transpile-expr ctx value-expr)))
                                              (ctx-emit ctx (ctx-str4 ctx target-c " = " value-c ";")))))
                                        ((none)
                                          (let ((value-c (transpile-expr ctx value-expr)))
                                            (ctx-emit ctx (ctx-str4 ctx target-c " = " value-c ";")))))
                                      ;; Regular expression
                                      (let ((value-c (transpile-expr ctx value-expr)))
                                        (ctx-emit ctx (ctx-str4 ctx target-c " = " value-c ";")))))))))))
                      ((none) (ctx-add-error-at ctx "missing set! value" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))
                  ((none) (ctx-add-error-at ctx "missing set! target" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))
              (else (ctx-add-error-at ctx "invalid set!: need target and value" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))
        (else (ctx-add-error-at ctx "invalid set!" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))

  (fn get-var-c-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Get the C type of a variable expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (match (deref expr)
      ((sym sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry) (some (. var-entry c-type)))
            ((none) none))))
      (else none)))

  (fn is-pointer-target ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression is a pointer variable")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Look up variable type in context
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry)
              (let ((c-type (. var-entry c-type)))
                (ends-with c-type "*")))
            ((none) false))))
      (_ false)))

  (fn transpile-field-set ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile field assignment: (set! target field value)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; (set! (deref ptr) field value) -> (*ptr).field = value;
    ;; (set! ptr field value) -> ptr->field = value; (if ptr is pointer)
    ;; (set! target field value) -> target.field = value;
    (let ((arena (. (deref ctx) arena)))
      (match (list-get items 1)
        ((some target-expr)
          (match (list-get items 2)
            ((some field-expr)
              (match (list-get items 3)
                ((some value-expr)
                  (let ((field-name (get-symbol-name arena field-expr))
                        (value-c (transpile-expr ctx value-expr)))
                  ;; Check if target is (deref x)
                  (if (is-deref-expr target-expr)
                    ;; (set! (deref ptr) field value) -> (*ptr).field = value;
                    (let ((inner-expr (get-deref-inner target-expr))
                          (inner-c (transpile-expr ctx inner-expr)))
                      (ctx-emit ctx (ctx-str ctx "(*" (ctx-str ctx inner-c (ctx-str ctx ")." (ctx-str ctx field-name (ctx-str ctx " = " (ctx-str ctx value-c ";"))))))))
                    ;; Check if target is a pointer variable
                    (let ((target-c (transpile-expr ctx target-expr))
                          (is-ptr (is-pointer-target ctx target-expr)))
                      (if is-ptr
                        ;; Pointer access: target->field = value;
                        (ctx-emit ctx (ctx-str ctx target-c (ctx-str ctx "->" (ctx-str ctx field-name (ctx-str ctx " = " (ctx-str ctx value-c ";"))))))
                        ;; Value access: target.field = value;
                        (ctx-emit ctx (ctx-str ctx target-c (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " (ctx-str ctx value-c ";")))))))))))
              ((none) (ctx-add-error-at ctx "missing set! value" (ctx-sexpr-line target-expr) (ctx-sexpr-col target-expr)))))
            ((none) (ctx-add-error-at ctx "missing set! field" (ctx-sexpr-line target-expr) (ctx-sexpr-col target-expr)))))
        ((none) (ctx-add-error-at ctx "missing set! target" (ctx-list-first-line items) (ctx-list-first-col items))))))

  (fn transpile-typed-field-set ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Transpile typed field assignment: (set! target field Type value)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    ;; 5-arg form: (set! target field Type value)
    ;; items[0]=set!, items[1]=target, items[2]=field, items[3]=Type, items[4]=value
    (let ((arena (. (deref ctx) arena)))
      (match (list-get items 1)
        ((some target-expr)
          (match (list-get items 2)
            ((some field-expr)
              (match (list-get items 3)
                ((some type-expr)
                  (match (list-get items 4)
                    ((some value-expr)
                      (let ((field-name (get-symbol-name arena field-expr))
                            (c-type (to-c-type arena type-expr)))
                        ;; Build target access: (*ptr). or target-> or target.
                        (let ((target-access
                                (if (is-deref-expr target-expr)
                                  ;; (deref ptr) -> (*ptr).
                                  (let ((inner-expr (get-deref-inner target-expr))
                                        (inner-c (transpile-expr ctx inner-expr)))
                                    (ctx-str ctx "(*" (ctx-str ctx inner-c ").")))
                                  ;; Check if pointer
                                  (let ((target-c (transpile-expr ctx target-expr))
                                        (is-ptr (is-pointer-target ctx target-expr)))
                                    (if is-ptr
                                      (ctx-str ctx target-c "->")
                                      (ctx-str ctx target-c "."))))))
                          ;; Check if Option type
                          (if (starts-with c-type "slop_option_")
                            ;; Option type - handle none and (some x)
                            (if (is-none-form value-expr)
                              ;; none -> {.has_value = false}
                              (ctx-emit ctx (ctx-str ctx target-access
                                (ctx-str ctx field-name
                                  (ctx-str3 ctx " = (" c-type "){.has_value = false};"))))
                              ;; Check for (some x)
                              (match (get-some-value value-expr)
                                ((some inner-val)
                                  ;; (some x) -> {.has_value = 1, .value = x}
                                  (let ((val-c (transpile-expr ctx inner-val)))
                                    (ctx-emit ctx (ctx-str ctx target-access
                                      (ctx-str ctx field-name
                                        (ctx-str5 ctx " = (" c-type "){.has_value = 1, .value = " val-c "};"))))))
                                ((none)
                                  ;; Regular value
                                  (let ((val-c (transpile-expr ctx value-expr)))
                                    (ctx-emit ctx (ctx-str ctx target-access
                                      (ctx-str ctx field-name
                                        (ctx-str ctx " = " (ctx-str ctx val-c ";")))))))))
                            ;; Not Option type - regular assignment
                            (let ((val-c (transpile-expr ctx value-expr)))
                              (ctx-emit ctx (ctx-str ctx target-access
                                (ctx-str ctx field-name
                                  (ctx-str ctx " = " (ctx-str ctx val-c ";"))))))))))
                    ((none) (ctx-add-error-at ctx "missing set! value" (ctx-sexpr-line type-expr) (ctx-sexpr-col type-expr)))))
                ((none) (ctx-add-error-at ctx "missing set! type" (ctx-sexpr-line field-expr) (ctx-sexpr-col field-expr)))))
            ((none) (ctx-add-error-at ctx "missing set! field" (ctx-sexpr-line target-expr) (ctx-sexpr-col target-expr)))))
        ((none) (ctx-add-error-at ctx "missing set! target" (ctx-list-first-line items) (ctx-list-first-col items))))))

  (fn is-deref-expr ((expr (Ptr SExpr)))
    (@intent "Check if expression is (deref x)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym) (string-eq (. sym name) "deref"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn get-deref-inner ((expr (Ptr SExpr)))
    (@intent "Get the inner expression from (deref x)")
    (@spec (((Ptr SExpr)) -> (Ptr SExpr)))
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (match (list-get items 1)
            ((some inner) inner)
            ;; Return expr as fallback (should not happen)
            ((none) expr))))
      (else expr)))

  (fn get-symbol-name ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Get name from a symbol expression, converted to C identifier")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym) (to-c-name arena (. sym name)))
      (else "/* unknown field */")))

  ;; ============================================================
  ;; Do Block
  ;; ============================================================

  (fn transpile-do ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a do block")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items))
              (mut i 1))
          (while (< i len)
            (match (list-get items i)
              ((some body-expr)
                (let ((is-last (== i (- len 1))))
                  (transpile-stmt ctx body-expr (and is-return is-last))))
              ((none) (do)))
            (set! i (+ i 1)))))
      (else (do))))

  ;; ============================================================
  ;; With-Arena Block
  ;; ============================================================

  (fn transpile-with-arena ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a with-arena block")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; (with-arena size body...) - unnamed form, binds 'arena'
    ;; (with-arena :as name size body...) - named form, binds 'name'
    ;; Generates:
    ;; {
    ;;     slop_arena _arena_<name> = slop_arena_new(size);
    ;;     slop_arena* <name> = &_arena_<name>;
    ;;     <body statements>
    ;;     slop_arena_free(<name>);
    ;; }
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          (if (< len 2)
            (ctx-add-error-at ctx "invalid with-arena: need size" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
            ;; Detect :as form - check if items[1] is symbol ":as"
            (let ((is-named (match (list-get items 1)
                              ((some item1)
                                (string-eq (sexpr-get-symbol-name item1) ":as"))
                              ((none) false)))
                  (arena-name (if is-named
                                (match (list-get items 2)
                                  ((some name-expr) (sexpr-get-symbol-name name-expr))
                                  ((none) "arena"))
                                "arena"))
                  (size-idx (if is-named 3 1))
                  (body-start (if is-named 4 2))
                  ;; C local var: _arena for unnamed (backward compat), _arena_<name> for named
                  (c-local (if is-named
                             (string-concat (. (deref ctx) arena) "_arena_" arena-name)
                             "_arena")))
              ;; Validate minimum length for named form
              (if (and is-named (< len 4))
                (ctx-add-error-at ctx "with-arena :as requires name and size" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
                (do
                  ;; Open block
                  (ctx-emit ctx "{")
                  (ctx-indent ctx)
                  (ctx-push-scope ctx)
                  ;; Get size expression
                  (match (list-get items size-idx)
                    ((some size-expr)
                      (let ((size-c (transpile-expr ctx size-expr)))
                        ;; Debug guard: check size > 0
                        (ctx-emit ctx "#ifdef SLOP_DEBUG")
                        (ctx-emit ctx (ctx-str3 ctx "SLOP_PRE((" size-c ") > 0, \"with-arena size must be positive\");"))
                        (ctx-emit ctx "#endif")
                        ;; Emit arena creation
                        (ctx-emit ctx (ctx-str5 ctx "slop_arena " c-local " = slop_arena_new(" size-c ");"))
                        ;; Debug guard: check allocation succeeded
                        (ctx-emit ctx "#ifdef SLOP_DEBUG")
                        (ctx-emit ctx (ctx-str3 ctx "SLOP_PRE(" c-local ".base != NULL, \"arena allocation failed\");"))
                        (ctx-emit ctx "#endif")
                        (ctx-emit ctx (ctx-str5 ctx "slop_arena* " arena-name " = &" c-local ";"))))
                    ((none) (ctx-add-error-at ctx "missing size" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))
                  ;; Bind arena variable in scope
                  (ctx-bind-var ctx (VarEntry arena-name arena-name "slop_arena*" "" true false false "" ""))
                  ;; Process body statements
                  (let ((mut i body-start))
                    (while (< i len)
                      (match (list-get items i)
                        ((some body-expr)
                          (let ((is-last (== i (- len 1))))
                            (transpile-stmt ctx body-expr (and is-return is-last))))
                        ((none) (do)))
                      (set! i (+ i 1))))
                  ;; Free arena
                  (ctx-emit ctx (ctx-str3 ctx "slop_arena_free(" arena-name ");"))
                  ;; Close scope
                  (ctx-pop-scope ctx)
                  (ctx-dedent ctx)
                  (ctx-emit ctx "}")))))))
      (else (ctx-add-error-at ctx "invalid with-arena" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))

  ;; ============================================================
  ;; Cond Statement
  ;; ============================================================

  (fn transpile-cond ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a cond expression - chained if/else if/else")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; (cond (test1 body1...) (test2 body2...) (else body...))
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items))
              (mut i 1)
              (mut first true))
          (while (< i len)
            (match (list-get items i)
              ((some clause-expr)
                (match (deref clause-expr)
                  ((lst clause-lst)
                    (let ((clause-items (. clause-lst items))
                          (clause-len (list-len clause-items)))
                      (if (< clause-len 1)
                        (ctx-add-error-at ctx "invalid cond clause" (ctx-sexpr-line clause-expr) (ctx-sexpr-col clause-expr))
                        (match (list-get clause-items 0)
                          ((some test-expr)
                            (match (deref test-expr)
                              ;; Check for 'else' keyword
                              ((sym sym)
                                (if (string-eq (. sym name) "else")
                                  (do
                                    ;; else clause
                                    (ctx-emit ctx "} else {")
                                    (ctx-indent ctx)
                                    (transpile-cond-body ctx clause-items 1 is-return)
                                    (ctx-dedent ctx))
                                  (do
                                    ;; Regular test clause
                                    (let ((cond-c (transpile-expr ctx test-expr)))
                                      (if first
                                        (do
                                          (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                                          (set! first false))
                                        (ctx-emit ctx (ctx-str3 ctx "} else if (" cond-c ") {")))
                                      (ctx-indent ctx)
                                      (transpile-cond-body ctx clause-items 1 is-return)
                                      (ctx-dedent ctx)))))
                              ;; Non-symbol test - evaluate as expression
                              (_
                                (let ((cond-c (transpile-expr ctx test-expr)))
                                  (if first
                                    (do
                                      (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                                      (set! first false))
                                    (ctx-emit ctx (ctx-str3 ctx "} else if (" cond-c ") {")))
                                  (ctx-indent ctx)
                                  (transpile-cond-body ctx clause-items 1 is-return)
                                  (ctx-dedent ctx)))))
                          ((none) (ctx-add-error-at ctx "missing test" (ctx-sexpr-line clause-expr) (ctx-sexpr-col clause-expr)))))))
                  (else (ctx-add-error-at ctx "cond clause must be list" (ctx-sexpr-line clause-expr) (ctx-sexpr-col clause-expr)))))
              ((none) (do)))
            (set! i (+ i 1)))
          ;; Close final brace
          (when (not first)
            (ctx-emit ctx "}"))))
      (else (ctx-add-error-at ctx "invalid cond" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))

  (fn transpile-cond-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int) (is-return Bool))
    (@intent "Transpile body statements of a cond clause")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some body-expr)
            (let ((is-last (== i (- len 1))))
              (transpile-stmt ctx body-expr (and is-return is-last))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; For Loop
  ;; ============================================================

  (fn transpile-for ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a for loop: (for (i start end) body)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-add-error-at ctx "invalid for: need binding" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
              (match (list-get items 1)
                ((some binding-expr)
                  (match (deref binding-expr)
                    ((lst binding-lst)
                      (let ((binding-items (. binding-lst items))
                            (binding-len (list-len binding-items)))
                        (if (< binding-len 3)
                          (ctx-add-error-at ctx "for binding needs (var start end)" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr))
                          (match (list-get binding-items 0)
                            ((some var-expr)
                              (match (deref var-expr)
                                ((sym var-sym)
                                  (let ((var-name (to-c-name arena (. var-sym name))))
                                    (match (list-get binding-items 1)
                                      ((some start-expr)
                                        (match (list-get binding-items 2)
                                          ((some end-expr)
                                            (let ((start-c (transpile-expr ctx start-expr))
                                                  (end-c (transpile-expr ctx end-expr)))
                                              ;; Emit: for (int64_t var = start; var < end; var++)
                                              (ctx-emit ctx (ctx-str5 ctx "for (int64_t " var-name " = " start-c
                                                              (ctx-str5 ctx "; " var-name " < " end-c
                                                                (ctx-str3 ctx "; " var-name "++) {"))))
                                              (ctx-indent ctx)
                                              ;; Bind loop variable
                                              (ctx-push-scope ctx)
                                              (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "int64_t" "" false false false "" ""))
                                              ;; Process body
                                              (let ((mut i 2))
                                                (while (< i len)
                                                  (match (list-get items i)
                                                    ((some body-expr)
                                                      (transpile-stmt ctx body-expr false))
                                                    ((none) (do)))
                                                  (set! i (+ i 1))))
                                              (ctx-pop-scope ctx)
                                              (ctx-dedent ctx)
                                              (ctx-emit ctx "}")))
                                          ((none) (ctx-add-error-at ctx "missing end" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr)))))
                                      ((none) (ctx-add-error-at ctx "missing start" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr))))))
                                (else (ctx-add-error-at ctx "for var must be symbol" (ctx-sexpr-line var-expr) (ctx-sexpr-col var-expr)))))
                            ((none) (ctx-add-error-at ctx "missing var" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr)))))))
                    (else (ctx-add-error-at ctx "for binding must be list" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr)))))
                ((none) (ctx-add-error-at ctx "missing binding" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))))
        (else (ctx-add-error-at ctx "invalid for" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))

  ;; ============================================================
  ;; For-Each Loop
  ;; ============================================================

  (fn transpile-for-each ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Transpile a for-each loop: (for-each (item coll) body)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 2)
              (ctx-add-error-at ctx "invalid for-each: need binding" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
              (match (list-get items 1)
                ((some binding-expr)
                  (match (deref binding-expr)
                    ((lst binding-lst)
                      (let ((binding-items (. binding-lst items))
                            (binding-len (list-len binding-items)))
                        (if (< binding-len 2)
                          (ctx-add-error-at ctx "for-each binding needs (var coll)" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr))
                          (match (list-get binding-items 0)
                            ((some var-expr)
                              (match (deref var-expr)
                                ((sym var-sym)
                                  (let ((var-name (to-c-name arena (. var-sym name))))
                                    (match (list-get binding-items 1)
                                      ((some coll-expr)
                                        (let ((coll-c (transpile-expr ctx coll-expr)))
                                          ;; Emit: for (size_t _i = 0; _i < coll.len; _i++)
                                          (ctx-emit ctx (ctx-str3 ctx "for (size_t _i = 0; _i < " coll-c ".len; _i++) {"))
                                          (ctx-indent ctx)
                                          ;; Emit: __auto_type var = coll.data[_i];
                                          (ctx-emit ctx (ctx-str5 ctx "__auto_type " var-name " = " coll-c ".data[_i];"))
                                          ;; Bind loop variable with inferred element type
                                          (ctx-push-scope ctx)
                                          (let ((elem-slop-type (infer-collection-element-slop-type ctx coll-expr)))
                                            (ctx-bind-var ctx (VarEntry (. var-sym name) var-name "auto" elem-slop-type false false false "" "")))
                                          ;; Process body
                                          (let ((mut i 2))
                                            (while (< i len)
                                              (match (list-get items i)
                                                ((some body-expr)
                                                  (transpile-stmt ctx body-expr false))
                                                ((none) (do)))
                                              (set! i (+ i 1))))
                                          (ctx-pop-scope ctx)
                                          (ctx-dedent ctx)
                                          (ctx-emit ctx "}")))
                                      ((none) (ctx-add-error-at ctx "missing collection" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr))))))
                                (else (ctx-add-error-at ctx "for-each var must be symbol" (ctx-sexpr-line var-expr) (ctx-sexpr-col var-expr)))))
                            ((none) (ctx-add-error-at ctx "missing var" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr)))))))
                    (else (ctx-add-error-at ctx "for-each binding must be list" (ctx-sexpr-line binding-expr) (ctx-sexpr-col binding-expr)))))
                ((none) (ctx-add-error-at ctx "missing binding" (ctx-sexpr-line expr) (ctx-sexpr-col expr)))))))
        (else (ctx-add-error-at ctx "invalid for-each" (ctx-sexpr-line expr) (ctx-sexpr-col expr))))))

  ;; ============================================================
  ;; Main Statement Dispatcher
  ;; ============================================================

  (fn transpile-stmt ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a SLOP statement to C code")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            (ctx-add-error-at ctx "empty list" (ctx-sexpr-line expr) (ctx-sexpr-col expr))
            (match (list-get items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ((or (string-eq op "let") (string-eq op "let*"))
                          (transpile-let ctx expr is-return))
                        ((string-eq op "if")
                          (transpile-if ctx expr is-return))
                        ((string-eq op "when")
                          (transpile-when ctx expr))
                        ((string-eq op "while")
                          (transpile-while ctx expr))
                        ((string-eq op "cond")
                          (transpile-cond ctx expr is-return))
                        ((string-eq op "for")
                          (transpile-for ctx expr))
                        ((string-eq op "for-each")
                          (transpile-for-each ctx expr))
                        ((string-eq op "match")
                          (transpile-match ctx expr is-return))
                        ((string-eq op "set!")
                          (transpile-set ctx expr))
                        ((string-eq op "do")
                          (transpile-do ctx expr is-return))
                        ((string-eq op "with-arena")
                          (transpile-with-arena ctx expr is-return))
                        ((string-eq op "return")
                          (if (< (list-len items) 2)
                            (ctx-emit ctx "return;")
                            (match (list-get items 1)
                              ((some val-expr)
                                ;; Use helper that handles (some ..), (none), and regular expressions
                                (emit-typed-return-expr ctx val-expr))
                              ((none) (ctx-emit ctx "return;")))))
                        ((string-eq op "break")
                          (ctx-emit ctx "break;"))
                        ((string-eq op "continue")
                          (ctx-emit ctx "continue;"))
                        ;; Default: expression statement
                        (else
                          (if is-return
                            (emit-typed-return-expr ctx expr)
                            (ctx-emit ctx (ctx-str ctx (transpile-expr ctx expr) ";")))))))
                  ;; Non-symbol head: expression statement
                  (else
                    (if is-return
                      (emit-typed-return-expr ctx expr)
                      (ctx-emit ctx (ctx-str ctx (transpile-expr ctx expr) ";"))))))
              ((none) (ctx-add-error-at ctx "empty" (ctx-list-first-line items) (ctx-list-first-col items)))))))
      ;; Non-list: expression statement
      (else
        (if is-return
          (emit-typed-return-expr ctx expr)
          (ctx-emit ctx (ctx-str ctx (transpile-expr ctx expr) ";"))))))

  ;; Helper to emit typed return from expression (handles some/none with proper typing)
  (fn emit-typed-return-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit return statement, handling (some ..) and (none) with proper Option typing")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Check if expression is (some ...) or (none) and use proper typing
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            (emit-return-with-typed-none ctx (transpile-expr ctx expr))
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((sym sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; (some value) - use return type for proper Option type
                        ((string-eq op "some")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                (if (< (list-len items) 2)
                                  (emit-return-with-typed-none ctx (transpile-expr ctx expr))
                                  (match (list-get items 1)
                                    ((some inner-expr)
                                      (let ((inner-c (transpile-expr ctx inner-expr)))
                                        (ctx-emit ctx (ctx-str5 ctx "return (" ret-type "){.has_value = 1, .value = " inner-c "};"))))
                                    ((none) (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))
                                (emit-return-with-typed-none ctx (transpile-expr ctx expr))))
                            ((none) (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))
                        ;; (none) - use return type for proper Option type
                        ((string-eq op "none")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                (ctx-emit ctx (ctx-str3 ctx "return (" ret-type "){.has_value = false};"))
                                (emit-return-with-typed-none ctx (transpile-expr ctx expr))))
                            ((none) (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))
                        ;; Other expressions - use existing helper
                        (else (emit-return-with-typed-none ctx (transpile-expr ctx expr))))))
                  (else (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))
              ((none) (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))))
      ;; Non-list: use existing helper
      (else (emit-return-with-typed-none ctx (transpile-expr ctx expr)))))

  ;; Helper to emit return with typed none when needed
  (fn emit-return-with-typed-none ((ctx (Ptr TranspileContext)) (code String))
    (@intent "Emit return statement, using typed none if returning from option-returning function")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    ;; Use sequential if statements to avoid complex cond type inference issues
    (let ((mut final-code code))
      ;; Literal none -> convert to typed option if needed
      (if (string-eq code "none")
        (match (ctx-get-current-return-type ctx)
          ((some ret-type)
            (when (starts-with ret-type "slop_option_")
              (set! final-code (ctx-str3 ctx "(" ret-type "){.has_value = false}"))))
          ((none) (do)))
        ;; Check if returning a variable of generic option type
        (match (ctx-get-current-return-type ctx)
          ((some ret-type)
            (when (starts-with ret-type "slop_option_")
              ;; Check if code is a simple variable name that's a generic option
              (match (ctx-lookup-var ctx code)
                ((some var-entry)
                  (let ((var-type (. var-entry c-type)))
                    (when (or (string-eq var-type "_slop_option_generic")
                              (string-eq var-type "auto"))
                      ;; Convert generic option to typed option
                      (let ((s1 (ctx-str ctx "((" ret-type))
                            (s2 (ctx-str ctx s1 "){.has_value = "))
                            (s3 (ctx-str ctx s2 code))
                            (s4 (ctx-str ctx s3 ".has_value, .value = "))
                            (s5 (ctx-str ctx s4 code))
                            (s6 (ctx-str ctx s5 ".value})")))
                        (set! final-code s6)))))
                ((none) (do)))))
          ((none) (do))))
      ;; Check if we're capturing to _retval (postconditions mode) or returning
      (if (ctx-is-capture-retval ctx)
        (ctx-emit ctx (ctx-str3 ctx "_retval = " final-code ";"))
        (ctx-emit ctx (ctx-str3 ctx "return " final-code ";")))))

) ;; end module
