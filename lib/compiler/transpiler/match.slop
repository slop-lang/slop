;; ============================================================
;; SLOP Native Transpiler - Match Module
;;
;; Transpiles SLOP pattern matching to C code.
;; ============================================================

(module match
  (export
    ;; Main entry point
    transpile-match
    ;; Pattern type detection
    is-option-match is-result-match is-enum-match is-literal-match
    ;; Pattern helpers
    extract-binding-name)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber))
  (import context (TranspileContext ctx-emit ctx-indent ctx-dedent ctx-push-scope ctx-pop-scope
                   ctx-bind-var ctx-lookup-var ctx-lookup-type ctx-str ctx-str3 ctx-str4 ctx-str5 VarEntry
                   ctx-lookup-enum-variant ctx-get-current-return-type ctx-gensym
                   to-c-type-prefixed))
  (import strlib (starts-with ends-with char-at))
  (import ctype (to-c-name to-c-type))
  (import expr (transpile-expr infer-expr-c-type))

  ;; ============================================================
  ;; Pattern Type Detection
  ;; ============================================================

  (fn is-option-match ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are option match (some/none)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut has-some false)
          (mut has-none false)
          (mut i 0))
      (while (< i len)
        (match (list-get patterns i)
          ((some pat-expr)
            (let ((tag (get-pattern-tag pat-expr)))
              (cond
                ((string-eq tag "some") (set! has-some true))
                ((string-eq tag "none") (set! has-none true))
                (else (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (or has-some has-none)))

  (fn is-result-match ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are result match (ok/error)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut has-ok false)
          (mut has-error false)
          (mut i 0))
      (while (< i len)
        (match (list-get patterns i)
          ((some pat-expr)
            (let ((tag (get-pattern-tag pat-expr)))
              (cond
                ((string-eq tag "ok") (set! has-ok true))
                ((string-eq tag "error") (set! has-error true))
                (else (do)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (or has-ok has-error)))

  (fn is-enum-match ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are enum match (simple symbols)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    ;; If all patterns are symbols (not lists), it's enum match
    (let ((len (list-len patterns))
          (mut all-symbols true)
          (mut i 0))
      (while (and (< i len) all-symbols)
        (match (list-get patterns i)
          ((some pat-expr)
            (match (deref pat-expr)
              ((symbol _) (do))  ;; Still true
              (else (set! all-symbols false))))
          ((none) (do)))
        (set! i (+ i 1)))
      all-symbols))

  (fn is-literal-match ((patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are literal match (numbers/strings)")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (let ((len (list-len patterns))
          (mut has-literal false)
          (mut i 0))
      (while (and (< i len) (not has-literal))
        (match (list-get patterns i)
          ((some pat-expr)
            (match (deref pat-expr)
              ((number _) (set! has-literal true))
              ((string _) (set! has-literal true))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      has-literal))

  (fn is-union-match ((ctx (Ptr TranspileContext)) (patterns (List (Ptr SExpr))))
    (@intent "Check if patterns are union match (tagged union variants)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Bool))
    (@pre {ctx != nil})
    ;; Union patterns are lists like (variant-name binding) where variant-name
    ;; is registered as an enum/union variant (and not one of special forms)
    (let ((len (list-len patterns))
          (mut has-union-variant false)
          (mut i 0))
      (while (and (< i len) (not has-union-variant))
        (match (list-get patterns i)
          ((some pat-expr)
            (let ((tag (get-pattern-tag pat-expr)))
              ;; Check if it's a registered variant (not special forms)
              (when (and (not (string-eq tag ""))
                         (not (string-eq tag "some"))
                         (not (string-eq tag "none"))
                         (not (string-eq tag "ok"))
                         (not (string-eq tag "error"))
                         (not (string-eq tag "else"))
                         (not (string-eq tag "_")))
                (match (ctx-lookup-enum-variant ctx tag)
                  ((some _) (set! has-union-variant true))
                  ((none) (do))))))
          ((none) (do)))
        (set! i (+ i 1)))
      has-union-variant))

  (fn get-pattern-tag ((pat-expr (Ptr SExpr)))
    (@intent "Get the tag from a pattern expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            ""
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (. sym name))
                  (else "")))
              ((none) "")))))
      ((symbol sym) (. sym name))
      (else "")))

  ;; ============================================================
  ;; Binding Name Extraction
  ;; ============================================================

  (fn extract-binding-name ((pat-expr (Ptr SExpr)))
    (@intent "Extract the binding name from a pattern like (some x) -> x")
    (@spec (((Ptr SExpr)) -> (Option String)))
    (@pre {pat-expr != nil})
    (match (deref pat-expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            none
            (match (list-get items 1)
              ((some binding)
                (match (deref binding)
                  ((symbol sym) (some (. sym name)))
                  (else none)))
              ((none) none)))))
      (else none)))

  ;; ============================================================
  ;; Main Match Transpilation
  ;; ============================================================

  (fn transpile-match ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)) (is-return Bool))
    (@intent "Transpile a match expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            (if (< len 3)
              (ctx-emit ctx "/* invalid match: need value and at least one branch */")
              (do
                ;; Get the scrutinee (value being matched)
                (match (list-get items 1)
                  ((some scrutinee)
                    (let ((scrutinee-c (transpile-expr ctx scrutinee))
                          (patterns (collect-patterns ctx items))
                          ;; Generate unique variable name for the scrutinee
                          (scrutinee-var (ctx-gensym ctx "_mv")))
                      ;; Store scrutinee in a variable first (avoids multiple evaluation)
                      (ctx-emit ctx (ctx-str4 ctx "__auto_type " scrutinee-var " = " (ctx-str ctx scrutinee-c ";")))
                      ;; Dispatch based on pattern types
                      (cond
                        ((is-option-match patterns)
                          (transpile-option-match ctx scrutinee-var patterns items is-return))
                        ((is-result-match patterns)
                          (transpile-result-match ctx scrutinee-var patterns items is-return))
                        ((is-enum-match patterns)
                          (transpile-enum-match ctx scrutinee-var items is-return))
                        ((is-literal-match patterns)
                          (transpile-literal-match ctx scrutinee-var items is-return))
                        ((is-union-match ctx patterns)
                          (transpile-union-match ctx scrutinee-var patterns items is-return))
                        (else
                          (transpile-generic-match ctx scrutinee-var items is-return)))))
                  ((none) (ctx-emit ctx "/* missing match scrutinee */")))))))
        (else (ctx-emit ctx "/* invalid match */")))))

  (fn collect-patterns ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Collect pattern expressions from match branches (skip head and scrutinee)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> (List (Ptr SExpr))))
    (@pre {ctx != nil})
    ;; Returns list of pattern parts from each branch
    ;; Branch structure: ((pattern) body...)
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut result (list-new arena (Ptr SExpr)))
          (mut i 2))  ;; Skip "match" and scrutinee
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 1)
                    (match (list-get branch-items 0)
                      ((some pattern) (list-push result pattern))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  ;; ============================================================
  ;; Option Match
  ;; ============================================================

  (fn transpile-option-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                              (patterns (List (Ptr SExpr))) (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile Option matching")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 2)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-pattern-tag pattern)))
                          (cond
                            ((string-eq tag "some")
                              (emit-option-some-branch ctx scrutinee-c pattern branch-items is-return first)
                              (set! first false))
                            ((string-eq tag "none")
                              (emit-option-none-branch ctx scrutinee-c branch-items is-return first)
                              (set! first false))
                            ((string-eq tag "else")
                              (emit-else-branch ctx branch-items is-return first)
                              (set! first false))
                            (else (do)))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Close the if chain
      (when (not first)
        (ctx-emit ctx "}"))))

  (fn emit-option-some-branch ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                               (pattern (Ptr SExpr)) (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit the (some x) branch")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Emit condition
      (if first
        (ctx-emit ctx (ctx-str3 ctx "if (" scrutinee-c ".has_value) {"))
        (ctx-emit ctx (ctx-str3 ctx "} else if (" scrutinee-c ".has_value) {")))
      (ctx-indent ctx)
      (ctx-push-scope ctx)
      ;; Bind the value if there's a name
      (match (extract-binding-name pattern)
        ((some binding-name)
          (let ((c-name (to-c-name arena binding-name)))
            (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx scrutinee-c ".value;")))
            (ctx-bind-var ctx (VarEntry binding-name c-name "auto" false false))))
        ((none) (do)))
      ;; Emit body
      (emit-branch-body ctx branch-items is-return)
      (ctx-pop-scope ctx)
      (ctx-dedent ctx)))

  (fn emit-option-none-branch ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                               (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit the (none) branch")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (if first
      (ctx-emit ctx (ctx-str3 ctx "if (!" scrutinee-c ".has_value) {"))
      (ctx-emit ctx (ctx-str3 ctx "} else if (!" scrutinee-c ".has_value) {")))
    (ctx-indent ctx)
    (emit-branch-body ctx branch-items is-return)
    (ctx-dedent ctx))

  ;; ============================================================
  ;; Result Match
  ;; ============================================================

  (fn transpile-result-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                              (patterns (List (Ptr SExpr))) (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile Result matching")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 2)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-pattern-tag pattern)))
                          (cond
                            ((string-eq tag "ok")
                              (emit-result-ok-branch ctx scrutinee-c pattern branch-items is-return first)
                              (set! first false))
                            ((string-eq tag "error")
                              (emit-result-error-branch ctx scrutinee-c pattern branch-items is-return first)
                              (set! first false))
                            ((string-eq tag "else")
                              (emit-else-branch ctx branch-items is-return first)
                              (set! first false))
                            (else (do)))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when (not first)
        (ctx-emit ctx "}"))))

  (fn emit-result-ok-branch ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                             (pattern (Ptr SExpr)) (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit the (ok x) branch")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena)))
      (if first
        (ctx-emit ctx (ctx-str3 ctx "if (" scrutinee-c ".is_ok) {"))
        (ctx-emit ctx (ctx-str3 ctx "} else if (" scrutinee-c ".is_ok) {")))
      (ctx-indent ctx)
      (ctx-push-scope ctx)
      (match (extract-binding-name pattern)
        ((some binding-name)
          (let ((c-name (to-c-name arena binding-name)))
            (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx scrutinee-c ".data.ok;")))
            (ctx-bind-var ctx (VarEntry binding-name c-name "auto" false false))))
        ((none) (do)))
      (emit-branch-body ctx branch-items is-return)
      (ctx-pop-scope ctx)
      (ctx-dedent ctx)))

  (fn emit-result-error-branch ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                                (pattern (Ptr SExpr)) (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit the (error e) branch")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena)))
      (if first
        (ctx-emit ctx (ctx-str3 ctx "if (!" scrutinee-c ".is_ok) {"))
        (ctx-emit ctx (ctx-str3 ctx "} else if (!" scrutinee-c ".is_ok) {")))
      (ctx-indent ctx)
      (ctx-push-scope ctx)
      (match (extract-binding-name pattern)
        ((some binding-name)
          (let ((c-name (to-c-name arena binding-name)))
            (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx scrutinee-c ".data.err;")))
            (ctx-bind-var ctx (VarEntry binding-name c-name "auto" false false))))
        ((none) (do)))
      (emit-branch-body ctx branch-items is-return)
      (ctx-pop-scope ctx)
      (ctx-dedent ctx)))

  ;; ============================================================
  ;; Enum Match
  ;; ============================================================

  (fn transpile-enum-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                            (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile enum matching using switch")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 2))
      ;; Emit switch
      (ctx-emit ctx (ctx-str3 ctx "switch (" scrutinee-c ") {"))
      (ctx-indent ctx)
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (emit-enum-case ctx pattern branch-items is-return))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-dedent ctx)
      (ctx-emit ctx "}")))

  (fn emit-enum-case ((ctx (Ptr TranspileContext)) (pattern (Ptr SExpr))
                      (branch-items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Emit a single enum case")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena))
          (tag (get-pattern-tag pattern)))
      (if (string-eq tag "else")
        (do
          (ctx-emit ctx "default: {")
          (ctx-indent ctx)
          (emit-branch-body ctx branch-items is-return)
          (ctx-emit ctx "break;")
          (ctx-dedent ctx)
          (ctx-emit ctx "}"))
        (do
          (let ((c-case (to-c-name arena tag)))
            (ctx-emit ctx (ctx-str ctx "case " (ctx-str ctx c-case ": {")))
            (ctx-indent ctx)
            (emit-branch-body ctx branch-items is-return)
            (ctx-emit ctx "break;")
            (ctx-dedent ctx)
            (ctx-emit ctx "}"))))))

  ;; ============================================================
  ;; Literal Match
  ;; ============================================================

  (fn transpile-literal-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                               (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile literal matching using if/else chain")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 2)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (emit-literal-case ctx scrutinee-c pattern branch-items is-return first)
                        (set! first false))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (when (not first)
        (ctx-emit ctx "}"))))

  (fn emit-literal-case ((ctx (Ptr TranspileContext)) (scrutinee-c String) (pattern (Ptr SExpr))
                         (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit a literal match case")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena))
          (tag (get-pattern-tag pattern)))
      (if (string-eq tag "else")
        (do
          (if first
            (ctx-emit ctx "{")
            (ctx-emit ctx "} else {"))
          (ctx-indent ctx)
          (emit-branch-body ctx branch-items is-return)
          (ctx-dedent ctx))
        (do
          (let ((literal-c (transpile-expr ctx pattern)))
            (if first
              (ctx-emit ctx (ctx-str5 ctx "if (" scrutinee-c " == " literal-c ") {"))
              (ctx-emit ctx (ctx-str5 ctx "} else if (" scrutinee-c " == " literal-c ") {")))
            (ctx-indent ctx)
            (emit-branch-body ctx branch-items is-return)
            (ctx-dedent ctx))))))

  ;; ============================================================
  ;; Union Match (tagged union)
  ;; ============================================================

  (fn transpile-union-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                             (patterns (List (Ptr SExpr))) (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile union (tagged union) matching using switch on tag")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 2)
          (mut first true))
      ;; Emit switch on the tag
      (ctx-emit ctx (ctx-str3 ctx "switch (" scrutinee-c ".tag) {"))
      (ctx-indent ctx)
      (while (< i len)
        (match (list-get items i)
          ((some branch)
            (match (deref branch)
              ((list branch-lst)
                (let ((branch-items (. branch-lst items)))
                  (when (>= (list-len branch-items) 2)
                    (match (list-get branch-items 0)
                      ((some pattern)
                        (let ((tag (get-pattern-tag pattern)))
                          (cond
                            ((or (string-eq tag "else") (string-eq tag "_"))
                              ;; Default case
                              (ctx-emit ctx "default: {")
                              (ctx-indent ctx)
                              (emit-branch-body ctx branch-items is-return)
                              (when (not is-return) (ctx-emit ctx "break;"))
                              (ctx-dedent ctx)
                              (ctx-emit ctx "}"))
                            (else
                              ;; Regular variant case
                              (emit-union-case ctx scrutinee-c pattern tag branch-items is-return)))))
                      ((none) (do))))))
              (else (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (ctx-dedent ctx)
      (ctx-emit ctx "}")))

  (fn emit-union-case ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                       (pattern (Ptr SExpr)) (tag String)
                       (branch-items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Emit a single union case")
    (@spec (((Ptr TranspileContext) String (Ptr SExpr) String (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {pattern != nil})
    (let ((arena (. (deref ctx) arena)))
      ;; Look up the type name for this variant
      (match (ctx-lookup-enum-variant ctx tag)
        ((some type-name)
          ;; Emit case TypeName_variantname:
          (let ((case-label (ctx-str4 ctx type-name "_" tag ":")))
            (ctx-emit ctx (ctx-str ctx "case " case-label))
            (ctx-emit ctx "{")
            (ctx-indent ctx)
            ;; Extract binding if present
            (match (extract-binding-name pattern)
              ((some binding-name)
                ;; __auto_type binding = scrutinee.data.variant;
                (let ((c-binding (to-c-name arena binding-name)))
                  (ctx-emit ctx (ctx-str5 ctx "__auto_type " c-binding " = " scrutinee-c
                                 (ctx-str3 ctx ".data." tag ";")))
                  (ctx-bind-var ctx (VarEntry binding-name c-binding "auto" false false))))
              ((none) (do)))
            ;; Emit body
            (emit-branch-body ctx branch-items is-return)
            (when (not is-return) (ctx-emit ctx "break;"))
            (ctx-dedent ctx)
            (ctx-emit ctx "}")))
        ((none)
          ;; Variant not found - emit error comment
          (ctx-emit ctx (ctx-str3 ctx "/* unknown variant: " tag " */"))))))

  ;; ============================================================
  ;; Generic Match (fallback)
  ;; ============================================================

  (fn transpile-generic-match ((ctx (Ptr TranspileContext)) (scrutinee-c String)
                               (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Transpile generic matching using if/else chain")
    (@spec (((Ptr TranspileContext) String (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    ;; Same as literal match - use if/else chain
    (transpile-literal-match ctx scrutinee-c items is-return))

  ;; ============================================================
  ;; Else Branch
  ;; ============================================================

  (fn emit-else-branch ((ctx (Ptr TranspileContext)) (branch-items (List (Ptr SExpr))) (is-return Bool) (first Bool))
    (@intent "Emit an else branch")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (if first
      (ctx-emit ctx "{")
      (ctx-emit ctx "} else {"))
    (ctx-indent ctx)
    (emit-branch-body ctx branch-items is-return)
    (ctx-dedent ctx))

  ;; ============================================================
  ;; Branch Body Emission
  ;; ============================================================

  (fn emit-branch-body ((ctx (Ptr TranspileContext)) (branch-items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Emit the body of a match branch")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    ;; Handle statement-like forms directly to avoid circular dependency with stmt module
    (let ((len (list-len branch-items))
          (mut i 1))  ;; Skip pattern at index 0
      (while (< i len)
        (match (list-get branch-items i)
          ((some body-expr)
            (let ((is-last (== i (- len 1))))
              (emit-branch-body-item ctx body-expr is-return is-last)))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-branch-body-item ((ctx (Ptr TranspileContext)) (body-expr (Ptr SExpr)) (is-return Bool) (is-last Bool))
    (@intent "Emit a single body item, handling statements specially")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (@pre {body-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref body-expr)
        ((list lst)
          (let ((items (. lst items)))
            (if (< (list-len items) 1)
              (ctx-emit ctx "/* empty list */;")
              (match (list-get items 0)
                ((some head-expr)
                  (match (deref head-expr)
                    ((symbol sym)
                      (let ((op (. sym name)))
                        (cond
                          ;; let - emit block with bindings
                          ((string-eq op "let")
                            (emit-inline-let ctx items is-return is-last))
                          ;; do - emit each item
                          ((string-eq op "do")
                            (emit-inline-do ctx items is-return is-last))
                          ;; if statement
                          ((string-eq op "if")
                            (emit-inline-if ctx items is-return))
                          ;; while loop
                          ((string-eq op "while")
                            (emit-inline-while ctx items))
                          ;; set! - assignment
                          ((string-eq op "set!")
                            (emit-inline-set ctx items))
                          ;; when - conditional execution
                          ((string-eq op "when")
                            (emit-inline-when ctx items))
                          ;; cond - chained conditionals
                          ((string-eq op "cond")
                            (emit-inline-cond ctx items is-return is-last))
                          ;; match - nested match (recurse)
                          ((string-eq op "match")
                            (transpile-match ctx body-expr is-return))
                          ;; with-arena - emit arena block
                          ((string-eq op "with-arena")
                            (emit-inline-with-arena ctx items is-return))
                          ;; return - explicit return statement
                          ((string-eq op "return")
                            (emit-inline-return ctx items))
                          ;; Default: treat as expression
                          (else
                            (if (and is-return is-last)
                              (emit-typed-return-expr ctx body-expr)
                              (ctx-emit ctx (ctx-str ctx (transpile-expr ctx body-expr) ";")))))))
                    (else
                      (ctx-emit ctx (ctx-str ctx (transpile-expr ctx body-expr) ";")))))
                ((none) (ctx-emit ctx "/* empty */;"))))))
        (else
          ;; Non-list (literal/symbol) - use as expression
          (if (and is-return is-last)
            (emit-typed-return-expr ctx body-expr)
            (ctx-emit ctx (ctx-str ctx (transpile-expr ctx body-expr) ";")))))))

  (fn emit-inline-let ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (is-return Bool) (is-last Bool))
    (@intent "Emit inline let binding (to avoid circular dep with stmt)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (ctx-emit ctx "/* invalid let */")
        (do
          (ctx-emit ctx "{")
          (ctx-indent ctx)
          (ctx-push-scope ctx)
          ;; Process bindings
          (match (list-get items 1)
            ((some bindings-expr)
              (emit-inline-bindings ctx bindings-expr))
            ((none) (do)))
          ;; Process body
          (let ((mut i 2))
            (while (< i len)
              (match (list-get items i)
                ((some body-item)
                  (let ((body-last (== i (- len 1))))
                    (emit-branch-body-item ctx body-item is-return (and is-last body-last))))
                ((none) (do)))
              (set! i (+ i 1))))
          (ctx-pop-scope ctx)
          (ctx-dedent ctx)
          (ctx-emit ctx "}")))))

  (fn emit-inline-bindings ((ctx (Ptr TranspileContext)) (bindings-expr (Ptr SExpr)))
    (@intent "Emit let bindings")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {bindings-expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref bindings-expr)
        ((list bindings-lst)
          (let ((bindings (. bindings-lst items))
                (len (list-len bindings))
                (mut i 0))
            (while (< i len)
              (match (list-get bindings i)
                ((some binding)
                  (emit-single-inline-binding ctx binding))
                ((none) (do)))
              (set! i (+ i 1)))))
        (else (do)))))

  (fn emit-single-inline-binding ((ctx (Ptr TranspileContext)) (binding (Ptr SExpr)))
    (@intent "Emit a single let binding")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {binding != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref binding)
        ((list binding-lst)
          (let ((items (. binding-lst items))
                (len (list-len items)))
            ;; Handle (mut name init) or (name init) or (name Type init)
            (let ((has-mut (binding-starts-with-mut items))
                  (start-idx (if (binding-starts-with-mut items) 1 0)))
              (if (< (- len start-idx) 2)
                (ctx-emit ctx "/* invalid binding */")
                (match (list-get items start-idx)
                  ((some name-expr)
                    (match (deref name-expr)
                      ((symbol name-sym)
                        (let ((raw-name (. name-sym name))
                              (c-name (to-c-name arena raw-name)))
                          ;; Check if typed binding (name Type init) or simple (name init)
                          (if (>= (- len start-idx) 3)
                            ;; Might be typed - check if middle element is a type
                            (let ((type-idx (+ start-idx 1))
                                  (val-idx (+ start-idx 2)))
                              (match (list-get items type-idx)
                                ((some type-expr)
                                  (if (is-type-expr type-expr)
                                    ;; Typed: (name Type init)
                                    (match (list-get items val-idx)
                                      ((some val-expr)
                                        (let ((c-type (to-c-type-prefixed ctx type-expr))
                                              (val-c (transpile-expr ctx val-expr))
                                              (is-ptr (ends-with c-type "*")))
                                          (ctx-emit ctx (ctx-str5 ctx c-type " " c-name " = " (ctx-str ctx val-c ";")))
                                          (ctx-bind-var ctx (VarEntry raw-name c-name c-type is-ptr has-mut))))
                                      ((none) (ctx-emit ctx "/* missing value */")))
                                    ;; Not typed - middle is actually value - infer type
                                    (match (list-get items type-idx)
                                      ((some val-expr)
                                        (let ((val-c (transpile-expr ctx val-expr))
                                              ;; Check if init is arena-alloc to get proper pointer type
                                              (ptr-type-opt (get-arena-alloc-ptr-type-inline ctx val-expr)))
                                          (match ptr-type-opt
                                            ((some ptr-type)
                                              ;; Arena-alloc returns pointer
                                              (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx val-c ";")))
                                              (ctx-bind-var ctx (VarEntry raw-name c-name ptr-type true has-mut)))
                                            ((none)
                                              ;; Infer type from expression
                                              (let ((inferred-type (infer-expr-c-type ctx val-expr))
                                                    (is-ptr (ends-with inferred-type "*")))
                                                (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx val-c ";")))
                                                (ctx-bind-var ctx (VarEntry raw-name c-name inferred-type is-ptr has-mut)))))))
                                      ((none) (ctx-emit ctx "/* missing value */")))))
                                ((none) (ctx-emit ctx "/* missing type/value */"))))
                            ;; Simple: (name init)
                            (let ((val-idx (+ start-idx 1)))
                              (match (list-get items val-idx)
                                ((some val-expr)
                                  (let ((val-c (transpile-expr ctx val-expr))
                                        ;; Check if init is arena-alloc to get proper pointer type
                                        (ptr-type-opt (get-arena-alloc-ptr-type-inline ctx val-expr)))
                                    (match ptr-type-opt
                                      ((some ptr-type)
                                        ;; Arena-alloc returns pointer
                                        (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx val-c ";")))
                                        (ctx-bind-var ctx (VarEntry raw-name c-name ptr-type true has-mut)))
                                      ((none)
                                        ;; Infer type from expression
                                        (let ((inferred-type (infer-expr-c-type ctx val-expr))
                                              (is-ptr (ends-with inferred-type "*")))
                                          (ctx-emit ctx (ctx-str4 ctx "__auto_type " c-name " = " (ctx-str ctx val-c ";")))
                                          (ctx-bind-var ctx (VarEntry raw-name c-name inferred-type is-ptr has-mut)))))))
                                ((none) (ctx-emit ctx "/* missing value */")))))))
                      (else (ctx-emit ctx "/* binding name must be symbol */"))))
                  ((none) (ctx-emit ctx "/* missing binding name */")))))))
        (else (ctx-emit ctx "/* binding must be list */")))))

  (fn binding-starts-with-mut ((items (List (Ptr SExpr))))
    (@intent "Check if binding starts with 'mut'")
    (@spec (((List (Ptr SExpr))) -> Bool))
    (if (< (list-len items) 1)
      false
      (match (list-get items 0)
        ((some first)
          (match (deref first)
            ((symbol sym)
              (string-eq (. sym name) "mut"))
            (else false)))
        ((none) false))))

  (fn is-type-expr ((expr (Ptr SExpr)))
    (@intent "Check if expression looks like a type (symbol starting uppercase or list)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((symbol sym)
        ;; Type names typically start with uppercase
        (let ((name (. sym name)))
          (if (== (string-len name) 0)
            false
            (let ((first-char (char-at name 0)))
              ;; A-Z is 65-90
              (and (>= first-char 65) (<= first-char 90))))))
      ((list _) true)  ;; Complex types like (Ptr X), (List X), (Option X)
      (else false)))

  (fn to-c-type-simple ((arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Simple type to C conversion for inline let")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre {type-expr != nil})
    ;; Delegate to ctype module
    (to-c-type arena type-expr))

  ;; ============================================================
  ;; Arena-alloc Pointer Type Detection (inline version)
  ;; ============================================================

  (fn get-arena-alloc-ptr-type-inline ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract pointer type from arena-alloc call: (arena-alloc arena (sizeof Type)) -> Some(Type*)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            (if (>= (list-len items) 3)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((symbol head-sym)
                      (if (string-eq (. head-sym name) "arena-alloc")
                        ;; Found arena-alloc, check size arg for sizeof
                        (match (list-get items 2)
                          ((some size-expr)
                            (extract-sizeof-type-inline ctx size-expr))
                          ((none) none))
                        none))
                    (else none)))
                ((none) none))
              none)))
        (else none))))

  (fn extract-sizeof-type-inline ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Extract type from (sizeof Type) or bare type symbol and return Some(Type*)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ;; Check for bare type symbol (arena-alloc arena TypeName)
        ((symbol sym)
          (let ((type-name (. sym name)))
            (match (ctx-lookup-type ctx type-name)
              ((some entry)
                ;; Known type - return pointer type
                (some (ctx-str ctx (. entry c-name) "*")))
              ((none) none))))
        ;; Check for (sizeof Type) expression
        ((list lst)
          (let ((items (. lst items)))
            (if (>= (list-len items) 2)
              (match (list-get items 0)
                ((some head-ptr)
                  (match (deref head-ptr)
                    ((symbol head-sym)
                      (if (string-eq (. head-sym name) "sizeof")
                        (match (list-get items 1)
                          ((some type-expr)
                            (let ((c-type (to-c-type-prefixed ctx type-expr)))
                              (some (ctx-str ctx c-type "*"))))
                          ((none) none))
                        none))
                    (else none)))
                ((none) none))
              none)))
        (else none))))

  (fn emit-inline-do ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (is-return Bool) (is-last Bool))
    (@intent "Emit inline do block")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i 1))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (let ((item-last (== i (- len 1))))
              (emit-branch-body-item ctx item is-return (and is-last item-last))))
          ((none) (do)))
        (set! i (+ i 1)))))

  (fn emit-inline-if ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Emit inline if statement")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        (ctx-emit ctx "/* invalid if */")
        (do
          ;; Condition
          (match (list-get items 1)
            ((some cond-expr)
              (let ((cond-c (transpile-expr ctx cond-expr)))
                (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))))
            ((none) (ctx-emit ctx "if (/* missing */) {")))
          (ctx-indent ctx)
          ;; Then branch
          (match (list-get items 2)
            ((some then-expr)
              (emit-branch-body-item ctx then-expr is-return true))
            ((none) (do)))
          (ctx-dedent ctx)
          ;; Else branch (if present)
          (if (>= len 4)
            (do
              (ctx-emit ctx "} else {")
              (ctx-indent ctx)
              (match (list-get items 3)
                ((some else-expr)
                  (emit-branch-body-item ctx else-expr is-return true))
                ((none) (do)))
              (ctx-dedent ctx)
              (ctx-emit ctx "}"))
            (ctx-emit ctx "}"))))))

  (fn emit-inline-while ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit inline while loop")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 3)
        (ctx-emit ctx "/* invalid while */")
        (do
          ;; Condition
          (match (list-get items 1)
            ((some cond-expr)
              (let ((cond-c (transpile-expr ctx cond-expr)))
                (ctx-emit ctx (ctx-str3 ctx "while (" cond-c ") {"))))
            ((none) (ctx-emit ctx "while (/* missing */) {")))
          (ctx-indent ctx)
          ;; Body
          (let ((mut i 2))
            (while (< i len)
              (match (list-get items i)
                ((some body-expr)
                  (emit-branch-body-item ctx body-expr false false))
                ((none) (do)))
              (set! i (+ i 1))))
          (ctx-dedent ctx)
          (ctx-emit ctx "}")))))

  (fn get-var-c-type-inline ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Get the C type of a variable expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre {ctx != nil})
    (match (deref expr)
      ((symbol sym)
        (let ((name (. sym name)))
          (match (ctx-lookup-var ctx name)
            ((some var-entry) (some (. var-entry c-type)))
            ((none) none))))
      (else none)))

  (fn get-some-value-inline ((expr (Ptr SExpr)))
    (@intent "Extract value from (some value) expression")
    (@spec (((Ptr SExpr)) -> (Option (Ptr SExpr))))
    (@pre {expr != nil})
    (let ((mut result (Option (Ptr SExpr)) none))
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            (when (>= (list-len items) 2)
              (match (list-get items 0)
                ((some head)
                  (match (deref head)
                    ((symbol sym)
                      (when (string-eq (. sym name) "some")
                        (match (list-get items 1)
                          ((some val)
                            (set! result (some val)))
                          ((none) (do)))))
                    (else (do))))
                ((none) (do))))))
        (else (do)))
      result))

  (fn emit-inline-set ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit inline set! assignment")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (cond
        ;; 4-arg form: (set! target field value) - field assignment
        ((== len 4)
          (match (list-get items 1)
            ((some target-expr)
              (match (list-get items 2)
                ((some field-expr)
                  (match (list-get items 3)
                    ((some value-expr)
                      (let ((field-name (get-field-name-inline ctx field-expr))
                            (value-c (transpile-expr ctx value-expr)))
                        ;; Check if target is (deref x)
                        (if (is-deref-inline target-expr)
                          ;; (set! (deref ptr) field value) -> (*ptr).field = value;
                          (let ((inner-c (get-deref-inner-inline ctx target-expr)))
                            (ctx-emit ctx (ctx-str ctx "(*" (ctx-str ctx inner-c (ctx-str ctx ")." (ctx-str ctx field-name (ctx-str ctx " = " (ctx-str ctx value-c ";"))))))))
                          ;; Regular target - check if pointer
                          (let ((target-c (transpile-expr ctx target-expr)))
                            ;; Assume value access for now: target.field = value;
                            (ctx-emit ctx (ctx-str ctx target-c (ctx-str ctx "." (ctx-str ctx field-name (ctx-str ctx " = " (ctx-str ctx value-c ";"))))))))))
                    ((none) (ctx-emit ctx "/* missing set! value */;"))))
                ((none) (ctx-emit ctx "/* missing set! field */;"))))
            ((none) (ctx-emit ctx "/* missing set! target */;"))))
        ;; 3-arg form: (set! target value) - simple assignment
        ((>= len 3)
          (match (list-get items 1)
            ((some target-expr)
              (match (list-get items 2)
                ((some val-expr)
                  (let ((target-c (transpile-expr ctx target-expr))
                        (target-type-opt (get-var-c-type-inline ctx target-expr)))
                    ;; Check if target is Option type
                    (match target-type-opt
                      ((some target-type)
                        (if (starts-with target-type "slop_option_")
                          ;; Option type - handle (some ...) specially
                          (let ((some-val-opt (get-some-value-inline val-expr)))
                            (match some-val-opt
                              ((some inner-expr)
                                ;; (some value) - generate typed Option literal
                                (let ((inner-c (transpile-expr ctx inner-expr)))
                                  (ctx-emit ctx (ctx-str ctx target-c (ctx-str5 ctx " = (" target-type "){.has_value = 1, .value = " inner-c "};")))))
                              ((none)
                                ;; Check for none
                                (let ((val-c (transpile-expr ctx val-expr)))
                                  (if (string-eq val-c "none")
                                    (ctx-emit ctx (ctx-str ctx target-c (ctx-str3 ctx " = (" target-type "){.has_value = false};")))
                                    (ctx-emit ctx (ctx-str4 ctx target-c " = " val-c ";")))))))
                          ;; Not Option type - regular assignment
                          (let ((val-c (transpile-expr ctx val-expr)))
                            (ctx-emit ctx (ctx-str4 ctx target-c " = " val-c ";")))))
                      ;; Couldn't get target type - regular assignment
                      ((none)
                        (let ((val-c (transpile-expr ctx val-expr)))
                          (ctx-emit ctx (ctx-str4 ctx target-c " = " val-c ";")))))))
                ((none) (ctx-emit ctx "/* missing set! value */;"))))
            ((none) (ctx-emit ctx "/* missing set! target */;"))))
        (else (ctx-emit ctx "/* invalid set! */")))))

  (fn is-deref-inline ((expr (Ptr SExpr)))
    (@intent "Check if expression is (deref x)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 2)
            false
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym) (string-eq (. sym name) "deref"))
                  (else false)))
              ((none) false)))))
      (else false)))

  (fn get-deref-inner-inline ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Get the inner expression from (deref x)")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (match (list-get items 1)
            ((some inner)
              (transpile-expr ctx inner))
            ((none) "/* missing deref arg */"))))
      (else "/* not a deref */")))

  (fn get-field-name-inline ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Get name from a symbol expression")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    (let ((arena (. (deref ctx) arena)))
      (match (deref expr)
        ((symbol sym) (to-c-name arena (. sym name)))
        (else "/* unknown field */"))))

  (fn emit-inline-when ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit inline when statement")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (ctx-emit ctx "/* invalid when */")
        (do
          ;; Condition
          (match (list-get items 1)
            ((some cond-expr)
              (let ((cond-c (transpile-expr ctx cond-expr)))
                (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))))
            ((none) (ctx-emit ctx "if (/* missing */) {")))
          (ctx-indent ctx)
          ;; Body
          (let ((mut i 2))
            (while (< i len)
              (match (list-get items i)
                ((some body-expr)
                  (emit-branch-body-item ctx body-expr false false))
                ((none) (do)))
              (set! i (+ i 1))))
          (ctx-dedent ctx)
          (ctx-emit ctx "}")))))

  (fn emit-inline-cond ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (is-return Bool) (is-last Bool))
    (@intent "Emit inline cond statement (to avoid circular dep with stmt)")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool Bool) -> Unit))
    (@pre {ctx != nil})
    ;; (cond (test1 body1...) (test2 body2...) (else body...))
    (let ((arena (. (deref ctx) arena))
          (len (list-len items))
          (mut i 1)
          (mut first true))
      (while (< i len)
        (match (list-get items i)
          ((some clause-expr)
            (match (deref clause-expr)
              ((list clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (if (< clause-len 1)
                    (ctx-emit ctx "/* invalid cond clause */")
                    (match (list-get clause-items 0)
                      ((some test-expr)
                        (match (deref test-expr)
                          ;; Check for 'else' keyword
                          ((symbol sym)
                            (if (string-eq (. sym name) "else")
                              (do
                                ;; else clause
                                (ctx-emit ctx "} else {")
                                (ctx-indent ctx)
                                (emit-inline-cond-body ctx clause-items 1 is-return is-last)
                                (ctx-dedent ctx))
                              (do
                                ;; Regular test clause with symbol condition
                                (let ((cond-c (transpile-expr ctx test-expr)))
                                  (if first
                                    (do
                                      (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                                      (set! first false))
                                    (ctx-emit ctx (ctx-str3 ctx "} else if (" cond-c ") {")))
                                  (ctx-indent ctx)
                                  (emit-inline-cond-body ctx clause-items 1 is-return is-last)
                                  (ctx-dedent ctx)))))
                          ;; Non-symbol test - evaluate as expression
                          (else
                            (let ((cond-c (transpile-expr ctx test-expr)))
                              (if first
                                (do
                                  (ctx-emit ctx (ctx-str3 ctx "if (" cond-c ") {"))
                                  (set! first false))
                                (ctx-emit ctx (ctx-str3 ctx "} else if (" cond-c ") {")))
                              (ctx-indent ctx)
                              (emit-inline-cond-body ctx clause-items 1 is-return is-last)
                              (ctx-dedent ctx)))))
                      ((none) (ctx-emit ctx "/* missing test */"))))))
              (else (ctx-emit ctx "/* cond clause must be list */"))))
          ((none) (do)))
        (set! i (+ i 1)))
      ;; Close final brace
      (when (not first)
        (ctx-emit ctx "}"))))

  (fn emit-inline-cond-body ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (start Int) (is-return Bool) (is-last Bool))
    (@intent "Emit body statements of a cond clause inline")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Int Bool Bool) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items))
          (mut i start))
      (while (< i len)
        (match (list-get items i)
          ((some body-expr)
            (let ((body-is-last (== i (- len 1))))
              (emit-branch-body-item ctx body-expr is-return (and is-last body-is-last))))
          ((none) (do)))
        (set! i (+ i 1)))))

  ;; ============================================================
  ;; With-Arena Block (inline)
  ;; ============================================================

  (fn emit-inline-with-arena ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))) (is-return Bool))
    (@intent "Emit with-arena block in match branch")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr)) Bool) -> Unit))
    (@pre {ctx != nil})
    ;; (with-arena size body...)
    ;; Generates:
    ;; {
    ;;     slop_arena _arena = slop_arena_new(size);
    ;;     slop_arena* arena = &_arena;
    ;;     <body statements>
    ;;     slop_arena_free(arena);
    ;; }
    (let ((arena (. (deref ctx) arena))
          (len (list-len items)))
      (if (< len 2)
        (ctx-emit ctx "/* invalid with-arena: need size */")
        (do
          ;; Open block
          (ctx-emit ctx "{")
          (ctx-indent ctx)
          (ctx-push-scope ctx)
          ;; Get size expression
          (match (list-get items 1)
            ((some size-expr)
              (let ((size-c (transpile-expr ctx size-expr)))
                ;; Emit arena creation
                (ctx-emit ctx (ctx-str3 ctx "slop_arena _arena = slop_arena_new(" size-c ");"))
                (ctx-emit ctx "slop_arena* arena = &_arena;")))
            ((none) (ctx-emit ctx "/* missing size */")))
          ;; Bind arena variable in scope
          (ctx-bind-var ctx (VarEntry "arena" "arena" "slop_arena*" true false))
          ;; Process body statements (items 2 onwards)
          (let ((mut i 2))
            (while (< i len)
              (match (list-get items i)
                ((some body-expr)
                  (let ((is-last (== i (- len 1))))
                    (emit-branch-body-item ctx body-expr (and is-return is-last) is-last)))
                ((none) (do)))
              (set! i (+ i 1))))
          ;; Free arena
          (ctx-emit ctx "slop_arena_free(arena);")
          ;; Close scope
          (ctx-pop-scope ctx)
          (ctx-dedent ctx)
          (ctx-emit ctx "}")))))

  ;; ============================================================
  ;; Return Statement (inline)
  ;; ============================================================

  (fn emit-inline-return ((ctx (Ptr TranspileContext)) (items (List (Ptr SExpr))))
    (@intent "Emit explicit return statement")
    (@spec (((Ptr TranspileContext) (List (Ptr SExpr))) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len items)))
      (if (< len 2)
        (ctx-emit ctx "return;")
        (match (list-get items 1)
          ((some val-expr)
            (emit-typed-return-expr ctx val-expr))
          ((none) (ctx-emit ctx "return;"))))))

  ;; ============================================================
  ;; Helper for typed none in returns
  ;; ============================================================

  (fn emit-return-typed ((ctx (Ptr TranspileContext)) (code String))
    (@intent "Emit return statement, using typed none if returning 'none' from option-returning function")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (let ((final-code (if (string-eq code "none")
                         (match (ctx-get-current-return-type ctx)
                           ((some ret-type)
                             (if (starts-with ret-type "slop_option_")
                               (ctx-str3 ctx "(" ret-type "){.has_value = false}")
                               code))
                           ((none) code))
                         code)))
      (ctx-emit ctx (ctx-str3 ctx "return " final-code ";"))))

  ;; Helper to emit typed return from expression (handles some/none with proper typing)
  (fn emit-typed-return-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Emit return statement, handling (some ..) and (none) with proper Option typing")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Unit))
    (@pre {ctx != nil})
    (@pre {expr != nil})
    ;; Check if expression is (some ...) or (none) and use proper typing
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          (if (< (list-len items) 1)
            (emit-return-typed ctx (transpile-expr ctx expr))
            (match (list-get items 0)
              ((some head)
                (match (deref head)
                  ((symbol sym)
                    (let ((op (. sym name)))
                      (cond
                        ;; (some value) - use return type for proper Option type
                        ((string-eq op "some")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                (if (< (list-len items) 2)
                                  (emit-return-typed ctx (transpile-expr ctx expr))
                                  (match (list-get items 1)
                                    ((some inner-expr)
                                      (let ((inner-c (transpile-expr ctx inner-expr)))
                                        (ctx-emit ctx (ctx-str5 ctx "return (" ret-type "){.has_value = 1, .value = " inner-c "};"))))
                                    ((none) (emit-return-typed ctx (transpile-expr ctx expr)))))
                                (emit-return-typed ctx (transpile-expr ctx expr))))
                            ((none) (emit-return-typed ctx (transpile-expr ctx expr)))))
                        ;; (none) - use return type for proper Option type
                        ((string-eq op "none")
                          (match (ctx-get-current-return-type ctx)
                            ((some ret-type)
                              (if (starts-with ret-type "slop_option_")
                                (ctx-emit ctx (ctx-str3 ctx "return (" ret-type "){.has_value = false};"))
                                (emit-return-typed ctx (transpile-expr ctx expr))))
                            ((none) (emit-return-typed ctx (transpile-expr ctx expr)))))
                        ;; Other expressions - use existing helper
                        (else (emit-return-typed ctx (transpile-expr ctx expr))))))
                  (else (emit-return-typed ctx (transpile-expr ctx expr)))))
              ((none) (emit-return-typed ctx (transpile-expr ctx expr)))))))
      ;; Non-list: use existing helper
      (else (emit-return-typed ctx (transpile-expr ctx expr)))))

) ;; end module
