;; ============================================================
;; SLOP Native Transpiler - Context Management
;;
;; Mutable state during transpilation: type registry, variable
;; scopes, function registry, module context, output buffers.
;; ============================================================

(module context
  (export
    ;; Context type
    TranspileContext VarEntry
    ;; Lifecycle
    context-new
    ;; Type registry
    ctx-register-type ctx-lookup-type
    ctx-register-enum ctx-lookup-enum
    ;; Variable scopes
    ctx-push-scope ctx-pop-scope
    ctx-bind-var ctx-lookup-var
    ;; Function registry
    ctx-register-func ctx-lookup-func
    ctx-set-return-type ctx-get-return-type
    ;; Module context
    ctx-set-module ctx-get-module
    ctx-enable-prefixing ctx-prefixing-enabled
    ;; Output management
    ctx-emit ctx-emit-header ctx-get-output ctx-get-header
    ctx-indent ctx-dedent
    ;; Generic type tracking
    ctx-mark-type-emitted ctx-is-type-emitted
    ;; FFI
    ctx-add-include ctx-get-includes
    ;; String helpers
    ctx-str ctx-str3 ctx-str4 ctx-str5)

  (import types (SExpr ResolvedType FnSignature RangeBounds))

  ;; ============================================================
  ;; Variable Entry (for scope tracking)
  ;; ============================================================

  (type VarEntry (record
    (name String)               ;; SLOP variable name
    (c-name String)             ;; C variable name
    (c-type String)             ;; C type string
    (is-pointer Bool)
    (is-mutable Bool)))

  ;; ============================================================
  ;; Context Type
  ;; ============================================================

  (type TranspileContext (record
    (arena Arena)
    ;; Type registry
    (types (Map String (Ptr ResolvedType)))
    (enums (Map String String))             ;; value -> qualified C name
    ;; Variable scope stack - pointers to maps for mutability
    (scopes (List (Ptr (Map String VarEntry))))
    ;; Function registry
    (functions (Map String (Ptr FnSignature)))
    (current-return-type (Option String))
    ;; Module context
    (current-module (Option String))
    (prefixing-enabled Bool)
    ;; Output buffers
    (output (List String))          ;; Implementation (.c) lines
    (header (List String))          ;; Header (.h) lines
    (indent-level (Int 0 ..))
    ;; Generic type tracking (for deduplication)
    (emitted-types (Map String Bool))
    ;; FFI includes
    (includes (List String))))

  ;; ============================================================
  ;; Lifecycle
  ;; ============================================================

  (fn context-new ((arena Arena))
    (@intent "Create a new transpilation context")
    (@spec ((Arena) -> (Ptr TranspileContext)))
    (@alloc arena)
    (@post {$result != nil})
    (let ((ctx (cast (Ptr TranspileContext) (arena-alloc arena 256)))
          ;; Allocate the initial scope map and get a pointer to it
          (initial-scope-ptr (cast (Ptr (Map String VarEntry)) (arena-alloc arena 64))))
      ;; Initialize the scope map
      (set! (deref initial-scope-ptr) (map-new arena String VarEntry))
      ;; Initialize context
      (set! (deref ctx) (TranspileContext
        arena
        (map-new arena String (Ptr ResolvedType))
        (map-new arena String String)
        (list-new arena (Ptr (Map String VarEntry)))
        (map-new arena String (Ptr FnSignature))
        (none)
        (none)
        true
        (list-new arena String)
        (list-new arena String)
        0
        (map-new arena String Bool)
        (list-new arena String)))
      ;; Push initial scope pointer
      (list-push (. (deref ctx) scopes) initial-scope-ptr)
      ctx))

  ;; ============================================================
  ;; Type Registry
  ;; ============================================================

  (fn ctx-register-type ((ctx (Ptr TranspileContext)) (name String) (typ (Ptr ResolvedType)))
    (@intent "Register a resolved type in the registry")
    (@spec (((Ptr TranspileContext) String (Ptr ResolvedType)) -> Unit))
    (@pre {ctx != nil})
    (@pre {typ != nil})
    (map-put (. (deref ctx) types) name typ))

  (fn ctx-lookup-type ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Look up type by SLOP name")
    (@spec (((Ptr TranspileContext) String) -> (Option (Ptr ResolvedType))))
    (@pre {ctx != nil})
    (@pure)
    (map-get (. (deref ctx) types) name))

  (fn ctx-register-enum ((ctx (Ptr TranspileContext)) (value String) (qualified String))
    (@intent "Register enum value to qualified C name mapping")
    (@spec (((Ptr TranspileContext) String String) -> Unit))
    (@pre {ctx != nil})
    (map-put (. (deref ctx) enums) value qualified))

  (fn ctx-lookup-enum ((ctx (Ptr TranspileContext)) (value String))
    (@intent "Look up qualified C name for enum value")
    (@spec (((Ptr TranspileContext) String) -> (Option String)))
    (@pre {ctx != nil})
    (@pure)
    (map-get (. (deref ctx) enums) value))

  ;; ============================================================
  ;; Variable Scopes
  ;; ============================================================

  (fn ctx-push-scope ((ctx (Ptr TranspileContext)))
    (@intent "Push a new variable scope")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          ;; Allocate new scope map and get pointer
          (new-scope-ptr (cast (Ptr (Map String VarEntry)) (arena-alloc arena 64))))
      (set! (deref new-scope-ptr) (map-new arena String VarEntry))
      (list-push (. (deref ctx) scopes) new-scope-ptr)))

  (fn ctx-pop-scope ((ctx (Ptr TranspileContext)))
    (@intent "Pop the current variable scope")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (@pre {(list-len (. (deref ctx) scopes)) > 0})
    (do
      (list-pop (. (deref ctx) scopes))
      (do)))

  (fn ctx-bind-var ((ctx (Ptr TranspileContext)) (entry VarEntry))
    (@intent "Bind a variable in the current scope")
    (@spec (((Ptr TranspileContext) VarEntry) -> Unit))
    (@pre {ctx != nil})
    (@pre {(list-len (. (deref ctx) scopes)) > 0})
    (let ((scopes (. (deref ctx) scopes))
          (top-idx (- (list-len scopes) 1)))
      (match (list-get scopes top-idx)
        ((some scope-ptr)
          ;; Dereference pointer to get mutable map
          (map-put (deref scope-ptr) (. entry name) entry))
        ((none) (do)))))

  (fn ctx-lookup-var ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Look up variable, searching scopes from inner to outer")
    (@spec (((Ptr TranspileContext) String) -> (Option VarEntry)))
    (@pre {ctx != nil})
    (let ((scopes (. (deref ctx) scopes))
          (len (list-len scopes)))
      ;; Handle empty scopes case to avoid unsigned underflow
      (if (== len 0)
        (none)
        (let ((mut idx 0)
              (mut found false)
              (mut result (Option VarEntry) (none)))
          ;; Search from innermost (len-1) to outermost (0)
          ;; Use idx counting up to avoid unsigned underflow
          (while (and (not found) (< idx len))
            (let ((scope-idx (- (- len 1) idx)))
              (match (list-get scopes scope-idx)
                ((some scope-ptr)
                  ;; Dereference pointer to access map
                  (match (map-get (deref scope-ptr) name)
                    ((some entry)
                      (do
                        (set! result (some entry))
                        (set! found true)))
                    ((none) (do))))
                ((none) (do))))
            (set! idx (+ idx 1)))
          result))))

  ;; ============================================================
  ;; Function Registry
  ;; ============================================================

  (fn ctx-register-func ((ctx (Ptr TranspileContext)) (sig (Ptr FnSignature)))
    (@intent "Register a function signature")
    (@spec (((Ptr TranspileContext) (Ptr FnSignature)) -> Unit))
    (@pre {ctx != nil})
    (@pre {sig != nil})
    (map-put (. (deref ctx) functions) (. (deref sig) name) sig))

  (fn ctx-lookup-func ((ctx (Ptr TranspileContext)) (name String))
    (@intent "Look up function by name")
    (@spec (((Ptr TranspileContext) String) -> (Option (Ptr FnSignature))))
    (@pre {ctx != nil})
    (@pure)
    (map-get (. (deref ctx) functions) name))

  (fn ctx-set-return-type ((ctx (Ptr TranspileContext)) (typ (Option String)))
    (@intent "Set current function return type for inference")
    (@spec (((Ptr TranspileContext) (Option String)) -> Unit))
    (@pre {ctx != nil})
    (set! (. (deref ctx) current-return-type) typ))

  (fn ctx-get-return-type ((ctx (Ptr TranspileContext)))
    (@intent "Get current function return type")
    (@spec (((Ptr TranspileContext)) -> (Option String)))
    (@pre {ctx != nil})
    (@pure)
    (. (deref ctx) current-return-type))

  ;; ============================================================
  ;; Module Context
  ;; ============================================================

  (fn ctx-set-module ((ctx (Ptr TranspileContext)) (name (Option String)))
    (@intent "Set current module name")
    (@spec (((Ptr TranspileContext) (Option String)) -> Unit))
    (@pre {ctx != nil})
    (set! (. (deref ctx) current-module) name))

  (fn ctx-get-module ((ctx (Ptr TranspileContext)))
    (@intent "Get current module name")
    (@spec (((Ptr TranspileContext)) -> (Option String)))
    (@pre {ctx != nil})
    (@pure)
    (. (deref ctx) current-module))

  (fn ctx-enable-prefixing ((ctx (Ptr TranspileContext)) (enabled Bool))
    (@intent "Enable or disable module prefixing for names")
    (@spec (((Ptr TranspileContext) Bool) -> Unit))
    (@pre {ctx != nil})
    (set! (. (deref ctx) prefixing-enabled) enabled))

  (fn ctx-prefixing-enabled ((ctx (Ptr TranspileContext)))
    (@intent "Check if module prefixing is enabled")
    (@spec (((Ptr TranspileContext)) -> Bool))
    (@pre {ctx != nil})
    (@pure)
    (. (deref ctx) prefixing-enabled))

  ;; ============================================================
  ;; String Helpers
  ;; ============================================================

  (fn ctx-str ((ctx (Ptr TranspileContext)) (a String) (b String))
    (@intent "Concatenate two strings using context's arena")
    (@spec (((Ptr TranspileContext) String String) -> String))
    (@pre {ctx != nil})
    (string-concat (. (deref ctx) arena) a b))

  (fn ctx-str3 ((ctx (Ptr TranspileContext)) (a String) (b String) (c String))
    (@intent "Concatenate three strings using context's arena")
    (@spec (((Ptr TranspileContext) String String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (string-concat arena (string-concat arena a b) c)))

  (fn ctx-str4 ((ctx (Ptr TranspileContext)) (a String) (b String) (c String) (d String))
    (@intent "Concatenate four strings using context's arena")
    (@spec (((Ptr TranspileContext) String String String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (string-concat arena (string-concat arena (string-concat arena a b) c) d)))

  (fn ctx-str5 ((ctx (Ptr TranspileContext)) (a String) (b String) (c String) (d String) (e String))
    (@intent "Concatenate five strings using context's arena")
    (@spec (((Ptr TranspileContext) String String String String String) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena)))
      (string-concat arena (string-concat arena (string-concat arena (string-concat arena a b) c) d) e)))

  ;; ============================================================
  ;; Output Management
  ;; ============================================================

  (fn make-indent ((ctx (Ptr TranspileContext)) (level Int))
    (@intent "Create indentation string of given level")
    (@spec (((Ptr TranspileContext) Int) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (mut result "")
          (mut i 0))
      (while (< i level)
        (set! result (string-concat arena result "    "))
        (set! i (+ i 1)))
      result))

  (fn ctx-emit ((ctx (Ptr TranspileContext)) (line String))
    (@intent "Emit a line to the implementation output with current indentation")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (indent (make-indent ctx (. (deref ctx) indent-level)))
          (indented-line (string-concat arena indent line)))
      (list-push (. (deref ctx) output) indented-line)))

  (fn ctx-emit-header ((ctx (Ptr TranspileContext)) (line String))
    (@intent "Emit a line to the header output")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (list-push (. (deref ctx) header) line))

  (fn ctx-get-output ((ctx (Ptr TranspileContext)))
    (@intent "Get the implementation output as joined string")
    (@spec (((Ptr TranspileContext)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (lines (. (deref ctx) output))
          (len (list-len lines))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (match (list-get lines i)
          ((some line)
            (set! result (string-concat arena result (string-concat arena line "\n"))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn ctx-get-header ((ctx (Ptr TranspileContext)))
    (@intent "Get the header output as joined string")
    (@spec (((Ptr TranspileContext)) -> String))
    (@pre {ctx != nil})
    (let ((arena (. (deref ctx) arena))
          (lines (. (deref ctx) header))
          (len (list-len lines))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (match (list-get lines i)
          ((some line)
            (set! result (string-concat arena result (string-concat arena line "\n"))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn ctx-indent ((ctx (Ptr TranspileContext)))
    (@intent "Increase indentation level")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (set! (. (deref ctx) indent-level) (+ (. (deref ctx) indent-level) 1)))

  (fn ctx-dedent ((ctx (Ptr TranspileContext)))
    (@intent "Decrease indentation level")
    (@spec (((Ptr TranspileContext)) -> Unit))
    (@pre {ctx != nil})
    (@pre {(. (deref ctx) indent-level) > 0})
    (set! (. (deref ctx) indent-level) (- (. (deref ctx) indent-level) 1)))

  ;; ============================================================
  ;; Generic Type Tracking
  ;; ============================================================

  (fn ctx-mark-type-emitted ((ctx (Ptr TranspileContext)) (type-key String))
    (@intent "Mark a generated type as emitted")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (map-put (. (deref ctx) emitted-types) type-key true))

  (fn ctx-is-type-emitted ((ctx (Ptr TranspileContext)) (type-key String))
    (@intent "Check if a generated type has been emitted")
    (@spec (((Ptr TranspileContext) String) -> Bool))
    (@pre {ctx != nil})
    (@pure)
    (map-has (. (deref ctx) emitted-types) type-key))

  ;; ============================================================
  ;; FFI
  ;; ============================================================

  (fn ctx-add-include ((ctx (Ptr TranspileContext)) (header String))
    (@intent "Add a header file to includes list (if not already present)")
    (@spec (((Ptr TranspileContext) String) -> Unit))
    (@pre {ctx != nil})
    (let ((len (list-len (. (deref ctx) includes)))
          (mut found false)
          (mut i 0))
      (while (and (< i len) (not found))
        (match (list-get (. (deref ctx) includes) i)
          ((some existing)
            (when (string-eq existing header)
              (set! found true)))
          ((none) (do)))
        (set! i (+ i 1)))
      (when (not found)
        (list-push (. (deref ctx) includes) header))))

  (fn ctx-get-includes ((ctx (Ptr TranspileContext)))
    (@intent "Get list of include headers")
    (@spec (((Ptr TranspileContext)) -> (List String)))
    (@pre {ctx != nil})
    (@pure)
    (. (deref ctx) includes)))
