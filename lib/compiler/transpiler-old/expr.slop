;; ============================================================
;; SLOP Transpiler - Expression Transpilation
;;
;; Convert SLOP expressions to C expression strings.
;; Handles literals, symbols, operators, field access,
;; function calls, and constructors.
;; ============================================================

(module expr
  (export
    transpile-expr
    is-pointer-expr
    infer-expr-c-type)

  (import parser (SExpr SExprList SExprSymbol SExprNumber SExprString
                  is-form sexpr-line sexpr-col))
  (import context (TranspileContext ctx-lookup-var ctx-lookup-enum
                   ctx-lookup-function ctx-lookup-ffi-func
                   ctx-is-pointer ctx-get-return-type
                   ctx-lookup-fields ctx-get-type-env ctx-register-option))
  ;; Import type checker for type inference
  (import env (TypeEnv env-lookup-var env-lookup-function))
  (import types (ResolvedType FnSignature))
  (import ctype (to-c-type is-pointer-type is-string-type
                 is-option-type is-result-type))
  (import names (to-c-name to-qualified-name to-qualified-type-name type-to-identifier))
  (import emit (Emitter))
  (import strlib (float-to-string substring ends-with starts-with contains))
  (import transpiler-types (CFieldInfo))

  ;; ============================================================
  ;; Arena Inference
  ;; ============================================================

  (fn get-arena-from-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Get arena for list/map operations - extracts from ctx->arena or uses 'arena'")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= expr nil))
    (let ((arena (. (deref ctx) arena)))
      ;; For field access patterns like (. (deref ptr) field), use ptr->arena
      ;; This handles cases where the object has an arena field
      (match (deref expr)
        ((list lst)
          (let ((items (. lst items)))
            (match (list-get items 0)
              ((some first)
                (match (deref first)
                  ((symbol sym)
                    (if (string-eq (. sym name) ".")
                      ;; Field access: (. obj field) or (. (deref ptr) field)
                      (match (list-get items 1)
                        ((some obj-expr)
                          (match (deref obj-expr)
                            ;; (. (deref ptr) field) -> ptr->arena
                            ((list inner-lst)
                              (let ((inner-items (. inner-lst items)))
                                (match (list-get inner-items 0)
                                  ((some inner-first)
                                    (match (deref inner-first)
                                      ((symbol inner-sym)
                                        (if (string-eq (. inner-sym name) "deref")
                                          (match (list-get inner-items 1)
                                            ((some ptr-expr)
                                              (match (deref ptr-expr)
                                                ((symbol ptr-sym)
                                                  (string-concat arena (. ptr-sym name) "->arena"))
                                                (_ "arena")))
                                            ((none) "arena"))
                                          "arena"))
                                      (_ "arena")))
                                  ((none) "arena"))))
                            (_ "arena")))
                        ((none) "arena"))
                      "arena"))
                  (_ "arena")))
              ((none) "arena"))))
        (_ "arena"))))

  ;; ============================================================
  ;; Main Expression Transpilation
  ;; ============================================================

  (fn transpile-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr))
                      (expected-type (Option String)))
    (@intent "Transpile SLOP expression to C expression string")
    (@spec (((Ptr TranspileContext) (Ptr SExpr) (Option String)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= expr nil))
    (match (deref expr)
      ;; Number literal
      ((number n)
        (if (. n is-float)
          (float-to-string (. (deref ctx) arena) (. n float-value) 6)
          (int-to-string (. (deref ctx) arena) (. n int-value))))

      ;; String literal
      ((string s)
        (transpile-string-literal ctx (. s value)))

      ;; Symbol (variable, enum, builtin)
      ((symbol sym)
        (transpile-symbol ctx (. sym name) expected-type))

      ;; List (operator, function call, special form)
      ((list l)
        (transpile-list-expr ctx l expected-type))))

  ;; ============================================================
  ;; Literal Transpilation
  ;; ============================================================

  (fn escape-c-string ((ctx (Ptr TranspileContext)) (s String))
    (@intent "Escape special characters for C string literal")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (len (. s len))
          (data (. s data))
          (mut result ""))
      (do
        (for (i 0 len)
          (let ((c (cast Int (@ data i))))
            (cond
              ;; Backslash -> \\
              ((== c 92)
                (set! result (string-concat arena result "\\\\")))
              ;; Quote -> \"
              ((== c 34)
                (set! result (string-concat arena result "\\\"")))
              ;; Newline -> \n
              ((== c 10)
                (set! result (string-concat arena result "\\n")))
              ;; Carriage return -> \r
              ((== c 13)
                (set! result (string-concat arena result "\\r")))
              ;; Tab -> \t
              ((== c 9)
                (set! result (string-concat arena result "\\t")))
              ;; Other characters - append as-is using substring
              (else
                (set! result (string-concat arena result
                               (substring arena s i 1)))))))
        result)))

  (fn transpile-string-literal ((ctx (Ptr TranspileContext)) (value String))
    (@intent "Transpile string literal to SLOP_STR macro")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    ;; Output: SLOP_STR("escaped content")
    (let ((arena (. (deref ctx) arena))
          (escaped (escape-c-string ctx value)))
      (string-concat arena
        (string-concat arena "SLOP_STR(\"" escaped)
        "\")")))

  ;; ============================================================
  ;; Symbol Transpilation
  ;; ============================================================

  (fn transpile-symbol ((ctx (Ptr TranspileContext)) (name String)
                        (expected-type (Option String)))
    (@intent "Transpile symbol to C expression")
    (@spec (((Ptr TranspileContext) String (Option String)) -> String))
    (@pre (!= ctx nil))
    (cond
      ;; Boolean literals
      ((string-eq name "true") "true")
      ((string-eq name "false") "false")
      ;; Null
      ((string-eq name "nil") "NULL")
      ;; None constructor (needs expected type for proper typing)
      ((string-eq name "none")
        (transpile-none ctx expected-type))
      ;; Check if it's an enum value
      (else
        (match (ctx-lookup-enum ctx name)
          ((some qualified) qualified)
          ((none) (to-c-name (. (deref ctx) arena) name))))))

  ;; ============================================================
  ;; List Expression Transpilation
  ;; ============================================================

  (fn transpile-list-expr ((ctx (Ptr TranspileContext))
                           (lst SExprList)
                           (expected-type (Option String)))
    (@intent "Transpile list expression (operator, call, or special form)")
    (@spec (((Ptr TranspileContext) SExprList (Option String)) -> String))
    (@pre (!= ctx nil))
    (@pre (> (list-len (. lst items)) 0))
    ;; Get the operator/function name
    (match (list-get (. lst items) 0)
      ((none) "/* empty list */")
      ((some head)
        (match (deref head)
          ((symbol sym)
            (let ((op (. sym name)))
              (cond
                ;; Arithmetic operators
                ((string-eq op "+") (transpile-binary ctx lst "+"))
                ((string-eq op "-") (transpile-minus ctx lst))
                ((string-eq op "*") (transpile-binary ctx lst "*"))
                ((string-eq op "/") (transpile-binary ctx lst "/"))
                ((string-eq op "%") (transpile-binary ctx lst "%"))

                ;; Bitwise operators
                ((string-eq op "&") (transpile-binary ctx lst "&"))
                ((string-eq op "|") (transpile-binary ctx lst "|"))
                ((string-eq op "^") (transpile-binary ctx lst "^"))
                ((string-eq op "<<") (transpile-binary ctx lst "<<"))
                ((string-eq op ">>") (transpile-binary ctx lst ">>"))
                ((string-eq op "~") (transpile-unary ctx lst "~"))

                ;; Comparison operators
                ((string-eq op "==") (transpile-comparison ctx lst "=="))
                ((string-eq op "!=") (transpile-comparison ctx lst "!="))
                ((string-eq op "<") (transpile-comparison ctx lst "<"))
                ((string-eq op "<=") (transpile-comparison ctx lst "<="))
                ((string-eq op ">") (transpile-comparison ctx lst ">"))
                ((string-eq op ">=") (transpile-comparison ctx lst ">="))

                ;; Logical operators
                ((string-eq op "and") (transpile-binary ctx lst "&&"))
                ((string-eq op "or") (transpile-binary ctx lst "||"))
                ((string-eq op "not") (transpile-unary ctx lst "!"))

                ;; Field access
                ((string-eq op ".") (transpile-field-access ctx lst))

                ;; Index access
                ((string-eq op "@") (transpile-index-access ctx lst))

                ;; Pointer operations
                ((string-eq op "addr") (transpile-addr ctx lst))
                ((string-eq op "deref") (transpile-deref ctx lst))

                ;; Type cast
                ((string-eq op "cast") (transpile-cast ctx lst))

                ;; Option/Result constructors
                ((string-eq op "none") (transpile-none ctx expected-type))
                ((string-eq op "some") (transpile-some ctx lst expected-type))
                ((string-eq op "ok") (transpile-ok ctx lst expected-type))
                ((string-eq op "error") (transpile-error ctx lst expected-type))

                ;; Early return on error (? operator)
                ((string-eq op "?") (transpile-early-return ctx lst))

                ;; List operations
                ((string-eq op "list-new") (transpile-list-new ctx lst))
                ((string-eq op "list-push") (transpile-list-push ctx lst))
                ((string-eq op "list-pop") (transpile-list-pop ctx lst))
                ((string-eq op "list-get") (transpile-list-get ctx lst))
                ((string-eq op "list-len") (transpile-list-len ctx lst))

                ;; Map operations
                ((string-eq op "map-new") (transpile-map-new ctx lst))
                ((string-eq op "map-put") (transpile-map-put ctx lst))
                ((string-eq op "map-get") (transpile-map-get ctx lst))
                ((string-eq op "map-has") (transpile-map-has ctx lst))
                ((string-eq op "map-keys") (transpile-map-keys ctx lst))
                ((string-eq op "map-remove") (transpile-map-remove ctx lst))

                ;; Record construction
                ((string-eq op "record-new") (transpile-record-new ctx lst))

                ;; Union construction
                ((string-eq op "union-new") (transpile-union-new ctx lst))

                ;; Quote (enum literal)
                ((string-eq op "quote") (transpile-quote ctx lst))

                ;; C inline
                ((string-eq op "c-inline") (transpile-c-inline ctx lst))

                ;; Sizeof
                ((string-eq op "sizeof") (transpile-sizeof ctx lst))

                ;; Arena allocation
                ((string-eq op "arena-alloc") (transpile-arena-alloc ctx lst))

                ;; Primitive type constructors: (String data len), (Bytes data len cap)
                ((string-eq op "String")
                  (transpile-string-constructor ctx lst))
                ((string-eq op "Bytes")
                  (transpile-bytes-constructor ctx lst))

                ;; Statement forms as expressions - simple ternary/assignment forms
                ((string-eq op "set!")
                  (transpile-set-expr ctx lst))
                ((string-eq op "if")
                  (transpile-if-expr ctx lst))
                ((or (string-eq op "let") (string-eq op "let*"))
                  (transpile-let-expr ctx lst))
                ((string-eq op "while")
                  (transpile-while-expr ctx lst))
                ((string-eq op "for")
                  (transpile-for-expr ctx lst))
                ((string-eq op "for-each")
                  (transpile-for-each-expr ctx lst))
                ((string-eq op "do")
                  (transpile-do-expr ctx lst))
                ((string-eq op "match")
                  (transpile-match-expr ctx lst))

                ;; Print/println - convert to printf
                ((string-eq op "print")
                  (transpile-print ctx lst false))
                ((string-eq op "println")
                  (transpile-print ctx lst true))

                ;; Default: check if record constructor or function call
                (else
                  (let ((arena (. (deref ctx) arena))
                        (qtn (to-qualified-type-name arena ctx op)))
                    (match (ctx-lookup-fields ctx qtn)
                      ((some fields)
                        (transpile-record-ctor ctx qtn fields lst))
                      ((none)
                        (transpile-function-call ctx op lst))))))))
          ;; Head is not a symbol - treat as computed function call
          (_ "/* computed function expressions not supported */")))))

  ;; ============================================================
  ;; Arithmetic and Comparison
  ;; ============================================================

  (fn transpile-binary ((ctx (Ptr TranspileContext))
                        (lst SExprList) (c-op String))
    (@intent "Transpile binary operator expression")
    (@spec (((Ptr TranspileContext) SExprList String) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    (match (list-get (. lst items) 1)
      ((some left)
        (match (list-get (. lst items) 2)
          ((some right)
            (let ((left-str (transpile-expr ctx left (none)))
                  (right-str (transpile-expr ctx right (none)))
                  (arena (. (deref ctx) arena)))
              (string-concat arena
                (string-concat arena "(" left-str)
                (string-concat arena (string-concat arena " " c-op)
                  (string-concat arena (string-concat arena " " right-str) ")")))))
          ((none) "")))
      ((none) "")))

  (fn transpile-minus ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile minus (unary negation or binary subtraction)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (if (== (list-len (. lst items)) 2)
      (transpile-unary ctx lst "-")
      (transpile-binary ctx lst "-")))

  (fn transpile-unary ((ctx (Ptr TranspileContext))
                       (lst SExprList) (c-op String))
    (@intent "Transpile unary operator expression")
    (@spec (((Ptr TranspileContext) SExprList String) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((none) "/* missing operand */")
      ((some operand)
        (let ((operand-str (transpile-expr ctx operand (none)))
              (arena (. (deref ctx) arena)))
          (string-concat arena
            (string-concat arena c-op "(")
            (string-concat arena operand-str ")"))))))

  (fn transpile-comparison ((ctx (Ptr TranspileContext))
                            (lst SExprList) (c-op String))
    (@intent "Transpile comparison, handling string-eq specially")
    (@spec (((Ptr TranspileContext) SExprList String) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    ;; For string comparison, use slop_string_eq (TODO: add string check)
    (match (list-get (. lst items) 1)
      ((some left)
        (match (list-get (. lst items) 2)
          ((some right)
            (let ((left-str (transpile-expr ctx left (none)))
                  (right-str (transpile-expr ctx right (none)))
                  (arena (. (deref ctx) arena)))
              (string-concat arena
                (string-concat arena "(" left-str)
                (string-concat arena (string-concat arena " " c-op)
                  (string-concat arena (string-concat arena " " right-str) ")")))))
          ((none) "")))
      ((none) "")))

  ;; ============================================================
  ;; Field and Index Access
  ;; ============================================================

  (fn transpile-field-access ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile field access (. base field) or (. base field1 field2 ...)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    ;; Use -> for pointers, . for values
    ;; Special case: (. (deref x) field) -> x->field
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some base-expr)
          (match (list-get (. lst items) 2)
            ((some field-expr)
              (match (deref field-expr)
                ((symbol s)
                  (let ((field-name (to-c-name arena (. s name))))
                    ;; Check if base is (deref x) - emit x->field
                    (if (is-form base-expr "deref")
                      (match (deref base-expr)
                        ((list deref-lst)
                          (match (list-get (. deref-lst items) 1)
                            ((some ptr-expr)
                              (let ((ptr-str (transpile-expr ctx ptr-expr (none))))
                                (string-concat arena ptr-str
                                  (string-concat arena "->" field-name))))
                            ((none) "")))
                        (_ ""))
                      ;; Normal case
                      (let ((base-str (transpile-expr ctx base-expr (none)))
                            (is-ptr (is-pointer-expr ctx base-expr))
                            (op (if is-ptr "->" ".")))
                        (string-concat arena base-str (string-concat arena op field-name))))))
                (_ "")))
            ((none) "")))
        ((none) ""))))

  (fn transpile-index-access ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile index access (@ array index)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    (match (list-get (. lst items) 1)
      ((some arr-expr)
        (match (list-get (. lst items) 2)
          ((some idx-expr)
            (let ((arr-str (transpile-expr ctx arr-expr (none)))
                  (idx-str (transpile-expr ctx idx-expr (none)))
                  (arena (. (deref ctx) arena)))
              (string-concat arena arr-str (string-concat arena "[" (string-concat arena idx-str "]")))))
          ((none) "")))
      ((none) "")))

  ;; ============================================================
  ;; Pointer Operations
  ;; ============================================================

  (fn transpile-addr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile address-of (addr var)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((some operand)
        (let ((operand-str (transpile-expr ctx operand (none)))
              (arena (. (deref ctx) arena)))
          (string-concat arena "&(" (string-concat arena operand-str ")"))))
      ((none) "")))

  (fn transpile-deref ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile pointer dereference (deref ptr)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((some ptr-expr)
        (let ((ptr-str (transpile-expr ctx ptr-expr (none)))
              (arena (. (deref ctx) arena)))
          ;; Use (*(ptr)) for correct precedence with field access
          (string-concat arena "(*(" (string-concat arena ptr-str "))"))))
      ((none) "")))

  (fn transpile-cast ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile type cast (cast Type expr)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    ;; Handle range type constructors vs simple casts (TODO: add range check)
    (match (list-get (. lst items) 1)
      ((some type-expr)
        (match (list-get (. lst items) 2)
          ((some val-expr)
            (let ((c-type (to-c-type ctx type-expr))
                  (val-str (transpile-expr ctx val-expr (none)))
                  (arena (. (deref ctx) arena)))
              (string-concat arena "(("
                (string-concat arena c-type
                  (string-concat arena ")("
                    (string-concat arena val-str "))"))))))
          ((none) "")))
      ((none) "")))

  ;; ============================================================
  ;; Option/Result Constructors
  ;; ============================================================

  (fn is-valid-option-type ((typ String))
    (@intent "Check if type is valid for Option constructor")
    (@spec ((String) -> Bool))
    (@pure)
    ;; Option types should start with slop_option_ or contain _option_
    ;; Don't use void, pointer types, or arbitrary types
    (and (not (string-eq typ "void"))
         (not (ends-with typ "*"))
         (or (starts-with typ "slop_option_")
             (contains typ "_option_"))))

  (fn transpile-none ((ctx (Ptr TranspileContext))
                      (expected-type (Option String)))
    (@intent "Transpile none constructor")
    (@spec (((Ptr TranspileContext) (Option String)) -> String))
    (@pre (!= ctx nil))
    ;; Output: ((type){ .has_value = false })
    (let ((arena (. (deref ctx) arena)))
      (match expected-type
        ((some typ)
          ;; Only use type if it's a valid option type
          (if (is-valid-option-type typ)
            (string-concat arena "((" (string-concat arena typ "){ .has_value = false })"))
            "(slop_option_string){ .has_value = false }"))
        ((none)
          (match (ctx-get-return-type ctx)
            ((some typ)
              ;; Only use type if it's a valid option type
              (if (is-valid-option-type typ)
                (string-concat arena "((" (string-concat arena typ "){ .has_value = false })"))
                "(slop_option_string){ .has_value = false }"))
            ;; Fallback for unknown type context - use string option (most common)
            ((none) "(slop_option_string){ .has_value = false }"))))))

  (fn transpile-some ((ctx (Ptr TranspileContext)) (lst SExprList)
                      (expected-type (Option String)))
    (@intent "Transpile some constructor (some value)")
    (@spec (((Ptr TranspileContext) SExprList (Option String)) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    ;; Output: ((type){ .has_value = true, .value = expr })
    (match (list-get (. lst items) 1)
      ((some val-expr)
        (let ((val-str (transpile-expr ctx val-expr (none)))
              (arena (. (deref ctx) arena))
              (typ (match expected-type
                     ((some t) t)
                     ((none) (match (ctx-get-return-type ctx)
                               ((some rt) rt)
                               ((none) "slop_option"))))))
          (string-concat arena
            (string-concat arena "((" typ)
            (string-concat arena "){ .has_value = true, .value = "
              (string-concat arena val-str " })")))))
      ((none) "")))

  (fn transpile-ok ((ctx (Ptr TranspileContext)) (lst SExprList)
                    (expected-type (Option String)))
    (@intent "Transpile ok constructor (ok value)")
    (@spec (((Ptr TranspileContext) SExprList (Option String)) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    ;; Output: ((type){ .is_ok = true, .data.ok = expr })
    (match (list-get (. lst items) 1)
      ((some val-expr)
        (let ((val-str (transpile-expr ctx val-expr (none)))
              (arena (. (deref ctx) arena))
              (typ (match expected-type
                     ((some t) t)
                     ((none) (match (ctx-get-return-type ctx)
                               ((some rt) rt)
                               ((none) "slop_result"))))))
          (string-concat arena
            (string-concat arena "((" typ)
            (string-concat arena "){ .is_ok = true, .data.ok = "
              (string-concat arena val-str " })")))))
      ((none) "")))

  (fn transpile-error ((ctx (Ptr TranspileContext)) (lst SExprList)
                       (expected-type (Option String)))
    (@intent "Transpile error constructor (error value)")
    (@spec (((Ptr TranspileContext) SExprList (Option String)) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    ;; Output: ((type){ .is_ok = false, .data.err = expr })
    (match (list-get (. lst items) 1)
      ((some err-expr)
        (let ((err-str (transpile-expr ctx err-expr (none)))
              (arena (. (deref ctx) arena))
              (typ (match expected-type
                     ((some t) t)
                     ((none) (match (ctx-get-return-type ctx)
                               ((some rt) rt)
                               ((none) "slop_result"))))))
          (string-concat arena
            (string-concat arena "((" typ)
            (string-concat arena "){ .is_ok = false, .data.err = "
              (string-concat arena err-str " })")))))
      ((none) "")))

  (fn transpile-early-return ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile early return operator (? expr)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    ;; Output: ({ __auto_type _tmp = expr; if (!_tmp.is_ok) return _tmp; _tmp.data.ok; })
    (match (list-get (. lst items) 1)
      ((some result-expr)
        (let ((result-str (transpile-expr ctx result-expr (none)))
              (arena (. (deref ctx) arena)))
          (string-concat arena "({ __auto_type _tmp = "
            (string-concat arena result-str
              "; if (!_tmp.is_ok) return _tmp; _tmp.data.ok; })"))))
      ((none) "")))

  ;; ============================================================
  ;; Collection Operations
  ;; ============================================================

  (fn transpile-list-new ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile list-new (list-new arena Type)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items)))
      (match (list-get items 1)
        ((some arena-expr)
          (let ((arena-str (transpile-expr ctx arena-expr (none))))
            ;; Check for explicit element type argument
            (match (list-get items 2)
              ((some type-expr)
                ;; (list-new arena Type) - use explicit type
                (let ((elem-c-type (to-c-type ctx type-expr))
                      (elem-id (type-to-identifier arena elem-c-type)))
                  (string-concat arena "((slop_list_"
                    (string-concat arena elem-id
                      (string-concat arena "){ .data = ("
                        (string-concat arena elem-c-type
                          (string-concat arena "*)slop_arena_alloc("
                            (string-concat arena arena-str
                              (string-concat arena ", 16 * sizeof("
                                (string-concat arena elem-c-type ")), .len = 0, .cap = 16 })"))))))))))
              ;; No type argument - fallback to void* list
              ((none)
                (string-concat arena "(slop_list_ptr){ .data = slop_arena_alloc("
                  (string-concat arena arena-str ", 16 * sizeof(void*)), .len = 0, .cap = 16 }"))))))
        ((none) ""))))

  (fn transpile-list-push ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile list-push (list-push list item) - inline with growth")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items)))
      (match (list-get items 1)
        ((some list-expr)
          (match (list-get items 2)
            ((some val-expr)
              (let ((list-str (transpile-expr ctx list-expr (none)))
                    (val-str (transpile-expr ctx val-expr (none)))
                    (arena-str (get-arena-from-expr ctx list-expr)))
                (string-concat arena "({ __auto_type _lst_p = &("
                  (string-concat arena list-str
                    (string-concat arena "); __auto_type _item = ("
                      (string-concat arena val-str
                        (string-concat arena "); if (_lst_p->len >= _lst_p->cap) { size_t _nc = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _nd = (__typeof__(_lst_p->data))slop_arena_alloc("
                          (string-concat arena arena-str
                            ", _nc * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_nd, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _nd; _lst_p->cap = _nc; } _lst_p->data[_lst_p->len++] = _item; })"))))))))
            ((none) "")))
        ((none) ""))))

  (fn transpile-list-pop ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile list-pop (list-pop list) -> Option<T>")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some list-expr)
          (let ((list-str (transpile-expr ctx list-expr (none))))
            ;; Generate inline pop returning Option using __typeof__
            (string-concat arena "({ __auto_type _lst_p = &("
              (string-concat arena list-str
                "); struct { bool has_value; __typeof__(_lst_p->data[0]) value; } _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; })"))))
        ((none) ""))))

  (fn infer-list-get-option-type ((ctx (Ptr TranspileContext)) (arena Arena)
                                   (list-expr (Ptr SExpr)) (fallback String))
    (@intent "Infer Option type for list-get, falling back to return type or anonymous struct")
    (@spec (((Ptr TranspileContext) Arena (Ptr SExpr) String) -> String))
    (@pre (!= ctx nil))
    (@pre (!= list-expr nil))
    (match (infer-expr-c-type ctx list-expr)
      ((some list-type)
        ;; Extract element type from slop_list_X -> slop_option_X
        (let ((prefix "slop_list_")
              (prefix-len (string-len prefix)))
          (if (>= (string-len list-type) prefix-len)
            (let ((elem-type (substring arena list-type
                               (cast (Int 0 ..) prefix-len)
                               (cast (Int 0 ..) (- (string-len list-type) prefix-len))))
                  (opt-name (string-concat arena "slop_option_" elem-type)))
              ;; Register the Option type for header emission
              (do
                (ctx-register-option ctx opt-name elem-type)
                opt-name))
            ;; List type doesn't match expected prefix, try return type
            (infer-option-from-return-type ctx fallback))))
      ((none)
        ;; Type inference failed, try return type
        (infer-option-from-return-type ctx fallback))))

  (fn infer-option-from-return-type ((ctx (Ptr TranspileContext)) (fallback String))
    (@intent "Get Option type from function return type if it's an Option")
    (@spec (((Ptr TranspileContext) String) -> String))
    (@pre (!= ctx nil))
    (match (ctx-get-return-type ctx)
      ((some ret-type)
        (if (starts-with ret-type "slop_option_")
          ret-type
          fallback))
      ((none) fallback)))

  (fn transpile-list-get ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile list-get (list-get list index) - returns Option")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (anon-struct "struct { bool has_value; __typeof__(_lst.data[0]) value; }"))
      (match (list-get (. lst items) 1)
        ((some list-expr)
          (match (list-get (. lst items) 2)
            ((some idx-expr)
              (let ((list-str (transpile-expr ctx list-expr (none)))
                    (idx-str (transpile-expr ctx idx-expr (none)))
                    ;; Infer the Option type from the list type, fall back to return type or anon struct
                    (option-type (infer-list-get-option-type ctx arena list-expr anon-struct)))
                ;; Generate inline bounds-checked access returning Option with named type
                (string-concat arena "({ __auto_type _lst = "
                  (string-concat arena list-str
                    (string-concat arena "; size_t _idx = (size_t)"
                      (string-concat arena idx-str
                        (string-concat arena "; "
                          (string-concat arena option-type
                            " _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; })"))))))))
            ((none) "")))
        ((none) ""))))

  (fn transpile-list-len ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile list-len (list-len list)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (match (list-get (. lst items) 1)
      ((none) "0")
      ((some expr)
        (let ((list-expr (transpile-expr ctx expr (none))))
          (string-concat (. (deref ctx) arena) list-expr ".len")))))

  (fn transpile-map-new ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-new (map-new arena) -> slop_map_new(arena, 16)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((items (. lst items))
          (arena (. (deref ctx) arena)))
      ;; map-new takes an arena argument
      (match (list-get items 1)
        ((some arena-expr)
          (let ((arena-str (transpile-expr ctx arena-expr (none))))
            (string-concat arena "slop_map_new("
              (string-concat arena arena-str ", 16)"))))
        ((none) "slop_map_new(arena, 16)"))))

  (fn transpile-map-put ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-put (map-put map key val)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((items (. lst items))
          (arena (. (deref ctx) arena)))
      (match (list-get items 1)
        ((some map-expr)
          (match (list-get items 2)
            ((some key-expr)
              (match (list-get items 3)
                ((some val-expr)
                  (let ((map-str (transpile-expr ctx map-expr (none)))
                        (key-str (transpile-expr ctx key-expr (none)))
                        (val-str (transpile-expr ctx val-expr (none)))
                        (arena-str (get-arena-from-expr ctx map-expr))
                        ;; Infer map type to generate typed put function
                        (map-type (infer-expr-c-type ctx map-expr))
                        (fn-name (match map-type
                                   ((some mt) (string-concat arena mt "_put"))
                                   ((none) "slop_map_put"))))
                    ;; Generate: map_type_put(arena_expr, &map, key, val)
                    (string-concat arena fn-name
                      (string-concat arena "("
                        (string-concat arena arena-str
                          (string-concat arena ", &"
                            (string-concat arena map-str
                              (string-concat arena ", "
                                (string-concat arena key-str
                                  (string-concat arena ", "
                                    (string-concat arena val-str ")")))))))))))
                ((none) "")))
            ((none) "")))
        ((none) ""))))

  (fn transpile-map-get ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-get (map-get map key)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (match (list-get (. lst items) 1)
      ((some map-expr)
        (match (list-get (. lst items) 2)
          ((some key-expr)
            (let ((map-str (transpile-expr ctx map-expr (none)))
                  (key-str (transpile-expr ctx key-expr (none)))
                  (arena (. (deref ctx) arena))
                  ;; Infer map type to generate typed get function
                  (map-type (infer-expr-c-type ctx map-expr))
                  (fn-name (match map-type
                             ((some mt) (string-concat arena mt "_get"))
                             ((none) "slop_map_get"))))
              (string-concat arena fn-name
                (string-concat arena "(&"
                  (string-concat arena map-str
                    (string-concat arena ", " (string-concat arena key-str ")")))))))
          ((none) "")))
      ((none) "")))

  (fn transpile-map-has ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-has (map-has map key)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (match (list-get (. lst items) 1)
      ((some map-expr)
        (match (list-get (. lst items) 2)
          ((some key-expr)
            (let ((map-str (transpile-expr ctx map-expr (none)))
                  (key-str (transpile-expr ctx key-expr (none)))
                  (arena (. (deref ctx) arena))
                  ;; Infer map type to generate typed has function
                  (map-type (infer-expr-c-type ctx map-expr))
                  (fn-name (match map-type
                             ((some mt) (string-concat arena mt "_has"))
                             ((none) "slop_map_has"))))
              (string-concat arena fn-name
                (string-concat arena "(&"
                  (string-concat arena map-str
                    (string-concat arena ", " (string-concat arena key-str ")")))))))
          ((none) "")))
      ((none) "")))

  (fn transpile-map-keys ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-keys (map-keys map)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (match (list-get (. lst items) 1)
      ((some map-expr)
        (let ((map-str (transpile-expr ctx map-expr (none)))
              (arena (. (deref ctx) arena)))
          (string-concat arena "slop_map_keys(arena, &"
            (string-concat arena map-str ")"))))
      ((none) "")))

  (fn transpile-map-remove ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile map-remove (map-remove map key)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (match (list-get (. lst items) 1)
      ((some map-expr)
        (match (list-get (. lst items) 2)
          ((some key-expr)
            (let ((map-str (transpile-expr ctx map-expr (none)))
                  (key-str (transpile-expr ctx key-expr (none)))
                  (arena (. (deref ctx) arena)))
              (string-concat arena "slop_map_remove(&"
                (string-concat arena map-str
                  (string-concat arena ", " (string-concat arena key-str ")"))))))
          ((none) "")))
      ((none) "")))

  ;; ============================================================
  ;; Record and Union Construction
  ;; ============================================================

  (fn transpile-record-new ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile record constructor (record-new Type (field val) ...)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    ;; Syntax: (record-new Type (field1 val1) (field2 val2) ...)
    ;; Output: ((TypeName){ .field1 = val1, .field2 = val2 })
    (let ((items (. lst items))
          (arena (. (deref ctx) arena))
          (len (list-len items)))
      (match (list-get items 1)
        ((some type-expr)
          (match (deref type-expr)
            ((symbol s)
              (let ((type-name (to-c-name arena (. s name)))
                    (mut fields-str ""))
                (do
                  ;; Iterate over field pairs starting at index 2
                  (for (i 2 len)
                    (match (list-get items i)
                      ((some field-pair)
                        (match (deref field-pair)
                          ((list pair-lst)
                            (match (list-get (. pair-lst items) 0)
                              ((some fname-expr)
                                (match (deref fname-expr)
                                  ((symbol fname-sym)
                                    (match (list-get (. pair-lst items) 1)
                                      ((some fval-expr)
                                        (let ((fname (to-c-name arena (. fname-sym name)))
                                              (fval (transpile-expr ctx fval-expr (none)))
                                              (init (string-concat arena "."
                                                      (string-concat arena fname
                                                        (string-concat arena " = " fval)))))
                                          (if (== i 2)
                                            (set! fields-str init)
                                            (set! fields-str (string-concat arena fields-str
                                                               (string-concat arena ", " init))))))
                                      ((none) (do))))
                                  (_ (do))))
                              ((none) (do))))
                          (_ (do))))
                      ((none) (do))))
                  ;; Build final output: ((TypeName){ fields })
                  (string-concat arena "(("
                    (string-concat arena type-name
                      (string-concat arena "){"
                        (string-concat arena fields-str "})")))))))
            (_ "/* invalid record-new */")))
        ((none) ""))))

  (fn transpile-union-new ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile union constructor (union-new Type tag value?)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    ;; Syntax: (union-new Type Tag value?)
    ;; Output with value: ((TypeName){ .tag = TypeName_tag_TAG, .data.tag = value })
    ;; Output without value: ((TypeName){ .tag = TypeName_tag_TAG })
    (let ((items (. lst items))
          (arena (. (deref ctx) arena))
          (len (list-len items)))
      (match (list-get items 1)
        ((some type-expr)
          (match (deref type-expr)
            ((symbol type-sym)
              (let ((type-name (to-qualified-type-name arena ctx (. type-sym name))))
                (match (list-get items 2)
                  ((some tag-expr)
                    (match (deref tag-expr)
                      ((symbol tag-sym)
                        (let ((tag (to-c-name arena (. tag-sym name)))
                              ;; Build tag constant: TypeName_tag_TAG
                              (tag-const (string-concat arena type-name
                                           (string-concat arena "_"
                                             (string-concat arena tag "_TAG")))))
                          (if (> len 3)
                            ;; Has payload value
                            (match (list-get items 3)
                              ((some val-expr)
                                (let ((val (transpile-expr ctx val-expr (none))))
                                  ;; ((TypeName){ .tag = TAG, .data.tag = val })
                                  (string-concat arena "(("
                                    (string-concat arena type-name
                                      (string-concat arena "){ .tag = "
                                        (string-concat arena tag-const
                                          (string-concat arena ", .data."
                                            (string-concat arena tag
                                              (string-concat arena " = "
                                                (string-concat arena val " })"))))))))))
                              ((none) "/* missing union value */"))
                            ;; No payload
                            (string-concat arena "(("
                              (string-concat arena type-name
                                (string-concat arena "){ .tag = "
                                  (string-concat arena tag-const " })")))))))
                      (_ "/* invalid union tag */")))
                  ((none) "/* missing union tag */"))))
            (_ "/* invalid union-new */")))
        ((none) ""))))

  ;; ============================================================
  ;; Quote (Enum Literals)
  ;; ============================================================

  (fn transpile-quote ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile quoted symbol as enum value (quote sym) or 'sym")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((some sym-expr)
        (match (deref sym-expr)
          ((symbol s)
            (let ((name (. s name))
                  (arena (. (deref ctx) arena)))
              (match (ctx-lookup-enum ctx name)
                ((some qualified) qualified)
                ((none) (to-c-name arena name)))))
          (_ "/* quote requires symbol */")))
      ((none) "")))

  ;; ============================================================
  ;; Print/Println
  ;; ============================================================

  (fn transpile-print ((ctx (Ptr TranspileContext)) (lst SExprList)
                       (newline Bool))
    (@intent "Transpile print/println to printf")
    (@spec (((Ptr TranspileContext) SExprList Bool) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (nl (if newline "\\n" "")))
      (if (< (list-len (. lst items)) 2)
        (if newline "printf(\"\\n\")" "0")
        (match (list-get (. lst items) 1)
          ((some arg-expr)
            (match (deref arg-expr)
              ((string s)
                (let ((escaped (escape-c-string ctx (. s value))))
                  (string-concat arena "printf(\"%s"
                    (string-concat arena nl
                      (string-concat arena "\", \""
                        (string-concat arena escaped "\")"))))))
              (_
                (let ((arg-str (transpile-expr ctx arg-expr (none))))
                  (string-concat arena "printf(\"%.*s"
                    (string-concat arena nl
                      (string-concat arena "\", (int)("
                        (string-concat arena arg-str
                          (string-concat arena ").len, ("
                            (string-concat arena arg-str ").data)"))))))))))
          ((none) "0")))))

  ;; ============================================================
  ;; C Inline and Sizeof
  ;; ============================================================

  (fn transpile-c-inline ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile c-inline (c-inline \"C code\")")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((some s-expr)
        (match (deref s-expr)
          ((string s) (. s value))
          (_ "/* invalid c-inline */")))
      ((none) "/* missing c-inline arg */")))

  (fn transpile-sizeof ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile sizeof (sizeof Type)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 2))
    (match (list-get (. lst items) 1)
      ((some type-expr)
        (let ((arena (. (deref ctx) arena)))
          (string-concat arena
            (string-concat arena "sizeof(" (to-c-type ctx type-expr))
            ")")))
      ((none) "")))

  (fn transpile-arena-alloc ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile arena-alloc (arena-alloc arena size)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (>= (list-len (. lst items)) 3))
    (match (list-get (. lst items) 1)
      ((some arena-arg)
        (match (list-get (. lst items) 2)
          ((some size-arg)
            (let ((arena-str (transpile-expr ctx arena-arg (none)))
                  (size-str (transpile-expr ctx size-arg (none)))
                  (arena (. (deref ctx) arena))
                  ;; Extract type from sizeof if present: (sizeof Type) -> Type*
                  (cast-type (match (deref size-arg)
                               ((list size-lst)
                                 (match (list-get (. size-lst items) 0)
                                   ((some head-expr)
                                     (match (deref head-expr)
                                       ((symbol head-sym)
                                         (if (string-eq (. head-sym name) "sizeof")
                                           ;; Found sizeof - extract the type
                                           (match (list-get (. size-lst items) 1)
                                             ((some type-expr)
                                               (string-concat arena "(" (string-concat arena (to-c-type ctx type-expr) "*)")))
                                             ((none) "(uint8_t*)"))
                                           "(uint8_t*)"))
                                       (_ "(uint8_t*)")))
                                   ((none) "(uint8_t*)")))
                               (_ "(uint8_t*)"))))
              (string-concat arena cast-type
                (string-concat arena "slop_arena_alloc("
                  (string-concat arena arena-str
                    (string-concat arena ", "
                      (string-concat arena size-str ")")))))))
          ((none) "")))
      ((none) "")))

  ;; ============================================================
  ;; Primitive Type Constructors
  ;; ============================================================

  (fn transpile-string-constructor ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile String constructor: (String data len)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (== (list-len (. lst items)) 3))
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some data-arg)
          (match (list-get (. lst items) 2)
            ((some len-arg)
              (let ((data-str (transpile-expr ctx data-arg (none)))
                    (len-str (transpile-expr ctx len-arg (none))))
                (string-concat arena "((slop_string){.data = "
                  (string-concat arena data-str
                    (string-concat arena ", .len = "
                      (string-concat arena len-str "})"))))))
            ((none) "/* missing len arg */")))
        ((none) "/* missing data arg */"))))

  (fn transpile-bytes-constructor ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile Bytes constructor: (Bytes data len cap)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (@pre (== (list-len (. lst items)) 4))
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some data-arg)
          (match (list-get (. lst items) 2)
            ((some len-arg)
              (match (list-get (. lst items) 3)
                ((some cap-arg)
                  (let ((data-str (transpile-expr ctx data-arg (none)))
                        (len-str (transpile-expr ctx len-arg (none)))
                        (cap-str (transpile-expr ctx cap-arg (none))))
                    (string-concat arena "((slop_bytes){.data = "
                      (string-concat arena data-str
                        (string-concat arena ", .len = "
                          (string-concat arena len-str
                            (string-concat arena ", .cap = "
                              (string-concat arena cap-str "})"))))))))
                ((none) "/* missing cap arg */")))
            ((none) "/* missing len arg */")))
        ((none) "/* missing data arg */"))))

  ;; ============================================================
  ;; Function Calls
  ;; ============================================================

  (fn transpile-function-call ((ctx (Ptr TranspileContext))
                               (fn-name String) (lst SExprList))
    (@intent "Transpile function call")
    (@spec (((Ptr TranspileContext) String SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          ;; Check if this is an FFI function - use C name directly, no prefix
          (c-name (match (ctx-lookup-ffi-func ctx fn-name)
                    ((some ffi-entry) (. ffi-entry c-name))
                    ((none) (to-qualified-name arena ctx fn-name))))
          (items (. lst items))
          (len (list-len items))
          (mut result ""))
      (do
        (set! result (string-concat arena c-name "("))
        (for (i 1 len)
          (match (list-get items i)
            ((some arg)
              (let ((arg-str (transpile-expr ctx arg (none))))
                (if (> i 1)
                  (set! result (string-concat arena result (string-concat arena ", " arg-str)))
                  (set! result (string-concat arena result arg-str)))))
            ((none) (do))))
        (set! result (string-concat arena result ")"))
        result)))

  ;; ============================================================
  ;; Type Inference Helpers
  ;; ============================================================

  (fn is-pointer-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression evaluates to a pointer type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre (!= ctx nil))
    (@pre (!= expr nil))
    (@pure)
    ;; Checks:
    ;; - Variable is marked as pointer
    ;; - arena-alloc result
    ;; - (addr x)
    ;; - (cast (Ptr T) x)
    ;; - Field access on pointer type yielding pointer
    ;; - Function call returning pointer
    (match (deref expr)
      ((symbol s)
        (ctx-is-pointer ctx (. s name)))
      ((list lst)
        (match (list-get (. lst items) 0)
          ((some head)
            (match (deref head)
              ((symbol op-sym)
                (let ((op (. op-sym name)))
                  (or (string-eq op "addr")
                      (or (string-eq op "arena-alloc")
                          (string-eq op "cast")))))
              (_ false)))
          ((none) false)))
      (_ false)))

  (fn is-string-expr ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Check if expression evaluates to String type")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> Bool))
    (@pre (!= ctx nil))
    (@pre (!= expr nil))
    (@pure)
    (match (deref expr)
      ((string _) true)
      ((symbol sym)
        (match (ctx-lookup-var ctx (. sym name))
          ((some entry) (string-eq (. entry c-type) "slop_string"))
          ((none) false)))
      (_ false)))

  (fn infer-expr-c-type ((ctx (Ptr TranspileContext)) (expr (Ptr SExpr)))
    (@intent "Infer the C type of an expression using type environment")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> (Option String)))
    (@pre (!= ctx nil))
    (@pre (!= expr nil))
    (@pure)
    (match (ctx-get-type-env ctx)
      ((none)
        ;; No type environment available, fall back to none
        (none))
      ((some type-env)
        ;; Use type environment for inference
        (match (deref expr)
          ;; Number literal -> int64_t or double
          ((number n)
            (if (. n is-float)
              (some "double")
              (some "int64_t")))
          ;; String literal -> slop_string_t
          ((string s)
            (some "slop_string_t"))
          ;; Symbol -> look up variable type
          ((symbol sym)
            (let ((name (. sym name)))
              (cond
                ;; Boolean literals
                ((or (string-eq name "true") (string-eq name "false"))
                  (some "bool"))
                ;; nil
                ((string-eq name "nil")
                  (some "void*"))
                ;; Variable lookup - try context first (for local vars)
                (else
                  (match (ctx-lookup-var ctx name)
                    ((some var-entry)
                      ;; If c-type is __auto_type, try type environment for specific type
                      (if (string-eq (. var-entry c-type) "__auto_type")
                        (match (env-lookup-var type-env name)
                          ((some resolved-type)
                            (some (. (deref resolved-type) c-name)))
                          ((none) (some "__auto_type")))
                        (some (. var-entry c-type))))
                    ((none)
                      ;; Try type environment
                      (match (env-lookup-var type-env name)
                        ((some resolved-type)
                          (some (. (deref resolved-type) c-name)))
                        ((none)
                          ;; Try as function (return type)
                          (match (env-lookup-function type-env name)
                            ((some fn-sig)
                              (some (. (deref (. (deref fn-sig) return-type)) c-name)))
                            ((none) (none)))))))))))
          ;; List expression (function call, operator, etc)
          ((list lst)
            (infer-list-c-type ctx type-env lst))))))

  (fn infer-list-c-type ((ctx (Ptr TranspileContext)) (type-env (Ptr TypeEnv)) (lst SExprList))
    (@intent "Infer C type of a list expression")
    (@spec (((Ptr TranspileContext) (Ptr TypeEnv) SExprList) -> (Option String)))
    (@pre (!= ctx nil))
    (@pre (!= type-env nil))
    (@pure)
    (let ((items (. lst items))
          (len (list-len items)))
      (if (== len 0)
        (some "void")
        (match (list-get items 0)
          ((none) (none))
          ((some head)
            (match (deref head)
              ((symbol sym)
                (let ((op (. sym name)))
                  (cond
                    ;; Comparison operators return bool
                    ((or (string-eq op "==") (string-eq op "!=")
                         (string-eq op "<") (string-eq op "<=")
                         (string-eq op ">") (string-eq op ">=")
                         (string-eq op "and") (string-eq op "or") (string-eq op "not"))
                      (some "bool"))
                    ;; Arithmetic operators return int64_t
                    ((or (string-eq op "+") (string-eq op "-")
                         (string-eq op "*") (string-eq op "/") (string-eq op "%"))
                      (some "int64_t"))
                    ;; Deref returns pointed-to type
                    ((string-eq op "deref")
                      (match (list-get items 1)
                        ((none) (none))
                        ((some arg-expr)
                          (match (infer-expr-c-type ctx arg-expr)
                            ((none) (none))
                            ((some ptr-type)
                              ;; Strip trailing _ptr or * to get base type
                              (let ((tlen (cast Int (string-len ptr-type)))
                                    (arena (. (deref ctx) arena)))
                                (cond
                                  ;; Check for _ptr suffix first (slop style)
                                  ((ends-with ptr-type "_ptr")
                                    (if (>= tlen 4)
                                      (some (substring arena ptr-type 0 (- tlen 4)))
                                      (some ptr-type)))
                                  ;; Check for * suffix (C style)
                                  ((ends-with ptr-type "*")
                                    (if (>= tlen 1)
                                      (some (substring arena ptr-type 0 (- tlen 1)))
                                      (some ptr-type)))
                                  ;; Not a pointer type we recognize
                                  (else (some ptr-type)))))))))
                    ;; list-get returns Option of element type
                    ((string-eq op "list-get")
                      (match (list-get items 1)
                        ((none) (none))
                        ((some list-expr)
                          (match (infer-expr-c-type ctx list-expr)
                            ((none) (none))
                            ((some list-type)
                              ;; Extract element type from slop_list_X -> slop_option_X
                              (let ((arena (. (deref ctx) arena))
                                    (prefix "slop_list_")
                                    (prefix-len (string-len prefix)))
                                (if (>= (string-len list-type) prefix-len)
                                  (let ((elem-type (substring arena list-type
                                                     (cast (Int 0 ..) prefix-len)
                                                     (cast (Int 0 ..) (- (string-len list-type) prefix-len)))))
                                    (some (string-concat arena "slop_option_" elem-type)))
                                  (none))))))))
                    ;; list-new returns List type based on element type
                    ((string-eq op "list-new")
                      (match (list-get items 2)
                        ((none) (none))
                        ((some type-expr)
                          (let ((arena (. (deref ctx) arena))
                                (elem-c-type (to-c-type ctx type-expr))
                                (elem-id (type-to-identifier arena elem-c-type)))
                            (some (string-concat arena "slop_list_" elem-id))))))
                    ;; Field access - look up field type from struct
                    ((string-eq op ".")
                      (match (list-get items 1)
                        ((none) (none))
                        ((some base-expr)
                          (match (list-get items 2)
                            ((none) (none))
                            ((some field-expr)
                              (match (deref field-expr)
                                ((symbol field-sym)
                                  (let ((field-name (. field-sym name))
                                        (arena (. (deref ctx) arena)))
                                    (match (infer-expr-c-type ctx base-expr)
                                      ((none) (none))
                                      ((some base-type)
                                        ;; Strip pointer suffix if present (_ptr or *)
                                        (let ((clean-type (cond
                                                            ((ends-with base-type "_ptr")
                                                              (substring arena base-type 0
                                                                (cast (Int 0 ..) (- (string-len base-type) 4))))
                                                            ((ends-with base-type "*")
                                                              (substring arena base-type 0
                                                                (cast (Int 0 ..) (- (string-len base-type) 1))))
                                                            (else base-type))))
                                          ;; Look up fields for this type
                                          (match (ctx-lookup-fields ctx clean-type)
                                            ((none) (none))
                                            ((some fields)
                                              ;; Find the field by name
                                              (let ((num-fields (list-len fields))
                                                    (mut result (Option String) (none))
                                                    (mut i 0))
                                                (do
                                                  (while (< i num-fields)
                                                    (match (list-get fields i)
                                                      ((some f)
                                                        (when (string-eq (. f name) field-name)
                                                          (set! result (some (. f c-type)))))
                                                      ((none) (do)))
                                                    (set! i (+ i 1)))
                                                  result)))))))))
                                (_ (none))))))))
                    ;; Function call - look up return type
                    (else
                      (match (env-lookup-function type-env op)
                        ((some fn-sig)
                          (some (. (deref (. (deref fn-sig) return-type)) c-name)))
                        ((none) (none)))))))
              (_ (none))))))))

  ;; ============================================================
  ;; Statement Forms as Expressions
  ;; ============================================================

  (fn transpile-set-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile set! as expression: (set! var val) -> (var = val)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some var-expr)
          (match (list-get (. lst items) 2)
            ((some val-expr)
              (let ((var-str (transpile-expr ctx var-expr (none)))
                    (val-str (transpile-expr ctx val-expr (none))))
                (string-concat arena "("
                  (string-concat arena var-str
                    (string-concat arena " = "
                      (string-concat arena val-str ")"))))))
            ((none) "/* missing set! value */")))
        ((none) "/* missing set! var */"))))

  (fn transpile-if-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile if as expression: (if cond then else) -> (cond ? then : else)")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena)))
      (match (list-get (. lst items) 1)
        ((some cond-expr)
          (match (list-get (. lst items) 2)
            ((some then-expr)
              (let ((cond-str (transpile-expr ctx cond-expr (none)))
                    (then-str (transpile-expr ctx then-expr (none))))
                (match (list-get (. lst items) 3)
                  ((some else-expr)
                    (let ((else-str (transpile-expr ctx else-expr (none))))
                      (string-concat arena "("
                        (string-concat arena cond-str
                          (string-concat arena " ? "
                            (string-concat arena then-str
                              (string-concat arena " : "
                                (string-concat arena else-str ")"))))))))
                  ;; No else branch - use void expression
                  ((none)
                    (string-concat arena "("
                      (string-concat arena cond-str
                        (string-concat arena " ? "
                          (string-concat arena then-str " : (void)0)"))))))))
            ((none) "/* missing if then */")))
        ((none) "/* missing if cond */"))))

  (fn transpile-let-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile let as expression using GCC statement expression")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items))
          (mut result "({ "))
      ;; Need at least (let ((bindings...)) body)
      (if (< num-items 2)
        "({ 0; })"
        (do
          ;; Process bindings (item 1)
          (match (list-get items 1)
            ((some bindings-expr)
              (match (deref bindings-expr)
                ((list bindings-lst)
                  (let ((binding-items (. bindings-lst items))
                        (num-bindings (list-len binding-items)))
                    (for (bi 0 num-bindings)
                      (match (list-get binding-items bi)
                        ((some binding)
                          (match (deref binding)
                            ((list bind-lst)
                              (let ((bind-items (. bind-lst items))
                                    (bind-len (list-len bind-items)))
                                ;; Handle (mut var init) or (var init)
                                (match (list-get bind-items 0)
                                  ((some first-expr)
                                    (match (deref first-expr)
                                      ((symbol first-sym)
                                        (if (== (. first-sym name) "mut")
                                          ;; (mut var init) - var at index 1, init at index 2
                                          (when (>= bind-len 3)
                                            (match (list-get bind-items 1)
                                              ((some var-expr)
                                                (match (deref var-expr)
                                                  ((symbol var-sym)
                                                    (match (list-get bind-items 2)
                                                      ((some init-expr)
                                                        (let ((var-name (to-c-name arena (. var-sym name)))
                                                              (init-str (transpile-expr ctx init-expr (none))))
                                                          (set! result (string-concat arena result
                                                            (string-concat arena "__auto_type "
                                                              (string-concat arena var-name
                                                                (string-concat arena " = "
                                                                  (string-concat arena init-str "; "))))))))
                                                      ((none) (do))))
                                                  (_ (do))))
                                              ((none) (do))))
                                          ;; (var init) - var at index 0, init at index 1
                                          (when (>= bind-len 2)
                                            (match (list-get bind-items 1)
                                              ((some init-expr)
                                                (let ((var-name (to-c-name arena (. first-sym name)))
                                                      (init-str (transpile-expr ctx init-expr (none))))
                                                  (set! result (string-concat arena result
                                                    (string-concat arena "__auto_type "
                                                      (string-concat arena var-name
                                                        (string-concat arena " = "
                                                          (string-concat arena init-str "; "))))))))
                                              ((none) (do))))))
                                      (_ (do))))
                                  ((none) (do)))))
                            (_ (do))))
                        ((none) (do))))))
                (_ (do))))
            ((none) (do)))
          ;; Process body expressions (items 2+)
          (for (i 2 num-items)
            (match (list-get items i)
              ((some body-expr)
                (let ((body-str (transpile-expr ctx body-expr (none))))
                  (set! result (string-concat arena result
                    (string-concat arena body-str "; ")))))
              ((none) (do))))
          (string-concat arena result "})")))))

  (fn transpile-while-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile while as expression: ({ while(cond) { body }; 0; })")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items)))
      ;; Need at least (while cond)
      (if (< num-items 2)
        "({ 0; })"
        (match (list-get items 1)
          ((some cond-expr)
            (let ((cond-str (transpile-expr ctx cond-expr (none)))
                  (mut body-str ""))
              (do
                ;; Collect body expressions (items 2+)
                (for (i 2 num-items)
                  (match (list-get items i)
                    ((some body-expr)
                      (let ((expr-str (transpile-expr ctx body-expr (none))))
                        (set! body-str (string-concat arena body-str
                          (string-concat arena expr-str "; ")))))
                    ((none) (do))))
                ;; Build: ({ while (cond) { body } 0; })
                (string-concat arena "({ while ("
                  (string-concat arena cond-str
                    (string-concat arena ") { "
                      (string-concat arena body-str "} 0; })")))))))
          ((none) "({ 0; })")))))

  (fn transpile-for-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile for as expression: ({ for(i=start; i<end; i++) { body }; 0; })")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items)))
      ;; Need at least (for (var start end))
      (if (< num-items 2)
        "({ 0; })"
        (match (list-get items 1)
          ((some range-expr)
            (match (deref range-expr)
              ((list range-lst)
                (let ((range-items (. range-lst items)))
                  ;; Extract var, start, end from (var start end)
                  (match (list-get range-items 0)
                    ((some var-expr)
                      (match (deref var-expr)
                        ((symbol sym)
                          (let ((var-name (to-c-name arena (. sym name))))
                            (match (list-get range-items 1)
                              ((some start-expr)
                                (match (list-get range-items 2)
                                  ((some end-expr)
                                    (let ((start-str (transpile-expr ctx start-expr (none)))
                                          (end-str (transpile-expr ctx end-expr (none)))
                                          (mut body-str ""))
                                      (do
                                        ;; Collect body expressions (items 2+)
                                        (for (i 2 num-items)
                                          (match (list-get items i)
                                            ((some body-expr)
                                              (let ((expr-str (transpile-expr ctx body-expr (none))))
                                                (set! body-str (string-concat arena body-str
                                                  (string-concat arena expr-str "; ")))))
                                            ((none) (do))))
                                        ;; Build: ({ for (int64_t var = start; var < end; var++) { body } 0; })
                                        (string-concat arena "({ for (int64_t "
                                          (string-concat arena var-name
                                            (string-concat arena " = "
                                              (string-concat arena start-str
                                                (string-concat arena "; "
                                                  (string-concat arena var-name
                                                    (string-concat arena " < "
                                                      (string-concat arena end-str
                                                        (string-concat arena "; "
                                                          (string-concat arena var-name
                                                            (string-concat arena "++) { "
                                                              (string-concat arena body-str "} 0; })")))))))))))))))
                                  ((none) "({ 0; })")))
                              ((none) "({ 0; })"))))
                        (_ "({ 0; })")))
                    ((none) "({ 0; })"))))
              (_ "({ 0; })")))
          ((none) "({ 0; })")))))

  (fn transpile-for-each-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile for-each as expression")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items)))
      ;; Need at least (for-each (var list))
      (if (< num-items 2)
        "({ 0; })"
        (match (list-get items 1)
          ((some iter-expr)
            (match (deref iter-expr)
              ((list iter-lst)
                (let ((iter-items (. iter-lst items)))
                  ;; Extract var and list from (var list)
                  (match (list-get iter-items 0)
                    ((some var-expr)
                      (match (deref var-expr)
                        ((symbol var-sym)
                          (match (list-get iter-items 1)
                            ((some list-expr)
                              (let ((var-name (to-c-name arena (. var-sym name)))
                                    (list-str (transpile-expr ctx list-expr (none)))
                                    (mut body-str ""))
                                (do
                                  ;; Collect body expressions (items 2+)
                                  (for (i 2 num-items)
                                    (match (list-get items i)
                                      ((some body-expr)
                                        (let ((expr-str (transpile-expr ctx body-expr (none))))
                                          (set! body-str (string-concat arena body-str
                                            (string-concat arena expr-str "; ")))))
                                      ((none) (do))))
                                  ;; Build: ({ slop_list_T _lst = list; for (uint64_t _i = 0; _i < _lst.len; _i++) { auto var = _lst.items[_i]; body } 0; })
                                  (string-concat arena "({ __auto_type _fe_lst = "
                                    (string-concat arena list-str
                                      (string-concat arena "; for (uint64_t _fe_i = 0; _fe_i < _fe_lst.len; _fe_i++) { __auto_type "
                                        (string-concat arena var-name
                                          (string-concat arena " = _fe_lst.items[_fe_i]; "
                                            (string-concat arena body-str "} 0; })")))))))))
                            ((none) "({ 0; })")))
                        (_ "({ 0; })")))
                    ((none) "({ 0; })"))))
              (_ "({ 0; })")))
          ((none) "({ 0; })")))))

  (fn transpile-do-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile do as expression: sequence returning last value")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items)))
      (cond
        ;; Empty do -> 0
        ((<= num-items 1)
          "0")
        ;; Single expression -> just transpile it
        ((== num-items 2)
          (match (list-get items 1)
            ((some expr) (transpile-expr ctx expr (none)))
            ((none) "0")))
        ;; Multiple expressions -> GCC statement expression
        (else
          (let ((mut result "({ "))
            (do
              (for (i 1 num-items)
                (match (list-get items i)
                  ((some expr)
                    (let ((expr-str (transpile-expr ctx expr (none))))
                      (set! result (string-concat arena result
                        (string-concat arena expr-str "; ")))))
                  (none (do))))
              (string-concat arena result "})")))))))

  (fn transpile-match-expr ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile match as expression using GCC statement expression")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items)))
      (if (< num-items 3)
        "/* invalid match */"
        ;; For exactly 2 cases (common Option/Result pattern), use ternary
        (if (== num-items 4)
          (transpile-match-ternary ctx lst)
          ;; For more cases, use if-else chain with explicit result type
          (match (list-get items 1)
            ((some target-expr)
              (let ((target-str (transpile-expr ctx target-expr (none)))
                    (first-body (transpile-match-first-body ctx lst))
                    (cases-str (transpile-match-cases ctx lst 2)))
                (string-concat arena "({ __auto_type _match_scrutinee = "
                  (string-concat arena target-str
                    (string-concat arena "; typeof("
                      (string-concat arena first-body
                        (string-concat arena ") _match_result; "
                          (string-concat arena cases-str
                            " _match_result; })"))))))))
            ((none) "/* match: missing target */"))))))

  (fn transpile-match-ternary ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Transpile two-case match as ternary expression")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items)))
      (match (list-get items 1)
        ((some target-expr)
          (let ((target-str (transpile-expr ctx target-expr (none))))
            (match (list-get items 2)
              ((some case1-expr)
                (match (list-get items 3)
                  ((some case2-expr)
                    (let ((case1-test (transpile-match-case-test ctx case1-expr))
                          (case1-body (transpile-match-case-body-expr ctx case1-expr))
                          (case2-body (transpile-match-case-body-expr ctx case2-expr)))
                      (string-concat arena "({ __auto_type _match_scrutinee = "
                        (string-concat arena target-str
                          (string-concat arena "; "
                            (string-concat arena case1-test
                              (string-concat arena " ? "
                                (string-concat arena case1-body
                                  (string-concat arena " : "
                                    (string-concat arena case2-body "; })"))))))))))
                  ((none) "/* match: missing case 2 */")))
              ((none) "/* match: missing case 1 */"))))
        ((none) "/* match: missing target */"))))

  (fn transpile-match-case-test ((ctx (Ptr TranspileContext)) (case-expr (Ptr SExpr)))
    (@intent "Get test condition from a match case")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= case-expr nil))
    (match (deref case-expr)
      ((list case-lst)
        (let ((case-items (. case-lst items)))
          (match (list-get case-items 0)
            ((some pattern-expr)
              (transpile-match-pattern ctx pattern-expr))
            ((none) "true"))))
      (_ "true")))

  (fn transpile-match-case-body-expr ((ctx (Ptr TranspileContext)) (case-expr (Ptr SExpr)))
    (@intent "Get body expression from a match case, wrapped with bindings")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= case-expr nil))
    (let ((arena (. (deref ctx) arena)))
      (match (deref case-expr)
        ((list case-lst)
          (let ((case-items (. case-lst items)))
            (match (list-get case-items 0)
              ((some pattern-expr)
                (let ((binding (transpile-match-binding ctx pattern-expr))
                      (body (transpile-match-body ctx case-lst 1)))
                  (if (== (string-len binding) 0)
                    body
                    (string-concat arena "({ "
                      (string-concat arena binding
                        (string-concat arena body "; })"))))))
              ((none) "0"))))
        (_ "0"))))

  (fn transpile-match-first-body ((ctx (Ptr TranspileContext)) (lst SExprList))
    (@intent "Get the body expression of the first match case for typeof")
    (@spec (((Ptr TranspileContext) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((items (. lst items)))
      (match (list-get items 2)
        ((some case-expr)
          (transpile-match-case-body-expr ctx case-expr))
        ((none) "0"))))

  (fn transpile-match-cases ((ctx (Ptr TranspileContext)) (lst SExprList)
                              (start-idx Int))
    (@intent "Transpile match cases as nested if/else expressions")
    (@spec (((Ptr TranspileContext) SExprList Int) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-items (list-len items))
          (mut result ""))
      (do
        (for (i start-idx num-items)
          (let ((case-result (transpile-one-match-case ctx lst i)))
            (when (> (string-len case-result) 0)
              (if (== (string-len result) 0)
                (set! result case-result)
                (set! result (string-concat arena result
                  (string-concat arena " else " case-result)))))))
        result)))

  (fn transpile-one-match-case ((ctx (Ptr TranspileContext)) (lst SExprList)
                                 (idx Int))
    (@intent "Transpile a single match case")
    (@spec (((Ptr TranspileContext) SExprList Int) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items)))
      (match (list-get items idx)
        ((some case-expr)
          (match (deref case-expr)
            ((list case-lst)
              (let ((case-items (. case-lst items)))
                (if (< (list-len case-items) 2)
                  ""
                  (match (list-get case-items 0)
                    ((some pattern-expr)
                      (let ((test (transpile-match-pattern ctx pattern-expr))
                            (binding (transpile-match-binding ctx pattern-expr))
                            (body (transpile-match-body ctx case-lst 1)))
                        (string-concat arena "if ("
                          (string-concat arena test
                            (string-concat arena ") { "
                              (string-concat arena binding
                                (string-concat arena "_match_result = "
                                  (string-concat arena body "; }"))))))))
                    ((none) "")))))
            (_ "")))
        ((none) ""))))

  (fn transpile-match-binding ((ctx (Ptr TranspileContext)) (pattern (Ptr SExpr)))
    (@intent "Generate variable bindings from match pattern")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= pattern nil))
    (let ((arena (. (deref ctx) arena)))
      (match (deref pattern)
        ((list pattern-lst)
          (let ((pattern-items (. pattern-lst items)))
            (if (< (list-len pattern-items) 2)
              ""
              (match (list-get pattern-items 0)
                ((some head-expr)
                  (match (deref head-expr)
                    ((symbol head-sym)
                      (let ((head-name (. head-sym name)))
                        (cond
                          ((string-eq head-name "some")
                            (match (list-get pattern-items 1)
                              ((some bind-expr)
                                (match (deref bind-expr)
                                  ((symbol bind-sym)
                                    (string-concat arena "__auto_type "
                                      (string-concat arena (to-c-name arena (. bind-sym name))
                                        " = _match_scrutinee.value; ")))
                                  (_ "")))
                              ((none) "")))
                          ((string-eq head-name "ok")
                            (match (list-get pattern-items 1)
                              ((some bind-expr)
                                (match (deref bind-expr)
                                  ((symbol bind-sym)
                                    (string-concat arena "__auto_type "
                                      (string-concat arena (to-c-name arena (. bind-sym name))
                                        " = _match_scrutinee.data.ok; ")))
                                  (_ "")))
                              ((none) "")))
                          ((string-eq head-name "error")
                            (match (list-get pattern-items 1)
                              ((some bind-expr)
                                (match (deref bind-expr)
                                  ((symbol bind-sym)
                                    (string-concat arena "__auto_type "
                                      (string-concat arena (to-c-name arena (. bind-sym name))
                                        " = _match_scrutinee.data.err; ")))
                                  (_ "")))
                              ((none) "")))
                          (else ""))))
                    (_ "")))
                ((none) "")))))
        (_ ""))))

  (fn transpile-match-pattern ((ctx (Ptr TranspileContext)) (pattern (Ptr SExpr)))
    (@intent "Generate C condition for match pattern")
    (@spec (((Ptr TranspileContext) (Ptr SExpr)) -> String))
    (@pre (!= ctx nil))
    (@pre (!= pattern nil))
    (let ((arena (. (deref ctx) arena)))
      (match (deref pattern)
        ((list pattern-lst)
          (let ((pattern-items (. pattern-lst items)))
            (match (list-get pattern-items 0)
              ((some head-expr)
                (match (deref head-expr)
                  ((symbol head-sym)
                    (let ((head-name (. head-sym name)))
                      (cond
                        ;; Option patterns
                        ((string-eq head-name "some")
                          "_match_scrutinee.has_value")
                        ((string-eq head-name "none")
                          "!_match_scrutinee.has_value")
                        ;; Result patterns
                        ((string-eq head-name "ok")
                          "_match_scrutinee.is_ok")
                        ((string-eq head-name "error")
                          "!_match_scrutinee.is_ok")
                        ;; Enum/Union patterns - need the variant name
                        (else
                          (string-concat arena "_match_scrutinee == "
                            (to-c-name arena head-name))))))
                  (_ "true")))
              ((none) "true"))))
        ((symbol sym)
          ;; Bare symbol pattern (enum variant or wildcard)
          (if (string-eq (. sym name) "_")
            "true"
            (string-concat arena "_match_scrutinee == "
              (to-c-name arena (. sym name)))))
        (_ "true"))))

  (fn transpile-match-body ((ctx (Ptr TranspileContext)) (case-lst SExprList)
                            (start-idx Int))
    (@intent "Transpile match case body expressions")
    (@spec (((Ptr TranspileContext) SExprList Int) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. case-lst items))
          (num-items (list-len items))
          (mut result ""))
      (do
        ;; Transpile all body expressions
        (for (i start-idx num-items)
          (match (list-get items i)
            ((some expr)
              (let ((expr-str (transpile-expr ctx expr (none))))
                (if (== i (- num-items 1))
                  ;; Last expression is the result
                  (set! result (string-concat arena result expr-str))
                  ;; Earlier expressions are statements
                  (set! result (string-concat arena result
                    (string-concat arena expr-str "; "))))))
            ((none) (do))))
        result)))

  ;; ============================================================
  ;; Positional Record Constructor
  ;; ============================================================

  (fn transpile-record-ctor ((ctx (Ptr TranspileContext)) (type-name String)
                             (fields (List CFieldInfo)) (lst SExprList))
    (@intent "Transpile positional record constructor: (Type arg1 arg2...) -> ((Type){.f1=a1, ...})")
    (@spec (((Ptr TranspileContext) String (List CFieldInfo) SExprList) -> String))
    (@pre (!= ctx nil))
    (let ((arena (. (deref ctx) arena))
          (items (. lst items))
          (num-args (- (list-len items) 1))
          (num-fields (list-len fields))
          (mut result ""))
      (do
        ;; Start with ((TypeName){
        (set! result (string-concat arena "(("
                       (string-concat arena type-name "){")))
        ;; Add each field assignment
        (for (i 0 num-fields)
          (match (list-get fields i)
            ((some field-info)
              (let ((field-c-name (. field-info c-name))
                    (field-c-type (. field-info c-type)))
                ;; Get corresponding argument (index i+1 in items)
                (match (list-get items (+ i 1))
                  ((some arg-expr)
                    ;; Pass field c-type as expected type for proper option transpilation
                    (let ((arg-str (transpile-expr ctx arg-expr (some field-c-type)))
                          (field-assign (string-concat arena "."
                                          (string-concat arena field-c-name
                                            (string-concat arena " = " arg-str)))))
                      (if (== i 0)
                        (set! result (string-concat arena result field-assign))
                        (set! result (string-concat arena result
                                       (string-concat arena ", " field-assign))))))
                  ((none) (do)))))
            ((none) (do))))
        ;; Close with })
        (set! result (string-concat arena result "})"))
        result)))
)
