;; ============================================================
;; SLOP Transpiler CLI - Native transpiler binary entry point
;;
;; Usage: slop-transpiler <file1.slop> [file2.slop ...]
;; Transpiles SLOP source file(s) to separate .h/.c per module.
;; Output is JSON: {"module": {"header": "...", "impl": "..."}, ...}
;; Files should be listed in dependency order (dependencies first).
;; ============================================================

(module transpiler-cli
  (export (main 2))

  (import file (FileMode FileError File
                file-open file-close file-read-all file-write))
  (import parser (ParseResult ParseError SExpr SExprList parse))
  (import transpiler (TranspileResult TranspileError ModuleOutput transpile-modules))
  (import strlib (starts-with char-at))

  ;; FFI for string operations
  (ffi "string.h"
    (strlen ((s (Ptr U8))) U64))

  (fn main ((argc Int) (argv (Ptr (Ptr U8))))
    (@intent "Transpile SLOP file(s) to C code (split mode)")
    (@spec ((Int (Ptr (Ptr U8))) -> Int))
    (if (< argc 2)
      (do
        (println "Usage: slop-transpiler <file1.slop> [file2.slop ...]")
        (println "")
        (println "Transpiles SLOP modules to separate .h/.c per module.")
        (println "Output is JSON to stdout.")
        (println "Files should be listed in dependency order (dependencies first).")
        1)
      (with-arena 134217728  ;; 128MB arena for multi-file transpiling
        (let ((input-files (collect-input-files arena argc argv)))
          (if (== (list-len input-files) 0)
            (do
              (println "Error: No input files specified")
              1)
            ;; Parse all input files
            (let ((module-asts (list-new arena (List (Ptr SExpr))))
                  (mut parse-success true))
              (for-each (path input-files)
                (when parse-success
                  (match (parse-file arena path)
                    ((ok ast)
                      (list-push module-asts ast))
                    ((error _msg)
                      (do
                        (print "Error parsing ")
                        (println path)
                        (println "  Parse failed")
                        (set! parse-success false))))))
              (if (not parse-success)
                1
                ;; Transpile all modules
                (match (transpile-modules arena module-asts)
                  ((error e)
                    (do
                      (print "Transpile error at line ")
                      (print (. e line))
                      (print ", col ")
                      (print (. e col))
                      (print ": ")
                      (println (. e message))
                      1))
                  ((ok results)
                    ;; Output JSON
                    (output-json arena results))))))))))

  (fn collect-input-files ((arena Arena) (argc Int) (argv (Ptr (Ptr U8))))
    (@intent "Collect input .slop files from argv")
    (@spec ((Arena Int (Ptr (Ptr U8))) -> (List String)))
    (@alloc arena)
    (let ((files (list-new arena String))
          (mut i 1))
      (while (< i argc)
        (let ((arg (String (@ argv i) (strlen (@ argv i)))))
          (if (starts-with arg "-")
            ;; Skip flags
            (do)
            (list-push files arg)))
        (set! i (+ i 1)))
      files))

  (fn parse-file ((arena Arena) (path String))
    (@intent "Read and parse a SLOP file")
    (@spec ((Arena String) -> (Result (List (Ptr SExpr)) String)))
    (@alloc arena)
    (match (file-open path 'read)
      ((error e)
        (error "Could not open file"))
      ((ok f)
        (match (file-read-all arena (addr f))
          ((error e)
            (do
              (file-close (addr f))
              (error "Could not read file")))
          ((ok source)
            (do
              (file-close (addr f))
              (match (parse arena source)
                ((ok ast) (ok ast))
                ((error e)
                  (error (. e message))))))))))

  (fn output-json ((arena Arena) (results (List ModuleOutput)))
    (@intent "Output results as JSON to stdout")
    (@spec ((Arena (List ModuleOutput)) -> Int))
    (print "{")
    (let ((mut first true))
      (for-each (mod results)
        (do
          (if first
            (set! first false)
            (print ","))
          (print "\"")
          (print (. mod name))
          (print "\":{\"header\":\"")
          (print-json-escaped (. mod header))
          (print "\",\"impl\":\"")
          (print-json-escaped (. mod impl))
          (print "\"}"))))
    (println "}")
    0)

  (fn print-json-escaped ((s String))
    (@intent "Print string with JSON escaping")
    (@spec ((String) -> Unit))
    (let ((len (cast Int (string-len s))))
      (for (i 0 len)
        (let ((c (char-at s i)))
          (cond
            ((== c 10)  ;; newline
              (do (print "\\") (print "n")))
            ((== c 13)  ;; carriage return
              (do (print "\\") (print "r")))
            ((== c 9)   ;; tab
              (do (print "\\") (print "t")))
            ((== c 34)  ;; double quote
              (do (print "\\") (print "\"")))
            ((== c 92)  ;; backslash
              (do (print "\\") (print "\\")))
            (else
              ;; Print single character
              (print (String (cast (Ptr U8) (addr c)) 1))))))))
)
