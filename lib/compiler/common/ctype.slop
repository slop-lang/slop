;; ============================================================
;; SLOP Native Transpiler - C Type Module
;;
;; SLOP type → C type conversion, identifier mangling,
;; and builtin type mappings.
;; ============================================================

(module ctype
  (export
    ;; Type conversion
    to-c-type to-c-name type-to-identifier sexpr-to-type-string
    ;; Builtin type lookup
    builtin-type-c is-builtin-type is-builtin-c-type
    ;; Type category predicates
    is-int-type is-float-type is-bool-type is-numeric-type
    ;; Range type handling
    range-type-to-c-type
    ;; C keyword check
    is-c-keyword
    ;; Resolved type bridge (checker → transpiler)
    get-node-resolved-type resolved-type-to-c)

  (import types (SExpr SExprList SExprSymbol SExprString SExprNumber
                 ResolvedType ResolvedTypeKind))
  (import strlib (replace replace-all starts-with substring))

  ;; ============================================================
  ;; C Keywords (must be escaped in identifiers)
  ;; ============================================================

  (fn is-c-keyword ((name String))
    (@intent "Check if name is a C reserved keyword")
    (@spec ((String) -> Bool))
    (@example ("int") -> true)
    (@example ("foo") -> false)
    (or (string-eq name "auto")
        (string-eq name "break")
        (string-eq name "case")
        (string-eq name "char")
        (string-eq name "const")
        (string-eq name "continue")
        (string-eq name "default")
        (string-eq name "do")
        (string-eq name "double")
        (string-eq name "else")
        (string-eq name "enum")
        (string-eq name "extern")
        (string-eq name "float")
        (string-eq name "for")
        (string-eq name "goto")
        (string-eq name "if")
        (string-eq name "int")
        (string-eq name "long")
        (string-eq name "register")
        (string-eq name "return")
        (string-eq name "short")
        (string-eq name "signed")
        (string-eq name "sizeof")
        (string-eq name "static")
        (string-eq name "struct")
        (string-eq name "switch")
        (string-eq name "typedef")
        (string-eq name "union")
        (string-eq name "unsigned")
        (string-eq name "void")
        (string-eq name "volatile")
        (string-eq name "while")
        (string-eq name "inline")
        (string-eq name "restrict")))

  ;; ============================================================
  ;; Builtin Type Mapping
  ;; ============================================================

  (fn is-builtin-type ((name String))
    (@intent "Check if name is a builtin SLOP type")
    (@spec ((String) -> Bool))
    (@example ("Int") -> true)
    (@example ("MyRecord") -> false)
    (or (string-eq name "Int")
        (string-eq name "I8")
        (string-eq name "I16")
        (string-eq name "I32")
        (string-eq name "I64")
        (string-eq name "U8")
        (string-eq name "U16")
        (string-eq name "U32")
        (string-eq name "U64")
        (string-eq name "Char")
        (string-eq name "Float")
        (string-eq name "F32")
        (string-eq name "Bool")
        (string-eq name "String")
        (string-eq name "Bytes")
        (string-eq name "Unit")
        (string-eq name "Void")
        (string-eq name "Arena")
        (string-eq name "Milliseconds")))

  (fn is-builtin-c-type ((c-name String))
    (@intent "Check if name is a builtin C type (int64_t, slop_string, etc.)")
    (@spec ((String) -> Bool))
    (@example ("int64_t") -> true)
    (@example ("slop_string") -> true)
    (@example ("MyRecord") -> false)
    (or (string-eq c-name "int64_t")
        (string-eq c-name "int32_t")
        (string-eq c-name "int16_t")
        (string-eq c-name "int8_t")
        (string-eq c-name "uint64_t")
        (string-eq c-name "uint32_t")
        (string-eq c-name "uint16_t")
        (string-eq c-name "uint8_t")
        (string-eq c-name "double")
        (string-eq c-name "float")
        (string-eq c-name "bool")
        (string-eq c-name "char")
        (string-eq c-name "void")
        (string-eq c-name "slop_string")
        (string-eq c-name "slop_bytes")
        (string-eq c-name "slop_arena")
        (string-eq c-name "slop_arena*")))

  ;; ============================================================
  ;; Type Category Predicates
  ;; ============================================================

  (fn is-int-type ((name String))
    (@intent "Check if SLOP or C type name is an integer type")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (string-eq name "I8")  (string-eq name "I16")
        (string-eq name "I32") (string-eq name "I64")
        (string-eq name "U8")  (string-eq name "U16")
        (string-eq name "U32") (string-eq name "U64")
        (string-eq name "int64_t")  (string-eq name "int32_t")
        (string-eq name "int16_t")  (string-eq name "int8_t")
        (string-eq name "uint64_t") (string-eq name "uint32_t")
        (string-eq name "uint16_t") (string-eq name "uint8_t")))

  (fn is-float-type ((name String))
    (@intent "Check if SLOP or C type name is a floating point type")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Float") (string-eq name "F32")
        (string-eq name "double") (string-eq name "float")))

  (fn is-bool-type ((name String))
    (@intent "Check if SLOP or C type name is a boolean type")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Bool") (string-eq name "bool")))

  (fn is-numeric-type ((name String))
    (@intent "Check if type is any numeric type (int or float)")
    (@spec ((String) -> Bool))
    (@pure)
    (or (is-int-type name) (is-float-type name)))

  ;; ============================================================
  ;; Builtin Type to C Mapping
  ;; ============================================================

  (fn builtin-type-c ((arena Arena) (name String))
    (@intent "Get C type for a builtin SLOP type")
    (@spec ((Arena String) -> (Option String)))
    (@example (arena "Int") -> (some "int64_t"))
    (@example (arena "String") -> (some "slop_string"))
    (@example (arena "MyRecord") -> none)
    (cond
      ((string-eq name "Int") (some "int64_t"))
      ((string-eq name "I8") (some "int8_t"))
      ((string-eq name "I16") (some "int16_t"))
      ((string-eq name "I32") (some "int32_t"))
      ((string-eq name "I64") (some "int64_t"))
      ((string-eq name "U8") (some "uint8_t"))
      ((string-eq name "U16") (some "uint16_t"))
      ((string-eq name "U32") (some "uint32_t"))
      ((string-eq name "U64") (some "uint64_t"))
      ((string-eq name "Char") (some "char"))
      ((string-eq name "Float") (some "double"))
      ((string-eq name "F32") (some "float"))
      ((string-eq name "Bool") (some "uint8_t"))
      ((string-eq name "String") (some "slop_string"))
      ((string-eq name "Bytes") (some "slop_bytes"))
      ((string-eq name "Unit") (some "void"))
      ((string-eq name "Void") (some "void"))
      ((string-eq name "Arena") (some "slop_arena*"))
      ((string-eq name "Milliseconds") (some "int64_t"))
      (else none)))

  ;; ============================================================
  ;; Identifier Conversion
  ;; ============================================================

  (fn to-c-name ((arena Arena) (name String))
    (@intent "Convert SLOP identifier to valid C name")
    (@spec ((Arena String) -> String))
    (@example (arena "foo-bar") -> "foo_bar")
    (@example (arena "empty?") -> "empty_p")
    (@example (arena "set!") -> "set_x")
    (@example (arena "int") -> "slop_int")
    (@example (arena "utils/helper") -> "utils_helper")
    ;; Replace special characters using strlib's replace-all
    (let ((mut result (replace-all arena name "-" "_")))
      (set! result (replace-all arena result "/" "_"))
      (set! result (replace-all arena result "?" "_p"))
      (set! result (replace-all arena result "!" "_x"))
      (set! result (replace-all arena result "$" "_"))
      ;; Escape C keywords
      (if (is-c-keyword result)
        (string-concat arena "slop_" result)
        result)))

  (fn type-to-identifier ((arena Arena) (c-type String))
    (@intent "Convert C type to valid identifier component for container type names")
    (@spec ((Arena String) -> String))
    (@example (arena "int64_t") -> "int")
    (@example (arena "slop_string") -> "string")
    (@example (arena "MyRecord*") -> "MyRecord_ptr")
    (@example (arena "void*") -> "void_ptr")
    ;; Replace pointer with _ptr suffix
    (let ((mut result (replace arena c-type "*" "_ptr")))
      (set! result (replace arena result " " "_"))
      ;; Strip slop_ prefix for cleaner container names (5 = len("slop_"))
      (when (starts-with result "slop_")
        (let ((len-minus-5 (cast (Int 0 ..) (- (string-len result) 5))))
          (set! result (substring arena result 5 len-minus-5))))
      ;; Normalize C type names to short identifiers for runtime compatibility
      (when (string-eq result "int64_t")
        (set! result "int"))
      (when (string-eq result "uint8_t")
        (set! result "u8"))
      (when (string-eq result "int8_t")
        (set! result "i8"))
      (when (string-eq result "uint16_t")
        (set! result "u16"))
      (when (string-eq result "int16_t")
        (set! result "i16"))
      (when (string-eq result "uint32_t")
        (set! result "u32"))
      (when (string-eq result "int32_t")
        (set! result "i32"))
      (when (string-eq result "uint64_t")
        (set! result "u64"))
      result))

  ;; ============================================================
  ;; Type Conversion (SExpr -> C type string)
  ;; ============================================================

  (fn to-c-type ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Convert SLOP type expression to C type string")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@example (arena (parse-type "Int")) -> "int64_t")
    (@example (arena (parse-type "(Ptr Int)")) -> "int64_t*")
    (@example (arena (parse-type "(Option String)")) -> "slop_option_string")
    (@pre {expr != nil})
    (match (deref expr)
      ;; Symbol: builtin type or user-defined type name
      ((sym sym)
        (let ((name (. sym name)))
          (match (builtin-type-c arena name)
            ((some c-type) c-type)
            ;; Not a builtin - return as-is (user type)
            ((none) (to-c-name arena name)))))
      ;; List: compound type like (Ptr T), (Option T), etc.
      ((lst lst)
        (to-c-type-compound arena (. lst items)))
      ;; Other forms shouldn't appear as types
      ((str _) "void*")
      ((num _) "void*")))

  (fn to-c-type-compound ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Convert SLOP compound type to C type string")
    (@spec ((Arena (List (Ptr SExpr))) -> String))
    (let ((len (list-len items)))
      (if (< len 1)
        "void*"
        (match (list-get items 0)
          ((some first-expr)
            (match (deref first-expr)
              ((sym head-sym)
                (let ((head (. head-sym name)))
                  (cond
                    ;; (Ptr T) -> T*
                    ((string-eq head "Ptr")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (ScopedPtr T) -> T* (same as Ptr in C)
                    ((string-eq head "ScopedPtr")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (Option T) -> slop_option_<inner>
                    ((string-eq head "Option")
                      (if (< len 2)
                        "/* TRANSPILER_ERROR: Option requires inner type */"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_option_" inner-id)))
                          ((none) "/* TRANSPILER_ERROR: Option requires inner type */"))))

                    ;; (Result T E) -> slop_result_<ok>_<err>
                    ((string-eq head "Result")
                      (let ((ok-id (if (< len 2)
                                      "void"
                                      (match (list-get items 1)
                                        ((some ok-expr)
                                          (type-to-identifier arena (to-c-type arena ok-expr)))
                                        ((none) "void"))))
                            (err-id (if (< len 3)
                                       "slop_error"
                                       (match (list-get items 2)
                                         ((some err-expr)
                                           (type-to-identifier arena (to-c-type arena err-expr)))
                                         ((none) "slop_error")))))
                        (string-concat arena
                          (string-concat arena "slop_result_" ok-id)
                          (string-concat arena "_" err-id))))

                    ;; (List T) -> slop_list_<inner>
                    ((string-eq head "List")
                      (if (< len 2)
                        "slop_list_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_list_" inner-id)))
                          ((none) "slop_list_void"))))

                    ;; (Map K V) -> slop_map* (generic - value type tracked in VarEntry.slop-type)
                    ((string-eq head "Map")
                      "slop_map*")

                    ;; (Array T size) -> T*
                    ((string-eq head "Array")
                      (if (< len 2)
                        "void*"
                        (match (list-get items 1)
                          ((some inner)
                            (string-concat arena (to-c-type arena inner) "*"))
                          ((none) "void*"))))

                    ;; (Chan T) -> slop_chan_<inner>
                    ((string-eq head "Chan")
                      (if (< len 2)
                        "slop_chan_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_chan_" inner-id)))
                          ((none) "slop_chan_void"))))

                    ;; (Thread T) -> slop_thread_<inner>
                    ((string-eq head "Thread")
                      (if (< len 2)
                        "slop_thread_void"
                        (match (list-get items 1)
                          ((some inner)
                            (let ((inner-c (to-c-type arena inner))
                                  (inner-id (type-to-identifier arena inner-c)))
                              (string-concat arena "slop_thread_" inner-id)))
                          ((none) "slop_thread_void"))))

                    ;; (Fn (args...) return) -> return_type(*)(arg_types...)
                    ((string-eq head "Fn")
                      (if (< len 2)
                        "void*"
                        ;; Return type is the last item
                        (let ((ret-type (match (list-get items (- len 1))
                                          ((some ret) (to-c-type arena ret))
                                          ((none) "void"))))
                          ;; Build argument list from items 1 to len-2
                          (if (= len 2)
                            ;; (Fn RetType) - no args list
                            (string-concat arena ret-type "(*)(void)")
                            ;; (Fn (args...) RetType)
                            (match (list-get items 1)
                              ((some args-expr)
                                (let ((args-str (build-fn-args-str arena args-expr)))
                                  (string-concat arena
                                    (string-concat arena ret-type "(*)")
                                    args-str)))
                              ((none) (string-concat arena ret-type "(*)(void)")))))))

                    ;; (Int min .. max) range types -> smallest C type
                    ((string-eq head "Int")
                      (range-type-to-c-type arena items len))

                    ;; Default: treat as type name
                    (else
                      (match (builtin-type-c arena head)
                        ((some c-type) c-type)
                        ((none) (to-c-name arena head)))))))
              ;; Not a symbol head
              (_ "void*")))
          ((none) "void*")))))

(fn build-fn-args-str ((arena Arena) (args-expr (Ptr SExpr)))
  (@intent "Build C function argument string from SLOP Fn args list")
  (@spec ((Arena (Ptr SExpr)) -> String))
  (match (deref args-expr)
    ((lst args-list)
      (let ((arg-items (. args-list items))
            (arg-count (list-len arg-items)))
        (if (= arg-count 0)
          "(void)"
          ;; Build comma-separated args
          (let ((mut result "(")
                (mut i 0))
            (while (< i arg-count)
              (match (list-get arg-items i)
                ((some arg-expr)
                  (let ((arg-type (to-c-type arena arg-expr)))
                    (if (> i 0)
                      (set! result (string-concat arena result (string-concat arena ", " arg-type)))
                      (set! result (string-concat arena result arg-type)))))
                ((none) ()))
              (set! i (+ i 1)))
            (string-concat arena result ")")))))
    ;; Not a list - treat as void
    (_ "(void)")))

  ;; ============================================================
  ;; Type String Conversion
  ;; ============================================================

  (fn sexpr-to-type-string ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Convert type SExpr to string representation for slop-type field")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (match (deref expr)
      ((sym sym)
        ;; Simple type name
        (. sym name))
      ((lst lst)
        ;; Compound type like (Map K V), (Ptr T), etc.
        (let ((items (. lst items))
              (len (list-len items))
              (mut result "(")
              (mut i 0))
          (while (< i len)
            (match (list-get items i)
              ((some item-expr)
                (let ((item-str (sexpr-to-type-string arena item-expr)))
                  (if (> i 0)
                    (set! result (string-concat arena result (string-concat arena " " item-str)))
                    (set! result (string-concat arena result item-str)))))
              ((none) (do)))
            (set! i (+ i 1)))
          (string-concat arena result ")")))
      ;; Other forms - return empty
      (_ "")))

  ;; ============================================================
  ;; Range Type Handling
  ;; ============================================================

  (fn range-type-to-c-type ((arena Arena) (items (List (Ptr SExpr))) (len Int))
    (@intent "Convert (Int min .. max) range type to smallest C type")
    (@spec ((Arena (List (Ptr SExpr)) Int) -> String))
    ;; Expected form: (Int min .. max) where items = [Int, min, .., max]
    ;; Parse min and max values from the list
    (if (< len 4)
      "int64_t"
      (let ((mut min-val (cast I64 0))
            (mut max-val (cast I64 0))
            (mut has-min false)
            (mut has-max false))
        ;; item 1 = min, item 2 = .., item 3 = max
        (match (list-get items 1)
          ((some min-expr)
            (match (deref min-expr)
              ((num n)
                (set! has-min true)
                (set! min-val (cast I64 (. n int-value))))
              (_ (do))))
          ((none) (do)))
        (match (list-get items 3)
          ((some max-expr)
            (match (deref max-expr)
              ((num n)
                (set! has-max true)
                (set! max-val (cast I64 (. n int-value))))
              (_ (do))))
          ((none) (do)))
        (cond
          ((and has-min has-max)
            (cond
              ((and (>= min-val 0) (<= max-val 255)) "uint8_t")
              ((and (>= min-val 0) (<= max-val 65535)) "uint16_t")
              ((and (>= min-val (- 0 128)) (<= max-val 127)) "int8_t")
              ((and (>= min-val (- 0 32768)) (<= max-val 32767)) "int16_t")
              (else "int64_t")))
          (else "int64_t")))))

  ;; ============================================================
  ;; Resolved Type Bridge (Checker → Transpiler)
  ;; ============================================================

  (fn get-node-resolved-type ((expr (Ptr SExpr)))
    (@intent "Get the resolved type annotation from an AST node, if present")
    (@spec (((Ptr SExpr)) -> (Option (Ptr ResolvedType))))
    (@pre (!= expr nil))
    (match (deref expr)
      ((sym sym) (. sym resolved-type))
      ((str str) (. str resolved-type))
      ((num num) (. num resolved-type))
      ((lst lst) (. lst resolved-type))))

  (fn resolved-type-to-c ((arena Arena) (rt (Ptr ResolvedType)))
    (@intent "Convert a checker ResolvedType to a C type string using transpiler conventions")
    (@spec ((Arena (Ptr ResolvedType)) -> String))
    (@pre (!= rt nil))
    (let ((kind (. (deref rt) kind))
          (name (. (deref rt) name)))
      (cond
        ;; Primitives: use builtin-type-c for correct transpiler names
        ((== kind 'rk-primitive)
          (match (builtin-type-c arena name)
            ((some c) c)
            ((none) (to-c-name arena name))))
        ;; Range types: use the c-name which should be correct (uint8_t etc.)
        ((== kind 'rk-range)
          (. (deref rt) c-name))
        ;; Records, unions, enums: apply module prefix to c-name
        ((or (== kind 'rk-record) (or (== kind 'rk-union) (== kind 'rk-enum)))
          (let ((c-name (to-c-name arena name)))
            (match (. (deref rt) module-name)
              ((some mod-name)
                (string-concat arena (string-concat arena (to-c-name arena mod-name) "_") c-name))
              ((none) c-name))))
        ;; Ptr T -> inner_c* (but Chan/Thread already include *)
        ((== kind 'rk-ptr)
          (match (. (deref rt) inner-type)
            ((some inner)
              (let ((inner-kind (. (deref inner) kind)))
                (if (or (== inner-kind 'rk-chan) (== inner-kind 'rk-thread))
                  (resolved-type-to-c arena inner)
                  (string-concat arena (resolved-type-to-c arena inner) "*"))))
            ((none) "void*")))
        ;; Option T -> slop_option_<id>
        ((== kind 'rk-option)
          (match (. (deref rt) inner-type)
            ((some inner)
              (let ((inner-c (resolved-type-to-c arena inner)))
                (string-concat arena "slop_option_" (type-to-identifier arena inner-c))))
            ((none) "/* TRANSPILER_ERROR: Option requires inner type */")))
        ;; List T -> slop_list_<id>
        ((== kind 'rk-list)
          (match (. (deref rt) inner-type)
            ((some inner)
              (let ((inner-c (resolved-type-to-c arena inner)))
                (string-concat arena "slop_list_" (type-to-identifier arena inner-c))))
            ((none) "slop_list_void")))
        ;; Result T E -> slop_result_<ok_id>_<err_id>
        ((== kind 'rk-result)
          (let ((ok-id (match (. (deref rt) inner-type)
                         ((some ok-t)
                           (type-to-identifier arena (resolved-type-to-c arena ok-t)))
                         ((none) "void")))
                (err-id (match (. (deref rt) inner-type2)
                          ((some err-t)
                            (type-to-identifier arena (resolved-type-to-c arena err-t)))
                          ((none) "slop_error"))))
            (string-concat arena
              (string-concat arena "slop_result_" ok-id)
              (string-concat arena "_" err-id))))
        ;; Map K V -> slop_map*
        ((== kind 'rk-map) "slop_map*")
        ;; Function type -> void* (function pointers are complex)
        ((== kind 'rk-function) "void*")
        ;; Array -> inner*
        ((== kind 'rk-array)
          (match (. (deref rt) inner-type)
            ((some inner)
              (string-concat arena (resolved-type-to-c arena inner) "*"))
            ((none) "void*")))
        ;; Chan T -> slop_chan_<inner_id>*
        ((== kind 'rk-chan)
          (match (. (deref rt) inner-type)
            ((some inner)
              (let ((inner-c (resolved-type-to-c arena inner))
                    (inner-id (type-to-identifier arena inner-c)))
                (string-concat arena (string-concat arena "slop_chan_" inner-id) "*")))
            ((none) "slop_chan_int*")))
        ;; Thread T -> slop_thread_<inner_id>*
        ((== kind 'rk-thread)
          (match (. (deref rt) inner-type)
            ((some inner)
              (let ((inner-c (resolved-type-to-c arena inner))
                    (inner-id (type-to-identifier arena inner-c)))
                (string-concat arena (string-concat arena "slop_thread_" inner-id) "*")))
            ((none) "slop_thread_int*")))
        ;; Fallback
        (else (. (deref rt) c-name)))))

) ;; end module
