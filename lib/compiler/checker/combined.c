{"checker":{"header":"#ifndef SLOP_checker_H\n#define SLOP_checker_H\n\n#include \"slop_runtime.h\"\n#include <stdint.h>\n#include <stdbool.h>\n#include \"slop_parser.h\"\n#include \"slop_types.h\"\n#include \"slop_env.h\"\n#include \"slop_collect.h\"\n#include \"slop_resolve.h\"\n#include \"slop_infer.h\"\n#include \"slop_file.h\"\n#include \"slop_strlib.h\"\n#include <stdio.h>\n#include <string.h>\n\ntypedef enum {\n    checker_OutputFormat_fmt_text,\n    checker_OutputFormat_fmt_json\n} checker_OutputFormat;\n\n#ifndef SLOP_LIST_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_LIST_TYPES_SEXPR_PTR_DEFINED\nSLOP_LIST_DEFINE(types_SExpr*, slop_list_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr*, slop_option_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_RESULT_ENV_TYPEENV_PTR_TYPES_TYPEERROR_DEFINED\n#define SLOP_RESULT_ENV_TYPEENV_PTR_TYPES_TYPEERROR_DEFINED\ntypedef struct { bool is_ok; union { env_TypeEnv* ok; types_TypeError err; } data; } slop_result_env_TypeEnv_ptr_types_TypeError;\n#endif\n\ntypedef slop_result_env_TypeEnv_ptr_types_TypeError checker_TypeCheckResult;\n\nslop_result_env_TypeEnv_ptr_types_TypeError checker_type_check(slop_arena* arena, slop_list_types_SExpr_ptr ast);\nvoid checker_type_check_with_env(env_TypeEnv* env, slop_list_types_SExpr_ptr ast);\nvoid checker_check_all_functions(env_TypeEnv* env, slop_list_types_SExpr_ptr ast);\nuint8_t checker_is_annotation_form(types_SExpr* item);\nuint8_t checker_is_valid_toplevel_form(types_SExpr* item);\nslop_string checker_get_form_name(types_SExpr* item);\nvoid checker_check_module_functions(env_TypeEnv* env, types_SExpr* module_form);\nvoid checker_print_str(uint8_t* s);\nvoid checker_print_string(slop_string s);\nvoid checker_print_json_string(slop_arena* arena, slop_string s);\nslop_string checker_extract_module_name(slop_list_types_SExpr_ptr exprs);\nvoid checker_print_diagnostic(slop_arena* arena, slop_string filename, types_Diagnostic diag);\nvoid checker_output_diagnostics_text(slop_arena* arena, slop_string filename, slop_list_types_Diagnostic diagnostics);\nvoid checker_output_diagnostics_json(slop_arena* arena, slop_list_types_Diagnostic diagnostics);\nvoid checker_output_single_diagnostic_json(slop_arena* arena, types_Diagnostic diag);\nvoid checker_output_module_json(slop_arena* arena, slop_string mod_name, slop_list_types_Diagnostic diagnostics, uint8_t first);\nint64_t checker_check_single_file(env_TypeEnv* env, slop_arena* arena, uint8_t* filename, checker_OutputFormat format, uint8_t first);\nint64_t checker_count_errors(slop_list_types_Diagnostic diagnostics);\nslop_string checker_argv_to_string(uint8_t** argv, int64_t index);\ntypes_ResolvedType* checker_resolve_type_string(env_TypeEnv* env, slop_arena* arena, slop_string type_str);\nvoid checker_parse_and_bind_params(env_TypeEnv* env, slop_arena* arena, slop_string params_str);\nuint8_t checker_types_names_equal(types_ResolvedType* a, types_ResolvedType* b);\nint64_t checker_check_expr_mode(slop_arena* arena, env_TypeEnv* env, slop_string expr_str, slop_string type_str, slop_string context_file, slop_string params_str);\nvoid checker_output_expr_result(slop_arena* arena, uint8_t valid, slop_string inferred_type, slop_string expected_type, slop_list_types_Diagnostic diagnostics);\nint main(int64_t argc, uint8_t** argv);\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr*, slop_option_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n\n#endif\n","impl":"slop_result_env_TypeEnv_ptr_types_TypeError checker_type_check(slop_arena* arena, slop_list_types_SExpr_ptr ast);\nvoid checker_type_check_with_env(env_TypeEnv* env, slop_list_types_SExpr_ptr ast);\nvoid checker_check_all_functions(env_TypeEnv* env, slop_list_types_SExpr_ptr ast);\nuint8_t checker_is_annotation_form(types_SExpr* item);\nuint8_t checker_is_valid_toplevel_form(types_SExpr* item);\nslop_string checker_get_form_name(types_SExpr* item);\nvoid checker_check_module_functions(env_TypeEnv* env, types_SExpr* module_form);\nvoid checker_print_str(uint8_t* s);\nvoid checker_print_string(slop_string s);\nvoid checker_print_json_string(slop_arena* arena, slop_string s);\nslop_string checker_extract_module_name(slop_list_types_SExpr_ptr exprs);\nvoid checker_print_diagnostic(slop_arena* arena, slop_string filename, types_Diagnostic diag);\nvoid checker_output_diagnostics_text(slop_arena* arena, slop_string filename, slop_list_types_Diagnostic diagnostics);\nvoid checker_output_diagnostics_json(slop_arena* arena, slop_list_types_Diagnostic diagnostics);\nvoid checker_output_single_diagnostic_json(slop_arena* arena, types_Diagnostic diag);\nvoid checker_output_module_json(slop_arena* arena, slop_string mod_name, slop_list_types_Diagnostic diagnostics, uint8_t first);\nint64_t checker_check_single_file(env_TypeEnv* env, slop_arena* arena, uint8_t* filename, checker_OutputFormat format, uint8_t first);\nint64_t checker_count_errors(slop_list_types_Diagnostic diagnostics);\nslop_string checker_argv_to_string(uint8_t** argv, int64_t index);\ntypes_ResolvedType* checker_resolve_type_string(env_TypeEnv* env, slop_arena* arena, slop_string type_str);\nvoid checker_parse_and_bind_params(env_TypeEnv* env, slop_arena* arena, slop_string params_str);\nuint8_t checker_types_names_equal(types_ResolvedType* a, types_ResolvedType* b);\nint64_t checker_check_expr_mode(slop_arena* arena, env_TypeEnv* env, slop_string expr_str, slop_string type_str, slop_string context_file, slop_string params_str);\nvoid checker_output_expr_result(slop_arena* arena, uint8_t valid, slop_string inferred_type, slop_string expected_type, slop_list_types_Diagnostic diagnostics);\nint checker_main(int64_t argc, uint8_t** argv);\n\nslop_result_env_TypeEnv_ptr_types_TypeError checker_type_check(slop_arena* arena, slop_list_types_SExpr_ptr ast) {\n    SLOP_PRE(((((int64_t)((ast).len)) > 0)), \"(> (list-len ast) 0)\");\n    {\n        __auto_type env = env_env_new(arena);\n        collect_collect_module(env, ast);\n        resolve_resolve_imports(env, ast);\n        checker_check_all_functions(env, ast);\n        return ((slop_result_env_TypeEnv_ptr_types_TypeError){ .is_ok = true, .data.ok = env });\n    }\n}\n\nvoid checker_type_check_with_env(env_TypeEnv* env, slop_list_types_SExpr_ptr ast) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((((int64_t)((ast).len)) > 0)), \"(> (list-len ast) 0)\");\n    collect_collect_module(env, ast);\n    resolve_resolve_imports(env, ast);\n    checker_check_all_functions(env, ast);\n}\n\nvoid checker_check_all_functions(env_TypeEnv* env, slop_list_types_SExpr_ptr ast) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type len = ((int64_t)((ast).len));\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_0 = ({ __auto_type _lst = ast; size_t _idx = (size_t)i; slop_option_T_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_0.has_value) {\n                __auto_type expr = _mv_0.value;\n                if (parser_is_form(expr, SLOP_STR(\"fn\"))) {\n                    {\n                        __auto_type _ = infer_infer_fn_body(env, expr);\n                    }\n                } else if (parser_is_form(expr, SLOP_STR(\"module\"))) {\n                    checker_check_module_functions(env, expr);\n                } else {\n                }\n            } else if (!_mv_0.has_value) {\n            }\n        }\n    }\n}\n\nuint8_t checker_is_annotation_form(types_SExpr* item) {\n    if (parser_sexpr_is_list(item)) {\n        __auto_type _mv_1 = parser_sexpr_list_get(item, 0);\n        if (_mv_1.has_value) {\n            __auto_type head = _mv_1.value;\n            return ((uint8_t)(({ __auto_type name = parser_sexpr_get_symbol_name(head); (((name.len > 0)) ? (name.data[0] == 64) : 0); })));\n        } else if (!_mv_1.has_value) {\n            return 0;\n        }\n    } else {\n        return 0;\n    }\n}\n\nuint8_t checker_is_valid_toplevel_form(types_SExpr* item) {\n    if (parser_is_form(item, SLOP_STR(\"fn\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"type\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"const\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"ffi\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"ffi-struct\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"import\"))) {\n        return 1;\n    } else if (parser_is_form(item, SLOP_STR(\"export\"))) {\n        return 1;\n    } else if (checker_is_annotation_form(item)) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nslop_string checker_get_form_name(types_SExpr* item) {\n    if (parser_sexpr_is_list(item)) {\n        __auto_type _mv_2 = parser_sexpr_list_get(item, 0);\n        if (_mv_2.has_value) {\n            __auto_type head = _mv_2.value;\n            return parser_sexpr_get_symbol_name(head);\n        } else if (!_mv_2.has_value) {\n            return SLOP_STR(\"<empty>\");\n        }\n    } else {\n        return SLOP_STR(\"<non-list>\");\n    }\n}\n\nvoid checker_check_module_functions(env_TypeEnv* env, types_SExpr* module_form) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((module_form != NULL)), \"(!= module-form nil)\");\n    if (parser_sexpr_is_list(module_form)) {\n        __auto_type _mv_3 = parser_sexpr_list_get(module_form, 1);\n        if (_mv_3.has_value) {\n            __auto_type name_expr = _mv_3.value;\n            {\n                __auto_type mod_name = parser_sexpr_get_symbol_name(name_expr);\n                if (!(string_eq(mod_name, SLOP_STR(\"\")))) {\n                    env_env_set_module(env, (slop_option_string){.has_value = 1, .value = mod_name});\n                }\n            }\n        } else if (!_mv_3.has_value) {\n        }\n        {\n            __auto_type len = parser_sexpr_list_len(module_form);\n            for (int64_t i = 2; i < len; i++) {\n                __auto_type _mv_4 = parser_sexpr_list_get(module_form, i);\n                if (_mv_4.has_value) {\n                    __auto_type item = _mv_4.value;\n                    if (parser_is_form(item, SLOP_STR(\"fn\"))) {\n                        {\n                            __auto_type _ = infer_infer_fn_body(env, item);\n                        }\n                    } else if (checker_is_valid_toplevel_form(item)) {\n                    } else {\n                        {\n                            __auto_type arena = env_env_arena(env);\n                            __auto_type msg = string_concat(arena, SLOP_STR(\"Unknown top-level form: \"), checker_get_form_name(item));\n                            env_env_add_error(env, msg, parser_sexpr_line(item), parser_sexpr_col(item));\n                        }\n                    }\n                } else if (!_mv_4.has_value) {\n                }\n            }\n        }\n    }\n}\n\nvoid checker_print_str(uint8_t* s) {\n    SLOP_PRE(((s != NULL)), \"(!= s nil)\");\n    {\n        __auto_type i = 0;\n        while ((s[i] != 0)) {\n            putchar(((int64_t)(s[i])));\n            i = (i + 1);\n        }\n    }\n}\n\nvoid checker_print_string(slop_string s) {\n    {\n        __auto_type len = ((int64_t)(s.len));\n        __auto_type data = s.data;\n        __auto_type i = 0;\n        while ((i < len)) {\n            putchar(((int64_t)(data[i])));\n            i = (i + 1);\n        }\n    }\n}\n\nvoid checker_print_json_string(slop_arena* arena, slop_string s) {\n    putchar(34);\n    {\n        __auto_type len = ((int64_t)(s.len));\n        __auto_type data = s.data;\n        __auto_type i = 0;\n        while ((i < len)) {\n            {\n                __auto_type c = ((int64_t)(data[i]));\n                if ((c == 34)) {\n                    putchar(92);\n                    putchar(34);\n                } else if ((c == 92)) {\n                    putchar(92);\n                    putchar(92);\n                } else if ((c == 10)) {\n                    putchar(92);\n                    putchar(110);\n                } else if ((c == 13)) {\n                    putchar(92);\n                    putchar(114);\n                } else if ((c == 9)) {\n                    putchar(92);\n                    putchar(116);\n                } else {\n                    putchar(c);\n                }\n            }\n            i = (i + 1);\n        }\n    }\n    putchar(34);\n}\n\nslop_string checker_extract_module_name(slop_list_types_SExpr_ptr exprs) {\n    if ((((int64_t)((exprs).len)) < 1)) {\n        return SLOP_STR(\"unknown\");\n    } else {\n        __auto_type _mv_5 = ({ __auto_type _lst = exprs; size_t _idx = (size_t)0; slop_option_T_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n        if (_mv_5.has_value) {\n            __auto_type first_expr = _mv_5.value;\n            __auto_type _mv_6 = (*first_expr);\n            switch (_mv_6.tag) {\n                case types_SExpr_lst:\n                {\n                    __auto_type lst = _mv_6.data.lst;\n                    {\n                        __auto_type items = lst.items;\n                        if ((((int64_t)((items).len)) < 2)) {\n                            return SLOP_STR(\"unknown\");\n                        } else {\n                            __auto_type _mv_7 = ({ __auto_type _lst = items; size_t _idx = (size_t)0; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                            if (_mv_7.has_value) {\n                                __auto_type head = _mv_7.value;\n                                __auto_type _mv_8 = (*head);\n                                switch (_mv_8.tag) {\n                                    case types_SExpr_sym:\n                                    {\n                                        __auto_type sym = _mv_8.data.sym;\n                                        if (string_eq(sym.name, SLOP_STR(\"module\"))) {\n                                            __auto_type _mv_9 = ({ __auto_type _lst = items; size_t _idx = (size_t)1; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                                            if (_mv_9.has_value) {\n                                                __auto_type name_expr = _mv_9.value;\n                                                __auto_type _mv_10 = (*name_expr);\n                                                switch (_mv_10.tag) {\n                                                    case types_SExpr_sym:\n                                                    {\n                                                        __auto_type name_sym = _mv_10.data.sym;\n                                                        return name_sym.name;\n                                                    }\n                                                    default: {\n                                                        return SLOP_STR(\"unknown\");\n                                                    }\n                                                }\n                                            } else if (!_mv_9.has_value) {\n                                                return SLOP_STR(\"unknown\");\n                                            }\n                                        } else {\n                                            return SLOP_STR(\"unknown\");\n                                        }\n                                    }\n                                    default: {\n                                        return SLOP_STR(\"unknown\");\n                                    }\n                                }\n                            } else if (!_mv_7.has_value) {\n                                return SLOP_STR(\"unknown\");\n                            }\n                        }\n                    }\n                }\n                default: {\n                    return SLOP_STR(\"unknown\");\n                }\n            }\n        } else if (!_mv_5.has_value) {\n            return SLOP_STR(\"unknown\");\n        }\n    }\n}\n\nvoid checker_print_diagnostic(slop_arena* arena, slop_string filename, types_Diagnostic diag) {\n    printf(\"%.*s\", (int)(filename).len, (filename).data);\n    printf(\"%s\", \":\");\n    printf(\"%lld\", (long long)(diag.line));\n    printf(\"%s\", \":\");\n    printf(\"%lld\", (long long)(diag.col));\n    printf(\"%s\", \": \");\n    __auto_type _mv_11 = diag.level;\n    if (_mv_11 == diag_warning) {\n        printf(\"%s\", \"warning: \");\n    } else if (_mv_11 == diag_error) {\n        printf(\"%s\", \"error: \");\n    }\n    printf(\"%lld\\n\", (long long)(diag.message));\n}\n\nvoid checker_output_diagnostics_text(slop_arena* arena, slop_string filename, slop_list_types_Diagnostic diagnostics) {\n    {\n        __auto_type len = ((int64_t)((diagnostics).len));\n        __auto_type i = 0;\n        while ((i < len)) {\n            __auto_type _mv_12 = ({ __auto_type _lst = diagnostics; size_t _idx = (size_t)i; slop_option_T _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_12.has_value) {\n                __auto_type diag = _mv_12.value;\n                checker_print_diagnostic(arena, filename, diag);\n            } else if (!_mv_12.has_value) {\n            }\n            i = (i + 1);\n        }\n    }\n}\n\nvoid checker_output_diagnostics_json(slop_arena* arena, slop_list_types_Diagnostic diagnostics) {\n    putchar(91);\n    {\n        __auto_type len = ((int64_t)((diagnostics).len));\n        __auto_type i = 0;\n        while ((i < len)) {\n            if ((i > 0)) {\n                putchar(44);\n            }\n            __auto_type _mv_13 = ({ __auto_type _lst = diagnostics; size_t _idx = (size_t)i; slop_option_T _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_13.has_value) {\n                __auto_type diag = _mv_13.value;\n                checker_output_single_diagnostic_json(arena, diag);\n            } else if (!_mv_13.has_value) {\n            }\n            i = (i + 1);\n        }\n    }\n    putchar(93);\n}\n\nvoid checker_output_single_diagnostic_json(slop_arena* arena, types_Diagnostic diag) {\n    putchar(123);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"level\\\":\").data)));\n    __auto_type _mv_14 = diag.level;\n    if (_mv_14 == diag_warning) {\n        checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"warning\\\"\").data)));\n    } else if (_mv_14 == diag_error) {\n        checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"error\\\"\").data)));\n    }\n    putchar(44);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"line\\\":\").data)));\n    checker_print_string(int_to_string(arena, diag.line));\n    putchar(44);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"col\\\":\").data)));\n    checker_print_string(int_to_string(arena, diag.col));\n    putchar(44);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"message\\\":\").data)));\n    checker_print_json_string(arena, diag.message);\n    putchar(125);\n}\n\nvoid checker_output_module_json(slop_arena* arena, slop_string mod_name, slop_list_types_Diagnostic diagnostics, uint8_t first) {\n    if (!(first)) {\n        putchar(44);\n    }\n    checker_print_json_string(arena, mod_name);\n    putchar(58);\n    putchar(123);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"\\\"diagnostics\\\":\").data)));\n    checker_output_diagnostics_json(arena, diagnostics);\n    putchar(125);\n}\n\nint64_t checker_check_single_file(env_TypeEnv* env, slop_arena* arena, uint8_t* filename, checker_OutputFormat format, uint8_t first) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((filename != NULL)), \"(!= filename nil)\");\n    {\n        __auto_type filename_str = strlib_cstring_to_string(filename);\n        __auto_type _mv_15 = file_file_open(filename_str, file_FileMode_read);\n        if (!_mv_15.is_ok) {\n            __auto_type e = _mv_15.data.err;\n            printf(\"%s\", \"Error: Could not open file: \");\n            printf(\"%lld\\n\", (long long)(filename_str));\n            return 1;\n        } else if (_mv_15.is_ok) {\n            __auto_type f = _mv_15.data.ok;\n            __auto_type _mv_16 = file_file_read_all(arena, (&f));\n            if (!_mv_16.is_ok) {\n                __auto_type e = _mv_16.data.err;\n                file_file_close((&f));\n                printf(\"%s\", \"Error: Could not read file: \");\n                printf(\"%lld\\n\", (long long)(filename_str));\n                return 1;\n            } else if (_mv_16.is_ok) {\n                __auto_type source = _mv_16.data.ok;\n                file_file_close((&f));\n                __auto_type _mv_17 = parser_parse(arena, source);\n                if (_mv_17.is_ok) {\n                    __auto_type ast = _mv_17.data.ok;\n                    {\n                        __auto_type mod_name = checker_extract_module_name(ast);\n                        env_env_clear_imports(env);\n                        env_env_clear_diagnostics(env);\n                        checker_type_check_with_env(env, ast);\n                        {\n                            __auto_type diagnostics = env_env_get_diagnostics(env);\n                            if ((format == checker_OutputFormat_fmt_json)) {\n                                checker_output_module_json(arena, mod_name, diagnostics, first);\n                            }\n                            if ((format == checker_OutputFormat_fmt_text)) {\n                                checker_output_diagnostics_text(arena, filename_str, diagnostics);\n                            }\n                            return checker_count_errors(diagnostics);\n                        }\n                    }\n                } else if (!_mv_17.is_ok) {\n                    __auto_type parse_err = _mv_17.data.err;\n                    printf(\"%lld\", (long long)(filename_str));\n                    printf(\"%s\", \":\");\n                    printf(\"%lld\", (long long)(parse_err.line));\n                    printf(\"%s\", \":\");\n                    printf(\"%lld\", (long long)(parse_err.col));\n                    printf(\"%s\", \": error: \");\n                    printf(\"%lld\\n\", (long long)(parse_err.message));\n                    return 1;\n                }\n            }\n        }\n    }\n}\n\nint64_t checker_count_errors(slop_list_types_Diagnostic diagnostics) {\n    {\n        __auto_type len = ((int64_t)((diagnostics).len));\n        __auto_type errors = 0;\n        __auto_type i = 0;\n        while ((i < len)) {\n            __auto_type _mv_18 = ({ __auto_type _lst = diagnostics; size_t _idx = (size_t)i; slop_option_T _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_18.has_value) {\n                __auto_type diag = _mv_18.value;\n                __auto_type _mv_19 = diag.level;\n                if (_mv_19 == diag_error) {\n                    errors = (errors + 1);\n                } else if (_mv_19 == diag_warning) {\n                }\n            } else if (!_mv_18.has_value) {\n            }\n            i = (i + 1);\n        }\n        return errors;\n    }\n}\n\nslop_string checker_argv_to_string(uint8_t** argv, int64_t index) {\n    {\n        __auto_type ptr = argv[index];\n        return (slop_string){.len = strlen(ptr), .data = ptr};\n    }\n}\n\ntypes_ResolvedType* checker_resolve_type_string(env_TypeEnv* env, slop_arena* arena, slop_string type_str) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_20 = parser_parse(arena, type_str);\n    if (_mv_20.is_ok) {\n        __auto_type type_ast = _mv_20.data.ok;\n        if ((((int64_t)((type_ast).len)) == 0)) {\n            return env_env_get_int_type(env);\n        } else {\n            __auto_type _mv_21 = ({ __auto_type _lst = type_ast; size_t _idx = (size_t)0; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_21.has_value) {\n                __auto_type type_expr = _mv_21.value;\n                if (parser_sexpr_is_list(type_expr)) {\n                    return infer_resolve_complex_type_expr(env, type_expr);\n                } else {\n                    {\n                        __auto_type name = parser_sexpr_get_symbol_name(type_expr);\n                        if (string_eq(name, SLOP_STR(\"\"))) {\n                            return env_env_get_int_type(env);\n                        } else {\n                            return infer_resolve_simple_type(env, name);\n                        }\n                    }\n                }\n            } else if (!_mv_21.has_value) {\n                return env_env_get_int_type(env);\n            }\n        }\n    } else if (!_mv_20.is_ok) {\n        __auto_type _ = _mv_20.data.err;\n        return env_env_get_int_type(env);\n    }\n}\n\nvoid checker_parse_and_bind_params(env_TypeEnv* env, slop_arena* arena, slop_string params_str) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_22 = parser_parse(arena, params_str);\n    if (_mv_22.is_ok) {\n        __auto_type params_ast = _mv_22.data.ok;\n        if ((((int64_t)((params_ast).len)) > 0)) {\n            __auto_type _mv_23 = ({ __auto_type _lst = params_ast; size_t _idx = (size_t)0; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_23.has_value) {\n                __auto_type params_list = _mv_23.value;\n                __auto_type _mv_24 = (*params_list);\n                switch (_mv_24.tag) {\n                    case types_SExpr_lst:\n                    {\n                        __auto_type lst = _mv_24.data.lst;\n                        {\n                            __auto_type items = lst.items;\n                            __auto_type len = ((int64_t)((items).len));\n                            ({ for (int64_t i = 0; i < len; i++) { ({ __auto_type _mv = ({ __auto_type _lst = items; size_t _idx = (size_t)i; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type param = _mv.value; ({ __auto_type _mv = (*param); switch (_mv.tag) { case types_SExpr_lst: { __auto_type param_lst = _mv.data.lst; ({ __auto_type param_items = param_lst.items; (((((int64_t)((param_items).len)) >= 2)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = param_items; size_t _idx = (size_t)0; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); _mv.has_value ? ({ __auto_type name_expr = _mv.value; ({ __auto_type _mv = (*name_expr); Unknown _mr = {0}; switch (_mv.tag) { case types_SExpr_sym: { __auto_type name_sym = _mv.data.sym; _mr = ({ __auto_type param_name = name_sym.name; ({ __auto_type _mv = ({ __auto_type _lst = param_items; size_t _idx = (size_t)1; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); _mv.has_value ? ({ __auto_type type_expr = _mv.value; ({ __auto_type _mv = (*type_expr); Unknown _mr = {0}; switch (_mv.tag) { case types_SExpr_sym: { __auto_type type_sym = _mv.data.sym; _mr = ({ __auto_type param_type = checker_resolve_type_string(env, arena, type_sym.name); env_env_bind_var(env, param_name, param_type); }); break; } case types_SExpr_lst: { __auto_type _ = _mv.data.lst; _mr = ({ __auto_type param_type = infer_resolve_complex_type_expr(env, type_expr); env_env_bind_var(env, param_name, param_type); }); break; } default: { _mr = env_env_bind_var(env, param_name, env_env_get_int_type(env)); break; }  } _mr; }); }) : (({ (void)0; })); }); }); break; } default: { _mr = ({ (void)0; }); break; }  } _mr; }); }) : (({ (void)0; })); }); 0; }) : ({ (void)0; })); }); break; } default: { ({ (void)0; }); break; }  } (void)0; }); } else { ({ (void)0; }); } (void)0; }); } 0; });\n                        }\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n            } else if (!_mv_23.has_value) {\n            }\n        }\n    } else if (!_mv_22.is_ok) {\n        __auto_type _ = _mv_22.data.err;\n    }\n}\n\nuint8_t checker_types_names_equal(types_ResolvedType* a, types_ResolvedType* b) {\n    SLOP_PRE(((a != NULL)), \"(!= a nil)\");\n    SLOP_PRE(((b != NULL)), \"(!= b nil)\");\n    {\n        __auto_type a_name = (*a).name;\n        __auto_type b_name = (*b).name;\n        __auto_type a_kind = (*a).kind;\n        __auto_type b_kind = (*b).kind;\n        if (string_eq(a_name, b_name)) {\n            return 1;\n        } else if ((string_eq(a_name, SLOP_STR(\"T\")) || string_eq(b_name, SLOP_STR(\"T\")))) {\n            return 1;\n        } else if ((string_eq(a_name, SLOP_STR(\"Unknown\")) || string_eq(b_name, SLOP_STR(\"Unknown\")))) {\n            return 1;\n        } else if (((a_kind == rk_option) && (b_kind == rk_option))) {\n            __auto_type _mv_25 = (*a).inner_type;\n            if (_mv_25.has_value) {\n                __auto_type a_inner = _mv_25.value;\n                __auto_type _mv_26 = (*b).inner_type;\n                if (_mv_26.has_value) {\n                    __auto_type b_inner = _mv_26.value;\n                    return checker_types_names_equal(a_inner, b_inner);\n                } else if (!_mv_26.has_value) {\n                    return 1;\n                }\n            } else if (!_mv_25.has_value) {\n                return 1;\n            }\n        } else if (((a_kind == rk_result) && (b_kind == rk_result))) {\n            {\n                __auto_type ok_match = ({ __auto_type _mv = (*a).inner_type; _mv.has_value ? ({ __auto_type a_inner = _mv.value; ({ __auto_type _mv = (*b).inner_type; _mv.has_value ? ({ __auto_type b_inner = _mv.value; checker_types_names_equal(a_inner, b_inner); }) : (1); }); }) : (1); });\n                __auto_type err_match = ({ __auto_type _mv = (*a).inner_type2; _mv.has_value ? ({ __auto_type a_inner2 = _mv.value; ({ __auto_type _mv = (*b).inner_type2; _mv.has_value ? ({ __auto_type b_inner2 = _mv.value; checker_types_names_equal(a_inner2, b_inner2); }) : (1); }); }) : (1); });\n                return (ok_match && err_match);\n            }\n        } else if (((a_kind == rk_ptr) && (b_kind == rk_ptr))) {\n            __auto_type _mv_27 = (*a).inner_type;\n            if (_mv_27.has_value) {\n                __auto_type a_inner = _mv_27.value;\n                __auto_type _mv_28 = (*b).inner_type;\n                if (_mv_28.has_value) {\n                    __auto_type b_inner = _mv_28.value;\n                    return checker_types_names_equal(a_inner, b_inner);\n                } else if (!_mv_28.has_value) {\n                    return 1;\n                }\n            } else if (!_mv_27.has_value) {\n                return 1;\n            }\n        } else if ((a_kind == rk_range)) {\n            __auto_type _mv_29 = (*a).inner_type;\n            if (_mv_29.has_value) {\n                __auto_type base = _mv_29.value;\n                return checker_types_names_equal(base, b);\n            } else if (!_mv_29.has_value) {\n                return 0;\n            }\n        } else if ((b_kind == rk_range)) {\n            __auto_type _mv_30 = (*b).inner_type;\n            if (_mv_30.has_value) {\n                __auto_type base = _mv_30.value;\n                return checker_types_names_equal(a, base);\n            } else if (!_mv_30.has_value) {\n                return 0;\n            }\n        } else if (((a_kind == rk_primitive) && (b_kind == rk_primitive))) {\n            {\n                __auto_type a_match = ({ __auto_type _mv = (*a).inner_type; _mv.has_value ? ({ __auto_type a_base = _mv.value; checker_types_names_equal(a_base, b); }) : (0); });\n                __auto_type b_match = ({ __auto_type _mv = (*b).inner_type; _mv.has_value ? ({ __auto_type b_base = _mv.value; checker_types_names_equal(a, b_base); }) : (0); });\n                return (a_match || b_match);\n            }\n        } else if ((a_kind == rk_primitive)) {\n            __auto_type _mv_31 = (*a).inner_type;\n            if (_mv_31.has_value) {\n                __auto_type a_base = _mv_31.value;\n                return checker_types_names_equal(a_base, b);\n            } else if (!_mv_31.has_value) {\n                return 0;\n            }\n        } else if ((b_kind == rk_primitive)) {\n            __auto_type _mv_32 = (*b).inner_type;\n            if (_mv_32.has_value) {\n                __auto_type b_base = _mv_32.value;\n                return checker_types_names_equal(a, b_base);\n            } else if (!_mv_32.has_value) {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n}\n\nint64_t checker_check_expr_mode(slop_arena* arena, env_TypeEnv* env, slop_string expr_str, slop_string type_str, slop_string context_file, slop_string params_str) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    if ((string_len(context_file) > 0)) {\n        __auto_type _mv_33 = file_file_open(context_file, file_FileMode_read);\n        if (!_mv_33.is_ok) {\n            __auto_type _ = _mv_33.data.err;\n        } else if (_mv_33.is_ok) {\n            __auto_type f = _mv_33.data.ok;\n            __auto_type _mv_34 = file_file_read_all(arena, (&f));\n            if (!_mv_34.is_ok) {\n                __auto_type _ = _mv_34.data.err;\n                file_file_close((&f));\n            } else if (_mv_34.is_ok) {\n                __auto_type source = _mv_34.data.ok;\n                file_file_close((&f));\n                __auto_type _mv_35 = parser_parse(arena, source);\n                if (_mv_35.is_ok) {\n                    __auto_type context_ast = _mv_35.data.ok;\n                    collect_collect_module(env, context_ast);\n                    resolve_resolve_imports(env, context_ast);\n                } else if (!_mv_35.is_ok) {\n                    __auto_type _ = _mv_35.data.err;\n                }\n            }\n        }\n    }\n    env_env_push_scope(env);\n    if ((string_len(params_str) > 0)) {\n        checker_parse_and_bind_params(env, arena, params_str);\n    }\n    {\n        __auto_type result = ({ __auto_type _mv = parser_parse(arena, expr_str); int64_t _mr; if (_mv.is_ok) { __auto_type expr_ast = _mv.data.ok; _mr = (((((int64_t)((expr_ast).len)) == 0)) ? ({ checker_print_str(((uint8_t*)(SLOP_STR(\"{\\\"valid\\\":false,\\\"diagnostics\\\":[{\\\"level\\\":\\\"error\\\",\\\"line\\\":1,\\\"col\\\":1,\\\"message\\\":\\\"Empty expression\\\"}]}\\n\").data))); 1; }) : ({ __auto_type _mv = ({ __auto_type _lst = expr_ast; size_t _idx = (size_t)0; struct { bool has_value; __typeof__(_lst.data[0]) value; } _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); _mv.has_value ? ({ __auto_type expr = _mv.value; ({ ({ __auto_type inferred_type = infer_infer_expr(env, expr); ({ __auto_type expected_type = checker_resolve_type_string(env, arena, type_str); __auto_type diagnostics = env_env_get_diagnostics(env); __auto_type num_errors = checker_count_errors(diagnostics); ({ __auto_type type_match = checker_types_names_equal(inferred_type, expected_type); __auto_type final_diagnostics = env_env_get_diagnostics(env); __auto_type final_errors = checker_count_errors(final_diagnostics); __auto_type is_valid = (type_match && (final_errors == 0)); checker_output_expr_result(arena, is_valid, (*inferred_type).name, type_str, final_diagnostics); ((is_valid) ? 0 : 1); }); }); }); }); }) : (({ checker_print_str(((uint8_t*)(SLOP_STR(\"{\\\"valid\\\":false,\\\"diagnostics\\\":[{\\\"level\\\":\\\"error\\\",\\\"line\\\":1,\\\"col\\\":1,\\\"message\\\":\\\"Empty expression\\\"}]}\\n\").data))); 1; })); })); } else { __auto_type parse_err = _mv.data.err; _mr = ({ checker_print_str(((uint8_t*)(SLOP_STR(\"{\\\"valid\\\":false,\\\"diagnostics\\\":[{\\\"level\\\":\\\"error\\\",\\\"line\\\":\").data))); checker_print_string(int_to_string(arena, parse_err.line)); checker_print_str(((uint8_t*)(SLOP_STR(\",\\\"col\\\":\").data))); checker_print_string(int_to_string(arena, parse_err.col)); checker_print_str(((uint8_t*)(SLOP_STR(\",\\\"message\\\":\").data))); checker_print_json_string(arena, parse_err.message); checker_print_str(((uint8_t*)(SLOP_STR(\"}]}\\n\").data))); 1; }); } _mr; });\n        env_env_pop_scope(env);\n        return result;\n    }\n}\n\nvoid checker_output_expr_result(slop_arena* arena, uint8_t valid, slop_string inferred_type, slop_string expected_type, slop_list_types_Diagnostic diagnostics) {\n    checker_print_str(((uint8_t*)(SLOP_STR(\"{\\\"valid\\\":\").data)));\n    if (valid) {\n        checker_print_str(((uint8_t*)(SLOP_STR(\"true\").data)));\n    } else {\n        checker_print_str(((uint8_t*)(SLOP_STR(\"false\").data)));\n    }\n    checker_print_str(((uint8_t*)(SLOP_STR(\",\\\"inferred_type\\\":\").data)));\n    checker_print_json_string(arena, inferred_type);\n    checker_print_str(((uint8_t*)(SLOP_STR(\",\\\"expected_type\\\":\").data)));\n    checker_print_json_string(arena, expected_type);\n    checker_print_str(((uint8_t*)(SLOP_STR(\",\\\"diagnostics\\\":\").data)));\n    checker_output_diagnostics_json(arena, diagnostics);\n    checker_print_str(((uint8_t*)(SLOP_STR(\"}\\n\").data)));\n}\n\nint main(int64_t argc, uint8_t** argv) {\n    if ((argc < 2)) {\n        printf(\"%s\\n\", \"Usage: slop-checker [--json] <file.slop> [file2.slop ...]\");\n        printf(\"%s\\n\", \"       slop-checker --expr EXPR --type TYPE [--context FILE] [--params PARAMS]\");\n        return 1;\n    } else {\n        {\n            #ifdef SLOP_DEBUG\n            SLOP_PRE((4194304) > 0, \"with-arena size must be positive\");\n            #endif\n            slop_arena _arena = slop_arena_new(4194304);\n            #ifdef SLOP_DEBUG\n            SLOP_PRE(_arena.base != NULL, \"arena allocation failed\");\n            #endif\n            slop_arena* arena = &_arena;\n            if (string_eq(checker_argv_to_string(argv, 1), SLOP_STR(\"--expr\"))) {\n                {\n                    __auto_type env = env_env_new(arena);\n                    slop_string expr_str = SLOP_STR(\"\");\n                    slop_string type_str = SLOP_STR(\"Int\");\n                    slop_string context_file = SLOP_STR(\"\");\n                    slop_string params_str = SLOP_STR(\"\");\n                    __auto_type i = 2;\n                    if ((i < argc)) {\n                        expr_str = checker_argv_to_string(argv, i);\n                        i = (i + 1);\n                    }\n                    while ((i < argc)) {\n                        {\n                            __auto_type arg = checker_argv_to_string(argv, i);\n                            if (string_eq(arg, SLOP_STR(\"--type\"))) {\n                                if (((i + 1) < argc)) {\n                                    type_str = checker_argv_to_string(argv, (i + 1));\n                                    i = (i + 2);\n                                }\n                            } else if (string_eq(arg, SLOP_STR(\"--context\"))) {\n                                if (((i + 1) < argc)) {\n                                    context_file = checker_argv_to_string(argv, (i + 1));\n                                    i = (i + 2);\n                                }\n                            } else if (string_eq(arg, SLOP_STR(\"--params\"))) {\n                                if (((i + 1) < argc)) {\n                                    params_str = checker_argv_to_string(argv, (i + 1));\n                                    i = (i + 2);\n                                }\n                            } else {\n                                i = (i + 1);\n                            }\n                        }\n                    }\n                    if ((string_len(expr_str) == 0)) {\n                        printf(\"%s\\n\", \"Error: --expr requires an expression argument\");\n                        return 1;\n                    } else {\n                        return checker_check_expr_mode(arena, env, expr_str, type_str, context_file, params_str);\n                    }\n                }\n            } else {\n                {\n                    __auto_type env = env_env_new(arena);\n                    __auto_type total_errors = 0;\n                    __auto_type format = checker_OutputFormat_fmt_text;\n                    __auto_type file_start = 1;\n                    if (string_eq(checker_argv_to_string(argv, 1), SLOP_STR(\"--json\"))) {\n                        format = checker_OutputFormat_fmt_json;\n                        file_start = 2;\n                    }\n                    if ((format == checker_OutputFormat_fmt_json)) {\n                        putchar(123);\n                    }\n                    {\n                        __auto_type i = file_start;\n                        __auto_type first = 1;\n                        while ((i < argc)) {\n                            {\n                                __auto_type filename = argv[i];\n                                __auto_type errors = checker_check_single_file(env, arena, filename, format, first);\n                                total_errors = (total_errors + errors);\n                                first = 0;\n                            }\n                            i = (i + 1);\n                        }\n                    }\n                    if ((format == checker_OutputFormat_fmt_json)) {\n                        putchar(125);\n                        putchar(10);\n                    }\n                    if ((total_errors > 0)) {\n                        return 1;\n                    } else {\n                        return 0;\n                    }\n                }\n            }\n            slop_arena_free(arena);\n        }\n    }\n}\n\n"}}
