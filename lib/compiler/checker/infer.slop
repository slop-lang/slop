;; ============================================================
;; Type Inference
;;
;; Infers types for all expressions in the AST, tracking
;; variables through scopes and resolving cross-module types.
;; ============================================================

(module infer
  (export
    infer-expr infer-fn-body check-match-patterns)

  (import parser (SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col))
  (import types (ResolvedType ResolvedTypeKind ResolvedVariant
                 resolved-type-is-union resolved-type-get-variant-index))
  (import env (TypeEnv env-arena env-push-scope env-pop-scope
               env-bind-var env-lookup-var env-lookup-type
               env-lookup-function env-get-int-type env-get-bool-type
               env-get-string-type env-get-unit-type env-add-warning env-add-error))

  ;; ============================================================
  ;; Type Comparison
  ;; ============================================================

  (fn types-equal ((a (Ptr ResolvedType)) (b (Ptr ResolvedType)))
    (@intent "Check if two types are equal by comparing names")
    (@spec (((Ptr ResolvedType) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= a nil))
    (@pre (!= b nil))
    (string-eq (. (deref a) name) (. (deref b) name)))

  (fn unify-branch-types ((env (Ptr TypeEnv)) (a (Ptr ResolvedType)) (b (Ptr ResolvedType))
                          (line Int) (col Int))
    (@intent "Unify two branch types, emitting warning if they differ")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) (Ptr ResolvedType) Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= a nil))
    (@pre (!= b nil))
    ;; If types are equal, return either
    (if (types-equal a b)
      a
      ;; Types differ - emit warning and return first type
      (let ((arena (env-arena env))
            (msg (string-concat arena "Branch types differ: "
                   (string-concat arena (. (deref a) name)
                     (string-concat arena " vs " (. (deref b) name))))))
        (env-add-warning env msg line col)
        a)))

  ;; ============================================================
  ;; Expression Type Inference
  ;; ============================================================

  (fn infer-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer the type of an expression")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (let ((line (sexpr-line expr))
          (col (sexpr-col expr)))
      (match (deref expr)
        ((symbol sym)
          (let ((name (. sym name)))
            (cond
              ;; Boolean literals
              ((or (string-eq name "true") (string-eq name "false"))
                (env-get-bool-type env))
              ;; nil
              ((string-eq name "nil")
                (env-get-unit-type env))
              ;; Variable lookup
              (else
                (match (env-lookup-var env name)
                  ((some t) t)
                  ((none)
                    ;; Try looking up as a function
                    (match (env-lookup-function env name)
                      ((some sig) (. (deref sig) return-type))
                      ((none)
                        ;; Undefined variable - emit error
                        (let ((arena (env-arena env))
                              (msg (string-concat arena "Undefined variable: " name)))
                          (env-add-error env msg line col)
                          (env-get-int-type env))))))))))
        ((number num)
          (env-get-int-type env))
        ((string str)
          (env-get-string-type env))
        ((list lst)
          (infer-list-expr env expr lst)))))

  (fn infer-list-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of a list expression (call or special form)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (let ((items (. lst items))
          (len (list-len items)))
      (if (== len 0)
        (env-get-unit-type env)
        (match (list-get items 0)
          ((none) (env-get-unit-type env))
          ((some head)
            (match (deref head)
              ((symbol sym)
                (let ((op (. sym name)))
                  (infer-special-form env expr lst op)))
              ;; Non-symbol head - just return unit
              (_ (env-get-unit-type env))))))))

  (fn infer-special-form ((env (Ptr TypeEnv)) (expr (Ptr SExpr))
                          (lst SExprList) (op String))
    (@intent "Infer type of a special form or function call")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr)))
      (cond
        ;; (if cond then else) - check branch types
        ((string-eq op "if")
          (if (>= len 4)
            (match (list-get items 2)
              ((some then-expr)
                (let ((then-type (infer-expr env then-expr)))
                  (match (list-get items 3)
                    ((some else-expr)
                      (let ((else-type (infer-expr env else-expr)))
                        (unify-branch-types env then-type else-type line col)))
                    ((none) then-type))))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (cond (test1 body1) (test2 body2) ... (else bodyN))
        ((string-eq op "cond")
          (infer-cond-expr env expr lst))

        ;; (match scrutinee clauses...)
        ((string-eq op "match")
          (infer-match-expr env expr lst))

        ;; (do exprs...) - type is last expr
        ((string-eq op "do")
          (if (> len 1)
            (match (list-get items (- len 1))
              ((some last) (infer-expr env last))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (let ((bindings)) body...) - type is last body expr
        ((string-eq op "let")
          (if (> len 2)
            (match (list-get items (- len 1))
              ((some last) (infer-expr env last))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (when cond body...) - returns Unit
        ((string-eq op "when")
          (env-get-unit-type env))

        ;; (for ...) - returns Unit
        ((string-eq op "for")
          (env-get-unit-type env))

        ;; (while ...) - returns Unit
        ((string-eq op "while")
          (env-get-unit-type env))

        ;; (set! ...) - returns Unit
        ((string-eq op "set!")
          (env-get-unit-type env))

        ;; (return expr) - type of expr
        ((string-eq op "return")
          (if (>= len 2)
            (match (list-get items 1)
              ((some ret-expr) (infer-expr env ret-expr))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; Comparison operators return Bool
        ((or (string-eq op "==") (string-eq op "!=")
             (string-eq op "<") (string-eq op "<=")
             (string-eq op ">") (string-eq op ">=")
             (string-eq op "and") (string-eq op "or") (string-eq op "not"))
          (env-get-bool-type env))

        ;; Arithmetic operators return Int
        ((or (string-eq op "+") (string-eq op "-")
             (string-eq op "*") (string-eq op "/") (string-eq op "%"))
          (env-get-int-type env))

        ;; (quote symbol) - quoted enum variant, infer as Int for now
        ;; TODO: Look up which enum type contains this variant
        ((string-eq op "quote")
          (env-get-int-type env))

        ;; Function call - look up return type
        (else
          (match (env-lookup-function env op)
            ((some sig) (. (deref sig) return-type))
            ((none) (env-get-unit-type env)))))))

  (fn infer-cond-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of cond expression, checking branch types")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr))
          (mut result-type (Ptr ResolvedType) nil)
          (mut i 1))
      ;; Process each clause
      (while (< i len)
        (match (list-get items i)
          ((some clause)
            (match (deref clause)
              ((list clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (> clause-len 1)
                    (match (list-get clause-items (- clause-len 1))
                      ((some body)
                        (let ((body-type (infer-expr env body)))
                          (if (== result-type nil)
                            (set! result-type body-type)
                            (set! result-type (unify-branch-types env result-type body-type line col)))))
                      ((none) (do))))))
              (_ (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (if (== result-type nil)
        (env-get-unit-type env)
        result-type)))

  (fn infer-match-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of match expression, checking branch types")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr))
          (mut result-type (Ptr ResolvedType) nil)
          (mut i 2))  ;; Skip 'match' and scrutinee
      ;; Process each clause
      (while (< i len)
        (match (list-get items i)
          ((some clause)
            (match (deref clause)
              ((list clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (> clause-len 1)
                    (match (list-get clause-items (- clause-len 1))
                      ((some body)
                        (let ((body-type (infer-expr env body)))
                          (if (== result-type nil)
                            (set! result-type body-type)
                            (set! result-type (unify-branch-types env result-type body-type line col)))))
                      ((none) (do))))))
              (_ (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      (if (== result-type nil)
        (env-get-unit-type env)
        result-type)))

  (fn check-return-type ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr))
                         (fn-name String) (inferred-type (Ptr ResolvedType))
                         (fn-line Int) (fn-col Int))
    (@intent "Check if inferred return type matches declared @spec return type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (@pre (!= inferred-type nil))
    (match (deref fn-form)
      ((list fn-lst)
        (let ((items (. fn-lst items))
              (len (list-len items)))
          ;; Search through function body elements for @spec
          (for (i 3 len)
            (match (list-get items i)
              ((some item)
                (when (is-form item "@spec")
                  (check-spec-return-type env item fn-name inferred-type fn-line fn-col)))
              ((none) (do))))))
      (_ (do))))

  (fn check-spec-return-type ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr))
                              (fn-name String) (inferred-type (Ptr ResolvedType))
                              (fn-line Int) (fn-col Int))
    (@intent "Check return type from a @spec form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= spec-form nil))
    (match (deref spec-form)
      ((list spec-lst)
        ;; (@spec ((Types) -> RetType))
        (let ((spec-items (. spec-lst items)))
          (match (list-get spec-items 1)
            ((some spec-body)
              (check-spec-body-return env spec-body fn-name inferred-type fn-line fn-col))
            ((none) (do)))))
      (_ (do))))

  (fn check-spec-body-return ((env (Ptr TypeEnv)) (spec-body (Ptr SExpr))
                              (fn-name String) (inferred-type (Ptr ResolvedType))
                              (fn-line Int) (fn-col Int))
    (@intent "Check return type from spec body ((Types) -> RetType)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= spec-body nil))
    (match (deref spec-body)
      ((list body-lst)
        ;; ((Types) -> RetType) - last element is return type
        (let ((body-items (. body-lst items))
              (body-len (list-len body-items)))
          (match (list-get body-items (- body-len 1))
            ((some ret-expr)
              (check-return-expr env ret-expr fn-name inferred-type fn-line fn-col))
            ((none) (do)))))
      (_ (do))))

  (fn is-primitive-type ((name String))
    (@intent "Check if type name is a known primitive")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (or (string-eq name "Bool")
            (or (string-eq name "String")
                (or (string-eq name "Unit")
                    (or (string-eq name "Arena")
                        (or (string-eq name "I8")
                            (or (string-eq name "I16")
                                (or (string-eq name "I32")
                                    (or (string-eq name "I64")
                                        (or (string-eq name "U8")
                                            (or (string-eq name "U16")
                                                (or (string-eq name "U32")
                                                    (or (string-eq name "U64")
                                                        (or (string-eq name "F32")
                                                            (string-eq name "F64"))))))))))))))))

  (fn check-return-expr ((env (Ptr TypeEnv)) (ret-expr (Ptr SExpr))
                         (fn-name String) (inferred-type (Ptr ResolvedType))
                         (fn-line Int) (fn-col Int))
    (@intent "Check if return type expression matches inferred type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= ret-expr nil))
    (match (deref ret-expr)
      ((symbol ret-sym)
        (let ((declared-name (. ret-sym name))
              (inferred-name (. (deref inferred-type) name)))
          ;; Only check if types differ AND both are primitives
          ;; Custom types (enums, records) need proper variant tracking
          (when (and (not (string-eq declared-name inferred-name))
                     (and (is-primitive-type declared-name)
                          (is-primitive-type inferred-name)))
            (let ((arena (env-arena env))
                  (msg (string-concat arena "return value of '"
                         (string-concat arena fn-name
                           (string-concat arena "': expected "
                             (string-concat arena declared-name
                               (string-concat arena ", got " inferred-name)))))))
              (env-add-error env msg fn-line fn-col)))))
      (_ (do))))

  (fn get-fn-name ((fn-form (Ptr SExpr)))
    (@intent "Extract function name from fn form")
    (@spec (((Ptr SExpr)) -> String))
    (@pre (!= fn-form nil))
    (match (deref fn-form)
      ((list fn-lst)
        (let ((items (. fn-lst items)))
          (match (list-get items 1)
            ((some name-expr)
              (match (deref name-expr)
                ((symbol sym) (. sym name))
                (_ "unknown")))
            ((none) "unknown"))))
      (_ "unknown")))

  (fn infer-fn-body ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)))
    (@intent "Type check a function body, binding parameters and inferring body type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (@pre (is-form fn-form "fn"))
    (let ((fn-name (get-fn-name fn-form))
          (fn-line (sexpr-line fn-form))
          (fn-col (sexpr-col fn-form)))
      (env-push-scope env)
      ;; Extract and bind parameters from fn-form
      (match (deref fn-form)
        ((list fn-lst)
          (let ((items (. fn-lst items)))
            ;; Get params from element 2: (fn name ((param Type) ...) ...)
            (match (list-get items 2)
              ((some params-expr)
                (match (deref params-expr)
                  ((list params-lst)
                    (let ((params (. params-lst items))
                          (param-len (list-len params)))
                      (for (k 0 param-len)
                        (match (list-get params k)
                          ((some param-form)
                            (match (deref param-form)
                              ((list param-lst)
                                (let ((param-items (. param-lst items)))
                                  (match (list-get param-items 0)
                                    ((some name-expr)
                                      (match (deref name-expr)
                                        ((symbol name-sym)
                                          (let ((param-name (. name-sym name)))
                                            ;; Bind with placeholder type
                                            (env-bind-var env param-name (env-get-int-type env))))
                                        (_ (do))))
                                    ((none) (do)))))
                              (_ (do))))
                          ((none) (do))))))
                  (_ (do))))
              ((none) (do)))))
        (_ (do)))
      ;; Infer body type (last element)
      (let ((result-type (match (deref fn-form)
                           ((list fn-lst)
                             (let ((items (. fn-lst items))
                                   (item-len (list-len items)))
                               (match (list-get items (- item-len 1))
                                 ((some body) (infer-expr env body))
                                 ((none) (env-get-unit-type env)))))
                           (_ (env-get-unit-type env)))))
        ;; Check return type matches declared spec
        (check-return-type env fn-form fn-name result-type fn-line fn-col)
        (env-pop-scope env)
        result-type)))

  ;; ============================================================
  ;; Match Pattern Analysis
  ;; ============================================================

  (fn check-match-patterns ((env (Ptr TypeEnv)) (scrutinee-type (Ptr ResolvedType))
                            (patterns (List (Ptr SExpr))))
    (@intent "Check match patterns are valid for scrutinee type and return binding types")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (@pre (!= scrutinee-type nil))
    (when (resolved-type-is-union scrutinee-type)
      (let ((num-patterns (list-len patterns)))
        (for (i 0 num-patterns)
          (match (list-get patterns i)
            ((some pattern-case)
              ;; Pattern case is ((variant-name binding-var) body)
              (match (deref pattern-case)
                ((list pattern-list)
                  (when (> (list-len (. pattern-list items)) 0)
                    (match (list-get (. pattern-list items) 0)
                      ((some pattern-expr)
                        ;; Pattern expr is (variant-name binding-var)
                        (match (deref pattern-expr)
                          ((list variant-list)
                            (let ((variant-items (. variant-list items)))
                              ;; Get variant name (first element)
                              (when (> (list-len variant-items) 0)
                                (match (list-get variant-items 0)
                                  ((some variant-name-expr)
                                    (match (deref variant-name-expr)
                                      ((symbol variant-sym)
                                        (let ((variant-name (. variant-sym name)))
                                          ;; Verify variant exists
                                          (match (resolved-type-get-variant-index scrutinee-type variant-name)
                                            ((some variant-idx)
                                              ;; If there's a binding variable, bind it
                                              (when (> (list-len variant-items) 1)
                                                (match (list-get variant-items 1)
                                                  ((some binding-expr)
                                                    (match (deref binding-expr)
                                                      ((symbol binding-sym)
                                                        ;; Bind with scrutinee type as placeholder
                                                        (env-bind-var env (. binding-sym name) scrutinee-type))
                                                      (_ (do))))
                                                  ((none) (do)))))
                                            ((none) (do)))))
                                      (_ (do))))
                                  ((none) (do))))))
                          (_ (do))))
                      ((none) (do)))))
                (_ (do))))
            ((none) (do)))))))
)
