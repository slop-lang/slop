;; ============================================================
;; Type Inference
;;
;; Infers types for all expressions in the AST, tracking
;; variables through scopes and resolving cross-module types.
;; ============================================================

(module infer
  (export
    infer-expr infer-fn-body check-match-patterns
    resolve-complex-type-expr resolve-simple-type)

  (import parser (SExpr SExprList SExprSymbol SExprString SExprNumber is-form
                  sexpr-line sexpr-col
                  sexpr-list-len sexpr-list-get sexpr-is-list sexpr-get-symbol-name))
  (import types (ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo
                 resolved-type-new resolved-type-set-inner resolved-type-set-inner2
                 resolved-type-is-pointer resolved-type-is-union
                 resolved-type-get-variant-index resolved-type-get-variant-payload
                 resolved-type-is-record resolved-type-has-field resolved-type-get-field-type))
  (import env (TypeEnv env-arena env-push-scope env-pop-scope
               env-bind-var env-lookup-var env-lookup-type
               env-lookup-function env-lookup-variant env-lookup-constant
               env-get-int-type env-get-bool-type
               env-get-string-type env-get-unit-type env-get-arena-type
               env-get-unknown-type
               env-make-option-type env-make-ptr-type env-make-result-type env-make-fn-type env-get-generic-type
               env-add-warning env-add-error
               env-set-fn-type-params env-clear-fn-type-params env-is-type-param))
  (import collect (find-fn-type-params))
  (import strlib (starts-with ends-with string-build))

  ;; ============================================================
  ;; String Utilities
  ;; ============================================================

  (fn string-contains-char ((s String) (c Int))
    (@intent "Check if string contains the given character (as ASCII code)")
    (@spec ((String Int) -> Bool))
    (@pure)
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut found false))
      (for (i 0 len)
        (when (and (not found) (== (cast Int (@ data i)) c))
          (set! found true)))
      found))

  (fn string-index-of ((s String) (c Int))
    (@intent "Find index of first occurrence of character, or -1 if not found")
    (@spec ((String Int) -> Int))
    (@pure)
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut result -1))
      (for (i 0 len)
        (when (and (== result -1) (== (cast Int (@ data i)) c))
          (set! result i)))
      result))

  (fn string-substring ((arena Arena) (s String) (start Int) (end Int))
    (@intent "Extract substring from start to end (exclusive)")
    (@spec ((Arena String Int Int) -> String))
    (@pure)
    (let ((s-len (cast Int (. s len)))
          (actual-end (if (< end s-len) end s-len))
          (actual-start (if (< start 0) 0 start))
          (new-len (- actual-end actual-start)))
      (if (<= new-len 0)
        (String (cast (Ptr U8) "") 0)
        (let ((buf (cast (Ptr U8) (arena-alloc arena (+ new-len 1))))
              (src (. s data)))
          (for (i 0 new-len)
            (set! (@ buf i) (@ src (+ actual-start i))))
          (set! (@ buf new-len) 0)
          (String buf new-len)))))

  ;; ============================================================
  ;; Threading Builtins (Polymorphic)
  ;; ============================================================

  (fn is-qualified-threading-builtin ((op String))
    (@intent "Check if op is a qualified (module:name) threading builtin")
    (@spec ((String) -> Bool))
    (@pure)
    (cond
      ((ends-with op ":send") 1)
      ((ends-with op ":recv") 1)
      ((ends-with op ":spawn") 1)
      ((ends-with op ":join") 1)
      ((ends-with op ":chan-buffered") 1)
      (else 0)))

  (fn is-bare-threading-builtin ((op String))
    (@intent "Check if op is a bare (unqualified) threading builtin name")
    (@spec ((String) -> Bool))
    (@pure)
    (cond
      ((string-eq op "send") 1)
      ((string-eq op "recv") 1)
      ((string-eq op "spawn") 1)
      ((string-eq op "join") 1)
      ((string-eq op "chan-buffered") 1)
      (else 0)))

  (fn is-threading-module ((mod-name String))
    (@intent "Check if a module name is a threading module")
    (@spec ((String) -> Bool))
    (@pure)
    (string-eq mod-name "thread"))

  (fn is-send-op ((op String))
    (@intent "Check if op is send or qualified send")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq op "send") (ends-with op ":send")))

  (fn is-recv-op ((op String))
    (@intent "Check if op is recv or qualified recv")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq op "recv") (ends-with op ":recv")))

  (fn is-spawn-op ((op String))
    (@intent "Check if op is spawn or qualified spawn")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq op "spawn") (ends-with op ":spawn")))

  (fn is-join-op ((op String))
    (@intent "Check if op is join or qualified join")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq op "join") (ends-with op ":join")))

  (fn infer-threading-builtin ((env (Ptr TypeEnv)) (op String) (expr (Ptr SExpr))
                                (items (List (Ptr SExpr))) (len Int) (line Int) (col Int))
    (@intent "Infer return type for polymorphic threading builtins")
    (@spec (((Ptr TypeEnv) String (Ptr SExpr) (List (Ptr SExpr)) Int Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (do (infer-builtin-args env expr)
        (cond
          ((is-send-op op)
            (do (check-builtin-args env "send" 2 (- len 1) line col)
                (env-make-result-type env)))
          ((is-recv-op op)
            (do (check-builtin-args env "recv" 1 (- len 1) line col)
                (env-make-result-type env)))
          ((is-spawn-op op)
            (do (check-builtin-args env "spawn" 2 (- len 1) line col)
                (env-make-ptr-type env (env-get-generic-type env))))
          ((is-join-op op)
            (do (check-builtin-args env "join" 1 (- len 1) line col)
                (env-get-generic-type env)))
          (else
            (do (check-builtin-args env "chan-buffered" 2 (- len 1) line col)
                (let ((arena (env-arena env))
                      (int-type (env-get-int-type env))
                      (chan-type (resolved-type-new arena 'rk-chan "Chan" (none) "slop_chan_int*")))
                  (resolved-type-set-inner chan-type int-type)
                  (env-make-ptr-type env chan-type)))))))

  ;; ============================================================
  ;; Generic Type Parameter Support
  ;; ============================================================

  ;; TypeBinding: maps a type variable name to a concrete type
  ;; Stored as parallel lists for simplicity (no separate record needed)

  (fn has-type-params ((sig (Ptr FnSignature)))
    (@intent "Check if a function signature has generic type parameters")
    (@spec (((Ptr FnSignature)) -> Bool))
    (@pure)
    (@pre (!= sig nil))
    (> (list-len (. (deref sig) type-params)) 0))

  (fn find-binding ((bind-names (List String)) (bind-types (List (Ptr ResolvedType))) (name String))
    (@intent "Look up a type variable binding by name")
    (@spec (((List String) (List (Ptr ResolvedType)) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (let ((len (list-len bind-names))
          (mut found (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (match (list-get bind-names i)
          ((some bn)
            (when (string-eq bn name)
              (match (list-get bind-types i)
                ((some bt) (set! found (some bt)))
                ((none) (do)))))
          ((none) (do))))
      found))

  (fn unify-types ((arena Arena) (formal (Ptr ResolvedType)) (actual (Ptr ResolvedType))
                    (bind-names (List String)) (bind-types (List (Ptr ResolvedType))))
    (@intent "Unify a formal type with an actual type, binding type variables")
    (@spec ((Arena (Ptr ResolvedType) (Ptr ResolvedType) (List String) (List (Ptr ResolvedType))) -> Unit))
    (@pre (!= formal nil))
    (@pre (!= actual nil))
    (let ((f-kind (. (deref formal) kind)))
      (cond
        ;; Type variable — bind it
        ((== f-kind 'rk-typevar)
          (let ((tv-name (. (deref formal) name)))
            ;; Only bind if not already bound
            (match (find-binding bind-names bind-types tv-name)
              ((some existing) (do))  ;; Already bound, skip (could check consistency)
              ((none)
                (do (list-push bind-names tv-name)
                    (list-push bind-types actual))))))
        ;; Ptr: recurse into inner type
        ((== f-kind 'rk-ptr)
          (when (== (. (deref actual) kind) 'rk-ptr)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; Chan: recurse into inner type
        ((== f-kind 'rk-chan)
          (when (== (. (deref actual) kind) 'rk-chan)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; Thread: recurse into inner type
        ((== f-kind 'rk-thread)
          (when (== (. (deref actual) kind) 'rk-thread)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; List: recurse into inner type
        ((== f-kind 'rk-list)
          (when (== (. (deref actual) kind) 'rk-list)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; Option: recurse into inner type
        ((== f-kind 'rk-option)
          (when (== (. (deref actual) kind) 'rk-option)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; Result: recurse into both inner types
        ((== f-kind 'rk-result)
          (when (== (. (deref actual) kind) 'rk-result)
            (match (. (deref formal) inner-type)
              ((some f-inner)
                (match (. (deref actual) inner-type)
                  ((some a-inner) (unify-types arena f-inner a-inner bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))
            (match (. (deref formal) inner-type2)
              ((some f-inner2)
                (match (. (deref actual) inner-type2)
                  ((some a-inner2) (unify-types arena f-inner2 a-inner2 bind-names bind-types))
                  ((none) (do))))
              ((none) (do)))))
        ;; Concrete types — no unification needed
        (else (do)))))

  (fn substitute-type-vars ((arena Arena) (t (Ptr ResolvedType))
                             (bind-names (List String)) (bind-types (List (Ptr ResolvedType))))
    (@intent "Replace type variables with their bound concrete types")
    (@spec ((Arena (Ptr ResolvedType) (List String) (List (Ptr ResolvedType))) -> (Ptr ResolvedType)))
    (@pre (!= t nil))
    (let ((kind (. (deref t) kind)))
      (cond
        ;; Type variable — look up binding
        ((== kind 'rk-typevar)
          (let ((tv-name (. (deref t) name)))
            (match (find-binding bind-names bind-types tv-name)
              ((some bound) bound)
              ((none) t))))  ;; Unbound typevar stays as-is
        ;; Ptr: substitute inner
        ((== kind 'rk-ptr)
          (match (. (deref t) inner-type)
            ((some inner)
              (let ((new-inner (substitute-type-vars arena inner bind-names bind-types))
                    (inner-name (. (deref new-inner) name))
                    (ptr-name (string-concat arena "Ptr_" inner-name))
                    (new-ptr (resolved-type-new arena 'rk-ptr ptr-name (none) "void*")))
                (resolved-type-set-inner new-ptr new-inner)
                new-ptr))
            ((none) t)))
        ;; Chan: substitute inner
        ((== kind 'rk-chan)
          (match (. (deref t) inner-type)
            ((some inner)
              (let ((new-inner (substitute-type-vars arena inner bind-names bind-types))
                    (new-chan (resolved-type-new arena 'rk-chan "Chan" (none) "slop_chan_int*")))
                (resolved-type-set-inner new-chan new-inner)
                new-chan))
            ((none) t)))
        ;; Thread: substitute inner
        ((== kind 'rk-thread)
          (match (. (deref t) inner-type)
            ((some inner)
              (let ((new-inner (substitute-type-vars arena inner bind-names bind-types))
                    (new-thread (resolved-type-new arena 'rk-thread "Thread" (none) "slop_thread_int*")))
                (resolved-type-set-inner new-thread new-inner)
                new-thread))
            ((none) t)))
        ;; List: substitute inner
        ((== kind 'rk-list)
          (match (. (deref t) inner-type)
            ((some inner)
              (let ((new-inner (substitute-type-vars arena inner bind-names bind-types))
                    (new-list (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                (resolved-type-set-inner new-list new-inner)
                new-list))
            ((none) t)))
        ;; Option: substitute inner
        ((== kind 'rk-option)
          (match (. (deref t) inner-type)
            ((some inner)
              (let ((new-inner (substitute-type-vars arena inner bind-names bind-types))
                    (inner-name (. (deref new-inner) name))
                    (opt-name (string-concat arena "Option_" inner-name))
                    (new-opt (resolved-type-new arena 'rk-option opt-name (none) "slop_option")))
                (resolved-type-set-inner new-opt new-inner)
                new-opt))
            ((none) t)))
        ;; Result: substitute both inner types
        ((== kind 'rk-result)
          (let ((new-ok (match (. (deref t) inner-type)
                          ((some ok) (substitute-type-vars arena ok bind-names bind-types))
                          ((none) nil)))
                (new-err (match (. (deref t) inner-type2)
                           ((some err) (substitute-type-vars arena err bind-names bind-types))
                           ((none) nil))))
            (if (== new-ok nil)
              t
              (let ((ok-name (. (deref new-ok) name))
                    (err-name (if (!= new-err nil) (. (deref new-err) name) "Error"))
                    (result-name (string-concat arena "Result_"
                                   (string-concat arena ok-name
                                     (string-concat arena "_" err-name))))
                    (new-result (resolved-type-new arena 'rk-result result-name (none) "Result")))
                (resolved-type-set-inner new-result new-ok)
                (when (!= new-err nil)
                  (resolved-type-set-inner2 new-result new-err))
                new-result))))
        ;; Other types — return as-is
        (else t))))

  (fn infer-generic-call ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)) (expr (Ptr SExpr))
                            (line Int) (col Int))
    (@intent "Infer return type for a generic function call by unifying type params")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature) (Ptr SExpr) Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (@pre (!= expr nil))
    (let ((arena (env-arena env))
          (params (. (deref sig) params))
          (num-params (list-len params))
          (bind-names (list-new arena String))
          (bind-types (list-new arena (Ptr ResolvedType))))
      ;; Infer argument types and unify with formal params
      (when (sexpr-is-list expr)
        (let ((num-args (- (sexpr-list-len expr) 1)))
          ;; Check arity
          (when (!= num-args num-params)
            (let ((msg (string-concat arena "'"
                         (string-concat arena (. (deref sig) name)
                           (string-concat arena "' expects "
                             (string-concat arena (int-to-string arena num-params)
                               (string-concat arena " argument(s), got "
                                 (int-to-string arena num-args))))))))
              (env-add-error env msg line col)))
          ;; Unify each arg with its formal param
          (let ((limit (if (< num-args num-params) num-args num-params)))
            (for (i 0 limit)
              (match (sexpr-list-get expr (+ i 1))
                ((some arg-expr)
                  (let ((actual-type (infer-expr env arg-expr)))
                    (match (list-get params i)
                      ((some param-info)
                        (let ((formal-type (. param-info param-type)))
                          (unify-types arena formal-type actual-type bind-names bind-types)))
                      ((none) (do)))))
                ((none) (do)))))))
      ;; Substitute type variables in return type
      (let ((ret-type (. (deref sig) return-type)))
        (substitute-type-vars arena ret-type bind-names bind-types))))

  ;; ============================================================
  ;; Type Comparison
  ;; ============================================================

  (fn types-equal ((a (Ptr ResolvedType)) (b (Ptr ResolvedType)))
    (@intent "Check if two types are equal, handling generics and aliases")
    (@spec (((Ptr ResolvedType) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= a nil))
    (@pre (!= b nil))
    (let ((a-kind (. (deref a) kind))
          (b-kind (. (deref b) kind))
          (a-name (. (deref a) name))
          (b-name (. (deref b) name)))
      (cond
        ;; Same name - definitely equal
        ((string-eq a-name b-name) true)

        ;; Type variables match anything
        ((or (== a-kind 'rk-typevar) (== b-kind 'rk-typevar)) true)

        ;; Generic type variable "T" matches anything (legacy)
        ((or (string-eq a-name "T") (string-eq b-name "T")) true)

        ;; Both Option types - check if one is generic (Option_T)
        ((and (== a-kind 'rk-option) (== b-kind 'rk-option))
          (or (string-eq a-name "Option_T")
              (string-eq b-name "Option_T")))

        ;; Both Result types - generic "Result" matches any Result_X_Y
        ((and (== a-kind 'rk-result) (== b-kind 'rk-result))
          (or (string-eq a-name "Result")
              (string-eq b-name "Result")))

        ;; Range type vs its base type (e.g., AsciiChar vs Int)
        ((or (== a-kind 'rk-range) (== b-kind 'rk-range))
          (types-compatible-with-range a b))

        ;; Function types are compatible if both are rk-function
        ;; or if one is named "Fn" (generic function type from parameter parsing)
        ;; TODO: Full signature comparison
        ((and (== a-kind 'rk-function) (== b-kind 'rk-function)) true)
        ((or (string-eq a-name "Fn") (string-eq b-name "Fn"))
          (or (== a-kind 'rk-function) (== b-kind 'rk-function)))

        ;; Different names, not special case - not equal
        (else false))))

  (fn types-compatible-with-range ((a (Ptr ResolvedType)) (b (Ptr ResolvedType)))
    (@intent "Check if types are compatible considering range types")
    (@spec (((Ptr ResolvedType) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= a nil))
    (@pre (!= b nil))
    (let ((a-kind (. (deref a) kind))
          (b-kind (. (deref b) kind)))
      (cond
        ;; If a is range type, check if b matches its base type
        ((== a-kind 'rk-range)
          (match (. (deref a) inner-type)
            ((some base) (string-eq (. (deref base) name) (. (deref b) name)))
            ((none) false)))
        ;; If b is range type, check if a matches its base type
        ((== b-kind 'rk-range)
          (match (. (deref b) inner-type)
            ((some base) (string-eq (. (deref a) name) (. (deref base) name)))
            ((none) false)))
        (else false))))

  (fn unify-branch-types ((env (Ptr TypeEnv)) (a (Ptr ResolvedType)) (b (Ptr ResolvedType))
                          (line Int) (col Int))
    (@intent "Unify two branch types, emitting warning if they differ")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) (Ptr ResolvedType) Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= a nil))
    (@pre (!= b nil))
    ;; If types are equal, return either
    (if (types-equal a b)
      a
      ;; Types differ - emit warning and return first type
      (let ((arena (env-arena env))
            (msg (string-concat arena "Branch types differ: "
                   (string-concat arena (. (deref a) name)
                     (string-concat arena " vs " (. (deref b) name))))))
        (env-add-warning env msg line col)
        a)))

  ;; ============================================================
  ;; AST Type Annotation
  ;; ============================================================

  (fn sexpr-set-resolved-type ((expr (Ptr SExpr)) (t (Ptr ResolvedType)))
    (@intent "Set the resolved type annotation on an AST node")
    (@spec (((Ptr SExpr) (Ptr ResolvedType)) -> Unit))
    (@pre (!= expr nil))
    (match (deref expr)
      ((sym sym)
        (set! (deref expr) (union-new SExpr sym
          (SExprSymbol (. sym name) (. sym line) (. sym col) (some t)))))
      ((str str)
        (set! (deref expr) (union-new SExpr str
          (SExprString (. str value) (. str line) (. str col) (some t)))))
      ((num num)
        (set! (deref expr) (union-new SExpr num
          (SExprNumber (. num int-value) (. num float-value) (. num is-float) (. num raw) (. num line) (. num col) (some t)))))
      ((lst lst)
        (set! (deref expr) (union-new SExpr lst
          (SExprList (. lst items) (. lst line) (. lst col) (some t)))))))

  ;; ============================================================
  ;; Expression Type Inference
  ;; ============================================================

  (fn infer-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer the type of an expression and annotate the AST node")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (let ((result (infer-expr-inner env expr)))
      ;; Annotate the AST node with the inferred type (skip if nil - polymorphic builtins)
      (when (!= result nil)
        (sexpr-set-resolved-type expr result))
      result))

  (fn infer-expr-inner ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer the type of an expression (internal, without annotation)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (let ((line (sexpr-line expr))
          (col (sexpr-col expr)))
      (match (deref expr)
        ((sym sym)
          (let ((name (. sym name)))
            (cond
              ;; Boolean literals
              ((or (string-eq name "true") (string-eq name "false"))
                (env-get-bool-type env))
              ;; nil and unit
              ((or (string-eq name "nil") (string-eq name "unit"))
                (env-get-unit-type env))
              ;; none - Option type with unknown inner type
              ((string-eq name "none")
                (env-make-option-type env nil))
              ;; Variable lookup
              (else
                (match (env-lookup-var env name)
                  ((some t) t)
                  ((none)
                    ;; Try looking up as a constant
                    (match (env-lookup-constant env name)
                      ((some t) t)
                      ((none)
                        ;; Try looking up as a function (return Fn type for value use)
                        (match (env-lookup-function env name)
                          ((some sig) (env-make-fn-type env sig))
                          ((none)
                            ;; Check for dot notation: var.field or Type.variant
                            (if (string-contains-char name 46)
                              (let ((dot-pos (string-index-of name 46))
                                    (arena (env-arena env))
                                    (base-name (string-substring arena name 0 dot-pos))
                                    (field-name (string-substring arena name (+ dot-pos 1) (cast Int (. name len)))))
                                ;; Try as variable field access
                                (match (env-lookup-var env base-name)
                                  ((some obj-type)
                                    (check-field-exists env obj-type field-name line col))
                                  ((none)
                                    ;; Try as enum Type.variant
                                    (match (env-lookup-type env base-name)
                                      ((some type-info)
                                        type-info)
                                      ((none)
                                        (let ((msg (string-concat arena "Undefined variable: " name)))
                                          (env-add-error env msg line col)
                                          (env-get-int-type env)))))))
                              ;; No dot - check if it's a type name used as a value
                              (match (env-lookup-type env name)
                                ((some type-info)
                                  type-info)
                                ((none)
                                  (let ((arena (env-arena env))
                                        (msg (string-concat arena "Undefined variable: " name)))
                                    (env-add-error env msg line col)
                                    (env-get-int-type env)))))))))))))))
        ((num num)
          (env-get-int-type env))
        ((str str)
          (env-get-string-type env))
        ((lst lst)
          (infer-list-expr env expr lst)))))

  (fn infer-list-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of a list expression (call or special form)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (let ((items (. lst items))
          (len (list-len items)))
      (if (== len 0)
        (env-get-unit-type env)
        (match (list-get items 0)
          ((none) (env-get-unit-type env))
          ((some head)
            (match (deref head)
              ((sym sym)
                (let ((op (. sym name)))
                  (infer-special-form env expr lst op)))
              ;; Non-symbol head - just return unit
              (_ (env-get-unit-type env))))))))

  (fn infer-special-form ((env (Ptr TypeEnv)) (expr (Ptr SExpr))
                          (lst SExprList) (op String))
    (@intent "Infer type of a special form or function call")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr)))
      (cond
        ;; (if cond then else) - check branch types
        ((string-eq op "if")
          (if (>= len 4)
            (do
            ;; Visit condition at index 1
            (match (list-get items 1)
              ((some cond-expr) (let ((_ (infer-expr env cond-expr))) (do)))
              ((none) (do)))
            (match (list-get items 2)
              ((some then-expr)
                (let ((then-type (infer-expr env then-expr)))
                  (match (list-get items 3)
                    ((some else-expr)
                      (let ((else-type (infer-expr env else-expr)))
                        (unify-branch-types env then-type else-type line col)))
                    ((none) then-type))))
              ((none) (env-get-unit-type env))))
            (env-get-unit-type env)))

        ;; (cond (test1 body1) (test2 body2) ... (else bodyN))
        ((string-eq op "cond")
          (infer-cond-expr env expr lst))

        ;; (match scrutinee clauses...)
        ((string-eq op "match")
          (infer-match-expr env expr lst))

        ;; (do exprs...) - visit all, type is last expr
        ((string-eq op "do")
          (do (infer-body-exprs env expr 1)
              (if (> len 1)
                (match (list-get items (- len 1))
                  ((some last) (infer-expr env last))
                  ((none) (env-get-unit-type env)))
                (env-get-unit-type env))))

        ;; (let ((bindings)) body...) - bind variables and infer body type
        ((string-eq op "let")
          (infer-let-expr env expr))

        ;; (when cond body...) - check condition and all body expressions, return Unit
        ((string-eq op "when")
          (do (infer-body-exprs env expr 1)
              (env-get-unit-type env)))

        ;; (for (i start end) body...) - bind loop var as Int, infer body exprs
        ((string-eq op "for")
          (if (>= len 2)
            (do
              ;; Bind loop variable and infer start/end expressions
              (match (list-get items 1)
                ((some binding-form)
                  (when (sexpr-is-list binding-form)
                    (let ((bind-len (sexpr-list-len binding-form)))
                      (when (>= bind-len 3)
                        (match (sexpr-list-get binding-form 0)
                          ((some var-expr)
                            (let ((var-name (sexpr-get-symbol-name var-expr)))
                              (when (not (string-eq var-name ""))
                                (env-push-scope env)
                                (env-bind-var env var-name (env-get-int-type env))
                                ;; Infer start and end expressions
                                (match (sexpr-list-get binding-form 1)
                                  ((some start-expr) (let ((_ (infer-expr env start-expr))) (do)))
                                  ((none) (do)))
                                (match (sexpr-list-get binding-form 2)
                                  ((some end-expr) (let ((_ (infer-expr env end-expr))) (do)))
                                  ((none) (do)))
                                ;; Infer all body expressions
                                (for (body-idx 2 len)
                                  (match (list-get items body-idx)
                                    ((some body-expr) (let ((_ (infer-expr env body-expr))) (do)))
                                    ((none) (do))))
                                (env-pop-scope env))))
                          ((none) (do)))))))
                ((none) (do)))
              (env-get-unit-type env))
            (env-get-unit-type env)))

        ;; (for-each (item collection) body...) - bind item to element type
        ((string-eq op "for-each")
          (if (>= len 3)
            (match (list-get items 1)
              ((some binding-form)
                ;; binding-form is (item collection)
                (if (sexpr-is-list binding-form)
                  (let ((bind-len (sexpr-list-len binding-form)))
                    (if (>= bind-len 2)
                      (match (sexpr-list-get binding-form 0)
                        ((some var-expr)
                          (let ((var-name (sexpr-get-symbol-name var-expr)))
                            (if (string-eq var-name "")
                              (env-get-unit-type env)
                              (match (sexpr-list-get binding-form 1)
                                ((some coll-expr)
                                  (let ((coll-type (infer-expr env coll-expr))
                                        (coll-line (sexpr-line coll-expr))
                                        (coll-col (sexpr-col coll-expr)))
                                    ;; Get element type from collection's inner-type
                                    (let ((elem-type (match (. (deref coll-type) inner-type)
                                                       ((some inner) inner)
                                                       ((none)
                                                         ;; Error: collection has no known element type
                                                         (let ((arena (env-arena env))
                                                               (coll-name (. (deref coll-type) name))
                                                               (msg (string-concat arena "for-each: cannot determine element type of '"
                                                                      (string-concat arena coll-name
                                                                        "' - collection has no inner type"))))
                                                           (env-add-error env msg coll-line coll-col)
                                                           (env-get-unknown-type env))))))
                                      ;; Push scope, bind var, infer body, pop scope
                                      (env-push-scope env)
                                      (env-bind-var env var-name elem-type)
                                      ;; Infer all body expressions (discard results)
                                      (for (body-idx 2 len)
                                        (match (list-get items body-idx)
                                          ((some body-expr) (let ((_ (infer-expr env body-expr))) (do)))
                                          ((none) (do))))
                                      (env-pop-scope env)
                                      (env-get-unit-type env))))
                                ((none) (env-get-unit-type env))))))
                        ((none) (env-get-unit-type env)))
                      (env-get-unit-type env)))
                  (env-get-unit-type env)))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (while ...) - returns Unit
        ;; (while cond body...) - check condition and all body expressions, return Unit
        ((string-eq op "while")
          (do (infer-body-exprs env expr 1)
              (env-get-unit-type env)))

        ;; (@loop-invariant cond) - loop invariant annotation, returns Unit
        ;; Type-check the condition expression, used by verifier
        ((string-eq op "@loop-invariant")
          (do (infer-body-exprs env expr 1)
              (env-get-unit-type env)))

        ;; (with-arena size body...) - binds 'arena' and returns last body type
        ((string-eq op "with-arena")
          (infer-with-arena-expr env expr))

        ;; (set! var expr) - infer expr for error checking, returns Unit
        ((string-eq op "set!")
          (do (cond
                ;; Record field update: (set! record field value) - 4 elements
                ((>= len 4)
                  (match (list-get items 3)
                    ((some val-expr) (let ((_ (infer-expr env val-expr))) (do)))
                    ((none) (do))))
                ;; Simple assignment: (set! var value) - 3 elements
                ((>= len 3)
                  (match (list-get items 2)
                    ((some val-expr) (let ((_ (infer-expr env val-expr))) (do)))
                    ((none) (do))))
                (else (do)))
              (env-get-unit-type env)))

        ;; (return expr) - type of expr
        ((string-eq op "return")
          (if (>= len 2)
            (match (list-get items 1)
              ((some ret-expr) (infer-expr env ret-expr))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; Comparison operators return Bool
        ((or (string-eq op "==") (string-eq op "!=")
             (string-eq op "<") (string-eq op "<=")
             (string-eq op ">") (string-eq op ">=")
             (string-eq op "and") (string-eq op "or") (string-eq op "not"))
          (do (infer-body-exprs env expr 1)
              (env-get-bool-type env)))

        ;; Arithmetic operators return Int
        ((or (string-eq op "+") (string-eq op "-")
             (string-eq op "*") (string-eq op "/") (string-eq op "%"))
          (do (infer-body-exprs env expr 1)
              (env-get-int-type env)))

        ;; (deref ptr-expr) - dereference pointer, returns inner type
        ((string-eq op "deref")
          (if (>= len 2)
            (match (list-get items 1)
              ((some ptr-expr)
                (let ((ptr-type (infer-expr env ptr-expr)))
                  ;; Check if it's a pointer type and get the inner type
                  (if (resolved-type-is-pointer ptr-type)
                    (match (. (deref ptr-type) inner-type)
                      ((some inner) inner)
                      ((none) (env-get-unit-type env)))
                    ;; Not a pointer - return the type as-is (may want to add warning later)
                    ptr-type)))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (addr expr) - take address of expression, returns pointer type
        ((string-eq op "addr")
          (if (>= len 2)
            (match (list-get items 1)
              ((some inner-expr)
                (let ((inner-type (infer-expr env inner-expr)))
                  (env-make-ptr-type env inner-type)))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env)))

        ;; (cast TargetType expr) - cast expression to target type
        ((string-eq op "cast")
          (if (>= len 2)
            (match (list-get items 1)
              ((some type-expr)
                ;; Get the target type name and look it up
                (let ((type-name (sexpr-get-symbol-name type-expr)))
                  (if (string-eq type-name "")
                    ;; Complex type like (Int 0 ..) or (Ptr T)
                    ;; Check if it's a range type or other complex type
                    (if (sexpr-is-list type-expr)
                      (match (sexpr-list-get type-expr 0)
                        ((some head-expr)
                          (let ((head-name (sexpr-get-symbol-name head-expr)))
                            (cond
                              ;; Range type (Int min .. max) is Int
                              ((string-eq head-name "Int") (env-get-int-type env))
                              ;; Ptr type casts return the pointer type
                              ((string-eq head-name "Ptr")
                                (let ((inner-type (resolve-ptr-inner-type env type-expr)))
                                  (env-make-ptr-type env inner-type)))
                              ;; U8, U16, etc range types are Int
                              ((string-eq head-name "U8") (env-get-int-type env))
                              ((string-eq head-name "U16") (env-get-int-type env))
                              ((string-eq head-name "U32") (env-get-int-type env))
                              ((string-eq head-name "U64") (env-get-int-type env))
                              ((string-eq head-name "I8") (env-get-int-type env))
                              ((string-eq head-name "I16") (env-get-int-type env))
                              ((string-eq head-name "I32") (env-get-int-type env))
                              ((string-eq head-name "I64") (env-get-int-type env))
                              ;; Other complex types - return Unknown
                              (else (env-get-unknown-type env)))))
                        ((none) (env-get-unknown-type env)))
                      (env-get-unknown-type env))
                    ;; Simple type name - look it up
                    (match (env-lookup-type env type-name)
                      ((some t) t)
                      ((none)
                        (cond
                          ((string-eq type-name "Int") (env-get-int-type env))
                          ((string-eq type-name "Bool") (env-get-bool-type env))
                          ((string-eq type-name "String") (env-get-string-type env))
                          ((string-eq type-name "Unit") (env-get-unit-type env))
                          (else (env-get-unknown-type env))))))))
              ((none) (env-get-unknown-type env)))
            (env-get-unknown-type env)))

        ;; (quote symbol) - quoted enum variant, look up the enum type
        ((string-eq op "quote")
          (if (>= len 2)
            (match (list-get items 1)
              ((some variant-expr)
                (let ((variant-name (sexpr-get-symbol-name variant-expr)))
                  (if (string-eq variant-name "")
                    (env-get-unknown-type env)
                    ;; Look up which enum contains this variant
                    (match (env-lookup-variant env variant-name)
                      ((some enum-name)
                        ;; Look up the enum type
                        (match (env-lookup-type env enum-name)
                          ((some enum-type) enum-type)
                          ((none) (env-get-unknown-type env))))
                      ((none) (env-get-unknown-type env))))))
              ((none) (env-get-unknown-type env)))
            (env-get-unknown-type env)))

        ;; (. obj field) - field access
        ((string-eq op ".")
          (infer-field-access env expr lst line col))

        ;; (some x) - Option type constructor
        ((string-eq op "some")
          (if (>= len 2)
            (match (list-get items 1)
              ((some inner-expr)
                (let ((inner-type (infer-expr env inner-expr)))
                  (env-make-option-type env inner-type)))
              ((none) (env-make-option-type env nil)))
            (env-make-option-type env nil)))

        ;; (none) - Option type with unknown inner
        ((string-eq op "none")
          (env-make-option-type env nil))

        ;; (record-new TypeName (field1 val1) ...) - create record instance
        ((string-eq op "record-new")
          (do
          ;; Visit field value expressions at indices 2+ ; each is (field val)
          (for (fi 2 len)
            (match (list-get items fi)
              ((some field-pair)
                (when (and (sexpr-is-list field-pair) (>= (sexpr-list-len field-pair) 2))
                  (match (sexpr-list-get field-pair 1)
                    ((some val-expr) (let ((_ (infer-expr env val-expr))) (do)))
                    ((none) (do)))))
              ((none) (do))))
          (if (>= len 2)
            (match (list-get items 1)
              ((some type-expr)
                (let ((type-name (sexpr-get-symbol-name type-expr)))
                  (if (string-eq type-name "")
                    (env-get-unit-type env)
                    (match (env-lookup-type env type-name)
                      ((some t) t)
                      ((none) (env-get-unit-type env))))))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env))))

        ;; (union-new TypeName variant value) - create union instance
        ((string-eq op "union-new")
          (do
          ;; Visit value expression at index 3 (skip type name and variant name)
          (when (>= len 4)
            (match (list-get items 3)
              ((some val-expr) (let ((_ (infer-expr env val-expr))) (do)))
              ((none) (do))))
          (if (>= len 2)
            (match (list-get items 1)
              ((some type-expr)
                (let ((type-name (sexpr-get-symbol-name type-expr)))
                  (if (string-eq type-name "")
                    (env-get-unit-type env)
                    (match (env-lookup-type env type-name)
                      ((some t) t)
                      ((none) (env-get-unit-type env))))))
              ((none) (env-get-unit-type env)))
            (env-get-unit-type env))))

        ;; (hole Type "prompt" [:context ...]) - unfilled hole
        ((string-eq op "hole")
          (let ((hole-type (resolve-hole-type env items len))
                (raw-prompt (get-hole-prompt items len))
                (arena (env-arena env))
                (hole-msg (string-concat arena "Unfilled hole: " raw-prompt)))
            ;; Report unfilled hole as an error
            (env-add-error env hole-msg line col)
            hole-type))

        ;; Function call - look up return type and check arguments
        (else
          (match (env-lookup-function env op)
            ((some sig)
              ;; Generic functions: unify type params from arguments
              (if (has-type-params sig)
                (infer-generic-call env sig expr line col)
                (do (check-fn-call-args env sig expr line col)
                    (. (deref sig) return-type))))
            ;; Not a function - check if it's a type constructor or builtin
            ((none)
              (match (env-lookup-type env op)
                ;; Type constructor - return the type itself
                ((some the-type) the-type)
                ;; Check for built-in list functions
                ((none)
                  (cond
                    ;; list-get returns Option_T (generic Option) - expects 2 args: list, index
                    ((string-eq op "list-get")
                      (do (check-builtin-args env "list-get" 2 (- len 1) line col)
                          (infer-builtin-args env expr)
                          ;; Extract element type from list arg to make Option type more precise
                          (let ((mut elem-type (Ptr ResolvedType) nil))
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some list-arg)
                                  (let ((list-type (infer-expr env list-arg)))
                                    (when (== (. (deref list-type) kind) 'rk-list)
                                      (match (. (deref list-type) inner-type)
                                        ((some inner) (set! elem-type inner))
                                        ((none) (do))))))
                                ((none) (do))))
                            (env-make-option-type env elem-type))))
                    ;; list-len returns Int - expects 1 arg: list
                    ((string-eq op "list-len")
                      (do (check-builtin-args env "list-len" 1 (- len 1) line col)
                          (env-get-int-type env)))
                    ;; (arena-alloc arena Type) - return (Ptr Type)
                    ;; Also supports (arena-alloc arena size-expr) for raw byte allocation
                    ((string-eq op "arena-alloc")
                      (if (< len 3)
                        (do
                          (env-add-error env "arena-alloc requires arena and type/size arguments" line col)
                          (env-get-int-type env))
                        (match (list-get items 2)
                          ((some type-expr)
                            (let ((type-name (sexpr-get-symbol-name type-expr)))
                              (if (string-eq type-name "")
                                ;; Not a symbol - size expression, can't determine exact return type
                                (env-get-int-type env)
                                (match (env-lookup-type env type-name)
                                  ((some resolved) (env-make-ptr-type env resolved))
                                  ((none)
                                    ;; Symbol but unknown type - emit warning but continue
                                    (do
                                      (let ((arena (env-arena env)))
                                        (env-add-warning env (string-concat arena "arena-alloc: unknown type: " type-name) line col))
                                      (env-get-int-type env)))))))
                          ((none) (env-get-int-type env)))))
                    ;; cast returns Int (approximation)
                    ((string-eq op "cast") (env-get-int-type env))
                    ;; List operations
                    ;; list-push expects 2 args: list, item
                    ((string-eq op "list-push")
                      (do (check-builtin-args env "list-push" 2 (- len 1) line col)
                          (infer-builtin-args env expr)
                          (env-get-unit-type env)))
                    ;; list-pop expects 1 arg: list
                    ((string-eq op "list-pop")
                      (do (check-builtin-args env "list-pop" 1 (- len 1) line col)
                          (env-make-option-type env nil)))
                    ;; list-new expects 2 args: arena, Type - returns List
                    ((string-eq op "list-new")
                      (do (check-builtin-args env "list-new" 2 (- len 1) line col)
                          (let ((arena (env-arena env))
                                (list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                            ;; Extract element type from third argument (index 2): (list-new arena ElemType)
                            (when (>= len 3)
                              (match (list-get items 2)
                                ((some type-expr)
                                  (let ((elem-type (if (sexpr-is-list type-expr)
                                                     (resolve-complex-type-expr env type-expr)
                                                     (let ((tname (sexpr-get-symbol-name type-expr)))
                                                       (if (string-eq tname "")
                                                         nil
                                                         (resolve-simple-type env tname))))))
                                    (when (!= elem-type nil)
                                      (resolved-type-set-inner list-type elem-type))))
                                ((none) (do))))
                            list-type)))
                    ;; SExpr helpers
                    ((string-eq op "sexpr-is-list") (env-get-bool-type env))
                    ((string-eq op "sexpr-is-symbol") (env-get-bool-type env))
                    ((string-eq op "sexpr-list-len") (env-get-int-type env))
                    ((string-eq op "sexpr-list-get") (env-make-option-type env nil))
                    ((string-eq op "sexpr-get-symbol-name") (env-get-string-type env))
                    ((string-eq op "sexpr-line") (env-get-int-type env))
                    ((string-eq op "sexpr-col") (env-get-int-type env))
                    ;; IO builtins
                    ((string-eq op "print") (env-get-unit-type env))
                    ((string-eq op "println") (env-get-unit-type env))
                    ;; Result constructors - infer inner types
                    ((string-eq op "ok")
                      (let ((arena (env-arena env))
                            (result-type (resolved-type-new arena 'rk-result "Result" (none) "Result")))
                        (when (>= len 2)
                          (match (list-get items 1)
                            ((some val-expr)
                              (let ((val-type (infer-expr env val-expr)))
                                (resolved-type-set-inner result-type val-type)))
                            ((none) (do))))
                        result-type))
                    ((string-eq op "error")
                      (let ((arena (env-arena env))
                            (result-type (resolved-type-new arena 'rk-result "Result" (none) "Result")))
                        (when (>= len 2)
                          (match (list-get items 1)
                            ((some val-expr)
                              (let ((val-type (infer-expr env val-expr)))
                                (resolved-type-set-inner2 result-type val-type)))
                            ((none) (do))))
                        result-type))
                    ;; Array indexing builtin: (@ ptr index) returns element type
                    ((string-eq op "@")
                      (if (>= len 2)
                        (match (list-get items 1)
                          ((some ptr-expr)
                            (let ((ptr-type (infer-expr env ptr-expr)))
                              ;; Get the element type from the pointer
                              (if (resolved-type-is-pointer ptr-type)
                                (match (. (deref ptr-type) inner-type)
                                  ((some inner) inner)
                                  ((none) (env-get-int-type env)))
                                ;; Not a pointer - default to Int
                                (env-get-int-type env))))
                          ((none) (env-get-int-type env)))
                        (env-get-int-type env)))
                    ;; Option constructor
                    ((string-eq op "some") (env-make-option-type env nil))
                    ;; c-inline - returns generic type (unknown C code)
                    ((string-eq op "c-inline") (env-get-generic-type env))
                    ;; Map builtins
                    ;; map-new expects 3 args: arena, KeyType, ValueType - returns Map with tracked types
                    ((string-eq op "map-new")
                      (do (check-builtin-args env "map-new" 3 (- len 1) line col)
                          (let ((arena (env-arena env))
                                (mut key-type (Ptr ResolvedType) nil)
                                (mut val-type (Ptr ResolvedType) nil))
                            ;; Extract key type from second argument
                            (when (>= len 3)
                              (match (list-get items 2)
                                ((some type-expr)
                                  (let ((type-name (sexpr-get-symbol-name type-expr)))
                                    (when (not (string-eq type-name ""))
                                      (match (env-lookup-type env type-name)
                                        ((some t) (set! key-type t))
                                        ((none) (do))))))
                                ((none) (do))))
                            ;; Extract value type from third argument
                            (when (>= len 4)
                              (match (list-get items 3)
                                ((some type-expr)
                                  (let ((type-name (sexpr-get-symbol-name type-expr)))
                                    (when (not (string-eq type-name ""))
                                      (match (env-lookup-type env type-name)
                                        ((some t) (set! val-type t))
                                        ((none) (do))))))
                                ((none) (do))))
                            (let ((map-type (resolved-type-new arena 'rk-map "Map" (none) "slop_map*")))
                              (when (!= key-type nil)
                                (resolved-type-set-inner map-type key-type))
                              (when (!= val-type nil)
                                (resolved-type-set-inner2 map-type val-type))
                              map-type))))
                    ;; map-get expects 2 args: map, key - returns Option with map's value type
                    ((string-eq op "map-get")
                      (do (check-builtin-args env "map-get" 2 (- len 1) line col)
                          ;; Infer the map argument's type to get value type
                          (let ((mut val-type (Ptr ResolvedType) nil))
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-type (infer-expr env map-expr)))
                                    (match (. (deref map-type) inner-type2)
                                      ((some inner) (set! val-type inner))
                                      ((none) (do)))))
                                ((none) (do))))
                            (env-make-option-type env val-type))))
                    ;; map-put expects 3 args: map, key, value - returns Unit
                    ((string-eq op "map-put")
                      (do (check-builtin-args env "map-put" 3 (- len 1) line col)
                          (env-get-unit-type env)))
                    ;; map-has expects 2 args: map, key - returns Bool
                    ((string-eq op "map-has")
                      (do (check-builtin-args env "map-has" 2 (- len 1) line col)
                          ;; Check first arg is Map, not Option<Map>
                          (when (>= len 2)
                            (match (list-get items 1)
                              ((some map-expr)
                                (let ((map-type (infer-expr env map-expr))
                                      (type-name (. (deref map-type) name))
                                      (arena (env-arena env)))
                                  (when (starts-with type-name "Option")
                                    (let ((msg (string-concat arena "map-has: expected Map, got "
                                                 (string-concat arena type-name " - use match to unwrap Option first"))))
                                      (env-add-error env msg line col)))))
                              ((none) (do))))
                          (env-get-bool-type env)))
                    ;; map-keys expects 1 arg: map - returns List with map's key type
                    ((string-eq op "map-keys")
                      (do (check-builtin-args env "map-keys" 1 (- len 1) line col)
                          (let ((arena (env-arena env))
                                (mut key-type (Ptr ResolvedType) nil))
                            ;; Infer the map argument's type to get key type
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some map-expr)
                                  (let ((map-type (infer-expr env map-expr)))
                                    (match (. (deref map-type) inner-type)
                                      ((some inner) (set! key-type inner))
                                      ((none) (do)))))
                                ((none) (do))))
                            (let ((list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                              (when (!= key-type nil)
                                (resolved-type-set-inner list-type key-type))
                              list-type))))
                    ;; map-remove expects 2 args: map, key - returns Unit
                    ((string-eq op "map-remove")
                      (do (check-builtin-args env "map-remove" 2 (- len 1) line col)
                          (env-get-unit-type env)))
                    ;; Set builtins
                    ;; set literal: (set Type e1 e2...) - returns Set
                    ((string-eq op "set")
                      (let ((arena (env-arena env)))
                        (resolved-type-new arena 'rk-primitive "Set" (none) "slop_map*")))
                    ;; set-new expects 2 args: arena, ElementType - returns Set with tracked element type
                    ((string-eq op "set-new")
                      (do (check-builtin-args env "set-new" 2 (- len 1) line col)
                          (let ((arena (env-arena env))
                                (mut elem-type (Ptr ResolvedType) nil))
                            ;; Extract element type from second argument
                            (when (>= len 3)
                              (match (list-get items 2)
                                ((some type-expr)
                                  (let ((type-name (sexpr-get-symbol-name type-expr)))
                                    (when (not (string-eq type-name ""))
                                      (match (env-lookup-type env type-name)
                                        ((some t) (set! elem-type t))
                                        ((none) (do))))))
                                ((none) (do))))
                            (let ((set-type (resolved-type-new arena 'rk-primitive "Set" (none) "slop_map*")))
                              (when (!= elem-type nil)
                                (resolved-type-set-inner set-type elem-type))
                              set-type))))
                    ;; set-put expects 2 args: set, element - returns Unit
                    ((string-eq op "set-put")
                      (do (check-builtin-args env "set-put" 2 (- len 1) line col)
                          (env-get-unit-type env)))
                    ;; set-has expects 2 args: set, element - returns Bool
                    ((string-eq op "set-has")
                      (do (check-builtin-args env "set-has" 2 (- len 1) line col)
                          (env-get-bool-type env)))
                    ;; set-remove expects 2 args: set, element - returns Unit
                    ((string-eq op "set-remove")
                      (do (check-builtin-args env "set-remove" 2 (- len 1) line col)
                          (env-get-unit-type env)))
                    ;; set-elements expects 1 arg: set - returns List with set's element type
                    ((string-eq op "set-elements")
                      (do (check-builtin-args env "set-elements" 1 (- len 1) line col)
                          (let ((arena (env-arena env))
                                (mut elem-type (Ptr ResolvedType) nil))
                            ;; Infer the set argument's type to get element type
                            (when (>= len 2)
                              (match (list-get items 1)
                                ((some set-expr)
                                  (let ((set-type (infer-expr env set-expr)))
                                    (match (. (deref set-type) inner-type)
                                      ((some inner) (set! elem-type inner))
                                      ((none) (do)))))
                                ((none) (do))))
                            (let ((list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                              (when (!= elem-type nil)
                                (resolved-type-set-inner list-type elem-type))
                              list-type))))
                    ;; Verification-only forms - skip type checking
                    ((or (string-eq op "exists")
                         (or (string-eq op "forall")
                             (string-eq op "implies")))
                      (env-get-unit-type env))
                    ;; Unknown function/form - check if it's a variant being misused
                    (else
                      (let ((arena (env-arena env)))
                        (match (env-lookup-variant env op)
                          ((some parent-type)
                            (let ((msg (string-concat arena "'"
                                         (string-concat arena op
                                           (string-concat arena "' is a variant of '"
                                             (string-concat arena parent-type
                                               "'. Use (union-new Type variant value) syntax"))))))
                              (env-add-error env msg line col)
                              (env-get-unknown-type env)))
                          ((none)
                            ;; Check for threading builtins first (chan-buffered, send, recv, etc.)
                            (if (is-bare-threading-builtin op)
                              (infer-threading-builtin env op expr items len line col)
                              ;; Check if it looks like a builtin (set-, map-, list-, etc.)
                              (if (or (starts-with op "set-")
                                      (or (starts-with op "map-")
                                          (or (starts-with op "list-")
                                              (starts-with op "arena-"))))
                              (let ((msg (string-concat arena "Unknown builtin: '"
                                           (string-concat arena op "'"))))
                                (env-add-error env msg line col)
                                (env-get-unknown-type env))
                              ;; Check if it's a local variable (function pointer call)
                              (match (env-lookup-var env op)
                                ((some var-type)
                                  ;; It's a local variable being called - infer args but don't error
                                  (infer-builtin-args env expr)
                                  var-type)
                                ((none)
                                  ;; Check if it looks like a SLOP function (contains hyphen)
                                  ;; If so, emit error - likely missing import
                                  (if (string-contains-char op 45)  ;; 45 = '-'
                                    (do
                                      (let ((msg (string-concat arena "Unknown function: '"
                                                   (string-concat arena op
                                                     "' - did you forget to import it?"))))
                                        (env-add-error env msg line col))
                                      ;; Still infer argument types for annotation coverage
                                      (infer-builtin-args env expr)
                                      (env-get-unknown-type env))
                                      ;; May be an FFI function - infer args for annotation coverage
                                      (do (infer-builtin-args env expr)
                                          (env-get-unknown-type env))))))))))))))))))))

  (fn check-fn-call-args ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)) (expr (Ptr SExpr))
                           (line Int) (col Int))
    (@intent "Check function call argument types match parameter types")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature) (Ptr SExpr) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (@pre (!= expr nil))
    (let ((fn-name (. (deref sig) name))
          (params (. (deref sig) params))
          (num-params (list-len params))
          (arena (env-arena env)))
      ;; expr is (fn-name arg1 arg2 ...) - args start at index 1
      (when (sexpr-is-list expr)
        (let ((num-args (- (sexpr-list-len expr) 1)))
          ;; Check argument count
          (cond
            ((< num-args num-params)
              (let ((msg (string-concat arena "'"
                           (string-concat arena fn-name
                             (string-concat arena "' expects "
                               (string-concat arena (int-to-string arena num-params)
                                 (string-concat arena " argument(s), got "
                                   (int-to-string arena num-args))))))))
                (env-add-error env msg line col)))
            ((> num-args num-params)
              (let ((msg (string-concat arena "'"
                           (string-concat arena fn-name
                             (string-concat arena "' expects "
                               (string-concat arena (int-to-string arena num-params)
                                 (string-concat arena " argument(s), got "
                                   (int-to-string arena num-args))))))))
                (env-add-error env msg line col)))
            ;; Counts match - check individual argument types
            (else
              (for (i 0 num-params)
                (check-single-arg env sig expr i line col))))))))

  (fn check-single-arg ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)) (expr (Ptr SExpr))
                         (arg-idx Int) (line Int) (col Int))
    (@intent "Check a single argument type against expected parameter type")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature) (Ptr SExpr) Int Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (let ((params (. (deref sig) params))
          (fn-name (. (deref sig) name))
          (arena (env-arena env)))
      ;; Get expected parameter type
      (match (list-get params arg-idx)
        ((some param-info)
          (let ((expected-type (. param-info param-type)))
            ;; Get actual argument at position arg-idx + 1 (skip fn name)
            (match (sexpr-list-get expr (+ arg-idx 1))
              ((some arg-expr)
                (let ((actual-type (infer-expr env arg-expr))
                      (expected-name (. (deref expected-type) name))
                      (actual-name (. (deref actual-type) name)))
                  ;; Catch Option passed to non-Option parameter
                  (when (and (or (string-eq actual-name "Option_T")
                                 (starts-with actual-name "Option_"))
                             (not (starts-with expected-name "Option_")))
                    (let ((parts (list-new arena String)))
                      (list-push parts "argument ")
                      (list-push parts (int-to-string arena (+ arg-idx 1)))
                      (list-push parts " to '")
                      (list-push parts fn-name)
                      (list-push parts "': expected ")
                      (list-push parts expected-name)
                      (list-push parts ", got ")
                      (list-push parts actual-name)
                      (list-push parts " - use match to unwrap")
                      (env-add-error env (string-build arena parts) line col)))
                  ;; Error if types differ, but skip check for:
                  ;; - Unknown or generic T types
                  ;; - Option_T matching any Option_* type (not non-Option types - caught above)
                  ;; - Generic container types (Ptr_T, Ptr_Ptr_SExpr vs List, etc.)
                  ;; - Unit (nil) passed to pointer types
                  ;; - Range types compatible with their base type (e.g., Score vs Int)
                  ;; - Any Ptr_* matching Ptr_Void (C void* compatibility)
                  ;; - Integer types compatible with each other (FFI compatibility)
                  (when (and (not (types-equal expected-type actual-type))
                             (not (string-eq actual-name "Unknown"))
                             (not (string-eq actual-name "T"))
                             (not (string-eq expected-name "Unknown"))
                             (not (string-eq expected-name "T"))
                             ;; Allow Option_T to match any Option_* type (not non-Option types - caught above)
                             (not (and (string-eq actual-name "Option_T")
                                       (starts-with expected-name "Option_")))
                             ;; Allow Ptr_T to match any Ptr type
                             (not (string-eq actual-name "Ptr_T"))
                             ;; Allow generic List/Ptr mismatches for now
                             (not (starts-with actual-name "Ptr_Ptr_"))
                             ;; Allow Unit (nil) to match pointer types
                             (not (and (string-eq actual-name "Unit")
                                       (starts-with expected-name "Ptr_")))
                             ;; Allow any Ptr_* to match Ptr_Void (C void* compatibility)
                             (not (and (starts-with actual-name "Ptr_")
                                       (string-eq expected-name "Ptr_Void")))
                             ;; Allow integer types to be compatible (FFI compatibility)
                             (not (and (is-integer-type actual-name)
                                       (is-integer-type expected-name))))
                    (let ((msg (string-concat arena "argument "
                                 (string-concat arena (int-to-string arena (+ arg-idx 1))
                                   (string-concat arena " to '"
                                     (string-concat arena fn-name
                                       (string-concat arena "': expected "
                                         (string-concat arena expected-name
                                           (string-concat arena ", got " actual-name)))))))))
                      (env-add-error env msg line col)))))
              ((none) (do)))))
        ((none) (do)))))

  (fn check-builtin-args ((env (Ptr TypeEnv)) (op String) (expected Int) (actual Int)
                           (line Int) (col Int))
    (@intent "Validate argument count for built-in operations")
    (@spec (((Ptr TypeEnv) String Int Int Int Int) -> Unit))
    (@pre (!= env nil))
    (when (!= actual expected)
      (let ((arena (env-arena env))
            (msg (string-concat arena "'"
                   (string-concat arena op
                     (string-concat arena "' expects "
                       (string-concat arena (int-to-string arena expected)
                         (string-concat arena " argument(s), got "
                           (int-to-string arena actual))))))))
        (env-add-error env msg line col))))

  (fn infer-builtin-args ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer types of all arguments in a builtin call to catch nested errors")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (when (sexpr-is-list expr)
      (let ((len (sexpr-list-len expr)))
        ;; Start from index 1 (skip the operator)
        (for (i 1 len)
          (match (sexpr-list-get expr i)
            ((some arg-expr)
              (let ((_ (infer-expr env arg-expr)))
                (do)))
            ((none) (do)))))))

  (fn infer-body-exprs ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (start-idx Int))
    (@intent "Infer types of all body expressions starting from given index")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (when (sexpr-is-list expr)
      (let ((len (sexpr-list-len expr)))
        (for (i start-idx len)
          (match (sexpr-list-get expr i)
            ((some body-expr)
              (let ((_ (infer-expr env body-expr)))
                (do)))
            ((none) (do)))))))

  (fn infer-field-access ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList)
                           (line Int) (col Int))
    (@intent "Infer type of field access (. obj field), checking field exists")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items)))
      (if (< len 3)
        ;; Not enough arguments for field access
        (env-get-unit-type env)
        ;; Get object (index 1) and field name (index 2)
        (match (list-get items 1)
          ((none) (env-get-unit-type env))
          ((some obj-expr)
            (let ((obj-type (infer-expr env obj-expr)))
              ;; Get field name
              (match (list-get items 2)
                ((none) (env-get-unit-type env))
                ((some field-expr)
                  (match (deref field-expr)
                    ((sym field-sym)
                      (let ((field-name (. field-sym name)))
                        (check-field-exists env obj-type field-name line col)))
                    ;; Non-symbol field - return unit
                    (_ (env-get-unit-type env)))))))))))

  (fn check-field-exists ((env (Ptr TypeEnv)) (obj-type (Ptr ResolvedType))
                           (field-name String) (line Int) (col Int))
    (@intent "Check if field exists on type, emit error if not")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) String Int Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= obj-type nil))
    (let ((type-name (. (deref obj-type) name))
          (arena (env-arena env)))
      ;; Check if it's a record type
      (if (resolved-type-is-record obj-type)
        ;; Look up the field type
        (match (resolved-type-get-field-type obj-type field-name)
          ((some field-type)
            field-type)
          ((none)
            ;; Field doesn't exist - emit error
            (let ((msg (string-concat arena "Record '"
                         (string-concat arena type-name
                           (string-concat arena "' has no field '"
                             (string-concat arena field-name "'"))))))
              (env-add-error env msg line col)
              (env-get-unit-type env))))
        ;; Not a record type - could be accessing field on unknown type
        ;; For generic type T, return generic type
        (if (string-eq type-name "T")
          (env-get-generic-type env)
          ;; Allow String's internal fields (data, len)
          (if (string-eq type-name "String")
            (cond
              ((string-eq field-name "data") (env-get-int-type env))  ;; char* as int for pointer
              ((string-eq field-name "len") (env-get-int-type env))
              (else (env-get-unknown-type env)))
            ;; Allow Unknown type field access
            (if (string-eq type-name "Unknown")
              (env-get-unknown-type env)
              ;; Allow field access on Ptr types (transpiler handles auto-dereference)
              (if (starts-with type-name "Ptr_")
                (env-get-unknown-type env)
                ;; Error: trying to access field on non-record type
                (let ((msg (string-concat arena "Cannot access field '"
                             (string-concat arena field-name
                               (string-concat arena "' on non-record type '"
                                 (string-concat arena type-name "'"))))))
                  (env-add-error env msg line col)
                  (env-get-unknown-type env)))))))))

  (fn infer-cond-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of cond expression, checking branch types")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr))
          (mut has-result Bool false)
          (mut result-type (Ptr ResolvedType) (env-get-unit-type env))
          (mut i 1))
      ;; Process each clause
      (while (< i len)
        (match (list-get items i)
          ((some clause)
            (match (deref clause)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (> clause-len 1)
                    ;; Visit condition elements (all but last), skipping 'else' keyword
                    (for (ci 0 (- clause-len 1))
                      (match (list-get clause-items ci)
                        ((some clause-elem)
                          (let ((elem-name (sexpr-get-symbol-name clause-elem)))
                            (when (not (string-eq elem-name "else"))
                              (let ((_ (infer-expr env clause-elem))) (do)))))
                        ((none) (do))))
                    ;; Infer and unify the body (last element) type
                    (match (list-get clause-items (- clause-len 1))
                      ((some body)
                        (let ((body-type (infer-expr env body)))
                          (if (not has-result)
                            (do
                              (set! result-type body-type)
                              (set! has-result true))
                            (set! result-type (unify-branch-types env result-type body-type line col)))))
                      ((none) (do))))))
              (_ (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result-type))

  (fn bind-match-pattern ((env (Ptr TypeEnv)) (scrutinee-type (Ptr ResolvedType)) (pattern (Ptr SExpr)))
    (@intent "Bind pattern variables from a match pattern")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= pattern nil))
    ;; Pattern is either (variant-name binding) or (variant-name) or _ or symbol
    (when (sexpr-is-list pattern)
      (when (> (sexpr-list-len pattern) 0)
        ;; Get variant name
        (match (sexpr-list-get pattern 0)
          ((some variant-expr)
            (let ((variant-name (sexpr-get-symbol-name variant-expr)))
              (when (not (string-eq variant-name ""))
                ;; If there's a binding variable at position 1
                (when (> (sexpr-list-len pattern) 1)
                  (match (sexpr-list-get pattern 1)
                    ((some binding-expr)
                      (let ((binding-name (sexpr-get-symbol-name binding-expr)))
                        (when (not (string-eq binding-name ""))
                          ;; Check if scrutinee is a generic type - if so, bind to generic
                          (let ((scrutinee-name (. (deref scrutinee-type) name))
                                (scrutinee-kind (. (deref scrutinee-type) kind)))
                            (if (string-eq scrutinee-name "T")
                              ;; Generic scrutinee - bind to generic type
                              (env-bind-var env binding-name (env-get-generic-type env))
                              ;; Special case for Option types: "some" variant gets inner-type
                              (if (and (== scrutinee-kind 'rk-option)
                                       (string-eq variant-name "some"))
                                ;; For Option types, payload is the inner-type
                                (match (. (deref scrutinee-type) inner-type)
                                  ((some inner) (env-bind-var env binding-name inner))
                                  ;; Generic Option_T - bind to generic T type that matches anything
                                  ((none) (env-bind-var env binding-name (env-get-generic-type env))))
                                ;; Special case for Result types: "ok" and "error" variants
                                (if (== scrutinee-kind 'rk-result)
                                  (cond
                                    ;; "ok" variant gets inner-type (the success type)
                                    ((string-eq variant-name "ok")
                                      (match (. (deref scrutinee-type) inner-type)
                                        ((some inner) (env-bind-var env binding-name inner))
                                        ((none) (env-bind-var env binding-name (env-get-generic-type env)))))
                                    ;; "error" variant gets inner-type2 (the error type)
                                    ((string-eq variant-name "error")
                                      (match (. (deref scrutinee-type) inner-type2)
                                        ((some inner2) (env-bind-var env binding-name inner2))
                                        ((none) (env-bind-var env binding-name (env-get-generic-type env)))))
                                    ;; Other variant names - fallback to generic
                                    (else (env-bind-var env binding-name (env-get-generic-type env))))
                                  ;; Normal variant lookup for non-Option/non-Result types
                                  (match (resolved-type-get-variant-payload scrutinee-type variant-name)
                                    ((some payload-type)
                                      (env-bind-var env binding-name payload-type))
                                    ((none)
                                      ;; No payload - bind to generic type to avoid cascading errors
                                      (env-bind-var env binding-name (env-get-generic-type env)))))))))))
                    ((none) (do)))))))
          ((none) (do))))))

  (fn infer-match-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)) (lst SExprList))
    (@intent "Infer type of match expression, checking branch types")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) SExprList) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((items (. lst items))
          (len (list-len items))
          (line (sexpr-line expr))
          (col (sexpr-col expr))
          (mut has-result Bool false)
          (mut result-type (Ptr ResolvedType) (env-get-unit-type env))
          ;; Get scrutinee type for pattern binding
          (scrutinee-type (if (>= len 2)
                            (match (list-get items 1)
                              ((some scrutinee) (infer-expr env scrutinee))
                              ((none) (env-get-unit-type env)))
                            (env-get-unit-type env)))
          (mut i 2))  ;; Skip 'match' and scrutinee
      ;; Process each clause
      (while (< i len)
        (match (list-get items i)
          ((some clause)
            (match (deref clause)
              ((lst clause-lst)
                (let ((clause-items (. clause-lst items))
                      (clause-len (list-len clause-items)))
                  (when (> clause-len 1)
                    ;; Push scope for this clause's pattern bindings
                    (env-push-scope env)
                    ;; Bind pattern variables from first element
                    (match (list-get clause-items 0)
                      ((some pattern) (bind-match-pattern env scrutinee-type pattern))
                      ((none) (do)))
                    ;; Infer ALL body expressions (index 1 to clause-len-1)
                    ;; Visit non-last body exprs for annotation coverage
                    (for (bi 1 (- clause-len 1))
                      (match (list-get clause-items bi)
                        ((some body-expr) (let ((_ (infer-expr env body-expr))) (do)))
                        ((none) (do))))
                    ;; Infer last body expression for the branch type
                    (match (list-get clause-items (- clause-len 1))
                      ((some body)
                        (let ((body-type (infer-expr env body)))
                          (if (not has-result)
                            (do
                              (set! result-type body-type)
                              (set! has-result true))
                            (set! result-type (unify-branch-types env result-type body-type line col)))))
                      ((none) (do)))
                    ;; Pop scope
                    (env-pop-scope env))))
              (_ (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      result-type))

  (fn check-return-type ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr))
                         (fn-name String) (inferred-type (Ptr ResolvedType))
                         (fn-line Int) (fn-col Int))
    (@intent "Check if inferred return type matches declared @spec return type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (@pre (!= inferred-type nil))
    (match (deref fn-form)
      ((lst fn-lst)
        (let ((items (. fn-lst items))
              (len (list-len items)))
          ;; Search through function body elements for @spec
          (for (i 3 len)
            (match (list-get items i)
              ((some item)
                (when (is-form item "@spec")
                  (check-spec-return-type env item fn-name inferred-type fn-line fn-col)))
              ((none) (do))))))
      (_ (do))))

  (fn check-spec-return-type ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr))
                              (fn-name String) (inferred-type (Ptr ResolvedType))
                              (fn-line Int) (fn-col Int))
    (@intent "Check return type from a @spec form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= spec-form nil))
    (match (deref spec-form)
      ((lst spec-lst)
        ;; (@spec ((Types) -> RetType))
        (let ((spec-items (. spec-lst items)))
          (match (list-get spec-items 1)
            ((some spec-body)
              (check-spec-body-return env spec-body fn-name inferred-type fn-line fn-col))
            ((none) (do)))))
      (_ (do))))

  (fn check-spec-body-return ((env (Ptr TypeEnv)) (spec-body (Ptr SExpr))
                              (fn-name String) (inferred-type (Ptr ResolvedType))
                              (fn-line Int) (fn-col Int))
    (@intent "Check return type from spec body ((Types) -> RetType)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= spec-body nil))
    (match (deref spec-body)
      ((lst body-lst)
        ;; ((Types) -> RetType) - last element is return type
        (let ((body-items (. body-lst items))
              (body-len (list-len body-items)))
          (match (list-get body-items (- body-len 1))
            ((some ret-expr)
              (check-return-expr env ret-expr fn-name inferred-type fn-line fn-col))
            ((none) (do)))))
      (_ (do))))

  (fn checker-is-primitive-type ((name String))
    (@intent "Check if type name is a known primitive")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (or (string-eq name "Bool")
            (or (string-eq name "String")
                (or (string-eq name "Unit")
                    (or (string-eq name "Arena")
                        (or (string-eq name "I8")
                            (or (string-eq name "I16")
                                (or (string-eq name "I32")
                                    (or (string-eq name "I64")
                                        (or (string-eq name "U8")
                                            (or (string-eq name "U16")
                                                (or (string-eq name "U32")
                                                    (or (string-eq name "U64")
                                                        (or (string-eq name "F32")
                                                            (string-eq name "F64"))))))))))))))))

  (fn is-integer-type ((name String))
    (@intent "Check if type name is an integer type (for FFI compatibility)")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (or (string-eq name "I8")
            (or (string-eq name "I16")
                (or (string-eq name "I32")
                    (or (string-eq name "I64")
                        (or (string-eq name "U8")
                            (or (string-eq name "U16")
                                (or (string-eq name "U32")
                                    (or (string-eq name "U64")
                                        (string-eq name "Size")))))))))))

  (fn check-return-expr ((env (Ptr TypeEnv)) (ret-expr (Ptr SExpr))
                         (fn-name String) (inferred-type (Ptr ResolvedType))
                         (fn-line Int) (fn-col Int))
    (@intent "Check if return type expression matches inferred type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) String (Ptr ResolvedType) Int Int) -> Unit))
    (@pre (!= env nil))
    (@pre (!= ret-expr nil))
    (match (deref ret-expr)
      ((sym ret-sym)
        (let ((declared-name (. ret-sym name))
              (inferred-name (. (deref inferred-type) name)))
          ;; Only check if types differ AND both are primitives
          ;; Custom types (enums, records) need proper variant tracking
          (when (and (not (string-eq declared-name inferred-name))
                     (and (checker-is-primitive-type declared-name)
                          (checker-is-primitive-type inferred-name)))
            (let ((arena (env-arena env))
                  (msg (string-concat arena "return value of '"
                         (string-concat arena fn-name
                           (string-concat arena "': expected "
                             (string-concat arena declared-name
                               (string-concat arena ", got " inferred-name)))))))
              (env-add-error env msg fn-line fn-col)))))
      (_ (do))))

  (fn bind-param-from-form ((env (Ptr TypeEnv)) (param-form (Ptr SExpr)))
    (@intent "Bind a function parameter from its form (param-name Type) or (mode param-name Type)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= param-form nil))
    ;; Use helper functions to avoid cross-module union matching issues
    ;; Handle both (name Type) and (mode name Type) forms
    (when (and (sexpr-is-list param-form) (>= (sexpr-list-len param-form) 2))
      (match (sexpr-list-get param-form 0)
        ((some first-expr)
          (let ((first-name (sexpr-get-symbol-name first-expr)))
            ;; Check if first element is a mode annotation (in, out, mut)
            (if (or (string-eq first-name "in")
                    (string-eq first-name "out")
                    (string-eq first-name "mut"))
              ;; Mode form: (mode name Type) - get name from position 1
              (when (>= (sexpr-list-len param-form) 3)
                (match (sexpr-list-get param-form 1)
                  ((some name-expr)
                    (let ((param-name (sexpr-get-symbol-name name-expr)))
                      (when (not (string-eq param-name ""))
                        (let ((param-type (get-param-type-from-form env param-form)))
                          (env-bind-var env param-name param-type)))))
                  ((none) (do))))
              ;; Regular form: (name Type) - first element is name
              (when (not (string-eq first-name ""))
                (let ((param-type (get-param-type-from-form env param-form)))
                  (env-bind-var env first-name param-type))))))
        ((none) (do)))))

  (fn get-param-type-from-form ((env (Ptr TypeEnv)) (param-form (Ptr SExpr)))
    (@intent "Get the type for a function parameter from its form expression")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= param-form nil))
    ;; param-form is (param-name Type) or (mode param-name Type)
    ;; Determine type position based on whether first element is a mode
    (let ((type-pos (match (sexpr-list-get param-form 0)
                      ((some first-expr)
                        (let ((first-name (sexpr-get-symbol-name first-expr)))
                          (if (or (string-eq first-name "in")
                                  (string-eq first-name "out")
                                  (string-eq first-name "mut"))
                            2  ;; Mode form: type at position 2
                            1))) ;; Regular form: type at position 1
                      ((none) 1))))
      (match (sexpr-list-get param-form type-pos)
        ((some type-expr)
          (let ((type-name (sexpr-get-symbol-name type-expr)))
            (if (string-eq type-name "")
              ;; Complex type expression like (Option Int), (Ptr T), (List T)
              (if (sexpr-is-list type-expr)
                (resolve-complex-type-expr env type-expr)
                (env-get-unknown-type env))
              ;; Simple symbol type - use resolve-simple-type for consistent handling
              (resolve-simple-type env type-name))))
        ((none) (env-get-unknown-type env)))))

  (fn resolve-complex-type-expr ((env (Ptr TypeEnv)) (type-expr (Ptr SExpr)))
    (@intent "Resolve a complex type expression like (Option Int)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= type-expr nil))
    (match (sexpr-list-get type-expr 0)
      ((some head-expr)
        (let ((head-name (sexpr-get-symbol-name head-expr)))
          (cond
            ;; Option type: (Option InnerType)
            ((string-eq head-name "Option")
              (let ((inner-type (resolve-option-inner-type env type-expr)))
                (env-make-option-type env inner-type)))
            ;; Ptr type: (Ptr InnerType)
            ((string-eq head-name "Ptr")
              (let ((inner-type (resolve-ptr-inner-type env type-expr)))
                (env-make-ptr-type env inner-type)))
            ;; List type: (List ElemType)
            ((string-eq head-name "List")
              (let ((arena (env-arena env))
                    (inner-type (resolve-ptr-inner-type env type-expr))
                    (list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                (resolved-type-set-inner list-type inner-type)
                list-type))
            ;; Map type: (Map KeyType ValueType)
            ((string-eq head-name "Map")
              (let ((arena (env-arena env))
                    (key-type (resolve-ptr-inner-type env type-expr))
                    (map-type (resolved-type-new arena 'rk-map "Map" (none) "slop_map*")))
                (resolved-type-set-inner map-type key-type)
                ;; Try to get value type from position 2
                (when (>= (sexpr-list-len type-expr) 3)
                  (match (sexpr-list-get type-expr 2)
                    ((some val-expr)
                      (let ((val-type (resolve-simple-type env (sexpr-get-symbol-name val-expr))))
                        (when (!= val-type nil)
                          (resolved-type-set-inner2 map-type val-type))))
                    ((none) (do))))
                map-type))
            ;; Set type: (Set ElemType)
            ((string-eq head-name "Set")
              (let ((arena (env-arena env))
                    (inner-type (resolve-ptr-inner-type env type-expr))
                    (set-type (resolved-type-new arena 'rk-primitive "Set" (none) "slop_map*")))
                (resolved-type-set-inner set-type inner-type)
                set-type))
            ;; Thread type: (Thread T) - built-in parameterized type
            ((string-eq head-name "Thread")
              (let ((inner-type (resolve-ptr-inner-type env type-expr))
                    (arena (env-arena env))
                    (t (resolved-type-new arena 'rk-thread "Thread" (none) "slop_thread_int*")))
                (resolved-type-set-inner t inner-type)
                t))
            ;; Chan type: (Chan T) - built-in parameterized type
            ((string-eq head-name "Chan")
              (let ((inner-type (resolve-ptr-inner-type env type-expr))
                    (arena (env-arena env))
                    (t (resolved-type-new arena 'rk-chan "Chan" (none) "slop_chan_int*")))
                (resolved-type-set-inner t inner-type)
                t))
            ;; Result type: (Result OkType ErrType)
            ((string-eq head-name "Result")
              (let ((arena (env-arena env))
                    (result-type (resolved-type-new arena 'rk-result "Result" (none) "Result")))
                ;; Set ok type from position 1
                (when (>= (sexpr-list-len type-expr) 2)
                  (match (sexpr-list-get type-expr 1)
                    ((some ok-expr)
                      (let ((ok-name (sexpr-get-symbol-name ok-expr)))
                        (let ((ok-type (if (string-eq ok-name "")
                                         (if (sexpr-is-list ok-expr)
                                           (resolve-complex-type-expr env ok-expr)
                                           (env-get-unknown-type env))
                                         (resolve-type-lenient env ok-name))))
                          (resolved-type-set-inner result-type ok-type))))
                    ((none) (do))))
                ;; Set error type from position 2
                (when (>= (sexpr-list-len type-expr) 3)
                  (match (sexpr-list-get type-expr 2)
                    ((some err-expr)
                      (let ((err-name (sexpr-get-symbol-name err-expr)))
                        (let ((err-type (if (string-eq err-name "")
                                          (if (sexpr-is-list err-expr)
                                            (resolve-complex-type-expr env err-expr)
                                            (env-get-unknown-type env))
                                          (resolve-type-lenient env err-name))))
                          (resolved-type-set-inner2 result-type err-type))))
                    ((none) (do))))
                result-type))
            ;; User-defined generic types - look up the base type
            (else
              (match (env-lookup-type env head-name)
                ((some t) t)
                ((none) (env-get-unknown-type env)))))))
      ((none) (env-get-unknown-type env))))

  (fn resolve-option-inner-type ((env (Ptr TypeEnv)) (type-expr (Ptr SExpr)))
    (@intent "Resolve the inner type of an Option type expression")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (if (< (sexpr-list-len type-expr) 2)
      (env-get-unknown-type env)
      (match (sexpr-list-get type-expr 1)
        ((some inner-expr)
          (let ((inner-name (sexpr-get-symbol-name inner-expr)))
            (if (string-eq inner-name "")
              (env-get-unknown-type env)
              (resolve-simple-type env inner-name))))
        ((none) (env-get-unknown-type env)))))

  (fn resolve-ptr-inner-type ((env (Ptr TypeEnv)) (type-expr (Ptr SExpr)))
    (@intent "Resolve the inner type of a Ptr or List type expression")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (if (< (sexpr-list-len type-expr) 2)
      (env-get-unit-type env)  ;; (Ptr) with no inner type
      (match (sexpr-list-get type-expr 1)
        ((some inner-expr)
          (let ((inner-name (sexpr-get-symbol-name inner-expr)))
            (if (string-eq inner-name "")
              ;; Inner type is complex, e.g. (Ptr (Ptr Int)) - recursively resolve
              (if (sexpr-is-list inner-expr)
                (resolve-complex-type-expr env inner-expr)
                (env-get-unknown-type env))
              (resolve-simple-type env inner-name))))
        ((none) (env-get-unit-type env)))))

  (fn resolve-type-lenient ((env (Ptr TypeEnv)) (type-name String))
    (@intent "Resolve a type by name without erroring on unknowns")
    (@spec (((Ptr TypeEnv) String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (env-lookup-type env type-name)
      ((some t) t)
      ((none)
        (let ((arena (env-arena env)))
          (cond
            ((string-eq type-name "Int") (env-get-int-type env))
            ((string-eq type-name "Bool") (env-get-bool-type env))
            ((string-eq type-name "String") (env-get-string-type env))
            ((string-eq type-name "Unit") (env-get-unit-type env))
            ((string-eq type-name "Arena") (env-get-arena-type env))
            ;; Unknown type - create a named primitive without error
            (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))

  (fn resolve-simple-type ((env (Ptr TypeEnv)) (type-name String))
    (@intent "Resolve a simple type by name")
    (@spec (((Ptr TypeEnv) String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (env-lookup-type env type-name)
      ((some t) t)
      ((none)
        (let ((arena (env-arena env)))
          (cond
            ;; Primitive types
            ((string-eq type-name "Int") (env-get-int-type env))
            ((string-eq type-name "Bool") (env-get-bool-type env))
            ((string-eq type-name "String") (env-get-string-type env))
            ((string-eq type-name "Unit") (env-get-unit-type env))
            ((string-eq type-name "Arena") (env-get-arena-type env))
            ;; Sized integer types - create named placeholder to match collect.slop
            ((string-eq type-name "Float") (resolved-type-new arena 'rk-primitive "Float" (none) "double"))
            ((string-eq type-name "I8") (resolved-type-new arena 'rk-primitive "I8" (none) "int8_t"))
            ((string-eq type-name "I16") (resolved-type-new arena 'rk-primitive "I16" (none) "int16_t"))
            ((string-eq type-name "I32") (resolved-type-new arena 'rk-primitive "I32" (none) "int32_t"))
            ((string-eq type-name "I64") (resolved-type-new arena 'rk-primitive "I64" (none) "int64_t"))
            ((string-eq type-name "U8") (resolved-type-new arena 'rk-primitive "U8" (none) "uint8_t"))
            ((string-eq type-name "U16") (resolved-type-new arena 'rk-primitive "U16" (none) "uint16_t"))
            ((string-eq type-name "U32") (resolved-type-new arena 'rk-primitive "U32" (none) "uint32_t"))
            ((string-eq type-name "U64") (resolved-type-new arena 'rk-primitive "U64" (none) "uint64_t"))
            ;; Char - for FFI C string interop
            ((string-eq type-name "Char") (resolved-type-new arena 'rk-primitive "Char" (none) "char"))
            ;; Void - for FFI opaque pointers (void*)
            ((string-eq type-name "Void") (resolved-type-new arena 'rk-primitive "Void" (none) "void"))
            ;; Bytes - for binary data buffers
            ((string-eq type-name "Bytes") (resolved-type-new arena 'rk-primitive "Bytes" (none) "slop_bytes"))
            ;; Check if it's a type parameter (e.g., T from @generic)
            ((env-is-type-param env type-name)
              (resolved-type-new arena 'rk-typevar type-name (none) "int64_t"))
            ;; Unknown type - emit error (may be missing import)
            (else
              (let ((msg (string-concat arena "Unknown type: " type-name)))
                (env-add-error env msg 0 0)
                (env-get-generic-type env))))))))

  ;; ============================================================
  ;; Let Binding Support
  ;; ============================================================

  (fn bind-let-binding ((env (Ptr TypeEnv)) (binding-form (Ptr SExpr)))
    (@intent "Bind a let variable from its form (name expr)")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= binding-form nil))
    ;; binding-form is (name expr) or (mut name expr) or (mut name Type expr)
    (when (and (sexpr-is-list binding-form) (>= (sexpr-list-len binding-form) 2))
      (match (sexpr-list-get binding-form 0)
        ((some first-expr)
          (let ((first-name (sexpr-get-symbol-name first-expr)))
            (if (string-eq first-name "mut")
              ;; Mutable: (mut name expr) or (mut name Type expr)
              (when (>= (sexpr-list-len binding-form) 3)
                (match (sexpr-list-get binding-form 1)
                  ((some name-expr)
                    (let ((var-name (sexpr-get-symbol-name name-expr)))
                      (when (not (string-eq var-name ""))
                        ;; Get the value expression (last element)
                        (let ((binding-len (sexpr-list-len binding-form)))
                          (match (sexpr-list-get binding-form (- binding-len 1))
                            ((some val-expr)
                              (let ((val-type (infer-expr env val-expr))
                                    (val-type-name (. (deref val-type) name)))
                                ;; Check for generic Option without explicit type annotation
                                ;; (mut name expr) has length 3, (mut name Type expr) has length 4
                                (if (and (== binding-len 3)
                                         (string-eq val-type-name "Option_T"))
                                  ;; Error: mut with generic Option needs explicit type
                                  (let ((arena (env-arena env))
                                        (line (sexpr-line binding-form))
                                        (col (sexpr-col binding-form))
                                        (parts (list-new arena String)))
                                    (list-push parts "mutable variable '")
                                    (list-push parts var-name)
                                    (list-push parts "' has ambiguous Option type - add explicit type: (mut ")
                                    (list-push parts var-name)
                                    (list-push parts " (Option T) ...)")
                                    (env-add-error env (string-build arena parts) line col)
                                    (env-bind-var env var-name val-type))
                                  ;; Concrete type - just bind it
                                  (env-bind-var env var-name val-type))))
                            ((none) (do)))))))
                  ((none) (do))))
              ;; Immutable: (name expr) or (name Type expr)
              (when (not (string-eq first-name ""))
                (let ((binding-len (sexpr-list-len binding-form)))
                  (if (== binding-len 3)
                    ;; Typed binding: (name Type expr) - get expr at position 2
                    (match (sexpr-list-get binding-form 2)
                      ((some val-expr)
                        (let ((val-type (infer-expr env val-expr)))
                          (env-bind-var env first-name val-type)))
                      ((none) (do)))
                    ;; Untyped binding: (name expr) - get expr at position 1
                    (match (sexpr-list-get binding-form 1)
                      ((some val-expr)
                        (let ((val-type (infer-expr env val-expr)))
                          (env-bind-var env first-name val-type)))
                      ((none) (do)))))))))
        ((none) (do)))))

  (fn infer-let-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer type of a let expression with proper variable binding")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    (env-push-scope env)
    ;; Get bindings list at position 1
    (when (sexpr-is-list expr)
      (match (sexpr-list-get expr 1)
        ((some bindings-expr)
          (when (sexpr-is-list bindings-expr)
            (let ((num-bindings (sexpr-list-len bindings-expr)))
              (for (i 0 num-bindings)
                (match (sexpr-list-get bindings-expr i)
                  ((some binding) (bind-let-binding env binding))
                  ((none) (do)))))))
        ((none) (do))))
    ;; Infer type of ALL body expressions, returning type of last
    (let ((result-type
            (if (sexpr-is-list expr)
              (let ((len (sexpr-list-len expr))
                    (mut last-type (Ptr ResolvedType) (env-get-unit-type env)))
                (for (i 2 len)
                  (match (sexpr-list-get expr i)
                    ((some body-expr) (set! last-type (infer-expr env body-expr)))
                    ((none) (do))))
                last-type)
              (env-get-unit-type env))))
      (env-pop-scope env)
      result-type))

  (fn infer-with-arena-expr ((env (Ptr TypeEnv)) (expr (Ptr SExpr)))
    (@intent "Infer type of with-arena expression, binding arena variable")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= expr nil))
    ;; (with-arena size body...) - unnamed, binds 'arena', size at 1, body at 2+
    ;; (with-arena :as name size body...) - named, binds 'name', size at 3, body at 4+
    (let ((len (sexpr-list-len expr)))
      (if (< len 2)
        (do
          (env-add-error env "with-arena requires size argument" (sexpr-line expr) (sexpr-col expr))
          (env-get-unit-type env))
        ;; Detect :as form - check if items[1] is symbol ":as"
        (let ((is-named (match (sexpr-list-get expr 1)
                          ((some item1)
                            (string-eq (sexpr-get-symbol-name item1) ":as"))
                          ((none) false)))
              (arena-name (if is-named
                            (match (sexpr-list-get expr 2)
                              ((some name-expr) (sexpr-get-symbol-name name-expr))
                              ((none) "arena"))
                            "arena"))
              (size-idx (if is-named 3 1))
              (body-start (if is-named 4 2)))
          ;; Validate minimum length for named form
          (if (and is-named (< len 4))
            (do
              (env-add-error env "with-arena :as requires name and size" (sexpr-line expr) (sexpr-col expr))
              (env-get-unit-type env))
            (do
              ;; Check for negative literal at size-idx
              (match (sexpr-list-get expr size-idx)
                ((some size-expr)
                  (match (deref size-expr)
                    ((num num)
                      (if (<= (. num int-value) 0)
                        (env-add-error env "with-arena size must be positive" (. num line) (. num col))
                        (do)))
                    (else (do))))
                ((none) (do)))
              ;; Proceed with normal type inference
              (env-push-scope env)
              (env-bind-var env arena-name (env-get-arena-type env))
              (let ((mut result-type (Ptr ResolvedType) (env-get-unit-type env)))
                (for (i body-start len)
                  (match (sexpr-list-get expr i)
                    ((some body-expr)
                      (set! result-type (infer-expr env body-expr)))
                    ((none) (do))))
                (env-pop-scope env)
                result-type)))))))

  (fn get-fn-name ((fn-form (Ptr SExpr)))
    (@intent "Extract function name from fn form")
    (@spec (((Ptr SExpr)) -> String))
    (@pre (!= fn-form nil))
    ;; Use sexpr-list-get and sexpr-get-symbol-name to avoid generic type issues
    (if (not (sexpr-is-list fn-form))
      "unknown"
      (if (< (sexpr-list-len fn-form) 2)
        "unknown"
        (match (sexpr-list-get fn-form 1)
          ((some name-expr)
            (let ((name (sexpr-get-symbol-name name-expr)))
              (if (string-eq name "")
                "unknown"
                name)))
          ((none) "unknown")))))

  (fn resolve-hole-type ((env (Ptr TypeEnv)) (items (List (Ptr SExpr))) (len Int))
    (@intent "Resolve the type from a hole form")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr)) Int) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    ;; (hole Type "prompt" ...) - type is at position 1
    (if (< len 2)
      (env-get-unit-type env)
      (match (list-get items 1)
        ((some type-expr)
          (let ((type-name (sexpr-get-symbol-name type-expr)))
            (if (string-eq type-name "")
              (env-get-unit-type env)
              ;; Look up the type
              (match (env-lookup-type env type-name)
                ((some t) t)
                ((none)
                  (cond
                    ((string-eq type-name "Int") (env-get-int-type env))
                    ((string-eq type-name "Bool") (env-get-bool-type env))
                    ((string-eq type-name "String") (env-get-string-type env))
                    ((string-eq type-name "Unit") (env-get-unit-type env))
                    (else (env-get-unit-type env))))))))
        ((none) (env-get-unit-type env)))))

  (fn get-hole-prompt ((items (List (Ptr SExpr))) (len Int))
    (@intent "Extract the prompt string from a hole form")
    (@spec (((List (Ptr SExpr)) Int) -> String))
    ;; (hole Type "prompt" ...) - prompt is at position 2
    (if (< len 3)
      "(no description)"
      (match (list-get items 2)
        ((some prompt-expr)
          (match (deref prompt-expr)
            ((str str) (. str value))
            (_ "(no description)")))
        ((none) "(no description)"))))

  (fn find-last-body-idx ((items (List (Ptr SExpr))))
    (@intent "Find index of last body expression, skipping :c-name and its value")
    (@spec (((List (Ptr SExpr))) -> Int))
    (let ((len (list-len items))
          (mut i (- len 1)))
      ;; Walk backwards to find last non-:c-name-related item
      ;; Skip strings that follow :c-name
      (while (and (>= i 3) (is-c-name-related items i))
        (set! i (- i 1)))
      i))

  (fn is-c-name-related ((items (List (Ptr SExpr))) (idx Int))
    (@intent "Check if item at index is :c-name or its string value")
    (@spec (((List (Ptr SExpr)) Int) -> Bool))
    (match (list-get items idx)
      ((some item)
        (match (deref item)
          ;; :c-name keyword
          ((sym sym) (string-eq (. sym name) ":c-name"))
          ;; String after :c-name (check previous item)
          ((str _)
            (if (> idx 0)
              (match (list-get items (- idx 1))
                ((some prev)
                  (match (deref prev)
                    ((sym sym) (string-eq (. sym name) ":c-name"))
                    (else false)))
                ((none) false))
              false))
          (else false)))
      ((none) false)))

  (fn is-annotation-expr ((expr (Ptr SExpr)))
    (@intent "Check if expression is an annotation form (starts with @ symbol)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pre (!= expr nil))
    (if (sexpr-is-list expr)
      (match (sexpr-list-get expr 0)
        ((some head)
          (match (deref head)
            ((sym sym) (starts-with (. sym name) "@"))
            (_ false)))
        ((none) false))
      false))

  (fn infer-fn-body ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)))
    (@intent "Type check a function body, binding parameters and inferring body type")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (@pre (is-form fn-form "fn"))
    (let ((fn-name (get-fn-name fn-form))
          (fn-line (sexpr-line fn-form))
          (fn-col (sexpr-col fn-form))
          ;; Extract @generic type params and store in env for type checking
          (type-params (find-fn-type-params (env-arena env) fn-form)))
      (env-set-fn-type-params env type-params)
      (env-push-scope env)
      ;; Extract and bind parameters using helper functions to avoid cross-module issues
      ;; fn-form is (fn name ((param Type) ...) ...)
      (when (sexpr-is-list fn-form)
        (let ((params-len (sexpr-list-len fn-form)))
          (when (> params-len 2)
            (match (sexpr-list-get fn-form 2)
              ((some params-expr)
                ;; params-expr is ((param Type) ...)
                (when (sexpr-is-list params-expr)
                  (let ((num-params (sexpr-list-len params-expr)))
                    (for (k 0 num-params)
                      (match (sexpr-list-get params-expr k)
                        ((some param-form)
                          (bind-param-from-form env param-form))
                        ((none) (do)))))))
              ((none) (do))))))
      ;; Infer body type - visit ALL body expressions, not just the last
      ;; Body starts at index 3 (after fn, name, params)
      (let ((result-type (match (deref fn-form)
                           ((lst fn-lst)
                             (let ((items (. fn-lst items))
                                   (item-len (list-len items))
                                   (last-body-idx (find-last-body-idx items))
                                   (mut body-type (env-get-unit-type env)))
                               ;; Visit all body expressions from index 3, skipping annotations
                               (for (bi 3 (+ last-body-idx 1))
                                 (match (list-get items bi)
                                   ((some body-expr)
                                     (when (and (not (is-annotation-expr body-expr))
                                                (not (is-c-name-related items bi)))
                                       (set! body-type (infer-expr env body-expr))))
                                   ((none) (do))))
                               body-type))
                           (_ (env-get-unit-type env)))))
        ;; Check return type matches declared spec
        (check-return-type env fn-form fn-name result-type fn-line fn-col)
        ;; Clear type params and pop scope
        (env-clear-fn-type-params env)
        (env-pop-scope env)
        result-type)))

  ;; ============================================================
  ;; Match Pattern Analysis
  ;; ============================================================

  (fn check-match-patterns ((env (Ptr TypeEnv)) (scrutinee-type (Ptr ResolvedType))
                            (patterns (List (Ptr SExpr))))
    (@intent "Check match patterns are valid for scrutinee type and return binding types")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (@pre (!= scrutinee-type nil))
    (when (resolved-type-is-union scrutinee-type)
      (let ((num-patterns (list-len patterns)))
        (for (i 0 num-patterns)
          (match (list-get patterns i)
            ((some pattern-case)
              ;; Pattern case is ((variant-name binding-var) body)
              (match (deref pattern-case)
                ((lst pattern-list)
                  (when (> (list-len (. pattern-list items)) 0)
                    (match (list-get (. pattern-list items) 0)
                      ((some pattern-expr)
                        ;; Pattern expr is (variant-name binding-var)
                        (match (deref pattern-expr)
                          ((lst variant-list)
                            (let ((variant-items (. variant-list items)))
                              ;; Get variant name (first element)
                              (when (> (list-len variant-items) 0)
                                (match (list-get variant-items 0)
                                  ((some variant-name-expr)
                                    (match (deref variant-name-expr)
                                      ((sym variant-sym)
                                        (let ((variant-name (. variant-sym name)))
                                          ;; Verify variant exists and get payload type
                                          (match (resolved-type-get-variant-payload scrutinee-type variant-name)
                                            ((some payload-type)
                                              ;; Variant has payload - bind variable to payload type
                                              (when (> (list-len variant-items) 1)
                                                (match (list-get variant-items 1)
                                                  ((some binding-expr)
                                                    (match (deref binding-expr)
                                                      ((sym binding-sym)
                                                        (env-bind-var env (. binding-sym name) payload-type))
                                                      (_ (do))))
                                                  ((none) (do)))))
                                            ((none)
                                              ;; Variant has no payload or doesn't exist - just verify it exists
                                              (match (resolved-type-get-variant-index scrutinee-type variant-name)
                                                ((some _) (do))
                                                ((none) (do)))))))
                                      (_ (do))))
                                  ((none) (do))))))
                          (_ (do))))
                      ((none) (do)))))
                (_ (do))))
            ((none) (do))))))))

