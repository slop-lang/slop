{"env":{"header":"#ifndef SLOP_env_H\n#define SLOP_env_H\n\n#include \"slop_runtime.h\"\n#include <stdint.h>\n#include <stdbool.h>\n#include \"slop_types.h\"\n\ntypedef struct env_VarBinding env_VarBinding;\ntypedef struct env_ConstBinding env_ConstBinding;\ntypedef struct env_ImportEntry env_ImportEntry;\ntypedef struct env_CheckerScope env_CheckerScope;\ntypedef struct env_VariantMapping env_VariantMapping;\ntypedef struct env_BindingAnnotation env_BindingAnnotation;\ntypedef struct env_TypeEnv env_TypeEnv;\n\n#ifndef SLOP_LIST_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_LIST_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_LIST_DEFINE(types_ResolvedType*, slop_list_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_LIST_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_LIST_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_LIST_DEFINE(types_FnSignature*, slop_list_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_LIST_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_LIST_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_LIST_DEFINE(env_CheckerScope*, slop_list_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature*, slop_option_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope*, slop_option_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_LIST_TYPES_PARAMINFO_DEFINED\n#define SLOP_LIST_TYPES_PARAMINFO_DEFINED\nSLOP_LIST_DEFINE(types_ParamInfo, slop_list_types_ParamInfo)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_LIST_TYPES_PARAMINFO_DEFINED\n#define SLOP_LIST_TYPES_PARAMINFO_DEFINED\nSLOP_LIST_DEFINE(types_ParamInfo, slop_list_types_ParamInfo)\n#endif\n\nstruct env_VarBinding {\n    slop_string name;\n    types_ResolvedType* var_type;\n};\ntypedef struct env_VarBinding env_VarBinding;\n\n#ifndef SLOP_OPTION_ENV_VARBINDING_DEFINED\n#define SLOP_OPTION_ENV_VARBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_VarBinding, slop_option_env_VarBinding)\n#endif\n\n#ifndef SLOP_LIST_ENV_VARBINDING_DEFINED\n#define SLOP_LIST_ENV_VARBINDING_DEFINED\nSLOP_LIST_DEFINE(env_VarBinding, slop_list_env_VarBinding)\n#endif\n\nstruct env_ConstBinding {\n    slop_string name;\n    types_ResolvedType* const_type;\n    slop_option_string module_name;\n};\ntypedef struct env_ConstBinding env_ConstBinding;\n\n#ifndef SLOP_OPTION_ENV_CONSTBINDING_DEFINED\n#define SLOP_OPTION_ENV_CONSTBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_ConstBinding, slop_option_env_ConstBinding)\n#endif\n\n#ifndef SLOP_LIST_ENV_CONSTBINDING_DEFINED\n#define SLOP_LIST_ENV_CONSTBINDING_DEFINED\nSLOP_LIST_DEFINE(env_ConstBinding, slop_list_env_ConstBinding)\n#endif\n\nstruct env_ImportEntry {\n    slop_string local;\n    slop_string qualified;\n};\ntypedef struct env_ImportEntry env_ImportEntry;\n\n#ifndef SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\n#define SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\nSLOP_OPTION_DEFINE(env_ImportEntry, slop_option_env_ImportEntry)\n#endif\n\n#ifndef SLOP_LIST_ENV_IMPORTENTRY_DEFINED\n#define SLOP_LIST_ENV_IMPORTENTRY_DEFINED\nSLOP_LIST_DEFINE(env_ImportEntry, slop_list_env_ImportEntry)\n#endif\n\nstruct env_CheckerScope {\n    slop_list_env_VarBinding bindings;\n};\ntypedef struct env_CheckerScope env_CheckerScope;\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope, slop_option_env_CheckerScope)\n#endif\n\nstruct env_VariantMapping {\n    slop_string variant_name;\n    slop_string enum_name;\n    slop_option_string module_name;\n};\ntypedef struct env_VariantMapping env_VariantMapping;\n\n#ifndef SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\nSLOP_OPTION_DEFINE(env_VariantMapping, slop_option_env_VariantMapping)\n#endif\n\n#ifndef SLOP_LIST_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_LIST_ENV_VARIANTMAPPING_DEFINED\nSLOP_LIST_DEFINE(env_VariantMapping, slop_list_env_VariantMapping)\n#endif\n\nstruct env_BindingAnnotation {\n    slop_string name;\n    int64_t line;\n    int64_t col;\n    slop_string slop_type;\n};\ntypedef struct env_BindingAnnotation env_BindingAnnotation;\n\n#ifndef SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\nSLOP_OPTION_DEFINE(env_BindingAnnotation, slop_option_env_BindingAnnotation)\n#endif\n\n#ifndef SLOP_LIST_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_LIST_ENV_BINDINGANNOTATION_DEFINED\nSLOP_LIST_DEFINE(env_BindingAnnotation, slop_list_env_BindingAnnotation)\n#endif\n\nstruct env_TypeEnv {\n    slop_arena* arena;\n    slop_list_types_ResolvedType_ptr types;\n    slop_list_types_FnSignature_ptr functions;\n    slop_list_env_ConstBinding constants;\n    slop_list_env_ImportEntry imports;\n    slop_list_env_VariantMapping enum_variants;\n    slop_list_env_CheckerScope_ptr scopes;\n    slop_option_string current_module;\n    types_ResolvedType* int_type;\n    types_ResolvedType* bool_type;\n    types_ResolvedType* string_type;\n    types_ResolvedType* unit_type;\n    types_ResolvedType* arena_type;\n    types_ResolvedType* unknown_type;\n    slop_list_types_Diagnostic diagnostics;\n    slop_list_env_BindingAnnotation binding_annotations;\n    slop_option_string current_file;\n    slop_list_string loaded_modules;\n    slop_list_string fn_type_params;\n};\ntypedef struct env_TypeEnv env_TypeEnv;\n\n#ifndef SLOP_OPTION_ENV_TYPEENV_DEFINED\n#define SLOP_OPTION_ENV_TYPEENV_DEFINED\nSLOP_OPTION_DEFINE(env_TypeEnv, slop_option_env_TypeEnv)\n#endif\n\nenv_TypeEnv* env_env_new(slop_arena* arena);\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type);\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t);\nslop_arena* env_env_arena(env_TypeEnv* env);\nvoid env_env_push_scope(env_TypeEnv* env);\nvoid env_env_pop_scope(env_TypeEnv* env);\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type);\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name);\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type);\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name);\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding);\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name);\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name);\nint64_t env_find_colon_pos(slop_string name);\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name);\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t);\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig);\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name);\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name);\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name);\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name);\nvoid env_env_clear_imports(env_TypeEnv* env);\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name);\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name);\nuint8_t env_env_variant_is_builtin(env_VariantMapping v);\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name);\nvoid env_env_check_variant_collisions(env_TypeEnv* env);\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b);\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name);\nslop_option_string env_env_get_module(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env);\nvoid env_env_clear_diagnostics(env_TypeEnv* env);\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type);\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env);\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path);\nslop_option_string env_env_get_current_file(env_TypeEnv* env);\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path);\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path);\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params);\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env);\nvoid env_env_clear_fn_type_params(env_TypeEnv* env);\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name);\n\n#ifndef SLOP_OPTION_ENV_VARBINDING_DEFINED\n#define SLOP_OPTION_ENV_VARBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_VarBinding, slop_option_env_VarBinding)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CONSTBINDING_DEFINED\n#define SLOP_OPTION_ENV_CONSTBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_ConstBinding, slop_option_env_ConstBinding)\n#endif\n\n#ifndef SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\n#define SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\nSLOP_OPTION_DEFINE(env_ImportEntry, slop_option_env_ImportEntry)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope, slop_option_env_CheckerScope)\n#endif\n\n#ifndef SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\nSLOP_OPTION_DEFINE(env_VariantMapping, slop_option_env_VariantMapping)\n#endif\n\n#ifndef SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\nSLOP_OPTION_DEFINE(env_BindingAnnotation, slop_option_env_BindingAnnotation)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature*, slop_option_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope*, slop_option_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n#ifndef SLOP_OPTION_ENV_TYPEENV_DEFINED\n#define SLOP_OPTION_ENV_TYPEENV_DEFINED\nSLOP_OPTION_DEFINE(env_TypeEnv, slop_option_env_TypeEnv)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n\n#endif\n","impl":"env_TypeEnv* env_env_new(slop_arena* arena);\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type);\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t);\nslop_arena* env_env_arena(env_TypeEnv* env);\nvoid env_env_push_scope(env_TypeEnv* env);\nvoid env_env_pop_scope(env_TypeEnv* env);\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type);\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name);\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type);\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name);\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding);\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name);\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name);\nint64_t env_find_colon_pos(slop_string name);\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name);\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t);\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig);\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name);\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name);\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name);\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name);\nvoid env_env_clear_imports(env_TypeEnv* env);\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name);\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name);\nuint8_t env_env_variant_is_builtin(env_VariantMapping v);\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name);\nvoid env_env_check_variant_collisions(env_TypeEnv* env);\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b);\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name);\nslop_option_string env_env_get_module(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env);\nvoid env_env_clear_diagnostics(env_TypeEnv* env);\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type);\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env);\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path);\nslop_option_string env_env_get_current_file(env_TypeEnv* env);\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path);\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path);\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params);\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env);\nvoid env_env_clear_fn_type_params(env_TypeEnv* env);\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name);\n\nenv_TypeEnv* env_env_new(slop_arena* arena) {\n    {\n        __auto_type int_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"Int\"), none, SLOP_STR(\"int64_t\"));\n        __auto_type bool_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"Bool\"), none, SLOP_STR(\"bool\"));\n        __auto_type string_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"String\"), none, SLOP_STR(\"slop_string_t\"));\n        __auto_type unit_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"Unit\"), none, SLOP_STR(\"void\"));\n        __auto_type arena_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"Arena\"), none, SLOP_STR(\"slop_arena_t*\"));\n        __auto_type unknown_t = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"Unknown\"), none, SLOP_STR(\"void\"));\n        __auto_type env = ((env_TypeEnv*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 320); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*env) = (env_TypeEnv){arena, ((slop_list_types_ResolvedType_ptr){ .data = (types_ResolvedType**)slop_arena_alloc(arena, 16 * sizeof(types_ResolvedType*)), .len = 0, .cap = 16 }), ((slop_list_types_FnSignature_ptr){ .data = (types_FnSignature**)slop_arena_alloc(arena, 16 * sizeof(types_FnSignature*)), .len = 0, .cap = 16 }), ((slop_list_env_ConstBinding){ .data = (env_ConstBinding*)slop_arena_alloc(arena, 16 * sizeof(env_ConstBinding)), .len = 0, .cap = 16 }), ((slop_list_env_ImportEntry){ .data = (env_ImportEntry*)slop_arena_alloc(arena, 16 * sizeof(env_ImportEntry)), .len = 0, .cap = 16 }), ((slop_list_env_VariantMapping){ .data = (env_VariantMapping*)slop_arena_alloc(arena, 16 * sizeof(env_VariantMapping)), .len = 0, .cap = 16 }), ((slop_list_env_CheckerScope_ptr){ .data = (env_CheckerScope**)slop_arena_alloc(arena, 16 * sizeof(env_CheckerScope*)), .len = 0, .cap = 16 }), ((slop_option_string){.has_value = false}), int_t, bool_t, string_t, unit_t, arena_t, unknown_t, ((slop_list_types_Diagnostic){ .data = (types_Diagnostic*)slop_arena_alloc(arena, 16 * sizeof(types_Diagnostic)), .len = 0, .cap = 16 }), ((slop_list_env_BindingAnnotation){ .data = (env_BindingAnnotation*)slop_arena_alloc(arena, 16 * sizeof(env_BindingAnnotation)), .len = 0, .cap = 16 }), ((slop_option_string){.has_value = false}), ((slop_list_string){ .data = (slop_string*)slop_arena_alloc(arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 }), ((slop_list_string){ .data = (slop_string*)slop_arena_alloc(arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 })};\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (int_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (bool_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (string_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (unit_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (arena_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        {\n            __auto_type i8 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"I8\"), none, SLOP_STR(\"int8_t\"));\n            __auto_type i16 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"I16\"), none, SLOP_STR(\"int16_t\"));\n            __auto_type i32 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"I32\"), none, SLOP_STR(\"int32_t\"));\n            __auto_type i64 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"I64\"), none, SLOP_STR(\"int64_t\"));\n            __auto_type u8 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"U8\"), none, SLOP_STR(\"uint8_t\"));\n            __auto_type u16 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"U16\"), none, SLOP_STR(\"uint16_t\"));\n            __auto_type u32 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"U32\"), none, SLOP_STR(\"uint32_t\"));\n            __auto_type u64 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"U64\"), none, SLOP_STR(\"uint64_t\"));\n            __auto_type f32 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"F32\"), none, SLOP_STR(\"float\"));\n            __auto_type f64 = types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"F64\"), none, SLOP_STR(\"double\"));\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i8); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i16); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u8); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u16); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (f32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (f64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            env_register_builtin_functions(env, arena, int_t, bool_t, string_t, arena_t, u8);\n        }\n        return env;\n    }\n}\n\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type) {\n    {\n        __auto_type sig = types_fn_signature_new(arena, name, c_name, params, ret_type);\n        env_env_register_function(env, sig);\n    }\n}\n\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t) {\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"a\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"b\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-eq\"), SLOP_STR(\"string_eq\"), p, bool_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"a\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"b\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-concat\"), SLOP_STR(\"string_concat\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-len\"), SLOP_STR(\"string_len\"), p, int_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-copy\"), SLOP_STR(\"string_copy\"), p, string_t);\n    }\n    {\n        __auto_type ptr_u8_t = env_env_make_ptr_type(env, u8_t);\n        {\n            __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n            ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"cstr\"), ptr_u8_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-new\"), SLOP_STR(\"string_new\"), p, string_t);\n        }\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"start\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"end\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-slice\"), SLOP_STR(\"string_slice\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"n\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"int-to-string\"), SLOP_STR(\"int_to_string\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"idx\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"char-at\"), SLOP_STR(\"char_at\"), p, int_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"c\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-push-char\"), SLOP_STR(\"slop_string_push_char\"), p, string_t);\n    }\n}\n\nslop_arena* env_env_arena(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).arena;\n}\n\nvoid env_env_push_scope(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type scope_ptr = ((env_CheckerScope*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 64); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*scope_ptr) = (env_CheckerScope){((slop_list_env_VarBinding){ .data = (env_VarBinding*)slop_arena_alloc(arena, 16 * sizeof(env_VarBinding)), .len = 0, .cap = 16 })};\n        ({ __auto_type _lst_p = &((*env).scopes); __auto_type _item = (scope_ptr); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n    }\n}\n\nvoid env_env_pop_scope(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((((int64_t)(((*env).scopes).len)) > 0)), \"(> (list-len (. (deref env) scopes)) 0)\");\n    {\n        __auto_type _ = ({ __auto_type _lst_p = &((*env).scopes); slop_option_env_CheckerScope_ptr _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; });\n    }\n}\n\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((var_type != NULL)), \"(!= var-type nil)\");\n    SLOP_PRE(((((int64_t)(((*env).scopes).len)) > 0)), \"(> (list-len (. (deref env) scopes)) 0)\");\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type scopes = (*env).scopes;\n        __auto_type top_idx = (((int64_t)((scopes).len)) - 1);\n        __auto_type _mv_0 = ({ __auto_type _lst = scopes; size_t _idx = (size_t)top_idx; slop_option_env_CheckerScope_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n        if (_mv_0.has_value) {\n            __auto_type scope_ptr = _mv_0.value;\n            ({ __auto_type _lst_p = &((*scope_ptr).bindings); __auto_type _item = ((env_VarBinding){name, var_type}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        } else if (!_mv_0.has_value) {\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name) {\n    SLOP_PRE(((scope_ptr != NULL)), \"(!= scope-ptr nil)\");\n    {\n        __auto_type bindings = (*scope_ptr).bindings;\n        __auto_type num_bindings = ((int64_t)((bindings).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t j = 0; j < num_bindings; j++) {\n            __auto_type _mv_1 = ({ __auto_type _lst = bindings; size_t _idx = (size_t)j; slop_option_env_VarBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_1.has_value) {\n                __auto_type binding = _mv_1.value;\n                if ((!(found) && string_eq(binding.name, name))) {\n                    found = 1;\n                    result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = binding.var_type};\n                }\n            } else if (!_mv_1.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type scopes = (*env).scopes;\n        __auto_type num_scopes = ((int64_t)((scopes).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < num_scopes; i++) {\n            if (!(found)) {\n                {\n                    __auto_type scope_idx = ((num_scopes) - (1) - (i));\n                    __auto_type _mv_2 = ({ __auto_type _lst = scopes; size_t _idx = (size_t)scope_idx; slop_option_env_CheckerScope_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_2.has_value) {\n                        __auto_type scope_ptr = _mv_2.value;\n                        __auto_type _mv_3 = env_scope_lookup_var(scope_ptr, name);\n                        if (_mv_3.has_value) {\n                            __auto_type var_type = _mv_3.value;\n                            found = 1;\n                            result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = var_type};\n                        } else if (!_mv_3.has_value) {\n                        }\n                    } else if (!_mv_2.has_value) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((const_type != NULL)), \"(!= const-type nil)\");\n    ({ __auto_type _lst_p = &((*env).constants); __auto_type _item = ((env_ConstBinding){name, const_type, env_env_get_module(env)}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name) {\n    __auto_type _mv_4 = binding.module_name;\n    if (_mv_4.has_value) {\n        __auto_type bmod = _mv_4.value;\n        return string_eq(bmod, mod_name);\n    } else if (!_mv_4.has_value) {\n        return 0;\n    }\n}\n\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding) {\n    __auto_type _mv_5 = binding.module_name;\n    if (!_mv_5.has_value) {\n        return 1;\n    } else if (_mv_5.has_value) {\n        __auto_type _ = _mv_5.value;\n        return 0;\n    }\n}\n\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type constants = (*env).constants;\n        __auto_type len = ((int64_t)((constants).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            if (!(found)) {\n                __auto_type _mv_6 = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                if (_mv_6.has_value) {\n                    __auto_type binding = _mv_6.value;\n                    if ((string_eq(binding.name, const_name) && env_env_constant_matches_module(binding, mod_name))) {\n                        found = 1;\n                    }\n                } else if (!_mv_6.has_value) {\n                }\n            }\n        }\n        return found;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type constants = (*env).constants;\n        __auto_type len = ((int64_t)((constants).len));\n        __auto_type current_mod = env_env_get_module(env);\n        __auto_type found = 0;\n        types_ResolvedType* found_type = NULL;\n        __auto_type _mv_7 = current_mod;\n        if (_mv_7.has_value) {\n            __auto_type mod = _mv_7.value;\n            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type binding = _mv.value; (((string_eq(binding.name, name) && env_env_constant_matches_module(binding, mod))) ? ({ ({ found = 1; (void)0; }); ({ found_type = binding.const_type; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n        } else if (!_mv_7.has_value) {\n        }\n        if (!(found)) {\n            __auto_type _mv_8 = env_env_resolve_import(env, name);\n            if (_mv_8.has_value) {\n                __auto_type qualified_name = _mv_8.value;\n                {\n                    __auto_type colon_pos = env_find_colon_pos(qualified_name);\n                    if ((colon_pos != -1)) {\n                        {\n                            __auto_type mod_part = (slop_string){.len = ((uint64_t)(colon_pos)), .data = qualified_name.data};\n                            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type binding = _mv.value; (((string_eq(binding.name, name) && env_env_constant_matches_module(binding, mod_part))) ? ({ ({ found = 1; (void)0; }); ({ found_type = binding.const_type; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n                        }\n                    }\n                }\n            } else if (!_mv_8.has_value) {\n            }\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_9 = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_9.has_value) {\n                        __auto_type binding = _mv_9.value;\n                        if ((string_eq(binding.name, name) && env_env_constant_is_builtin(binding))) {\n                            found = 1;\n                            found_type = binding.const_type;\n                        }\n                    } else if (!_mv_9.has_value) {\n                    }\n                }\n            }\n        }\n        if (found) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = found_type};\n        } else {\n            return (slop_option_types_ResolvedType_ptr){.has_value = false};\n        }\n    }\n}\n\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type types = (*env).types;\n        __auto_type len = ((int64_t)((types).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_10 = ({ __auto_type _lst = types; size_t _idx = (size_t)i; slop_option_ResolvedType_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_10.has_value) {\n                __auto_type t = _mv_10.value;\n                if ((!(found) && string_eq((*t).name, name))) {\n                    found = 1;\n                    result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n                }\n            } else if (!_mv_10.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nint64_t env_find_colon_pos(slop_string name) {\n    {\n        __auto_type len = string_len(name);\n        int64_t colon_pos = -1;\n        __auto_type i = 0;\n        while (((i < len) && (colon_pos == -1))) {\n            if ((name.data[i] == 58)) {\n                colon_pos = i;\n            }\n            i = (i + 1);\n        }\n        return colon_pos;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type colon_pos = env_find_colon_pos(qualified_name);\n        if ((colon_pos == -1)) {\n            return env_env_lookup_type_direct(env, qualified_name);\n        } else {\n            {\n                __auto_type mod_part = (slop_string){.len = ((uint64_t)(colon_pos)), .data = qualified_name.data};\n                __auto_type start_offset = (colon_pos + 1);\n                __auto_type type_len = (((int64_t)(qualified_name.len)) - start_offset);\n                __auto_type type_data = ((uint8_t*)((((int64_t)(qualified_name.data)) + start_offset)));\n                __auto_type type_part = (slop_string){.len = ((uint64_t)(type_len)), .data = type_data};\n                return env_env_lookup_type_qualified(env, mod_part, type_part);\n            }\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_11 = env_env_lookup_type_direct(env, name);\n    if (_mv_11.has_value) {\n        __auto_type t = _mv_11.value;\n        if (env_env_is_type_visible(env, t)) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n        } else {\n            __auto_type _mv_12 = env_env_resolve_import(env, name);\n            if (_mv_12.has_value) {\n                __auto_type qualified_name = _mv_12.value;\n                return env_lookup_type_by_qualified_name(env, qualified_name);\n            } else if (!_mv_12.has_value) {\n                return (slop_option_types_ResolvedType_ptr){.has_value = false};\n            }\n        }\n    } else if (!_mv_11.has_value) {\n        __auto_type _mv_13 = env_env_resolve_import(env, name);\n        if (_mv_13.has_value) {\n            __auto_type qualified_name = _mv_13.value;\n            return env_lookup_type_by_qualified_name(env, qualified_name);\n        } else if (!_mv_13.has_value) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = false};\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type types = (*env).types;\n        __auto_type len = ((int64_t)((types).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_14 = ({ __auto_type _lst = types; size_t _idx = (size_t)i; slop_option_ResolvedType_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_14.has_value) {\n                __auto_type t = _mv_14.value;\n                if (!(found)) {\n                    __auto_type _mv_15 = (*t).module_name;\n                    if (_mv_15.has_value) {\n                        __auto_type mod = _mv_15.value;\n                        if ((string_eq(mod, module_name) && string_eq((*t).name, type_name))) {\n                            found = 1;\n                            result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n                        }\n                    } else if (!_mv_15.has_value) {\n                    }\n                }\n            } else if (!_mv_14.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    __auto_type _mv_16 = (*t).module_name;\n    if (!_mv_16.has_value) {\n        return 1;\n    } else if (_mv_16.has_value) {\n        __auto_type mod = _mv_16.value;\n        __auto_type _mv_17 = env_env_get_module(env);\n        if (_mv_17.has_value) {\n            __auto_type current = _mv_17.value;\n            return string_eq(mod, current);\n        } else if (!_mv_17.has_value) {\n            return 0;\n        }\n    }\n}\n\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    __auto_type _mv_18 = (*sig).module_name;\n    if (!_mv_18.has_value) {\n        return 1;\n    } else if (_mv_18.has_value) {\n        __auto_type mod = _mv_18.value;\n        __auto_type _mv_19 = env_env_get_module(env);\n        if (_mv_19.has_value) {\n            __auto_type current = _mv_19.value;\n            return string_eq(mod, current);\n        } else if (!_mv_19.has_value) {\n            return 0;\n        }\n    }\n}\n\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    ({ __auto_type _lst_p = &((*env).functions); __auto_type _item = (sig); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type functions = (*env).functions;\n        __auto_type len = ((int64_t)((functions).len));\n        __auto_type found = 0;\n        slop_option_types_FnSignature_ptr result = (slop_option_types_FnSignature_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_20 = ({ __auto_type _lst = functions; size_t _idx = (size_t)i; slop_option_FnSignature_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_20.has_value) {\n                __auto_type sig = _mv_20.value;\n                if ((!(found) && (string_eq((*sig).name, name) || string_eq((*sig).c_name, name)))) {\n                    found = 1;\n                    result = (slop_option_types_FnSignature_ptr){.has_value = 1, .value = sig};\n                }\n            } else if (!_mv_20.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_21 = env_env_lookup_function_direct(env, name);\n    if (_mv_21.has_value) {\n        __auto_type sig = _mv_21.value;\n        if (env_env_is_function_visible(env, sig)) {\n            return (slop_option_types_FnSignature_ptr){.has_value = 1, .value = sig};\n        } else {\n            __auto_type _mv_22 = env_env_resolve_import(env, name);\n            if (_mv_22.has_value) {\n                __auto_type import_qualified = _mv_22.value;\n                return env_env_lookup_function_direct(env, import_qualified);\n            } else if (!_mv_22.has_value) {\n                __auto_type _mv_23 = env_env_get_module(env);\n                if (_mv_23.has_value) {\n                    __auto_type mod = _mv_23.value;\n                    {\n                        __auto_type qualified = string_concat(env_env_arena(env), mod, string_concat(env_env_arena(env), SLOP_STR(\":\"), name));\n                        return env_env_lookup_function_direct(env, qualified);\n                    }\n                } else if (!_mv_23.has_value) {\n                    return (slop_option_types_FnSignature_ptr){.has_value = false};\n                }\n            }\n        }\n    } else if (!_mv_21.has_value) {\n        __auto_type _mv_24 = env_env_resolve_import(env, name);\n        if (_mv_24.has_value) {\n            __auto_type import_qualified = _mv_24.value;\n            return env_env_lookup_function_direct(env, import_qualified);\n        } else if (!_mv_24.has_value) {\n            __auto_type _mv_25 = env_env_get_module(env);\n            if (_mv_25.has_value) {\n                __auto_type mod = _mv_25.value;\n                {\n                    __auto_type qualified = string_concat(env_env_arena(env), mod, string_concat(env_env_arena(env), SLOP_STR(\":\"), name));\n                    return env_env_lookup_function_direct(env, qualified);\n                }\n            } else if (!_mv_25.has_value) {\n                return (slop_option_types_FnSignature_ptr){.has_value = false};\n            }\n        }\n    }\n}\n\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).imports); __auto_type _item = ((env_ImportEntry){local_name, qualified_name}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type imports = (*env).imports;\n        __auto_type len = ((int64_t)((imports).len));\n        __auto_type found = 0;\n        slop_option_string result = (slop_option_string){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_26 = ({ __auto_type _lst = imports; size_t _idx = (size_t)i; slop_option_env_ImportEntry _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_26.has_value) {\n                __auto_type entry = _mv_26.value;\n                if ((!(found) && string_eq(entry.local, local_name))) {\n                    found = 1;\n                    result = (slop_option_string){.has_value = 1, .value = entry.qualified};\n                }\n            } else if (!_mv_26.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nvoid env_env_clear_imports(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        (*env).imports = ((slop_list_env_ImportEntry){ .data = (env_ImportEntry*)slop_arena_alloc(arena, 16 * sizeof(env_ImportEntry)), .len = 0, .cap = 16 });\n    }\n}\n\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).enum_variants); __auto_type _item = ((env_VariantMapping){variant_name, enum_name, env_env_get_module(env)}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name) {\n    __auto_type _mv_27 = v.module_name;\n    if (_mv_27.has_value) {\n        __auto_type vmod = _mv_27.value;\n        return string_eq(vmod, mod_name);\n    } else if (!_mv_27.has_value) {\n        return 0;\n    }\n}\n\nuint8_t env_env_variant_is_builtin(env_VariantMapping v) {\n    __auto_type _mv_28 = v.module_name;\n    if (!_mv_28.has_value) {\n        return 1;\n    } else if (_mv_28.has_value) {\n        __auto_type _ = _mv_28.value;\n        return 0;\n    }\n}\n\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type variants = (*env).enum_variants;\n        __auto_type len = ((int64_t)((variants).len));\n        __auto_type current_mod = env_env_get_module(env);\n        __auto_type found = 0;\n        slop_string found_name = SLOP_STR(\"\");\n        __auto_type _mv_29 = current_mod;\n        if (_mv_29.has_value) {\n            __auto_type mod = _mv_29.value;\n            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type v = _mv.value; (((string_eq(v.variant_name, variant_name) && env_env_variant_matches_module(v, mod))) ? ({ ({ found = 1; (void)0; }); ({ found_name = v.enum_name; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n        } else if (!_mv_29.has_value) {\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_30 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_30.has_value) {\n                        __auto_type v = _mv_30.value;\n                        if ((string_eq(v.variant_name, variant_name) && env_env_variant_is_builtin(v))) {\n                            found = 1;\n                            found_name = v.enum_name;\n                        }\n                    } else if (!_mv_30.has_value) {\n                    }\n                }\n            }\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_31 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_31.has_value) {\n                        __auto_type v = _mv_31.value;\n                        if (string_eq(v.variant_name, variant_name)) {\n                            __auto_type _mv_32 = v.module_name;\n                            if (_mv_32.has_value) {\n                                __auto_type vmod = _mv_32.value;\n                                __auto_type _mv_33 = env_env_resolve_import(env, v.enum_name);\n                                if (_mv_33.has_value) {\n                                    __auto_type _ = _mv_33.value;\n                                    found = 1;\n                                    found_name = v.enum_name;\n                                } else if (!_mv_33.has_value) {\n                                }\n                            } else if (!_mv_32.has_value) {\n                            }\n                        }\n                    } else if (!_mv_31.has_value) {\n                    }\n                }\n            }\n        }\n        if (found) {\n            return (slop_option_string){.has_value = 1, .value = found_name};\n        } else {\n            return (slop_option_string){.has_value = false};\n        }\n    }\n}\n\nvoid env_env_check_variant_collisions(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type variants = (*env).enum_variants;\n        __auto_type len = ((int64_t)((variants).len));\n        __auto_type arena = (*env).arena;\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_34 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_34.has_value) {\n                __auto_type v1 = _mv_34.value;\n                {\n                    __auto_type name1 = v1.variant_name;\n                    __auto_type enum1 = v1.enum_name;\n                    __auto_type mod1 = v1.module_name;\n                    __auto_type found_collision = 0;\n                    slop_string collision_enum = SLOP_STR(\"\");\n                    ({ for (int64_t j = (i + 1); j < len; j++) { ({ __auto_type _mv = ({ __auto_type _lst = variants; size_t _idx = (size_t)j; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type v2 = _mv.value; (((!(found_collision) && (string_eq(v2.variant_name, name1) && (!(string_eq(v2.enum_name, enum1)) && env_env_same_module_opt(mod1, v2.module_name))))) ? ({ ({ found_collision = 1; (void)0; }); ({ collision_enum = v2.enum_name; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); } 0; });\n                    if (found_collision) {\n                        {\n                            __auto_type msg = string_concat(arena, SLOP_STR(\"Ambiguous enum variant '\"), string_concat(arena, name1, string_concat(arena, SLOP_STR(\"' exists in multiple types: \"), string_concat(arena, enum1, string_concat(arena, SLOP_STR(\", \"), collision_enum)))));\n                            env_env_add_error(env, msg, 0, 0);\n                        }\n                    }\n                }\n            } else if (!_mv_34.has_value) {\n            }\n        }\n    }\n}\n\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b) {\n    __auto_type _mv_35 = a;\n    if (!_mv_35.has_value) {\n        __auto_type _mv_36 = b;\n        if (!_mv_36.has_value) {\n            return 1;\n        } else if (_mv_36.has_value) {\n            __auto_type _ = _mv_36.value;\n            return 0;\n        }\n    } else if (_mv_35.has_value) {\n        __auto_type amod = _mv_35.value;\n        __auto_type _mv_37 = b;\n        if (!_mv_37.has_value) {\n            return 0;\n        } else if (_mv_37.has_value) {\n            __auto_type bmod = _mv_37.value;\n            return string_eq(amod, bmod);\n        }\n    }\n}\n\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).current_module = module_name;\n}\n\nslop_option_string env_env_get_module(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).current_module;\n}\n\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).int_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).bool_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).string_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).unit_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).arena_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).unknown_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type inner_name = (((inner_type != NULL)) ? (*inner_type).name : SLOP_STR(\"T\"));\n        __auto_type opt_name = string_concat(arena, SLOP_STR(\"Option_\"), inner_name);\n        __auto_type opt_type = types_resolved_type_new(arena, rk_option, opt_name, none, opt_name);\n        types_resolved_type_set_inner(opt_type, inner_type);\n        return opt_type;\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type inner_name = (((inner_type != NULL)) ? (*inner_type).name : SLOP_STR(\"Void\"));\n        __auto_type ptr_name = string_concat(arena, SLOP_STR(\"Ptr_\"), inner_name);\n        __auto_type ptr_type = types_resolved_type_new(arena, rk_ptr, ptr_name, none, ptr_name);\n        types_resolved_type_set_inner(ptr_type, inner_type);\n        return ptr_type;\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        return types_resolved_type_new(arena, rk_primitive, SLOP_STR(\"T\"), none, SLOP_STR(\"void*\"));\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        return types_resolved_type_new(arena, rk_result, SLOP_STR(\"Result\"), none, SLOP_STR(\"Result\"));\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type fn_name = string_concat(arena, SLOP_STR(\"Fn_\"), (*sig).name);\n        return types_resolved_type_new(arena, rk_function, fn_name, none, fn_name);\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).diagnostics); __auto_type _item = (types_diagnostic_new(diag_warning, message, line, col)); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).diagnostics); __auto_type _item = (types_diagnostic_new(diag_error, message, line, col)); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).diagnostics;\n}\n\nvoid env_env_clear_diagnostics(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        (*env).diagnostics = ((slop_list_types_Diagnostic){ .data = (types_Diagnostic*)slop_arena_alloc(arena, 16 * sizeof(types_Diagnostic)), .len = 0, .cap = 16 });\n    }\n}\n\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).binding_annotations); __auto_type _item = ((env_BindingAnnotation){name, line, col, slop_type}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).binding_annotations;\n}\n\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).current_file = file_path;\n}\n\nslop_option_string env_env_get_current_file(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).current_file;\n}\n\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).loaded_modules); __auto_type _item = (module_path); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type modules = (*env).loaded_modules;\n        __auto_type len = ((int64_t)((modules).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_38 = ({ __auto_type _lst = modules; size_t _idx = (size_t)i; slop_option_string _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_38.has_value) {\n                __auto_type path = _mv_38.value;\n                if ((!(found) && string_eq(path, module_path))) {\n                    found = 1;\n                }\n            } else if (!_mv_38.has_value) {\n            }\n        }\n        return found;\n    }\n}\n\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).fn_type_params = params;\n}\n\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).fn_type_params;\n}\n\nvoid env_env_clear_fn_type_params(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).fn_type_params = ((slop_list_string){ .data = (slop_string*)slop_arena_alloc((*env).arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 });\n}\n\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type params = (*env).fn_type_params;\n        __auto_type len = ((int64_t)((params).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            if (!(found)) {\n                __auto_type _mv_39 = ({ __auto_type _lst = params; size_t _idx = (size_t)i; slop_option_string _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                if (_mv_39.has_value) {\n                    __auto_type p = _mv_39.value;\n                    if (string_eq(p, name)) {\n                        found = 1;\n                    }\n                } else if (!_mv_39.has_value) {\n                }\n            }\n        }\n        return found;\n    }\n}\n\n"}}
