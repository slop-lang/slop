;; ============================================================
;; Type Checker Environment
;;
;; Manages type environment including:
;; - Type registry (type definitions)
;; - Function registry (signatures)
;; - Import map (local → qualified names)
;; - Scope stack (variable bindings)
;; ============================================================

(module env
  (export
    ;; Core types
    TypeEnv CheckerScope VarBinding ImportEntry BindingAnnotation
    ;; Environment lifecycle
    env-new env-arena
    ;; Scope management
    env-push-scope env-pop-scope
    ;; Variable bindings
    env-bind-var env-lookup-var
    ;; Constant bindings
    env-register-constant env-lookup-constant env-lookup-constant-in-module
    ;; Type registry
    env-register-type env-lookup-type env-lookup-type-direct lookup-type-by-qualified-name
    ;; Function registry
    env-register-function env-lookup-function env-lookup-function-direct
    ;; Import management
    env-add-import env-resolve-import env-clear-imports
    ;; Enum variant management
    env-register-variant env-lookup-variant env-check-variant-collisions
    ;; Module context
    env-set-module env-get-module
    ;; File context for subdirectory imports
    env-set-current-file env-get-current-file
    env-add-loaded-module env-is-module-loaded
    ;; Builtin types
    env-get-int-type env-get-bool-type env-get-string-type
    env-get-unit-type env-get-arena-type env-get-unknown-type
    ;; Type constructors
    env-make-option-type env-make-ptr-type env-make-result-type env-make-fn-type env-get-generic-type
    ;; Diagnostics
    env-add-warning env-add-error env-get-diagnostics env-clear-diagnostics
    ;; Binding annotations for transpiler
    env-record-binding env-get-binding-annotations)

  (import types (ResolvedType ResolvedTypeKind FnSignature ParamInfo
                 Diagnostic DiagnosticLevel diagnostic-new
                 resolved-type-new resolved-type-set-inner
                 fn-signature-new param-info-new))

  ;; ============================================================
  ;; Core Types
  ;; ============================================================

  ;; A variable binding in a scope
  (type VarBinding (record
    (name String)
    (var-type (Ptr ResolvedType))))

  ;; A module-level constant binding
  (type ConstBinding (record
    (name String)
    (const-type (Ptr ResolvedType))
    (module-name (Option String))))

  ;; An import mapping (local name -> qualified name)
  (type ImportEntry (record
    (local String)
    (qualified String)))

  ;; A scope contains variable bindings
  ;; Scopes are pushed for let, match, for-each, fn bodies
  (type CheckerScope (record
    (bindings (List VarBinding))))

  ;; Maps an enum variant name to its parent enum type name
  (type VariantMapping (record
    (variant-name String)
    (enum-name String)
    (module-name (Option String))))

  ;; A binding annotation records type info for the transpiler
  ;; This persists after scopes are popped
  (type BindingAnnotation (record
    (name String)
    (line Int)
    (col Int)
    (slop-type String)))

  ;; The type environment tracks all type information
  (type TypeEnv (record
    (arena Arena)
    ;; Type definitions: name → ResolvedType
    (types (List (Ptr ResolvedType)))
    ;; Function signatures: name → FnSignature
    (functions (List (Ptr FnSignature)))
    ;; Module-level constants: name → type
    (constants (List ConstBinding))
    ;; Import map: local name → qualified name
    (imports (List ImportEntry))
    ;; Enum variant mappings: variant-name → enum-type-name
    (enum-variants (List VariantMapping))
    ;; Scope stack (innermost first) - store pointers so modifications persist
    (scopes (List (Ptr CheckerScope)))
    ;; Current module name (if inside a module)
    (current-module (Option String))
    ;; Builtin types (cached for fast access)
    (int-type (Ptr ResolvedType))
    (bool-type (Ptr ResolvedType))
    (string-type (Ptr ResolvedType))
    (unit-type (Ptr ResolvedType))
    (arena-type (Ptr ResolvedType))
    (unknown-type (Ptr ResolvedType))
    ;; Diagnostics (warnings and errors)
    (diagnostics (List Diagnostic))
    ;; Binding annotations for transpiler (persists after scopes popped)
    (binding-annotations (List BindingAnnotation))
    ;; Current file path for subdirectory import resolution
    (current-file (Option String))
    ;; Loaded module paths for cycle detection
    (loaded-modules (List String))))

  ;; ============================================================
  ;; Environment Lifecycle
  ;; ============================================================

  (fn env-new ((arena Arena))
    (@intent "Create a new type environment with builtins initialized")
    (@spec ((Arena) -> (Ptr TypeEnv)))
    (@alloc arena)
    ;; Create builtin types first
    (let ((int-t (resolved-type-new arena 'rk-primitive "Int" (none) "int64_t"))
          (bool-t (resolved-type-new arena 'rk-primitive "Bool" (none) "bool"))
          (string-t (resolved-type-new arena 'rk-primitive "String" (none) "slop_string_t"))
          (unit-t (resolved-type-new arena 'rk-primitive "Unit" (none) "void"))
          (arena-t (resolved-type-new arena 'rk-primitive "Arena" (none) "slop_arena_t*"))
          (unknown-t (resolved-type-new arena 'rk-primitive "Unknown" (none) "void"))
          (env (cast (Ptr TypeEnv) (arena-alloc arena 256))))
      (set! (deref env) (TypeEnv
        arena
        (list-new arena (Ptr ResolvedType))      ;; types
        (list-new arena (Ptr FnSignature))       ;; functions
        (list-new arena ConstBinding)            ;; constants
        (list-new arena ImportEntry)              ;; imports
        (list-new arena VariantMapping)          ;; enum-variants
        (list-new arena (Ptr CheckerScope))             ;; scopes - store pointers
        (none)                                   ;; current-module
        int-t bool-t string-t unit-t arena-t unknown-t
        (list-new arena Diagnostic)              ;; diagnostics
        (list-new arena BindingAnnotation)       ;; binding-annotations
        (none)                                   ;; current-file
        (list-new arena String)))                ;; loaded-modules
      ;; Register builtin types
      (list-push (. (deref env) types) int-t)
      (list-push (. (deref env) types) bool-t)
      (list-push (. (deref env) types) string-t)
      (list-push (. (deref env) types) unit-t)
      (list-push (. (deref env) types) arena-t)
      ;; Register additional primitive types
      (let ((i8 (resolved-type-new arena 'rk-primitive "I8" (none) "int8_t"))
            (i16 (resolved-type-new arena 'rk-primitive "I16" (none) "int16_t"))
            (i32 (resolved-type-new arena 'rk-primitive "I32" (none) "int32_t"))
            (i64 (resolved-type-new arena 'rk-primitive "I64" (none) "int64_t"))
            (u8 (resolved-type-new arena 'rk-primitive "U8" (none) "uint8_t"))
            (u16 (resolved-type-new arena 'rk-primitive "U16" (none) "uint16_t"))
            (u32 (resolved-type-new arena 'rk-primitive "U32" (none) "uint32_t"))
            (u64 (resolved-type-new arena 'rk-primitive "U64" (none) "uint64_t"))
            (f32 (resolved-type-new arena 'rk-primitive "F32" (none) "float"))
            (f64 (resolved-type-new arena 'rk-primitive "F64" (none) "double")))
        (do
          (list-push (. (deref env) types) i8)
          (list-push (. (deref env) types) i16)
          (list-push (. (deref env) types) i32)
          (list-push (. (deref env) types) i64)
          (list-push (. (deref env) types) u8)
          (list-push (. (deref env) types) u16)
          (list-push (. (deref env) types) u32)
          (list-push (. (deref env) types) u64)
          (list-push (. (deref env) types) f32)
          (list-push (. (deref env) types) f64)
          ;; Register builtin string functions
          (register-builtin-functions env arena int-t bool-t string-t arena-t u8)))
      env))

  (fn env-register-builtin-fn ((env (Ptr TypeEnv)) (arena Arena)
                                (name String) (c-name String)
                                (params (List ParamInfo)) (ret-type (Ptr ResolvedType)))
    (@intent "Register a single builtin function signature")
    (@spec (((Ptr TypeEnv) Arena String String (List ParamInfo) (Ptr ResolvedType)) -> Unit))
    (let ((sig (fn-signature-new arena name c-name params ret-type)))
      (env-register-function env sig)))

  (fn register-builtin-functions ((env (Ptr TypeEnv)) (arena Arena)
                                   (int-t (Ptr ResolvedType)) (bool-t (Ptr ResolvedType))
                                   (string-t (Ptr ResolvedType)) (arena-t (Ptr ResolvedType))
                                   (u8-t (Ptr ResolvedType)))
    (@intent "Register all builtin string functions with proper signatures")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr ResolvedType) (Ptr ResolvedType) (Ptr ResolvedType) (Ptr ResolvedType)) -> Unit))
    ;; string-eq: (String String) -> Bool
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "a" string-t)))
      (list-push p (deref (param-info-new arena "b" string-t)))
      (env-register-builtin-fn env arena "string-eq" "string_eq" p bool-t))
    ;; string-concat: (Arena String String) -> String
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "arena" arena-t)))
      (list-push p (deref (param-info-new arena "a" string-t)))
      (list-push p (deref (param-info-new arena "b" string-t)))
      (env-register-builtin-fn env arena "string-concat" "string_concat" p string-t))
    ;; string-len: (String) -> Int
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "s" string-t)))
      (env-register-builtin-fn env arena "string-len" "string_len" p int-t))
    ;; string-copy: (String) -> String
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "s" string-t)))
      (env-register-builtin-fn env arena "string-copy" "string_copy" p string-t))
    ;; string-new: (Arena (Ptr U8)) -> String
    (let ((ptr-u8-t (env-make-ptr-type env u8-t)))
      (let ((p (list-new arena ParamInfo)))
        (list-push p (deref (param-info-new arena "arena" arena-t)))
        (list-push p (deref (param-info-new arena "cstr" ptr-u8-t)))
        (env-register-builtin-fn env arena "string-new" "string_new" p string-t)))
    ;; string-slice: (String Int Int) -> String
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "s" string-t)))
      (list-push p (deref (param-info-new arena "start" int-t)))
      (list-push p (deref (param-info-new arena "end" int-t)))
      (env-register-builtin-fn env arena "string-slice" "string_slice" p string-t))
    ;; int-to-string: (Arena Int) -> String
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "arena" arena-t)))
      (list-push p (deref (param-info-new arena "n" int-t)))
      (env-register-builtin-fn env arena "int-to-string" "int_to_string" p string-t))
    ;; char-at: (String Int) -> Int
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "s" string-t)))
      (list-push p (deref (param-info-new arena "idx" int-t)))
      (env-register-builtin-fn env arena "char-at" "char_at" p int-t))
    ;; string-push-char: (Arena String Int) -> String
    (let ((p (list-new arena ParamInfo)))
      (list-push p (deref (param-info-new arena "arena" arena-t)))
      (list-push p (deref (param-info-new arena "s" string-t)))
      (list-push p (deref (param-info-new arena "c" int-t)))
      (env-register-builtin-fn env arena "string-push-char" "slop_string_push_char" p string-t)))

  (fn env-arena ((env (Ptr TypeEnv)))
    (@intent "Get the arena from a type environment")
    (@spec (((Ptr TypeEnv)) -> Arena))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) arena))

  ;; ============================================================
  ;; Scope Management
  ;; ============================================================

  (fn env-push-scope ((env (Ptr TypeEnv)))
    (@intent "Push a new empty scope onto the scope stack")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((arena (. (deref env) arena))
          ;; Allocate scope on arena so it persists and we can get a stable pointer
          (scope-ptr (cast (Ptr CheckerScope) (arena-alloc arena 64))))
      (set! (deref scope-ptr) (CheckerScope (list-new arena VarBinding)))
      (list-push (. (deref env) scopes) scope-ptr)))

  (fn env-pop-scope ((env (Ptr TypeEnv)))
    (@intent "Pop the innermost scope from the scope stack")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (@pre (> (list-len (. (deref env) scopes)) 0))
    (let ((_ (list-pop (. (deref env) scopes))))
      (do)))

  ;; ============================================================
  ;; Variable Bindings
  ;; ============================================================

  (fn env-bind-var ((env (Ptr TypeEnv)) (name String) (var-type (Ptr ResolvedType)))
    (@intent "Bind a variable in the current (innermost) scope")
    (@spec (((Ptr TypeEnv) String (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= var-type nil))
    (@pre (> (list-len (. (deref env) scopes)) 0))
    (let ((arena (. (deref env) arena))
          (scopes (. (deref env) scopes))
          (top-idx (- (list-len scopes) 1)))
      ;; scopes is (List (Ptr CheckerScope)), so list-get returns Option (Ptr CheckerScope)
      ;; We get the pointer directly, so modifications persist
      (match (list-get scopes top-idx)
        ((some scope-ptr)
          (list-push (. (deref scope-ptr) bindings) (VarBinding name var-type)))
        ((none) (do)))))

  ;; Helper to search bindings within a single scope
  (fn scope-lookup-var ((scope-ptr (Ptr CheckerScope)) (name String))
    (@intent "Look up a variable in a single scope")
    (@spec (((Ptr CheckerScope) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= scope-ptr nil))
    (let ((bindings (. (deref scope-ptr) bindings))
          (num-bindings (list-len bindings))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (j 0 num-bindings)
        (match (list-get bindings j)
          ((some binding)
            (when (and (not found) (string-eq (. binding name) name))
              (do
                (set! found true)
                (set! result (some (. binding var-type))))))
          ((none) (do))))
      result))

  (fn env-lookup-var ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a variable by name, searching from innermost to outermost scope")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    ;; Search scopes from innermost (end of list) to outermost (start)
    (let ((scopes (. (deref env) scopes))
          (num-scopes (list-len scopes))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 num-scopes)
        (when (not found)
          (let ((scope-idx (- num-scopes 1 i)))
            (match (list-get scopes scope-idx)
              ((some scope-ptr)
                (match (scope-lookup-var scope-ptr name)
                  ((some var-type)
                    (do
                      (set! found true)
                      (set! result (some var-type))))
                  ((none) (do))))
              ((none) (do))))))
      result))

  ;; ============================================================
  ;; Constant Registry
  ;; ============================================================

  (fn env-register-constant ((env (Ptr TypeEnv)) (name String) (const-type (Ptr ResolvedType)))
    (@intent "Register a module-level constant in the environment")
    (@spec (((Ptr TypeEnv) String (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= const-type nil))
    (list-push (. (deref env) constants) (ConstBinding name const-type (env-get-module env))))

  (fn env-constant-matches-module ((binding ConstBinding) (mod-name String))
    (@intent "Check if a constant binding belongs to the given module")
    (@spec ((ConstBinding String) -> Bool))
    (@pure)
    (match (. binding module-name)
      ((some bmod) (string-eq bmod mod-name))
      ((none) false)))

  (fn env-constant-is-builtin ((binding ConstBinding))
    (@intent "Check if a constant binding has no module (builtin)")
    (@spec ((ConstBinding) -> Bool))
    (@pure)
    (match (. binding module-name)
      ((none) true)
      ((some _) false)))

  (fn env-lookup-constant-in-module ((env (Ptr TypeEnv)) (mod-name String) (const-name String))
    (@intent "Check if a constant exists in the given module")
    (@spec (((Ptr TypeEnv) String String) -> Bool))
    (@pure)
    (@pre (!= env nil))
    (let ((constants (. (deref env) constants))
          (len (list-len constants))
          (mut found false))
      (for (i 0 len)
        (when (not found)
          (match (list-get constants i)
            ((some binding)
              (when (and (string-eq (. binding name) const-name)
                         (env-constant-matches-module binding mod-name))
                (set! found true)))
            ((none) (do)))))
      found))

  (fn env-lookup-constant ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a constant by name, respecting module boundaries")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((constants (. (deref env) constants))
          (len (list-len constants))
          (current-mod (env-get-module env))
          (mut found false)
          (mut found-type (Ptr ResolvedType) nil))
      ;; Pass 1: Try current module first
      (match current-mod
        ((some mod)
          (for (i 0 len)
            (when (not found)
              (match (list-get constants i)
                ((some binding)
                  (when (and (string-eq (. binding name) name)
                             (env-constant-matches-module binding mod))
                    (set! found true)
                    (set! found-type (. binding const-type))))
                ((none) (do))))))
        ((none) (do)))
      ;; Pass 2: Try import resolution
      (when (not found)
        (match (env-resolve-import env name)
          ((some qualified-name)
            (let ((colon-pos (find-colon-pos qualified-name)))
              (when (!= colon-pos -1)
                (let ((mod-part (String (. qualified-name data) (cast U64 colon-pos))))
                  (for (i 0 len)
                    (when (not found)
                      (match (list-get constants i)
                        ((some binding)
                          (when (and (string-eq (. binding name) name)
                                     (env-constant-matches-module binding mod-part))
                            (set! found true)
                            (set! found-type (. binding const-type))))
                        ((none) (do)))))))))
          ((none) (do))))
      ;; Pass 3: Try builtins (no module)
      (when (not found)
        (for (i 0 len)
          (when (not found)
            (match (list-get constants i)
              ((some binding)
                (when (and (string-eq (. binding name) name)
                           (env-constant-is-builtin binding))
                  (set! found true)
                  (set! found-type (. binding const-type))))
              ((none) (do))))))
      ;; Construct Option at top level where type is known
      (if found
        (some found-type)
        (none))))

  ;; ============================================================
  ;; Type Registry
  ;; ============================================================

  (fn env-register-type ((env (Ptr TypeEnv)) (t (Ptr ResolvedType)))
    (@intent "Register a type definition in the environment")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= t nil))
    (list-push (. (deref env) types) t))

  (fn env-lookup-type-direct ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a type by name directly (no import resolution)")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((types (. (deref env) types))
          (len (list-len types))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (match (list-get types i)
          ((some t)
            (when (and (not found) (string-eq (. (deref t) name) name))
              (do
                (set! found true)
                (set! result (some t)))))
          ((none) (do))))
      result))

  (fn find-colon-pos ((name String))
    (@intent "Find position of colon in string, or -1 if not found")
    (@spec ((String) -> Int))
    (@pure)
    (let ((len (string-len name))
          (mut colon-pos Int -1)
          (mut i 0))
      (while (and (< i len) (== colon-pos -1))
        (when (== (@ (. name data) i) 58)  ;; 58 = ':'
          (set! colon-pos i))
        (set! i (+ i 1)))
      colon-pos))

  (fn lookup-type-by-qualified-name ((env (Ptr TypeEnv)) (qualified-name String))
    (@intent "Look up type using a qualified name like 'module:typename'")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((colon-pos (find-colon-pos qualified-name)))
      (if (== colon-pos -1)
        ;; No colon - use direct lookup
        (env-lookup-type-direct env qualified-name)
        ;; Has colon - split and use qualified lookup
        (let ((mod-part (String (. qualified-name data) (cast U64 colon-pos)))
              (start-offset (+ colon-pos 1))
              (type-len (- (cast Int (. qualified-name len)) start-offset))
              (type-data (cast (Ptr U8) (+ (cast Int (. qualified-name data)) start-offset)))
              (type-part (String type-data (cast U64 type-len))))
          (env-lookup-type-qualified env mod-part type-part)))))

  (fn env-lookup-type ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a type by name, respecting module boundaries")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    ;; 1. Try direct lookup, but only accept if visible (builtin or same module)
    (match (env-lookup-type-direct env name)
      ((some t)
        (if (env-is-type-visible env t)
          (some t)
          ;; Not visible directly - fall through to import check
          (match (env-resolve-import env name)
            ((some qualified-name)
              (lookup-type-by-qualified-name env qualified-name))
            ((none) (none)))))
      ((none)
        ;; Not found directly - try import resolution
        (match (env-resolve-import env name)
          ((some qualified-name)
            (lookup-type-by-qualified-name env qualified-name))
          ((none) (none))))))

  (fn env-lookup-type-qualified ((env (Ptr TypeEnv)) (module-name String) (type-name String))
    (@intent "Look up a type by module and name")
    (@spec (((Ptr TypeEnv) String String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((types (. (deref env) types))
          (len (list-len types))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (match (list-get types i)
          ((some t)
            (when (not found)
              (match (. (deref t) module-name)
                ((some mod)
                  (when (and (string-eq mod module-name) (string-eq (. (deref t) name) type-name))
                    (do
                      (set! found true)
                      (set! result (some t)))))
                ((none) (do)))))
          ((none) (do))))
      result))

  (fn env-is-type-visible ((env (Ptr TypeEnv)) (t (Ptr ResolvedType)))
    (@intent "Check if type is visible without import (builtin or same module)")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= env nil))
    (@pre (!= t nil))
    (match (. (deref t) module-name)
      ((none) true)  ;; Builtin - always visible
      ((some mod)
        ;; Same module as current?
        (match (env-get-module env)
          ((some current) (string-eq mod current))
          ((none) false)))))

  (fn env-is-function-visible ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)))
    (@intent "Check if function is visible without import (builtin or same module)")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature)) -> Bool))
    (@pure)
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (match (. (deref sig) module-name)
      ((none) true)  ;; Builtin - always visible
      ((some mod)
        ;; Same module as current?
        (match (env-get-module env)
          ((some current) (string-eq mod current))
          ((none) false)))))

  ;; ============================================================
  ;; Function Registry
  ;; ============================================================

  (fn env-register-function ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)))
    (@intent "Register a function signature in the environment")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (list-push (. (deref env) functions) sig))

  (fn env-lookup-function-direct ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a function signature by name directly (no import resolution)")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr FnSignature))))
    (@pure)
    (@pre (!= env nil))
    (let ((functions (. (deref env) functions))
          (len (list-len functions))
          (mut found false)
          (mut result (Option (Ptr FnSignature)) (none)))
      (for (i 0 len)
        (match (list-get functions i)
          ((some sig)
            (when (and (not found)
                     (or (string-eq (. (deref sig) name) name)
                         (string-eq (. (deref sig) c-name) name)))
              (do
                (set! found true)
                (set! result (some sig)))))
          ((none) (do))))
      result))

  (fn env-lookup-function ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a function signature by name, respecting module boundaries")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr FnSignature))))
    (@pre (!= env nil))
    ;; 1. Try direct lookup, but only accept if visible (builtin or same module)
    (match (env-lookup-function-direct env name)
      ((some sig)
        (if (env-is-function-visible env sig)
          (some sig)
          ;; Not visible directly - fall through to import/same-module check
          (match (env-resolve-import env name)
            ((some import-qualified)
              (env-lookup-function-direct env import-qualified))
            ((none)
              ;; Try current module's qualified name (for same-module calls)
              (match (env-get-module env)
                ((some mod)
                  (let ((qualified (string-concat (env-arena env) mod
                                    (string-concat (env-arena env) ":" name))))
                    (env-lookup-function-direct env qualified)))
                ((none) (none)))))))
      ((none)
        ;; Not found directly - try import resolution
        (match (env-resolve-import env name)
          ((some import-qualified)
            (env-lookup-function-direct env import-qualified))
          ((none)
            ;; Try current module's qualified name (for same-module calls)
            (match (env-get-module env)
              ((some mod)
                (let ((qualified (string-concat (env-arena env) mod
                                  (string-concat (env-arena env) ":" name))))
                  (env-lookup-function-direct env qualified)))
              ((none) (none))))))))

  ;; ============================================================
  ;; Import Management
  ;; ============================================================

  (fn env-add-import ((env (Ptr TypeEnv)) (local-name String) (qualified-name String))
    (@intent "Add an import mapping from local name to qualified name")
    (@spec (((Ptr TypeEnv) String String) -> Unit))
    (@pre (!= env nil))
    ;; Store import as ImportEntry
    (list-push (. (deref env) imports)
      (ImportEntry local-name qualified-name)))

  (fn env-resolve-import ((env (Ptr TypeEnv)) (local-name String))
    (@intent "Resolve a local import name to its qualified name")
    (@spec (((Ptr TypeEnv) String) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (let ((imports (. (deref env) imports))
          (len (list-len imports))
          (mut found false)
          (mut result (Option String) (none)))
      (for (i 0 len)
        (match (list-get imports i)
          ((some entry)
            (when (and (not found) (string-eq (. entry local) local-name))
              (do
                (set! found true)
                (set! result (some (. entry qualified))))))
          ((none) (do))))
      result))

  (fn env-clear-imports ((env (Ptr TypeEnv)))
    (@intent "Clear all imports for a new file context")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((arena (. (deref env) arena)))
      (set! (. (deref env) imports) (list-new arena ImportEntry))))

  ;; ============================================================
  ;; Enum Variant Management
  ;; ============================================================

  (fn env-register-variant ((env (Ptr TypeEnv)) (variant-name String) (enum-name String))
    (@intent "Register an enum variant with its parent enum type")
    (@spec (((Ptr TypeEnv) String String) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) enum-variants)
      (VariantMapping variant-name enum-name (env-get-module env))))

  (fn env-variant-matches-module ((v VariantMapping) (mod-name String))
    (@intent "Check if a variant mapping belongs to the given module")
    (@spec ((VariantMapping String) -> Bool))
    (@pure)
    (match (. v module-name)
      ((some vmod) (string-eq vmod mod-name))
      ((none) false)))

  (fn env-variant-is-builtin ((v VariantMapping))
    (@intent "Check if a variant mapping has no module (builtin)")
    (@spec ((VariantMapping) -> Bool))
    (@pure)
    (match (. v module-name)
      ((none) true)
      ((some _) false)))

  (fn env-lookup-variant ((env (Ptr TypeEnv)) (variant-name String))
    (@intent "Look up which enum type contains a variant, preferring current module")
    (@spec (((Ptr TypeEnv) String) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (let ((variants (. (deref env) enum-variants))
          (len (list-len variants))
          (current-mod (env-get-module env))
          (mut found false)
          (mut found-name String ""))
      ;; Pass 1: Prefer variants from current module
      (match current-mod
        ((some mod)
          (for (i 0 len)
            (when (not found)
              (match (list-get variants i)
                ((some v)
                  (when (and (string-eq (. v variant-name) variant-name)
                             (env-variant-matches-module v mod))
                    (set! found true)
                    (set! found-name (. v enum-name))))
                ((none) (do))))))
        ((none) (do)))
      ;; Pass 2: Try builtins (no module) — e.g., some/none/ok/error
      (when (not found)
        (for (i 0 len)
          (when (not found)
            (match (list-get variants i)
              ((some v)
                (when (and (string-eq (. v variant-name) variant-name)
                           (env-variant-is-builtin v))
                  (set! found true)
                  (set! found-name (. v enum-name))))
              ((none) (do))))))
      ;; Pass 3: Try variants whose parent enum type is imported
      (when (not found)
        (for (i 0 len)
          (when (not found)
            (match (list-get variants i)
              ((some v)
                (when (string-eq (. v variant-name) variant-name)
                  ;; Check if the parent enum type is accessible via imports
                  (match (. v module-name)
                    ((some vmod)
                      (match (env-resolve-import env (. v enum-name))
                        ((some _)
                          (set! found true)
                          (set! found-name (. v enum-name)))
                        ((none) (do))))
                    ((none) (do)))))
              ((none) (do))))))
      ;; Construct Option at top level
      (if found
        (some found-name)
        (none))))

  (fn env-check-variant-collisions ((env (Ptr TypeEnv)))
    (@intent "Check for enum variants that appear in multiple enum types and emit errors")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((variants (. (deref env) enum-variants))
          (len (list-len variants))
          (arena (. (deref env) arena)))
      ;; For each variant, check if any later variant has the same name but different enum
      ;; Only collide if both are in the same module (or both have no module)
      (for (i 0 len)
        (match (list-get variants i)
          ((some v1)
            (let ((name1 (. v1 variant-name))
                  (enum1 (. v1 enum-name))
                  (mod1 (. v1 module-name))
                  (mut found-collision false)
                  (mut collision-enum String ""))
              ;; Check against all later variants for collision
              (for (j (+ i 1) len)
                (match (list-get variants j)
                  ((some v2)
                    (when (and (not found-collision)
                               (and (string-eq (. v2 variant-name) name1)
                                    (and (not (string-eq (. v2 enum-name) enum1))
                                         (env-same-module-opt mod1 (. v2 module-name)))))
                      (set! found-collision true)
                      (set! collision-enum (. v2 enum-name))))
                  ((none) (do))))
              ;; Emit error if collision found
              (when found-collision
                (let ((msg (string-concat arena "Ambiguous enum variant '"
                             (string-concat arena name1
                               (string-concat arena "' exists in multiple types: "
                                 (string-concat arena enum1
                                   (string-concat arena ", " collision-enum)))))))
                  (env-add-error env msg 0 0)))))
          ((none) (do))))))

  ;; Helper: check if two Option String module names refer to the same module
  (fn env-same-module-opt ((a (Option String)) (b (Option String)))
    (@intent "Check if two optional module names are the same")
    (@spec (((Option String) (Option String)) -> Bool))
    (@pure)
    (match a
      ((none) (match b ((none) true) ((some _) false)))
      ((some amod)
        (match b
          ((none) false)
          ((some bmod) (string-eq amod bmod))))))

  ;; ============================================================
  ;; Module Context
  ;; ============================================================

  (fn env-set-module ((env (Ptr TypeEnv)) (module-name (Option String)))
    (@intent "Set the current module context")
    (@spec (((Ptr TypeEnv) (Option String)) -> Unit))
    (@pre (!= env nil))
    (set! (. (deref env) current-module) module-name))

  (fn env-get-module ((env (Ptr TypeEnv)))
    (@intent "Get the current module name")
    (@spec (((Ptr TypeEnv)) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) current-module))

  ;; ============================================================
  ;; Builtin Type Accessors
  ;; ============================================================

  (fn env-get-int-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Int type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) int-type))

  (fn env-get-bool-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Bool type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) bool-type))

  (fn env-get-string-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin String type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) string-type))

  (fn env-get-unit-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Unit type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) unit-type))

  (fn env-get-arena-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Arena type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) arena-type))

  (fn env-get-unknown-type ((env (Ptr TypeEnv)))
    (@intent "Get the Unknown type for unrecognized expressions")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) unknown-type))

  ;; ============================================================
  ;; Type Constructors
  ;; ============================================================

  (fn env-make-option-type ((env (Ptr TypeEnv)) (inner-type (Ptr ResolvedType)))
    (@intent "Create an Option type with the given inner type")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena))
          (inner-name (if (!= inner-type nil)
                        (. (deref inner-type) name)
                        "T"))
          (opt-name (string-concat arena "Option_" inner-name))
          (opt-type (resolved-type-new arena 'rk-option opt-name (none) opt-name)))
      ;; Set the inner type using helper function (avoids transpiler type inference issues)
      (resolved-type-set-inner opt-type inner-type)
      opt-type))

  (fn env-make-ptr-type ((env (Ptr TypeEnv)) (inner-type (Ptr ResolvedType)))
    (@intent "Create a Ptr type with the given inner type")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena))
          (inner-name (if (!= inner-type nil)
                        (. (deref inner-type) name)
                        "Void"))
          (ptr-name (string-concat arena "Ptr_" inner-name))
          (ptr-type (resolved-type-new arena 'rk-ptr ptr-name (none) ptr-name)))
      (resolved-type-set-inner ptr-type inner-type)
      ptr-type))

  (fn env-get-generic-type ((env (Ptr TypeEnv)))
    (@intent "Get a generic type 'T' that matches any other type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena)))
      (resolved-type-new arena 'rk-primitive "T" (none) "void*")))

  (fn env-make-result-type ((env (Ptr TypeEnv)))
    (@intent "Create a generic Result type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena)))
      (resolved-type-new arena 'rk-result "Result" (none) "Result")))

  (fn env-make-fn-type ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)))
    (@intent "Create a function type from a function signature")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena))
          (fn-name (string-concat arena "Fn_" (. (deref sig) name))))
      (resolved-type-new arena 'rk-function fn-name (none) fn-name)))

  ;; ============================================================
  ;; Diagnostics
  ;; ============================================================

  (fn env-add-warning ((env (Ptr TypeEnv)) (message String) (line Int) (col Int))
    (@intent "Add a warning diagnostic to the environment")
    (@spec (((Ptr TypeEnv) String Int Int) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) diagnostics)
      (diagnostic-new 'diag-warning message line col)))

  (fn env-add-error ((env (Ptr TypeEnv)) (message String) (line Int) (col Int))
    (@intent "Add an error diagnostic to the environment")
    (@spec (((Ptr TypeEnv) String Int Int) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) diagnostics)
      (diagnostic-new 'diag-error message line col)))

  (fn env-get-diagnostics ((env (Ptr TypeEnv)))
    (@intent "Get all diagnostics collected during type checking")
    (@spec (((Ptr TypeEnv)) -> (List Diagnostic)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) diagnostics))

  (fn env-clear-diagnostics ((env (Ptr TypeEnv)))
    (@intent "Clear all diagnostics from the environment")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((arena (. (deref env) arena)))
      (set! (. (deref env) diagnostics) (list-new arena Diagnostic))))

  ;; ============================================================
  ;; Binding Annotations (for transpiler type info)
  ;; ============================================================

  (fn env-record-binding ((env (Ptr TypeEnv)) (name String) (line Int) (col Int) (slop-type String))
    (@intent "Record a binding annotation for the transpiler")
    (@spec (((Ptr TypeEnv) String Int Int String) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) binding-annotations)
      (BindingAnnotation name line col slop-type)))

  (fn env-get-binding-annotations ((env (Ptr TypeEnv)))
    (@intent "Get all binding annotations collected during type checking")
    (@spec (((Ptr TypeEnv)) -> (List BindingAnnotation)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) binding-annotations))

  ;; ============================================================
  ;; File Context (for subdirectory imports)
  ;; ============================================================

  (fn env-set-current-file ((env (Ptr TypeEnv)) (file-path (Option String)))
    (@intent "Set the current file path for import resolution")
    (@spec (((Ptr TypeEnv) (Option String)) -> Unit))
    (@pre (!= env nil))
    (set! (. (deref env) current-file) file-path))

  (fn env-get-current-file ((env (Ptr TypeEnv)))
    (@intent "Get the current file path")
    (@spec (((Ptr TypeEnv)) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) current-file))

  (fn env-add-loaded-module ((env (Ptr TypeEnv)) (module-path String))
    (@intent "Add a module path to the loaded modules list")
    (@spec (((Ptr TypeEnv) String) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) loaded-modules) module-path))

  (fn env-is-module-loaded ((env (Ptr TypeEnv)) (module-path String))
    (@intent "Check if a module has already been loaded")
    (@spec (((Ptr TypeEnv) String) -> Bool))
    (@pure)
    (@pre (!= env nil))
    (let ((modules (. (deref env) loaded-modules))
          (len (list-len modules))
          (mut found false))
      (for (i 0 len)
        (match (list-get modules i)
          ((some path)
            (when (and (not found) (string-eq path module-path))
              (set! found true)))
          ((none) (do))))
      found))
)
