;; ============================================================
;; Type Checker Environment
;;
;; Manages type environment including:
;; - Type registry (type definitions)
;; - Function registry (signatures)
;; - Import map (local → qualified names)
;; - Scope stack (variable bindings)
;; ============================================================

(module env
  (export
    ;; Core types
    TypeEnv Scope VarBinding ImportEntry
    ;; Environment lifecycle
    env-new env-arena
    ;; Scope management
    env-push-scope env-pop-scope
    ;; Variable bindings
    env-bind-var env-lookup-var
    ;; Constant bindings
    env-register-constant env-lookup-constant
    ;; Type registry
    env-register-type env-lookup-type
    ;; Function registry
    env-register-function env-lookup-function
    ;; Import management
    env-add-import env-resolve-import
    ;; Enum variant management
    env-register-variant env-lookup-variant env-check-variant-collisions
    ;; Module context
    env-set-module env-get-module
    ;; Builtin types
    env-get-int-type env-get-bool-type env-get-string-type
    env-get-unit-type env-get-arena-type
    ;; Type constructors
    env-make-option-type env-make-ptr-type env-make-result-type env-get-generic-type
    ;; Diagnostics
    env-add-warning env-add-error env-get-diagnostics env-clear-diagnostics)

  (import types (ResolvedType ResolvedTypeKind FnSignature
                 Diagnostic DiagnosticLevel diagnostic-new
                 resolved-type-new resolved-type-set-inner))

  ;; ============================================================
  ;; Core Types
  ;; ============================================================

  ;; A variable binding in a scope
  (type VarBinding (record
    (name String)
    (var-type (Ptr ResolvedType))))

  ;; A module-level constant binding
  (type ConstBinding (record
    (name String)
    (const-type (Ptr ResolvedType))))

  ;; An import mapping (local name -> qualified name)
  (type ImportEntry (record
    (local String)
    (qualified String)))

  ;; A scope contains variable bindings
  ;; Scopes are pushed for let, match, for-each, fn bodies
  (type Scope (record
    (bindings (List VarBinding))))

  ;; Maps an enum variant name to its parent enum type name
  (type VariantMapping (record
    (variant-name String)
    (enum-name String)))

  ;; The type environment tracks all type information
  (type TypeEnv (record
    (arena Arena)
    ;; Type definitions: name → ResolvedType
    (types (List (Ptr ResolvedType)))
    ;; Function signatures: name → FnSignature
    (functions (List (Ptr FnSignature)))
    ;; Module-level constants: name → type
    (constants (List ConstBinding))
    ;; Import map: local name → qualified name
    (imports (List ImportEntry))
    ;; Enum variant mappings: variant-name → enum-type-name
    (enum-variants (List VariantMapping))
    ;; Scope stack (innermost first) - store pointers so modifications persist
    (scopes (List (Ptr Scope)))
    ;; Current module name (if inside a module)
    (current-module (Option String))
    ;; Builtin types (cached for fast access)
    (int-type (Ptr ResolvedType))
    (bool-type (Ptr ResolvedType))
    (string-type (Ptr ResolvedType))
    (unit-type (Ptr ResolvedType))
    (arena-type (Ptr ResolvedType))
    ;; Diagnostics (warnings and errors)
    (diagnostics (List Diagnostic))))

  ;; ============================================================
  ;; Environment Lifecycle
  ;; ============================================================

  (fn env-new ((arena Arena))
    (@intent "Create a new type environment with builtins initialized")
    (@spec ((Arena) -> (Ptr TypeEnv)))
    (@alloc arena)
    ;; Create builtin types first
    (let ((int-t (resolved-type-new arena 'rk-primitive "Int" (none) "int64_t"))
          (bool-t (resolved-type-new arena 'rk-primitive "Bool" (none) "bool"))
          (string-t (resolved-type-new arena 'rk-primitive "String" (none) "slop_string_t"))
          (unit-t (resolved-type-new arena 'rk-primitive "Unit" (none) "void"))
          (arena-t (resolved-type-new arena 'rk-primitive "Arena" (none) "slop_arena_t*"))
          (env (cast (Ptr TypeEnv) (arena-alloc arena 256))))
      (set! (deref env) (TypeEnv
        arena
        (list-new arena (Ptr ResolvedType))      ;; types
        (list-new arena (Ptr FnSignature))       ;; functions
        (list-new arena ConstBinding)            ;; constants
        (list-new arena ImportEntry)              ;; imports
        (list-new arena VariantMapping)          ;; enum-variants
        (list-new arena (Ptr Scope))             ;; scopes - store pointers
        (none)                                   ;; current-module
        int-t bool-t string-t unit-t arena-t
        (list-new arena Diagnostic)))            ;; diagnostics
      ;; Register builtin types
      (list-push (. (deref env) types) int-t)
      (list-push (. (deref env) types) bool-t)
      (list-push (. (deref env) types) string-t)
      (list-push (. (deref env) types) unit-t)
      (list-push (. (deref env) types) arena-t)
      ;; Register additional primitive types
      (let ((i8 (resolved-type-new arena 'rk-primitive "I8" (none) "int8_t"))
            (i16 (resolved-type-new arena 'rk-primitive "I16" (none) "int16_t"))
            (i32 (resolved-type-new arena 'rk-primitive "I32" (none) "int32_t"))
            (i64 (resolved-type-new arena 'rk-primitive "I64" (none) "int64_t"))
            (u8 (resolved-type-new arena 'rk-primitive "U8" (none) "uint8_t"))
            (u16 (resolved-type-new arena 'rk-primitive "U16" (none) "uint16_t"))
            (u32 (resolved-type-new arena 'rk-primitive "U32" (none) "uint32_t"))
            (u64 (resolved-type-new arena 'rk-primitive "U64" (none) "uint64_t"))
            (f32 (resolved-type-new arena 'rk-primitive "F32" (none) "float"))
            (f64 (resolved-type-new arena 'rk-primitive "F64" (none) "double")))
        (do
          (list-push (. (deref env) types) i8)
          (list-push (. (deref env) types) i16)
          (list-push (. (deref env) types) i32)
          (list-push (. (deref env) types) i64)
          (list-push (. (deref env) types) u8)
          (list-push (. (deref env) types) u16)
          (list-push (. (deref env) types) u32)
          (list-push (. (deref env) types) u64)
          (list-push (. (deref env) types) f32)
          (list-push (. (deref env) types) f64)))
      env))

  (fn env-arena ((env (Ptr TypeEnv)))
    (@intent "Get the arena from a type environment")
    (@spec (((Ptr TypeEnv)) -> Arena))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) arena))

  ;; ============================================================
  ;; Scope Management
  ;; ============================================================

  (fn env-push-scope ((env (Ptr TypeEnv)))
    (@intent "Push a new empty scope onto the scope stack")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((arena (. (deref env) arena))
          ;; Allocate scope on arena so it persists and we can get a stable pointer
          (scope-ptr (cast (Ptr Scope) (arena-alloc arena 64))))
      (set! (deref scope-ptr) (Scope (list-new arena VarBinding)))
      (list-push (. (deref env) scopes) scope-ptr)))

  (fn env-pop-scope ((env (Ptr TypeEnv)))
    (@intent "Pop the innermost scope from the scope stack")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (@pre (> (list-len (. (deref env) scopes)) 0))
    (let ((_ (list-pop (. (deref env) scopes))))
      (do)))

  ;; ============================================================
  ;; Variable Bindings
  ;; ============================================================

  (fn env-bind-var ((env (Ptr TypeEnv)) (name String) (var-type (Ptr ResolvedType)))
    (@intent "Bind a variable in the current (innermost) scope")
    (@spec (((Ptr TypeEnv) String (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= var-type nil))
    (@pre (> (list-len (. (deref env) scopes)) 0))
    (let ((arena (. (deref env) arena))
          (scopes (. (deref env) scopes))
          (top-idx (- (list-len scopes) 1)))
      ;; scopes is (List (Ptr Scope)), so list-get returns Option (Ptr Scope)
      ;; We get the pointer directly, so modifications persist
      (match (list-get scopes top-idx)
        ((some scope-ptr)
          (list-push (. (deref scope-ptr) bindings) (VarBinding name var-type)))
        ((none) (do)))))

  ;; Helper to search bindings within a single scope
  (fn scope-lookup-var ((scope-ptr (Ptr Scope)) (name String))
    (@intent "Look up a variable in a single scope")
    (@spec (((Ptr Scope) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= scope-ptr nil))
    (let ((bindings (. (deref scope-ptr) bindings))
          (num-bindings (list-len bindings))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (j 0 num-bindings)
        (match (list-get bindings j)
          ((some binding)
            (when (and (not found) (string-eq (. binding name) name))
              (do
                (set! found true)
                (set! result (some (. binding var-type))))))
          ((none) (do))))
      result))

  (fn env-lookup-var ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a variable by name, searching from innermost to outermost scope")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    ;; Search scopes from innermost (end of list) to outermost (start)
    (let ((scopes (. (deref env) scopes))
          (num-scopes (list-len scopes))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 num-scopes)
        (when (not found)
          (let ((scope-idx (- num-scopes 1 i)))
            (match (list-get scopes scope-idx)
              ((some scope-ptr)
                (match (scope-lookup-var scope-ptr name)
                  ((some var-type)
                    (do
                      (set! found true)
                      (set! result (some var-type))))
                  ((none) (do))))
              ((none) (do))))))
      result))

  ;; ============================================================
  ;; Constant Registry
  ;; ============================================================

  (fn env-register-constant ((env (Ptr TypeEnv)) (name String) (const-type (Ptr ResolvedType)))
    (@intent "Register a module-level constant in the environment")
    (@spec (((Ptr TypeEnv) String (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= const-type nil))
    (list-push (. (deref env) constants) (ConstBinding name const-type)))

  (fn env-lookup-constant ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a constant by name")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((constants (. (deref env) constants))
          (len (list-len constants))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (when (not found)
          (match (list-get constants i)
            ((some binding)
              (when (string-eq (. binding name) name)
                (set! found true)
                (set! result (some (. binding const-type)))))
            ((none) (do)))))
      result))

  ;; ============================================================
  ;; Type Registry
  ;; ============================================================

  (fn env-register-type ((env (Ptr TypeEnv)) (t (Ptr ResolvedType)))
    (@intent "Register a type definition in the environment")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= t nil))
    (list-push (. (deref env) types) t))

  (fn env-lookup-type-direct ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a type by name directly (no import resolution)")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((types (. (deref env) types))
          (len (list-len types))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (match (list-get types i)
          ((some t)
            (when (and (not found) (string-eq (. (deref t) name) name))
              (do
                (set! found true)
                (set! result (some t)))))
          ((none) (do))))
      result))

  (fn env-lookup-type ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a type by name, resolving imports if needed")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    ;; First try direct lookup
    (match (env-lookup-type-direct env name)
      ((some t) (some t))
      ((none)
        ;; Try resolving as import
        (match (env-resolve-import env name)
          ((some qualified-name)
            (env-lookup-type-direct env qualified-name))
          ((none) (none))))))

  (fn env-lookup-type-qualified ((env (Ptr TypeEnv)) (module-name String) (type-name String))
    (@intent "Look up a type by module and name")
    (@spec (((Ptr TypeEnv) String String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (@pre (!= env nil))
    (let ((types (. (deref env) types))
          (len (list-len types))
          (mut found false)
          (mut result (Option (Ptr ResolvedType)) (none)))
      (for (i 0 len)
        (match (list-get types i)
          ((some t)
            (when (not found)
              (match (. (deref t) module-name)
                ((some mod)
                  (when (and (string-eq mod module-name) (string-eq (. (deref t) name) type-name))
                    (do
                      (set! found true)
                      (set! result (some t)))))
                ((none) (do)))))
          ((none) (do))))
      result))

  ;; ============================================================
  ;; Function Registry
  ;; ============================================================

  (fn env-register-function ((env (Ptr TypeEnv)) (sig (Ptr FnSignature)))
    (@intent "Register a function signature in the environment")
    (@spec (((Ptr TypeEnv) (Ptr FnSignature)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= sig nil))
    (list-push (. (deref env) functions) sig))

  (fn env-lookup-function-direct ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a function signature by name directly (no import resolution)")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr FnSignature))))
    (@pure)
    (@pre (!= env nil))
    (let ((functions (. (deref env) functions))
          (len (list-len functions))
          (mut found false)
          (mut result (Option (Ptr FnSignature)) (none)))
      (for (i 0 len)
        (match (list-get functions i)
          ((some sig)
            (when (and (not found) (string-eq (. (deref sig) name) name))
              (do
                (set! found true)
                (set! result (some sig)))))
          ((none) (do))))
      result))

  (fn env-lookup-function ((env (Ptr TypeEnv)) (name String))
    (@intent "Look up a function signature by name, resolving imports if needed")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr FnSignature))))
    (@pure)
    (@pre (!= env nil))
    ;; First try direct lookup
    (match (env-lookup-function-direct env name)
      ((some sig) (some sig))
      ((none)
        ;; Try resolving as import
        (match (env-resolve-import env name)
          ((some qualified-name)
            (env-lookup-function-direct env qualified-name))
          ((none) (none))))))

  ;; ============================================================
  ;; Import Management
  ;; ============================================================

  (fn env-add-import ((env (Ptr TypeEnv)) (local-name String) (qualified-name String))
    (@intent "Add an import mapping from local name to qualified name")
    (@spec (((Ptr TypeEnv) String String) -> Unit))
    (@pre (!= env nil))
    ;; Store import as ImportEntry
    (list-push (. (deref env) imports)
      (ImportEntry local-name qualified-name)))

  (fn env-resolve-import ((env (Ptr TypeEnv)) (local-name String))
    (@intent "Resolve a local import name to its qualified name")
    (@spec (((Ptr TypeEnv) String) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (let ((imports (. (deref env) imports))
          (len (list-len imports))
          (mut found false)
          (mut result (Option String) (none)))
      (for (i 0 len)
        (match (list-get imports i)
          ((some entry)
            (when (and (not found) (string-eq (. entry local) local-name))
              (do
                (set! found true)
                (set! result (some (. entry qualified))))))
          ((none) (do))))
      result))

  ;; ============================================================
  ;; Enum Variant Management
  ;; ============================================================

  (fn env-register-variant ((env (Ptr TypeEnv)) (variant-name String) (enum-name String))
    (@intent "Register an enum variant with its parent enum type")
    (@spec (((Ptr TypeEnv) String String) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) enum-variants)
      (VariantMapping variant-name enum-name)))

  (fn env-lookup-variant ((env (Ptr TypeEnv)) (variant-name String))
    (@intent "Look up which enum type contains a variant")
    (@spec (((Ptr TypeEnv) String) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (let ((variants (. (deref env) enum-variants))
          (len (list-len variants))
          (mut found false)
          (mut result (Option String) (none)))
      (for (i 0 len)
        (match (list-get variants i)
          ((some v)
            (when (and (not found) (string-eq (. v variant-name) variant-name))
              (set! found true)
              (set! result (some (. v enum-name)))))
          ((none) (do))))
      result))

  (fn env-check-variant-collisions ((env (Ptr TypeEnv)))
    (@intent "Check for enum variants that appear in multiple enum types and emit errors")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((variants (. (deref env) enum-variants))
          (len (list-len variants))
          (arena (. (deref env) arena)))
      ;; For each variant, check if any later variant has the same name but different enum
      (for (i 0 len)
        (match (list-get variants i)
          ((some v1)
            (let ((name1 (. v1 variant-name))
                  (enum1 (. v1 enum-name))
                  (mut found-collision false)
                  (mut collision-enum String ""))
              ;; Check against all later variants for collision
              (for (j (+ i 1) len)
                (match (list-get variants j)
                  ((some v2)
                    (when (and (not found-collision)
                               (and (string-eq (. v2 variant-name) name1)
                                    (not (string-eq (. v2 enum-name) enum1))))
                      (set! found-collision true)
                      (set! collision-enum (. v2 enum-name))))
                  ((none) (do))))
              ;; Emit error if collision found
              (when found-collision
                (let ((msg (string-concat arena "Ambiguous enum variant '"
                             (string-concat arena name1
                               (string-concat arena "' exists in multiple types: "
                                 (string-concat arena enum1
                                   (string-concat arena ", " collision-enum)))))))
                  (env-add-error env msg 0 0)))))
          ((none) (do))))))

  ;; ============================================================
  ;; Module Context
  ;; ============================================================

  (fn env-set-module ((env (Ptr TypeEnv)) (module-name (Option String)))
    (@intent "Set the current module context")
    (@spec (((Ptr TypeEnv) (Option String)) -> Unit))
    (@pre (!= env nil))
    (set! (. (deref env) current-module) module-name))

  (fn env-get-module ((env (Ptr TypeEnv)))
    (@intent "Get the current module name")
    (@spec (((Ptr TypeEnv)) -> (Option String)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) current-module))

  ;; ============================================================
  ;; Builtin Type Accessors
  ;; ============================================================

  (fn env-get-int-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Int type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) int-type))

  (fn env-get-bool-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Bool type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) bool-type))

  (fn env-get-string-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin String type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) string-type))

  (fn env-get-unit-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Unit type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) unit-type))

  (fn env-get-arena-type ((env (Ptr TypeEnv)))
    (@intent "Get the builtin Arena type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pure)
    (@pre (!= env nil))
    (@post (!= $result nil))
    (. (deref env) arena-type))

  ;; ============================================================
  ;; Type Constructors
  ;; ============================================================

  (fn env-make-option-type ((env (Ptr TypeEnv)) (inner-type (Ptr ResolvedType)))
    (@intent "Create an Option type with the given inner type")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena))
          (inner-name (if (!= inner-type nil)
                        (. (deref inner-type) name)
                        "T"))
          (opt-name (string-concat arena "Option_" inner-name))
          (opt-type (resolved-type-new arena 'rk-option opt-name (none) opt-name)))
      ;; Set the inner type using helper function (avoids transpiler type inference issues)
      (resolved-type-set-inner opt-type inner-type)
      opt-type))

  (fn env-make-ptr-type ((env (Ptr TypeEnv)) (inner-type (Ptr ResolvedType)))
    (@intent "Create a Ptr type with the given inner type")
    (@spec (((Ptr TypeEnv) (Ptr ResolvedType)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena))
          (inner-name (if (!= inner-type nil)
                        (. (deref inner-type) name)
                        "Void"))
          (ptr-name (string-concat arena "Ptr_" inner-name))
          (ptr-type (resolved-type-new arena 'rk-ptr ptr-name (none) ptr-name)))
      (resolved-type-set-inner ptr-type inner-type)
      ptr-type))

  (fn env-get-generic-type ((env (Ptr TypeEnv)))
    (@intent "Get a generic type 'T' that matches any other type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena)))
      (resolved-type-new arena 'rk-primitive "T" (none) "void*")))

  (fn env-make-result-type ((env (Ptr TypeEnv)))
    (@intent "Create a generic Result type")
    (@spec (((Ptr TypeEnv)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@post (!= $result nil))
    (let ((arena (. (deref env) arena)))
      (resolved-type-new arena 'rk-union "Result" (none) "Result")))

  ;; ============================================================
  ;; Diagnostics
  ;; ============================================================

  (fn env-add-warning ((env (Ptr TypeEnv)) (message String) (line Int) (col Int))
    (@intent "Add a warning diagnostic to the environment")
    (@spec (((Ptr TypeEnv) String Int Int) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) diagnostics)
      (diagnostic-new 'diag-warning message line col)))

  (fn env-add-error ((env (Ptr TypeEnv)) (message String) (line Int) (col Int))
    (@intent "Add an error diagnostic to the environment")
    (@spec (((Ptr TypeEnv) String Int Int) -> Unit))
    (@pre (!= env nil))
    (list-push (. (deref env) diagnostics)
      (diagnostic-new 'diag-error message line col)))

  (fn env-get-diagnostics ((env (Ptr TypeEnv)))
    (@intent "Get all diagnostics collected during type checking")
    (@spec (((Ptr TypeEnv)) -> (List Diagnostic)))
    (@pure)
    (@pre (!= env nil))
    (. (deref env) diagnostics))

  (fn env-clear-diagnostics ((env (Ptr TypeEnv)))
    (@intent "Clear all diagnostics from the environment")
    (@spec (((Ptr TypeEnv)) -> Unit))
    (@pre (!= env nil))
    (let ((arena (. (deref env) arena)))
      (set! (. (deref env) diagnostics) (list-new arena Diagnostic))))
)
