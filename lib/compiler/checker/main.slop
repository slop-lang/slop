;; ============================================================
;; Type Checker - Main Entry Point
;;
;; Orchestrates the type checking pipeline:
;; 1. Collect type definitions
;; 2. Resolve imports
;; 3. Infer expression types
;;
;; Supports multi-file builds with shared type environment.
;; Outputs JSON with per-module diagnostics.
;; ============================================================

(module checker
  (export
    type-check type-check-with-env TypeCheckResult (main 2))

  (import parser (SExpr parse is-form
                  sexpr-is-list sexpr-list-get sexpr-list-len sexpr-get-symbol-name
                  sexpr-line sexpr-col))
  (import types (TypeError TypeErrorKind type-error-new
                 Diagnostic DiagnosticLevel ResolvedType ResolvedTypeKind
                 ResolvedVariant ResolvedField RangeBounds FnSignature ParamInfo
                 resolved-type-to-slop-string))
  (import env (TypeEnv env-new env-get-diagnostics env-clear-diagnostics
               env-arena env-push-scope env-pop-scope env-bind-var
               env-lookup-type env-get-int-type env-get-bool-type
               env-get-string-type env-get-unit-type env-get-arena-type
               env-set-module env-add-error env-clear-imports
               env-get-types env-get-functions env-get-constants
               ConstBinding))
  (import collect (collect-module))
  (import resolve (resolve-imports))
  (import infer (infer-fn-body infer-expr resolve-complex-type-expr resolve-simple-type))
  (import file (FileMode FileError File
                file-open file-close file-read-all))
  (import strlib (cstring-to-string))

  ;; FFI for stdio functions
  (ffi "stdio.h"
    (putchar ((c Int)) Int))

  ;; FFI for string functions
  (ffi "string.h"
    (strlen ((s (Ptr U8))) U64))

  ;; ============================================================
  ;; Output Format
  ;; ============================================================

  (type OutputFormat (enum fmt-text fmt-json))

  ;; ============================================================
  ;; Result Type
  ;; ============================================================

  (type TypeCheckResult (Result (Ptr TypeEnv) TypeError))

  ;; ============================================================
  ;; Main Entry Point
  ;; ============================================================

  (fn type-check ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Type check an AST and return populated type environment")
    (@spec ((Arena (List (Ptr SExpr))) -> TypeCheckResult))
    (@alloc arena)
    (@pre (> (list-len ast) 0))
    ;; Create type environment with builtins
    (let ((env (env-new arena)))
      ;; Phase 1: Collect all type and function definitions
      (collect-module env ast)
      ;; Phase 2: Resolve imports
      (resolve-imports env ast)
      ;; Phase 3: Type check function bodies
      (check-all-functions env ast)
      ;; Return populated environment
      (ok env)))

  (fn type-check-with-env ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Type check an AST using existing environment (for multi-module)")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (@pre (> (list-len ast) 0))
    ;; Phase 1: Collect all type and function definitions
    (collect-module env ast)
    ;; Phase 2: Resolve imports
    (resolve-imports env ast)
    ;; Phase 3: Type check function bodies
    (check-all-functions env ast))

  (fn check-all-functions ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Type check all function bodies in the AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ;; Direct function at top level
              ((is-form expr "fn")
                (let ((_ (infer-fn-body env expr)))
                  (do)))
              ;; Module - check functions inside
              ((is-form expr "module")
                (check-module-functions env expr))
              (else (do))))
          ((none) (do))))))

  (fn is-annotation-form ((item (Ptr SExpr)))
    (@intent "Check if item starts with @ symbol")
    (@spec (((Ptr SExpr)) -> Bool))
    (if (sexpr-is-list item)
      (match (sexpr-list-get item 0)
        ((some head)
          (cast Bool (let ((name (sexpr-get-symbol-name head)))
                       (if (> (. name len) 0)
                         (= (@ (. name data) 0) 64)
                         false))))
        ((none) false))
      false))

  (fn is-valid-toplevel-form ((item (Ptr SExpr)))
    (@intent "Check if item is a valid top-level form")
    (@spec (((Ptr SExpr)) -> Bool))
    (cond
      ((is-form item "fn") true)
      ((is-form item "type") true)
      ((is-form item "const") true)
      ((is-form item "ffi") true)
      ((is-form item "ffi-struct") true)
      ((is-form item "import") true)
      ((is-form item "export") true)
      ((is-annotation-form item) true)
      (else false)))

  (fn get-form-name ((item (Ptr SExpr)))
    (@intent "Get the head symbol name of a form, or <unknown>")
    (@spec (((Ptr SExpr)) -> String))
    (if (sexpr-is-list item)
      (match (sexpr-list-get item 0)
        ((some head) (sexpr-get-symbol-name head))
        ((none) "<empty>"))
      "<non-list>"))

  (fn check-module-functions ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Type check all function bodies inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (when (sexpr-is-list module-form)
      ;; Extract and set module name from position 1
      (match (sexpr-list-get module-form 1)
        ((some name-expr)
          (let ((mod-name (sexpr-get-symbol-name name-expr)))
            (when (not (string-eq mod-name ""))
              (env-set-module env (some mod-name)))))
        ((none) (do)))
      (let ((len (sexpr-list-len module-form)))
        ;; Skip module name and export, start at index 2
        (for (i 2 len)
          (match (sexpr-list-get module-form i)
            ((some item)
              (cond
                ((is-form item "fn")
                  (let ((_ (infer-fn-body env item)))
                    (do)))
                ((is-valid-toplevel-form item) (do))
                (else
                  (let ((arena (env-arena env))
                        (msg (string-concat arena "Unknown top-level form: " (get-form-name item))))
                    (env-add-error env msg (sexpr-line item) (sexpr-col item))))))
            ((none) (do)))))))

  ;; ============================================================
  ;; Output Helpers
  ;; ============================================================

  (fn print-str ((s (Ptr U8)))
    (@intent "Print null-terminated C string to stdout")
    (@spec (((Ptr U8)) -> Unit))
    (@pre (!= s nil))
    (let ((mut i 0))
      (while (!= (@ s i) 0)
        (putchar (cast Int (@ s i)))
        (set! i (+ i 1))))
    (do))

  (fn print-string ((s String))
    (@intent "Print String to stdout")
    (@spec ((String) -> Unit))
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut i 0))
      (while (< i len)
        (putchar (cast Int (@ data i)))
        (set! i (+ i 1))))
    (do))

  (fn print-json-string ((arena Arena) (s String))
    (@intent "Print JSON-escaped string with quotes")
    (@spec ((Arena String) -> Unit))
    ;; Print opening quote
    (putchar 34)  ;; "
    ;; Escape and print content
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut i 0))
      (while (< i len)
        (let ((c (cast Int (@ data i))))
          (cond
            ((== c 34)   ;; " -> \"
              (putchar 92)
              (putchar 34))
            ((== c 92)   ;; \ -> \\
              (putchar 92)
              (putchar 92))
            ((== c 10)   ;; \n -> \n
              (putchar 92)
              (putchar 110))
            ((== c 13)   ;; \r -> \r
              (putchar 92)
              (putchar 114))
            ((== c 9)    ;; \t -> \t
              (putchar 92)
              (putchar 116))
            (else
              (putchar c))))
        (set! i (+ i 1))))
    ;; Print closing quote
    (putchar 34)
    (do))

  ;; ============================================================
  ;; Module Name Extraction
  ;; ============================================================

  (fn extract-module-name ((exprs (List (Ptr SExpr))))
    (@intent "Extract module name from parsed expressions")
    (@spec (((List (Ptr SExpr))) -> String))
    ;; Look for (module name ...) in first expression
    (if (< (list-len exprs) 1)
      "unknown"
      (match (list-get exprs 0)
        ((some first-expr)
          (match (deref first-expr)
            ((lst lst)
              (let ((items (. lst items)))
                (if (< (list-len items) 2)
                  "unknown"
                  (match (list-get items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym)
                          (if (string-eq (. sym name) "module")
                            (match (list-get items 1)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((sym name-sym) (. name-sym name))
                                  (_ "unknown")))
                              ((none) "unknown"))
                            "unknown"))
                        (_ "unknown")))
                    ((none) "unknown")))))
            (_ "unknown")))
        ((none) "unknown"))))

  ;; ============================================================
  ;; Diagnostic Printing (for stderr)
  ;; ============================================================

  (fn print-diagnostic ((arena Arena) (filename String) (diag Diagnostic))
    (@intent "Print a diagnostic message with location info")
    (@spec ((Arena String Diagnostic) -> Unit))
    (print filename)
    (print ":")
    (print (. diag line))
    (print ":")
    (print (. diag col))
    (print ": ")
    (match (. diag level)
      ('diag-warning (print "warning: "))
      ('diag-error (print "error: ")))
    (println (. diag message)))

  (fn output-diagnostics-text ((arena Arena) (filename String) (diagnostics (List Diagnostic)))
    (@intent "Output diagnostics in human-readable text format")
    (@spec ((Arena String (List Diagnostic)) -> Unit))
    (let ((len (list-len diagnostics))
          (mut i 0))
      (while (< i len)
        (match (list-get diagnostics i)
          ((some diag) (print-diagnostic arena filename diag))
          ((none) (do)))
        (set! i (+ i 1))))
    (do))

  ;; ============================================================
  ;; JSON Output for Multi-Module
  ;; ============================================================

  (fn output-diagnostics-json ((arena Arena) (diagnostics (List Diagnostic)))
    (@intent "Output diagnostics as JSON array")
    (@spec ((Arena (List Diagnostic)) -> Unit))
    ;; Output array opening
    (putchar 91)  ;; [
    (let ((len (list-len diagnostics))
          (mut i 0))
      (while (< i len)
        (when (> i 0)
          (putchar 44))  ;; ,
        (match (list-get diagnostics i)
          ((some diag)
            (output-single-diagnostic-json arena diag))
          ((none) (do)))
        (set! i (+ i 1))))
    (putchar 93)  ;; ]
    (do))

  (fn output-single-diagnostic-json ((arena Arena) (diag Diagnostic))
    (@intent "Output a single diagnostic as JSON object")
    (@spec ((Arena Diagnostic) -> Unit))
    (putchar 123)  ;; {
    ;; level
    (print-str (cast (Ptr U8) "\"level\":"))
    (match (. diag level)
      ('diag-warning (print-str (cast (Ptr U8) "\"warning\"")))
      ('diag-error (print-str (cast (Ptr U8) "\"error\""))))
    (putchar 44)  ;; ,
    ;; line
    (print-str (cast (Ptr U8) "\"line\":"))
    (print-string (int-to-string arena (. diag line)))
    (putchar 44)  ;; ,
    ;; col
    (print-str (cast (Ptr U8) "\"col\":"))
    (print-string (int-to-string arena (. diag col)))
    (putchar 44)  ;; ,
    ;; message
    (print-str (cast (Ptr U8) "\"message\":"))
    (print-json-string arena (. diag message))
    (putchar 125)  ;; }
    (do))

  (fn output-module-json ((arena Arena) (env (Ptr TypeEnv)) (mod-name String) (diagnostics (List Diagnostic)) (first Bool) (emit-types Bool))
    (@intent "Output JSON for a single module's diagnostics and optionally type info")
    (@spec ((Arena (Ptr TypeEnv) String (List Diagnostic) Bool Bool) -> Unit))
    ;; Add comma if not first
    (when (not first)
      (putchar 44))  ;; ,
    ;; Output: "mod-name": {"diagnostics": [...], "types": [...], ...}
    (print-json-string arena mod-name)
    (putchar 58)   ;; :
    (putchar 123)  ;; {
    (print-str (cast (Ptr U8) "\"diagnostics\":"))
    (output-diagnostics-json arena diagnostics)
    (when emit-types
      (putchar 44)  ;; ,
      (output-types-json arena mod-name (env-get-types env))
      (putchar 44)  ;; ,
      (output-functions-json arena mod-name (env-get-functions env))
      (putchar 44)  ;; ,
      (output-constants-json arena mod-name (env-get-constants env)))
    (putchar 125)  ;; }
    (do))

  ;; ============================================================
  ;; Type Info JSON Serialization (--emit-types)
  ;; ============================================================

  ;; Helper: check if a type belongs to a module
  (fn type-belongs-to-module ((t (Ptr ResolvedType)) (mod-name String))
    (@intent "Check if a resolved type belongs to the given module")
    (@spec (((Ptr ResolvedType) String) -> Bool))
    (@pure)
    (@pre (!= t nil))
    (match (. (deref t) module-name)
      ((some m) (string-eq m mod-name))
      ((none) false)))

  ;; Helper: check if a function belongs to a module
  (fn fn-belongs-to-module ((sig (Ptr FnSignature)) (mod-name String))
    (@intent "Check if a function signature belongs to the given module")
    (@spec (((Ptr FnSignature) String) -> Bool))
    (@pure)
    (@pre (!= sig nil))
    (match (. (deref sig) module-name)
      ((some m) (string-eq m mod-name))
      ((none) false)))

  ;; Helper: check if a constant belongs to a module
  (fn const-belongs-to-module ((binding ConstBinding) (mod-name String))
    (@intent "Check if a constant binding belongs to the given module")
    (@spec ((ConstBinding String) -> Bool))
    (@pure)
    (match (. binding module-name)
      ((some m) (string-eq m mod-name))
      ((none) false)))

  ;; Helper: convert ResolvedTypeKind to JSON string
  (fn resolved-kind-to-json-string ((kind ResolvedTypeKind))
    (@intent "Convert a ResolvedTypeKind to its JSON string value")
    (@spec ((ResolvedTypeKind) -> (Ptr U8)))
    (@pure)
    (match kind
      ('rk-primitive (cast (Ptr U8) "\"primitive\""))
      ('rk-range (cast (Ptr U8) "\"range\""))
      ('rk-record (cast (Ptr U8) "\"record\""))
      ('rk-union (cast (Ptr U8) "\"union\""))
      ('rk-enum (cast (Ptr U8) "\"enum\""))
      ('rk-list (cast (Ptr U8) "\"list\""))
      ('rk-ptr (cast (Ptr U8) "\"ptr\""))
      ('rk-option (cast (Ptr U8) "\"option\""))
      ('rk-result (cast (Ptr U8) "\"result\""))
      ('rk-function (cast (Ptr U8) "\"function\""))
      ('rk-array (cast (Ptr U8) "\"array\""))
      ('rk-map (cast (Ptr U8) "\"map\""))
      (else (cast (Ptr U8) "\"unknown\""))))

  ;; Output "types": [...] for types belonging to the current module
  (fn output-types-json ((arena Arena) (mod-name String) (types (List (Ptr ResolvedType))))
    (@intent "Output types array as JSON for a module")
    (@spec ((Arena String (List (Ptr ResolvedType))) -> Unit))
    (print-str (cast (Ptr U8) "\"types\":"))
    (putchar 91)  ;; [
    (let ((len (list-len types))
          (mut first true))
      (for (i 0 len)
        (match (list-get types i)
          ((some t)
            (when (type-belongs-to-module t mod-name)
              (when (not first)
                (putchar 44))  ;; ,
              (output-type-json arena t)
              (set! first false)))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output a single type as JSON object
  (fn output-type-json ((arena Arena) (t (Ptr ResolvedType)))
    (@intent "Output a single resolved type as JSON")
    (@spec ((Arena (Ptr ResolvedType)) -> Unit))
    (@pre (!= t nil))
    (let ((kind (. (deref t) kind))
          (name (. (deref t) name)))
      (putchar 123)  ;; {
      ;; "name": "..."
      (print-str (cast (Ptr U8) "\"name\":"))
      (print-json-string arena name)
      (putchar 44)  ;; ,
      ;; "kind": "..."
      (print-str (cast (Ptr U8) "\"kind\":"))
      (print-str (resolved-kind-to-json-string kind))
      ;; Kind-specific fields
      (match kind
        ('rk-enum
          (putchar 44)  ;; ,
          (output-enum-variants-json arena (. (deref t) variants)))
        ('rk-record
          (putchar 44)  ;; ,
          (output-record-fields-json arena (. (deref t) fields)))
        ('rk-union
          (putchar 44)  ;; ,
          (output-union-variants-json arena (. (deref t) variants)))
        ('rk-range
          (match (. (deref t) range)
            ((some bounds)
              (do
                (putchar 44)  ;; ,
                (print-str (cast (Ptr U8) "\"min\":"))
                (print-string (int-to-string arena (cast Int (. bounds min-val))))
                (putchar 44)  ;; ,
                (print-str (cast (Ptr U8) "\"max\":"))
                (print-string (int-to-string arena (cast Int (. bounds max-val))))))
            ((none) (do))))
        ('rk-ptr
          (match (. (deref t) inner-type)
            ((some inner)
              (do
                (putchar 44)  ;; ,
                (print-str (cast (Ptr U8) "\"target\":"))
                (print-json-string arena (resolved-type-to-slop-string arena inner))))
            ((none) (do))))
        ('rk-option
          (match (. (deref t) inner-type)
            ((some inner)
              (do
                (putchar 44)  ;; ,
                (print-str (cast (Ptr U8) "\"inner\":"))
                (print-json-string arena (resolved-type-to-slop-string arena inner))))
            ((none) (do))))
        ('rk-list
          (match (. (deref t) inner-type)
            ((some inner)
              (do
                (putchar 44)  ;; ,
                (print-str (cast (Ptr U8) "\"inner\":"))
                (print-json-string arena (resolved-type-to-slop-string arena inner))))
            ((none) (do))))
        ('rk-result
          (do
            (match (. (deref t) inner-type)
              ((some ok-type)
                (do
                  (putchar 44)  ;; ,
                  (print-str (cast (Ptr U8) "\"ok-type\":"))
                  (print-json-string arena (resolved-type-to-slop-string arena ok-type))))
              ((none) (do)))
            (match (. (deref t) inner-type2)
              ((some err-type)
                (do
                  (putchar 44)  ;; ,
                  (print-str (cast (Ptr U8) "\"err-type\":"))
                  (print-json-string arena (resolved-type-to-slop-string arena err-type))))
              ((none) (do)))))
        (else (do)))
      (putchar 125)  ;; }
      (do)))

  ;; Output enum variants as "variants": ["v1", "v2", ...]
  (fn output-enum-variants-json ((arena Arena) (variants (List ResolvedVariant)))
    (@intent "Output enum variants as JSON array of strings")
    (@spec ((Arena (List ResolvedVariant)) -> Unit))
    (print-str (cast (Ptr U8) "\"variants\":"))
    (putchar 91)  ;; [
    (let ((len (list-len variants))
          (mut first true))
      (for (i 0 len)
        (match (list-get variants i)
          ((some v)
            (when (not first)
              (putchar 44))  ;; ,
            (print-json-string arena (. v name))
            (set! first false))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output record fields as "fields": [{"name":"...", "type":"...", "is-pointer": true/false}, ...]
  (fn output-record-fields-json ((arena Arena) (fields (List ResolvedField)))
    (@intent "Output record fields as JSON array")
    (@spec ((Arena (List ResolvedField)) -> Unit))
    (print-str (cast (Ptr U8) "\"fields\":"))
    (putchar 91)  ;; [
    (let ((len (list-len fields))
          (mut first true))
      (for (i 0 len)
        (match (list-get fields i)
          ((some f)
            (when (not first)
              (putchar 44))  ;; ,
            (putchar 123)  ;; {
            (print-str (cast (Ptr U8) "\"name\":"))
            (print-json-string arena (. f name))
            (putchar 44)  ;; ,
            (print-str (cast (Ptr U8) "\"type\":"))
            (print-json-string arena (resolved-type-to-slop-string arena (. f field-type)))
            (putchar 44)  ;; ,
            (print-str (cast (Ptr U8) "\"is-pointer\":"))
            (if (== (. (deref (. f field-type)) kind) 'rk-ptr)
              (print-str (cast (Ptr U8) "true"))
              (print-str (cast (Ptr U8) "false")))
            (putchar 125)  ;; }
            (set! first false))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output union variants as "variants": [{"name":"...", "type":"..."}, ...]
  (fn output-union-variants-json ((arena Arena) (variants (List ResolvedVariant)))
    (@intent "Output union variants as JSON array of objects with name and type")
    (@spec ((Arena (List ResolvedVariant)) -> Unit))
    (print-str (cast (Ptr U8) "\"variants\":"))
    (putchar 91)  ;; [
    (let ((len (list-len variants))
          (mut first true))
      (for (i 0 len)
        (match (list-get variants i)
          ((some v)
            (when (not first)
              (putchar 44))  ;; ,
            (putchar 123)  ;; {
            (print-str (cast (Ptr U8) "\"name\":"))
            (print-json-string arena (. v name))
            (match (. v payload-type)
              ((some pt)
                (do
                  (putchar 44)  ;; ,
                  (print-str (cast (Ptr U8) "\"type\":"))
                  (print-json-string arena (resolved-type-to-slop-string arena pt))))
              ((none) (do)))
            (putchar 125)  ;; }
            (set! first false))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output "functions": [...] for functions belonging to the current module
  (fn output-functions-json ((arena Arena) (mod-name String) (functions (List (Ptr FnSignature))))
    (@intent "Output functions array as JSON for a module")
    (@spec ((Arena String (List (Ptr FnSignature))) -> Unit))
    (print-str (cast (Ptr U8) "\"functions\":"))
    (putchar 91)  ;; [
    (let ((len (list-len functions))
          (mut first true))
      (for (i 0 len)
        (match (list-get functions i)
          ((some sig)
            (when (fn-belongs-to-module sig mod-name)
              (when (not first)
                (putchar 44))  ;; ,
              (output-fn-json arena sig)
              (set! first false)))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output a single function signature as JSON
  (fn output-fn-json ((arena Arena) (sig (Ptr FnSignature)))
    (@intent "Output a single function signature as JSON")
    (@spec ((Arena (Ptr FnSignature)) -> Unit))
    (@pre (!= sig nil))
    (putchar 123)  ;; {
    ;; "name": "..."
    (print-str (cast (Ptr U8) "\"name\":"))
    (print-json-string arena (. (deref sig) name))
    (putchar 44)  ;; ,
    ;; "params": [...]
    (print-str (cast (Ptr U8) "\"params\":"))
    (output-fn-params-json arena (. (deref sig) params))
    (putchar 44)  ;; ,
    ;; "return-type": "..."
    (print-str (cast (Ptr U8) "\"return-type\":"))
    (print-json-string arena (resolved-type-to-slop-string arena (. (deref sig) return-type)))
    (putchar 44)  ;; ,
    ;; "returns-pointer": true/false
    (print-str (cast (Ptr U8) "\"returns-pointer\":"))
    (if (== (. (deref (. (deref sig) return-type)) kind) 'rk-ptr)
      (print-str (cast (Ptr U8) "true"))
      (print-str (cast (Ptr U8) "false")))
    (putchar 44)  ;; ,
    ;; "returns-string": true/false
    (print-str (cast (Ptr U8) "\"returns-string\":"))
    (if (string-eq (. (deref (. (deref sig) return-type)) name) "String")
      (print-str (cast (Ptr U8) "true"))
      (print-str (cast (Ptr U8) "false")))
    (putchar 125)  ;; }
    (do))

  ;; Output function params as JSON array
  (fn output-fn-params-json ((arena Arena) (params (List ParamInfo)))
    (@intent "Output function parameters as JSON array")
    (@spec ((Arena (List ParamInfo)) -> Unit))
    (putchar 91)  ;; [
    (let ((len (list-len params))
          (mut first true))
      (for (i 0 len)
        (match (list-get params i)
          ((some p)
            (when (not first)
              (putchar 44))  ;; ,
            (putchar 123)  ;; {
            (print-str (cast (Ptr U8) "\"name\":"))
            (print-json-string arena (. p name))
            (putchar 44)  ;; ,
            (print-str (cast (Ptr U8) "\"type\":"))
            (print-json-string arena (resolved-type-to-slop-string arena (. p param-type)))
            (putchar 125)  ;; }
            (set! first false))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; Output "constants": [...] for constants belonging to the current module
  (fn output-constants-json ((arena Arena) (mod-name String) (constants (List ConstBinding)))
    (@intent "Output constants array as JSON for a module")
    (@spec ((Arena String (List ConstBinding)) -> Unit))
    (print-str (cast (Ptr U8) "\"constants\":"))
    (putchar 91)  ;; [
    (let ((len (list-len constants))
          (mut first true))
      (for (i 0 len)
        (match (list-get constants i)
          ((some binding)
            (when (const-belongs-to-module binding mod-name)
              (when (not first)
                (putchar 44))  ;; ,
              (putchar 123)  ;; {
              (print-str (cast (Ptr U8) "\"name\":"))
              (print-json-string arena (. binding name))
              (putchar 44)  ;; ,
              (print-str (cast (Ptr U8) "\"type\":"))
              (print-json-string arena (resolved-type-to-slop-string arena (. binding const-type)))
              (putchar 125)  ;; }
              (set! first false)))
          ((none) (do)))))
    (putchar 93)  ;; ]
    (do))

  ;; ============================================================
  ;; Single File Processing
  ;; ============================================================

  (fn check-single-file ((env (Ptr TypeEnv)) (arena Arena) (filename (Ptr U8)) (format OutputFormat) (first Bool) (emit-types Bool))
    (@intent "Type check a single file using shared environment")
    (@spec (((Ptr TypeEnv) Arena (Ptr U8) OutputFormat Bool Bool) -> Int))
    (@pre (!= env nil))
    (@pre (!= filename nil))
    (let ((filename-str (cstring-to-string filename)))
      (match (file-open filename-str 'read)
        ((error e)
          (do
            (print "Error: Could not open file: ")
            (println filename-str)
            1))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error e)
              (do
                (file-close (addr f))
                (print "Error: Could not read file: ")
                (println filename-str)
                1))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok ast)
                    (let ((mod-name (extract-module-name ast)))
                      ;; Clear imports and diagnostics before checking this module
                      (env-clear-imports env)
                      (env-clear-diagnostics env)
                      ;; Type check with shared env
                      (type-check-with-env env ast)
                      ;; Get diagnostics for this module
                      (let ((diagnostics (env-get-diagnostics env)))
                        ;; Output based on format
                        (when (== format 'fmt-json)
                          (output-module-json arena env mod-name diagnostics first emit-types))
                        (when (== format 'fmt-text)
                          (output-diagnostics-text arena filename-str diagnostics))
                        ;; Return error count
                        (count-errors diagnostics))))
                  ((error parse-err)
                    (do
                      (print filename-str)
                      (print ":")
                      (print (. parse-err line))
                      (print ":")
                      (print (. parse-err col))
                      (print ": error: ")
                      (println (. parse-err message))
                      1))))))))))

  (fn count-errors ((diagnostics (List Diagnostic)))
    (@intent "Count number of error diagnostics")
    (@spec (((List Diagnostic)) -> Int))
    (let ((len (list-len diagnostics))
          (mut errors 0)
          (mut i 0))
      (while (< i len)
        (match (list-get diagnostics i)
          ((some diag)
            (match (. diag level)
              ('diag-error (set! errors (+ errors 1)))
              ('diag-warning (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      errors))

  ;; ============================================================
  ;; Argv Helper
  ;; ============================================================

  (fn argv-to-string ((argv (Ptr (Ptr U8))) (index Int))
    (@intent "Convert argv[index] to String")
    (@spec (((Ptr (Ptr U8)) Int) -> String))
    (let ((ptr (@ argv index)))
      (String ptr (strlen ptr))))

  ;; ============================================================
  ;; Expression Mode Support
  ;; ============================================================

  (fn resolve-type-string ((env (Ptr TypeEnv)) (arena Arena) (type-str String))
    (@intent "Parse a type string and resolve it to a ResolvedType")
    (@spec (((Ptr TypeEnv) Arena String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (parse arena type-str)
      ((ok type-ast)
        (if (== (list-len type-ast) 0)
          (env-get-int-type env)
          (match (list-get type-ast 0)
            ((some type-expr)
              (if (sexpr-is-list type-expr)
                (resolve-complex-type-expr env type-expr)
                (let ((name (sexpr-get-symbol-name type-expr)))
                  (if (string-eq name "")
                    (env-get-int-type env)
                    (resolve-simple-type env name)))))
            ((none) (env-get-int-type env)))))
      ((error _) (env-get-int-type env))))

  (fn parse-and-bind-params ((env (Ptr TypeEnv)) (arena Arena) (params-str String))
    (@intent "Parse a params string like '((a Int) (b String))' and bind to env")
    (@spec (((Ptr TypeEnv) Arena String) -> Unit))
    (@pre (!= env nil))
    (match (parse arena params-str)
      ((ok params-ast)
        (when (> (list-len params-ast) 0)
          (match (list-get params-ast 0)
            ((some params-list)
              ;; params-list is ((a Int) (b String) ...)
              (match (deref params-list)
                ((lst lst)
                  (let ((items (. lst items))
                        (len (list-len items)))
                    (for (i 0 len)
                      (match (list-get items i)
                        ((some param)
                          ;; param is (name Type)
                          (match (deref param)
                            ((lst param-lst)
                              (let ((param-items (. param-lst items)))
                                (when (>= (list-len param-items) 2)
                                  (match (list-get param-items 0)
                                    ((some name-expr)
                                      (match (deref name-expr)
                                        ((sym name-sym)
                                          (let ((param-name (. name-sym name)))
                                            (match (list-get param-items 1)
                                              ((some type-expr)
                                                (match (deref type-expr)
                                                  ((sym type-sym)
                                                    (let ((param-type (resolve-type-string env arena (. type-sym name))))
                                                      (env-bind-var env param-name param-type)))
                                                  ;; Complex type like (Ptr User), (Option Int)
                                                  ((lst _)
                                                    (let ((param-type (resolve-complex-type-expr env type-expr)))
                                                      (env-bind-var env param-name param-type)))
                                                  (_ (env-bind-var env param-name (env-get-int-type env)))))
                                              ((none) (do)))))
                                        (_ (do))))
                                    ((none) (do))))))
                            (_ (do))))
                        ((none) (do))))))
                (_ (do))))
            ((none) (do)))))
      ((error _) (do))))

  (fn types-names-equal ((a (Ptr ResolvedType)) (b (Ptr ResolvedType)))
    (@intent "Check if two types are structurally equal")
    (@spec (((Ptr ResolvedType) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= a nil))
    (@pre (!= b nil))
    (let ((a-name (. (deref a) name))
          (b-name (. (deref b) name))
          (a-kind (. (deref a) kind))
          (b-kind (. (deref b) kind)))
      (cond
        ;; Same name - equal
        ((string-eq a-name b-name) true)
        ;; Generic type "T" matches anything
        ((or (string-eq a-name "T") (string-eq b-name "T")) true)
        ;; Unknown matches anything
        ((or (string-eq a-name "Unknown") (string-eq b-name "Unknown")) true)
        ;; Both Option - compare inner types
        ((and (== a-kind 'rk-option) (== b-kind 'rk-option))
          (match (. (deref a) inner-type)
            ((some a-inner)
              (match (. (deref b) inner-type)
                ((some b-inner) (types-names-equal a-inner b-inner))
                ((none) true)))
            ((none) true)))
        ;; Both Result - compare inner types
        ((and (== a-kind 'rk-result) (== b-kind 'rk-result))
          (let ((ok-match (match (. (deref a) inner-type)
                            ((some a-inner)
                              (match (. (deref b) inner-type)
                                ((some b-inner) (types-names-equal a-inner b-inner))
                                ((none) true)))
                            ((none) true)))
                (err-match (match (. (deref a) inner-type2)
                             ((some a-inner2)
                               (match (. (deref b) inner-type2)
                                 ((some b-inner2) (types-names-equal a-inner2 b-inner2))
                                 ((none) true)))
                             ((none) true))))
            (and ok-match err-match)))
        ;; Both Ptr - compare inner types
        ((and (== a-kind 'rk-ptr) (== b-kind 'rk-ptr))
          (match (. (deref a) inner-type)
            ((some a-inner)
              (match (. (deref b) inner-type)
                ((some b-inner) (types-names-equal a-inner b-inner))
                ((none) true)))
            ((none) true)))
        ;; Range type vs base type (e.g., Count vs Int)
        ((== a-kind 'rk-range)
          (match (. (deref a) inner-type)
            ((some base) (types-names-equal base b))
            ((none) false)))
        ((== b-kind 'rk-range)
          (match (. (deref b) inner-type)
            ((some base) (types-names-equal a base))
            ((none) false)))
        ;; Type alias: primitive with inner-type is an alias
        ((and (== a-kind 'rk-primitive) (== b-kind 'rk-primitive))
          (let ((a-match (match (. (deref a) inner-type)
                           ((some a-base) (types-names-equal a-base b))
                           ((none) false)))
                (b-match (match (. (deref b) inner-type)
                           ((some b-base) (types-names-equal a b-base))
                           ((none) false))))
            (or a-match b-match)))
        ;; One is a primitive alias, the other is something else
        ((== a-kind 'rk-primitive)
          (match (. (deref a) inner-type)
            ((some a-base) (types-names-equal a-base b))
            ((none) false)))
        ((== b-kind 'rk-primitive)
          (match (. (deref b) inner-type)
            ((some b-base) (types-names-equal a b-base))
            ((none) false)))
        ;; Different names - not equal
        (else false))))

  (fn check-expr-mode ((arena Arena) (env (Ptr TypeEnv))
                        (expr-str String) (type-str String)
                        (context-file String) (params-str String))
    (@intent "Type check an expression against expected type with context")
    (@spec ((Arena (Ptr TypeEnv) String String String String) -> Int))
    (@pre (!= env nil))
    ;; 1. If context file provided, parse and collect types/functions
    (when (> (string-len context-file) 0)
      (match (file-open context-file 'read)
        ((error _) (do))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error _) (file-close (addr f)))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok context-ast)
                    (do
                      (collect-module env context-ast)
                      (resolve-imports env context-ast)))
                  ((error _) (do)))))))))
    ;; 2. Push scope and bind params if provided
    (env-push-scope env)
    (when (> (string-len params-str) 0)
      (parse-and-bind-params env arena params-str))
    ;; 3. Parse the expression
    (let ((result (match (parse arena expr-str)
                    ((error parse-err)
                      (do
                        ;; Output JSON error
                        (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":"))
                        (print-string (int-to-string arena (. parse-err line)))
                        (print-str (cast (Ptr U8) ",\"col\":"))
                        (print-string (int-to-string arena (. parse-err col)))
                        (print-str (cast (Ptr U8) ",\"message\":"))
                        (print-json-string arena (. parse-err message))
                        (print-str (cast (Ptr U8) "}]}\n"))
                        1))
                    ((ok expr-ast)
                      (if (== (list-len expr-ast) 0)
                        (do
                          (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":1,\"col\":1,\"message\":\"Empty expression\"}]}\n"))
                          1)
                        (match (list-get expr-ast 0)
                          ((none)
                            (do
                              (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":1,\"col\":1,\"message\":\"Empty expression\"}]}\n"))
                              1))
                          ((some expr)
                            (do
                              ;; 4. Infer expression type
                              (let ((inferred-type (infer-expr env expr)))
                                ;; 5. Parse expected type
                                (let ((expected-type (resolve-type-string env arena type-str))
                                      (diagnostics (env-get-diagnostics env))
                                      (num-errors (count-errors diagnostics)))
                                  ;; 6. Check type match and output result
                                  (let ((type-match (types-names-equal inferred-type expected-type))
                                        (final-diagnostics (env-get-diagnostics env))
                                        (final-errors (count-errors final-diagnostics))
                                        (is-valid (and type-match (== final-errors 0))))
                                    (output-expr-result arena is-valid
                                      (. (deref inferred-type) name) type-str final-diagnostics)
                                    (if is-valid 0 1))))))))))))
      (env-pop-scope env)
      result))

  (fn output-expr-result ((arena Arena) (valid Bool)
                           (inferred-type String) (expected-type String)
                           (diagnostics (List Diagnostic)))
    (@intent "Output JSON result for expression mode")
    (@spec ((Arena Bool String String (List Diagnostic)) -> Unit))
    ;; {"valid": true/false, "inferred_type": "...", "expected_type": "...", "diagnostics": [...]}
    (print-str (cast (Ptr U8) "{\"valid\":"))
    (if valid
      (print-str (cast (Ptr U8) "true"))
      (print-str (cast (Ptr U8) "false")))
    (print-str (cast (Ptr U8) ",\"inferred_type\":"))
    (print-json-string arena inferred-type)
    (print-str (cast (Ptr U8) ",\"expected_type\":"))
    (print-json-string arena expected-type)
    (print-str (cast (Ptr U8) ",\"diagnostics\":"))
    (output-diagnostics-json arena diagnostics)
    (print-str (cast (Ptr U8) "}\n"))
    (do))

  ;; ============================================================
  ;; Main - CLI Entry Point
  ;; ============================================================

  (fn main ((argc Int) (argv (Ptr (Ptr U8))))
    (@intent "Entry point for the type checker CLI - supports multiple files and expression mode")
    (@spec ((Int (Ptr (Ptr U8))) -> Int))
    (if (< argc 2)
      (do
        (println "Usage: slop-checker [--json] <file.slop> [file2.slop ...]")
        (println "       slop-checker --expr EXPR --type TYPE [--context FILE] [--params PARAMS]")
        1)
      (with-arena 4194304  ;; 4MB arena for multi-file builds
        ;; Check for expression mode (--expr)
        (if (string-eq (argv-to-string argv 1) "--expr")
          (do
            ;; Expression mode: parse --expr, --type, --context, --params flags
            (let ((env (env-new arena))
                  (mut expr-str String "")
                  (mut type-str String "Int")
                  (mut context-file String "")
                  (mut params-str String "")
                  (mut i 2))
              ;; Get expression (required after --expr)
              (when (< i argc)
                (set! expr-str (argv-to-string argv i))
                (set! i (+ i 1)))
              ;; Parse remaining flags
              (while (< i argc)
                (let ((arg (argv-to-string argv i)))
                  (cond
                    ((string-eq arg "--type")
                      (when (< (+ i 1) argc)
                        (set! type-str (argv-to-string argv (+ i 1)))
                        (set! i (+ i 2))))
                    ((string-eq arg "--context")
                      (when (< (+ i 1) argc)
                        (set! context-file (argv-to-string argv (+ i 1)))
                        (set! i (+ i 2))))
                    ((string-eq arg "--params")
                      (when (< (+ i 1) argc)
                        (set! params-str (argv-to-string argv (+ i 1)))
                        (set! i (+ i 2))))
                    (else
                      (set! i (+ i 1))))))
              ;; Run expression mode
              (if (== (string-len expr-str) 0)
                (do
                  (println "Error: --expr requires an expression argument")
                  1)
                (check-expr-mode arena env expr-str type-str context-file params-str))))
          ;; Normal file mode
          (let ((env (env-new arena))
                (mut total-errors 0)
                (mut format 'fmt-text)
                (mut emit-types false)
                (mut file-start 1))
            ;; Check for --json flag
            (when (string-eq (argv-to-string argv 1) "--json")
              (set! format 'fmt-json)
              (set! file-start 2))
            ;; Check for --emit-types flag
            (when (and (< file-start argc) (string-eq (argv-to-string argv file-start) "--emit-types"))
              (set! emit-types true)
              (set! file-start (+ file-start 1)))
            ;; JSON opening brace if needed
            (when (== format 'fmt-json)
              (putchar 123))  ;; {
            ;; Process each input file using the shared environment
            (let ((mut i file-start)
                  (mut first true))
              (while (< i argc)
                (let ((filename (@ argv i))
                      (errors (check-single-file env arena filename format first emit-types)))
                  (set! total-errors (+ total-errors errors))
                  (set! first false))
                (set! i (+ i 1))))
            ;; JSON closing if needed
            (when (== format 'fmt-json)
              (putchar 125)   ;; }
              (putchar 10))   ;; newline
            ;; Return non-zero if any errors
            (if (> total-errors 0) 1 0))))))
)
