;; ============================================================
;; Type Collection Pass
;;
;; Scans AST for type and function definitions, building
;; the type environment with resolved type information.
;; ============================================================

(module collect
  (export
    ;; Main collection functions
    collect-types collect-functions collect-constants collect-module)

  (import parser (SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col
                  sexpr-list-len sexpr-list-get sexpr-is-list sexpr-get-symbol-name))
  (import types (ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo
                 resolved-type-new resolved-variant-new resolved-field-new
                 resolved-type-set-inner resolved-type-set-inner2
                 resolved-type-is-pointer
                 fn-signature-new param-info-new))
  (import env (TypeEnv env-arena env-register-type env-lookup-type env-lookup-type-direct
               env-register-function env-register-constant env-set-module env-get-module
               env-get-int-type env-get-bool-type env-get-string-type
               env-get-unit-type env-register-variant env-check-variant-collisions
               env-make-option-type env-add-warning env-add-error))

  ;; ============================================================
  ;; Main Collection Functions
  ;; ============================================================

  (fn collect-module ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Collect all types, constants, and functions from a module AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    ;; First pass: collect all type definitions
    (collect-types env ast)
    ;; Check for ambiguous enum variants (same name in different enums)
    (env-check-variant-collisions env)
    ;; Second pass: collect constant definitions
    (collect-constants env ast)
    ;; Third pass: collect function signatures
    (collect-functions env ast))

  (fn collect-types ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for type definitions and register them")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ;; Direct type definition
              ((is-form expr "type")
                (collect-type-def env arena expr))
              ;; Module - scan inside for types
              ((is-form expr "module")
                (collect-module-types env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-type-def ((env (Ptr TypeEnv)) (arena Arena) (expr (Ptr SExpr)))
    (@intent "Collect a single type definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (let ((mod-name (env-get-module env)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items)))
            ;; Extract type name from position 1: (type NAME TYPE-EXPR)
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym)
                    (let ((type-name (. sym name)))
                      ;; Check type-expr to determine kind
                      (match (list-get items 2)
                        ((some type-expr)
                          (cond
                            ;; Enum: (type Name (enum v1 v2 ...))
                            ((is-form type-expr "enum")
                              (let ((resolved (resolved-type-new arena 'rk-enum type-name mod-name type-name)))
                                (env-register-type env resolved)
                                (collect-enum-variants env type-name type-expr)))
                            ;; Record: (type Name (record (field Type) ...))
                            ((is-form type-expr "record")
                              (let ((resolved (resolved-type-new arena 'rk-record type-name mod-name type-name)))
                                (env-register-type env resolved)
                                (collect-record-fields env arena resolved type-expr)))
                            ;; Union: (type Name (union (variant-name Type) ...))
                            ((is-form type-expr "union")
                              (let ((resolved (resolved-type-new arena 'rk-union type-name mod-name type-name)))
                                (env-register-type env resolved)
                                (collect-union-variants env arena resolved type-expr)))
                            ;; Range: (type Name (BaseType min .. max))
                            ((is-range-type-expr type-expr)
                              (let ((base-type (get-range-base-type env arena type-expr))
                                    (resolved (resolved-type-new arena 'rk-range type-name mod-name type-name)))
                                (resolved-type-set-inner resolved base-type)
                                (env-register-type env resolved)))
                            ;; Map alias: (type Name (Map KeyType ValueType))
                            ((is-form type-expr "Map")
                              (let ((resolved (resolved-type-new arena 'rk-map type-name mod-name "slop_map*"))
                                    (key-type (get-field-type env arena (get-type-arg type-expr 1)))
                                    (val-type (get-field-type env arena (get-type-arg type-expr 2))))
                                (resolved-type-set-inner resolved key-type)
                                (resolved-type-set-inner2 resolved val-type)
                                (env-register-type env resolved)))
                            ;; Set alias: (type Name (Set ElemType))
                            ((is-form type-expr "Set")
                              (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name "slop_map*"))
                                    (elem-type (get-field-type env arena (get-type-arg type-expr 1))))
                                (resolved-type-set-inner resolved elem-type)
                                (env-register-type env resolved)))
                            ;; List alias: (type Name (List ElemType))
                            ((is-form type-expr "List")
                              (let ((resolved (resolved-type-new arena 'rk-list type-name mod-name "slop_list_t*"))
                                    (elem-type (get-field-type env arena (get-type-arg type-expr 1))))
                                (resolved-type-set-inner resolved elem-type)
                                (env-register-type env resolved)))
                            ;; Other - check for simple type alias like (type Count Int)
                            (else
                              (let ((alias-name (sexpr-get-symbol-name type-expr)))
                                (if (not (string-eq alias-name ""))
                                  ;; Simple type alias - store with inner-type pointing to aliased type
                                  (let ((base-type (get-field-type env arena type-expr))
                                        (resolved (resolved-type-new arena 'rk-primitive type-name mod-name type-name)))
                                    (resolved-type-set-inner resolved base-type)
                                    (env-register-type env resolved))
                                  ;; Complex expression we don't recognize
                                  (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name type-name)))
                                    (env-register-type env resolved)))))))
                        ((none)
                          ;; No type expr - use placeholder
                          (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name type-name)))
                            (env-register-type env resolved))))))
                  (_ (do))))
              ((none) (do)))))
        (_ (do)))))

  (fn collect-record-fields ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (record-expr (Ptr SExpr)))
    (@intent "Extract field definitions from a record and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= record-expr nil))
    (match (deref record-expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "record" keyword), iterate fields from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some field-form)
                ;; Each field is (field-name Type)
                (match (deref field-form)
                  ((lst field-lst)
                    (let ((field-items (. field-lst items)))
                      ;; Get field name at index 0
                      (match (list-get field-items 0)
                        ((some name-expr)
                          (match (deref name-expr)
                            ((sym name-sym)
                              ;; Get field type at index 1
                              (match (list-get field-items 1)
                                ((some type-expr)
                                  (let ((field-name (. name-sym name))
                                        (field-type (get-field-type env arena type-expr))
                                        (field (resolved-field-new arena field-name field-type (- i 1))))
                                    ;; Push directly to resolved's fields list
                                    (do (list-push (. (deref resolved) fields) (deref field)))))
                                ((none) (do))))
                            (_ (do))))
                        ((none) (do)))))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  (fn get-type-arg ((type-expr (Ptr SExpr)) (idx Int))
    (@intent "Get type argument at given index from a type expression like (Map K V)")
    (@spec (((Ptr SExpr) Int) -> (Ptr SExpr)))
    (@pre (!= type-expr nil))
    (match (deref type-expr)
      ((lst lst)
        (match (list-get (. lst items) idx)
          ((some arg) arg)
          ((none) type-expr)))  ;; Fallback to expr itself
      (_ type-expr)))

  (fn get-field-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a field type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((sym sym)
        (let ((type-name (. sym name)))
          ;; During collection, use direct lookup (no import enforcement)
          ;; since imports aren't resolved yet. Import visibility is enforced
          ;; during inference phase.
          (match (env-lookup-type-direct env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder (errors during inference)
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ((lst lst)
        ;; Complex type expression like (Option Int), (Ptr T), (List T)
        (let ((items (. lst items)))
          (match (list-get items 0)
            ((some head-expr)
              (let ((head-name (sexpr-get-symbol-name head-expr)))
                (cond
                  ;; Option type: (Option InnerType)
                  ((string-eq head-name "Option")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (env-make-option-type env inner-type)))
                  ;; Ptr type: (Ptr PointeeType)
                  ((string-eq head-name "Ptr")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      ;; Use Ptr_<inner> naming to match env-make-ptr-type
                      (let ((inner-name (. (deref inner-type) name))
                            (ptr-name (string-concat arena "Ptr_" inner-name))
                            (ptr-type (resolved-type-new arena 'rk-ptr ptr-name (none) "void*")))
                        (resolved-type-set-inner ptr-type inner-type)
                        ptr-type)))
                  ;; List type: (List ElemType)
                  ((string-eq head-name "List")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                        (resolved-type-set-inner list-type inner-type)
                        list-type)))
                  ;; Set type: (Set ElemType)
                  ((string-eq head-name "Set")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((set-type (resolved-type-new arena 'rk-primitive "Set" (none) "slop_map*")))
                        (resolved-type-set-inner set-type inner-type)
                        set-type)))
                  ;; Map type: (Map KeyType ValueType)
                  ((string-eq head-name "Map")
                    (let ((key-type (if (>= (list-len items) 2)
                                      (match (list-get items 1)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-int-type env)))
                                      (env-get-int-type env)))
                          (val-type (if (>= (list-len items) 3)
                                      (match (list-get items 2)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-int-type env)))
                                      (env-get-int-type env))))
                      (let ((map-type (resolved-type-new arena 'rk-map "Map" (none) "slop_map*")))
                        (resolved-type-set-inner map-type key-type)
                        (resolved-type-set-inner2 map-type val-type)
                        map-type)))
                  ;; Unknown complex type
                  (else (resolved-type-new arena 'rk-primitive head-name (none) head-name)))))
            ((none) (env-get-unit-type env)))))
      ;; Other expression types
      (_ (env-get-unit-type env))))

  (fn collect-module-types ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect type definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        ;; Extract and set module name from position 1
        (match (sexpr-list-get module-form 1)
          ((some name-expr)
            (let ((mod-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq mod-name ""))
                (env-set-module env (some mod-name)))))
          ((none) (do)))
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "type")
                  (collect-type-def env arena item)))
              ((none) (do))))))))

  (fn lookup-payload-type ((env (Ptr TypeEnv)) (type-name String))
    (@intent "Look up a type by name for union payload")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (if (string-eq type-name "")
      (none)
      ;; Use direct lookup during collection (imports not resolved yet)
      (match (env-lookup-type-direct env type-name)
        ((some t) (some t))
        ((none)
          (cond
            ((string-eq type-name "Int") (some (env-get-int-type env)))
            ((string-eq type-name "Bool") (some (env-get-bool-type env)))
            ((string-eq type-name "String") (some (env-get-string-type env)))
            (else (none)))))))

  (fn is-range-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if expression is a range type like (Int 0 .. 127)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pure)
    ;; Range type is a list like (Int 0 .. 127) or (Int 0 127)
    ;; First element is the base type (a symbol like Int)
    (if (not (sexpr-is-list type-expr))
      false
      (if (< (sexpr-list-len type-expr) 2)
        false
        (match (sexpr-list-get type-expr 0)
          ((some first-elem)
            (let ((base-name (sexpr-get-symbol-name first-elem)))
              ;; Check if it's a known base type for ranges
              (or (string-eq base-name "Int")
                  (string-eq base-name "Float"))))
          ((none) false)))))

  (fn get-range-base-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get the base type from a range expression like (Int 0 .. 127)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (sexpr-list-get type-expr 0)
      ((some first-elem)
        (let ((base-name (sexpr-get-symbol-name first-elem)))
          (cond
            ((string-eq base-name "Int") (env-get-int-type env))
            ((string-eq base-name "Float")
              (match (env-lookup-type-direct env "Float")
                ((some t) t)
                ((none) (env-get-int-type env))))
            (else (env-get-int-type env)))))
      ((none) (env-get-int-type env))))

  (fn get-type-name-from-expr ((expr (Ptr SExpr)))
    (@intent "Extract type name from an expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    (match (deref expr)
      ((sym sym) (. sym name))
      (_ "")))

  ;; ============================================================
  ;; Reserved Variant Names Check
  ;; ============================================================

  (fn is-reserved-variant-name ((name String))
    (@intent "Check if a variant name shadows a built-in form")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "list")
        (string-eq name "ok")
        (string-eq name "error")
        (string-eq name "some")
        (string-eq name "none")))

  ;; ============================================================
  ;; Union Variant Collection
  ;; ============================================================

  (fn collect-union-variants ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (union-expr (Ptr SExpr)))
    (@intent "Extract variant definitions from a union and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= union-expr nil))
    (when (sexpr-is-list union-expr)
      (let ((len (sexpr-list-len union-expr))
            (mut variant-idx 0))
        ;; Skip index 0 (the "union" keyword), iterate variants from index 1
        (for (i 1 len)
          (match (sexpr-list-get union-expr i)
            ((some variant-form)
              (do (collect-single-union-variant env arena resolved variant-form variant-idx)
                  (set! variant-idx (+ variant-idx 1))))
            ((none) (do)))))))

  (fn get-variant-payload-type ((env (Ptr TypeEnv)) (variant-form (Ptr SExpr)))
    (@intent "Get the payload type from a variant form if present")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Option (Ptr ResolvedType))))
    (@pure)
    ;; Use sexpr-list-get to avoid cross-module type issues
    (if (<= (sexpr-list-len variant-form) 1)
      (none)
      (match (sexpr-list-get variant-form 1)
        ((some type-expr)
          (lookup-payload-type env (sexpr-get-symbol-name type-expr)))
        ((none) (none)))))

  (fn get-variant-name ((variant-form (Ptr SExpr)))
    (@intent "Get the variant name from a variant form")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    ;; Use parser helpers to avoid cross-module issues
    (if (sexpr-is-list variant-form)
      (if (== (sexpr-list-len variant-form) 0)
        ""
        (match (sexpr-list-get variant-form 0)
          ((some name-expr) (sexpr-get-symbol-name name-expr))
          ((none) "")))
      (match (deref variant-form)
        ((sym sym) (. sym name))
        (_ ""))))

  (fn collect-single-union-variant ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType))
                                     (variant-form (Ptr SExpr)) (variant-idx Int))
    (@intent "Process a single union variant")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr) Int) -> Unit))
    (let ((variant-name (get-variant-name variant-form))
          (type-name (. (deref resolved) name))
          (arena (env-arena env)))
      (when (not (string-eq variant-name ""))
        ;; Check for reserved names that shadow built-in forms
        (when (is-reserved-variant-name variant-name)
          (let ((msg (string-concat arena "union variant '"
                       (string-concat arena variant-name
                         (string-concat arena "' in type '"
                           (string-concat arena type-name "' shadows built-in form"))))))
            (env-add-warning env msg (sexpr-line variant-form) (sexpr-col variant-form))))
        (let ((payload-type (get-variant-payload-type env variant-form))
              (variant (resolved-variant-new arena variant-name variant-idx variant-name payload-type)))
          (list-push (. (deref resolved) variants) (deref variant))
          ;; Register variant for collision detection (same as enum variants)
          (env-register-variant env variant-name type-name)))))

  (fn collect-enum-variants ((env (Ptr TypeEnv)) (enum-name String) (enum-expr (Ptr SExpr)))
    (@intent "Extract variant names from an enum definition and register them")
    (@spec (((Ptr TypeEnv) String (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= enum-expr nil))
    (match (deref enum-expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "enum" keyword), iterate variants from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some variant-expr)
                (match (deref variant-expr)
                  ((sym sym)
                    (do (env-register-variant env (. sym name) enum-name)))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  ;; ============================================================
  ;; Constant Collection
  ;; ============================================================

  (fn collect-constants ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for constant definitions and register them")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "const")
                (collect-single-constant env arena expr))
              ((is-form expr "module")
                (collect-module-constants env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-constants ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect constant definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "const")
                  (collect-single-constant env arena item)))
              ((none) (do))))))))

  (fn collect-single-constant ((env (Ptr TypeEnv)) (arena Arena) (const-form (Ptr SExpr)))
    (@intent "Collect a single constant definition: (const NAME Type value)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= const-form nil))
    (when (sexpr-is-list const-form)
      (when (>= (sexpr-list-len const-form) 3)
        ;; Get name at position 1
        (match (sexpr-list-get const-form 1)
          ((some name-expr)
            (let ((const-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq const-name ""))
                ;; Get type at position 2
                (match (sexpr-list-get const-form 2)
                  ((some type-expr)
                    (let ((const-type (get-const-type env arena type-expr)))
                      (env-register-constant env const-name const-type)))
                  ((none) (do))))))
          ((none) (do))))))

  (fn get-const-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a constant type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((sym sym)
        (let ((type-name (. sym name)))
          ;; Use direct lookup during collection (imports not resolved yet)
          (match (env-lookup-type-direct env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ;; Complex type or other - use Int as default
      (_ (env-get-int-type env))))

  ;; ============================================================
  ;; Function Collection
  ;; ============================================================

  (fn collect-functions ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for function definitions and register signatures")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "fn")
                (collect-single-function env arena expr))
              ((is-form expr "module")
                (collect-module-functions env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-functions ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect function definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        ;; Extract and set module name from position 1
        (match (sexpr-list-get module-form 1)
          ((some name-expr)
            (let ((mod-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq mod-name ""))
                (env-set-module env (some mod-name)))))
          ((none) (do)))
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (cond
                  ((is-form item "fn")
                    (collect-single-function env arena item))
                  ((is-form item "ffi")
                    (collect-ffi-functions env arena item))
                  (else (do))))
              ((none) (do))))))))

  (fn collect-ffi-functions ((env (Ptr TypeEnv)) (arena Arena) (ffi-form (Ptr SExpr)))
    (@intent "Collect function signatures from an FFI declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= ffi-form nil))
    ;; ffi-form is (ffi "header.h" (func-name ((param Type)...) RetType) ...)
    (when (sexpr-is-list ffi-form)
      (let ((len (sexpr-list-len ffi-form)))
        ;; Skip index 0 (ffi) and index 1 (header), start at index 2
        (for (i 2 len)
          (match (sexpr-list-get ffi-form i)
            ((some func-decl)
              (collect-ffi-function env arena func-decl))
            ((none) (do)))))))

  (fn collect-ffi-function ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Collect a single FFI function or constant declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= func-decl nil))
    ;; func-decl is either:
    ;;   (func-name ((param Type)...) RetType) - function with 3 elements
    ;;   (CONST_NAME Type) - constant with 2 elements
    (when (sexpr-is-list func-decl)
      (let ((decl-len (sexpr-list-len func-decl)))
        (cond
          ;; Function declaration: 3+ elements
          ((>= decl-len 3)
            (match (sexpr-list-get func-decl 0)
              ((some name-expr)
                (let ((fn-name (sexpr-get-symbol-name name-expr)))
                  (when (not (string-eq fn-name ""))
                    ;; Build qualified name with current module
                    (let ((mod-opt (env-get-module env))
                          (qualified-name (if (. mod-opt has-value)
                                            (string-concat arena (. mod-opt value)
                                              (string-concat arena ":" fn-name))
                                            fn-name))
                          ;; Parse parameters from index 1
                          (params (collect-ffi-params env arena func-decl))
                          ;; Parse return type from index 2
                          (ret-type (get-ffi-return-type env arena func-decl))
                          (sig (fn-signature-new arena qualified-name fn-name params ret-type)))
                      ;; Set module-name for visibility checking
                      (set! (. (deref sig) module-name) mod-opt)
                      (env-register-function env sig)))))
              ((none) (do))))
          ;; Constant declaration: 2 elements (name Type)
          ((== decl-len 2)
            (match (sexpr-list-get func-decl 0)
              ((some name-expr)
                (let ((const-name (sexpr-get-symbol-name name-expr)))
                  (when (not (string-eq const-name ""))
                    (match (sexpr-list-get func-decl 1)
                      ((some type-expr)
                        (let ((const-type (get-field-type env arena type-expr)))
                          (env-register-constant env const-name const-type)))
                      ((none) (do))))))
              ((none) (do))))
          (else (do))))))

  (fn collect-ffi-params ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Collect parameters from FFI function declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (let ((params (list-new arena ParamInfo)))
      (match (sexpr-list-get func-decl 1)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (j 0 num-params)
                (match (sexpr-list-get params-expr j)
                  ((some param-form)
                    ;; param-form is (name Type)
                    (when (sexpr-is-list param-form)
                      (when (>= (sexpr-list-len param-form) 2)
                        (match (sexpr-list-get param-form 0)
                          ((some pname-expr)
                            (let ((param-name (sexpr-get-symbol-name pname-expr)))
                              (when (not (string-eq param-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some ptype-expr)
                                    (let ((param-type (get-field-type env arena ptype-expr))
                                          (info (param-info-new arena param-name param-type)))
                                      (list-push params (deref info))))
                                  ((none) (do))))))
                          ((none) (do))))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn get-ffi-return-type ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Get return type from FFI function declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (sexpr-list-get func-decl 2)
      ((some ret-expr)
        (get-field-type env arena ret-expr))
      ((none) (env-get-unit-type env))))

  (fn collect-single-function ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect signature for a single function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; fn-form is (fn NAME ((param Type)...) @contracts... body)
    (when (sexpr-is-list fn-form)
      (when (>= (sexpr-list-len fn-form) 3)
        (match (sexpr-list-get fn-form 1)
          ((some name-expr)
            (let ((fn-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq fn-name ""))
                ;; Build qualified name: module:fn-name
                (let ((mod-opt (env-get-module env))
                      (qualified-name (if (. mod-opt has-value)
                                        (string-concat arena (. mod-opt value)
                                          (string-concat arena ":" fn-name))
                                        fn-name))
                      (params (collect-fn-params env arena fn-form))
                      (ret-type (find-fn-return-type env fn-form))
                      (sig (fn-signature-new arena qualified-name fn-name params ret-type)))
                  ;; Set module-name on the signature for visibility checking
                  (set! (. (deref sig) module-name) mod-opt)
                  ;; Validate main function parameters
                  (when (string-eq fn-name "main")
                    (validate-main-params env fn-form params))
                  (env-register-function env sig)))))
          ((none) (do))))))

  (fn is-integer-type-name ((name String))
    (@intent "Check if type name is an integer type suitable for argc")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (string-eq name "I8")
        (string-eq name "I16")
        (string-eq name "I32")
        (string-eq name "I64")
        (string-eq name "U8")
        (string-eq name "U16")
        (string-eq name "U32")
        (string-eq name "U64")))

  (fn validate-main-params ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)) (params (List ParamInfo)))
    (@intent "Validate that main function has valid C entry point parameters")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) (List ParamInfo)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; Valid main signatures:
    ;; - () - no parameters
    ;; - ((argc Int) (argv (Ptr (Ptr U8)))) - standard C main
    ;; Invalid: any other parameter count or types like Arena
    (let ((num-params (list-len params))
          (line (sexpr-line fn-form))
          (col (sexpr-col fn-form)))
      (cond
        ;; No params is fine
        ((== num-params 0) (do))
        ;; Two params is the standard argc/argv pattern
        ((== num-params 2)
          ;; First param should be integer-like (Int, I32, etc.)
          (match (list-get params 0)
            ((some p0)
              (let ((t0 (. p0 param-type)))
                (when (!= t0 nil)
                  (let ((name0 (. (deref t0) name)))
                    ;; Check for integer type names specifically
                    (when (not (is-integer-type-name name0))
                      (env-add-error env
                        "main's first parameter must be an integer type (e.g., Int for argc)"
                        line col))))))
            ((none) (do)))
          ;; Second param should be pointer-like (Ptr (Ptr U8) or similar)
          (match (list-get params 1)
            ((some p1)
              (let ((t1 (. p1 param-type)))
                (when (!= t1 nil)
                  (when (not (resolved-type-is-pointer t1))
                    (env-add-error env
                      "main's second parameter must be a pointer type (e.g., (Ptr (Ptr U8)) for argv)"
                      line col)))))
            ((none) (do))))
        ;; Any other count is invalid
        (else
          (env-add-error env
            "main function must have either no parameters or exactly two parameters (argc: Int, argv: (Ptr (Ptr U8)))"
            line col)))))

  (fn collect-fn-params ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect parameter types from a function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((params (list-new arena ParamInfo)))
      ;; Get params-expr at position 2
      (match (sexpr-list-get fn-form 2)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (i 0 num-params)
                (match (sexpr-list-get params-expr i)
                  ((some param-form)
                    ;; param-form is (param-name Type) or (mode param-name Type)
                    (when (and (sexpr-is-list param-form) (>= (sexpr-list-len param-form) 2))
                      (match (sexpr-list-get param-form 0)
                        ((some first-expr)
                          (let ((first-name (sexpr-get-symbol-name first-expr)))
                            ;; Check if first element is a mode annotation (in, out, mut)
                            (if (or (string-eq first-name "in")
                                    (string-eq first-name "out")
                                    (string-eq first-name "mut"))
                              ;; Mode form: (mode name Type) - need at least 3 elements
                              (when (>= (sexpr-list-len param-form) 3)
                                (match (sexpr-list-get param-form 1)
                                  ((some name-expr)
                                    (let ((param-name (sexpr-get-symbol-name name-expr)))
                                      (when (not (string-eq param-name ""))
                                        (match (sexpr-list-get param-form 2)
                                          ((some type-expr)
                                            (let ((param-type (get-field-type env arena type-expr))
                                                  (info (param-info-new arena param-name param-type)))
                                              (do (list-push params (deref info)))))
                                          ((none) (do))))))
                                  ((none) (do))))
                              ;; Regular form: (name Type) - first element is name
                              (when (not (string-eq first-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some type-expr)
                                    (let ((param-type (get-field-type env arena type-expr))
                                          (info (param-info-new arena first-name param-type)))
                                      (do (list-push params (deref info)))))
                                  ((none) (do)))))))
                        ((none) (do)))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn find-fn-return-type ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)))
    (@intent "Find return type from @spec in function definition")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; Search through function body for @spec
    (let ((len (sexpr-list-len fn-form))
          (mut found Bool false)
          (mut found-type (Ptr ResolvedType) (env-get-unit-type env)))
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@spec")
              (when (not found)
                (set! found-type (extract-spec-return-type env item))
                (set! found true))))
          ((none) (do))))
      found-type))

  (fn extract-spec-return-type ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr)))
    (@intent "Extract return type from @spec form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    ;; (@spec ((Types) -> RetType))
    (let ((arena (env-arena env)))
      (match (sexpr-list-get spec-form 1)
        ((some spec-body)
          ;; spec-body is ((Types) -> RetType)
          (if (sexpr-is-list spec-body)
            (let ((len (sexpr-list-len spec-body)))
              ;; Last element is return type
              (match (sexpr-list-get spec-body (- len 1))
                ((some ret-expr)
                  (get-field-type env arena ret-expr))
                ((none) (env-get-unit-type env))))
            (env-get-unit-type env)))
        ((none) (env-get-unit-type env)))))
)
