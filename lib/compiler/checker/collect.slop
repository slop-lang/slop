;; ============================================================
;; Type Collection Pass
;;
;; Scans AST for type and function definitions, building
;; the type environment with resolved type information.
;; ============================================================

(module collect
  (export
    ;; Main collection functions
    collect-types collect-functions collect-constants collect-module
    ;; Type parameter extraction
    find-fn-type-params)

  (import parser (SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col
                  sexpr-list-len sexpr-list-get sexpr-is-list sexpr-get-symbol-name))
  (import types (ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo
                 resolved-type-new resolved-variant-new resolved-field-new
                 resolved-type-set-inner resolved-type-set-inner2
                 resolved-type-is-pointer
                 fn-signature-new param-info-new))
  (import env (TypeEnv env-arena env-register-type env-lookup-type env-lookup-type-direct
               env-register-function env-register-constant env-set-module env-get-module
               env-get-int-type env-get-bool-type env-get-string-type
               env-get-unit-type env-register-variant env-check-variant-collisions
               env-make-option-type env-add-warning env-add-error))

  ;; ============================================================
  ;; Main Collection Functions
  ;; ============================================================

  (fn collect-module ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Collect all types, constants, and functions from a module AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    ;; First pass: collect all type definitions
    (collect-types env ast)
    ;; Check for ambiguous enum variants (same name in different enums)
    (env-check-variant-collisions env)
    ;; Second pass: collect constant definitions
    (collect-constants env ast)
    ;; Third pass: collect function signatures
    (collect-functions env ast))

  (fn collect-types ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for type definitions: pass 1 registers names, pass 2 resolves bodies")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      ;; Pass 1: Register all type names (enables forward references)
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "type")
                (register-type-name env arena expr))
              ((is-form expr "module")
                (register-module-type-names env expr))
              (else (do))))
          ((none) (do))))
      ;; Pass 2: Resolve fields, variants, inner types
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "type")
                (resolve-type-body env arena expr))
              ((is-form expr "module")
                (resolve-module-type-bodies env expr))
              (else (do))))
          ((none) (do))))))

  ;; ============================================================
  ;; Two-Pass Type Collection
  ;;
  ;; Pass 1 (register-type-name): Register all type names with their
  ;; kind and module-name. No field/variant/inner-type resolution.
  ;; This ensures forward references can find the type by name.
  ;;
  ;; Pass 2 (resolve-type-body): Now that all type names exist,
  ;; resolve fields, variants, and inner types.
  ;; ============================================================

  (fn register-type-name ((env (Ptr TypeEnv)) (arena Arena) (expr (Ptr SExpr)))
    (@intent "Pass 1: Register type name and kind without resolving details")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (let ((mod-name (env-get-module env)))
      (match (deref expr)
        ((lst lst)
          (let ((items (. lst items)))
            (match (list-get items 1)
              ((some name-expr)
                (match (deref name-expr)
                  ((sym sym)
                    (let ((type-name (. sym name)))
                      (match (list-get items 2)
                        ((some type-expr)
                          (cond
                            ((is-form type-expr "enum")
                              (let ((resolved (resolved-type-new arena 'rk-enum type-name mod-name type-name)))
                                (env-register-type env resolved)))
                            ((is-form type-expr "record")
                              (let ((resolved (resolved-type-new arena 'rk-record type-name mod-name type-name)))
                                (env-register-type env resolved)))
                            ((is-form type-expr "union")
                              (let ((resolved (resolved-type-new arena 'rk-union type-name mod-name type-name)))
                                (env-register-type env resolved)))
                            ((is-range-type-expr type-expr)
                              (let ((resolved (resolved-type-new arena 'rk-range type-name mod-name type-name)))
                                (env-register-type env resolved)))
                            ((is-form type-expr "Map")
                              (let ((resolved (resolved-type-new arena 'rk-map type-name mod-name "slop_map*")))
                                (env-register-type env resolved)))
                            ((is-form type-expr "Set")
                              (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name "slop_map*")))
                                (env-register-type env resolved)))
                            ((is-form type-expr "List")
                              (let ((resolved (resolved-type-new arena 'rk-list type-name mod-name "slop_list_t*")))
                                (env-register-type env resolved)))
                            (else
                              (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name type-name)))
                                (env-register-type env resolved)))))
                        ((none)
                          (let ((resolved (resolved-type-new arena 'rk-primitive type-name mod-name type-name)))
                            (env-register-type env resolved))))))
                  (_ (do))))
              ((none) (do)))))
        (_ (do)))))

  (fn resolve-type-body ((env (Ptr TypeEnv)) (arena Arena) (expr (Ptr SExpr)))
    (@intent "Pass 2: Resolve fields, variants, and inner types for an already-registered type")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (match (deref expr)
      ((lst lst)
        (let ((items (. lst items)))
          (match (list-get items 1)
            ((some name-expr)
              (match (deref name-expr)
                ((sym sym)
                  (let ((type-name (. sym name)))
                    (match (list-get items 2)
                      ((some type-expr)
                        (cond
                          ((is-form type-expr "enum")
                            (collect-enum-variants env type-name type-expr))
                          ((is-form type-expr "record")
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (collect-record-fields env arena resolved type-expr))
                              ((none) (do))))
                          ((is-form type-expr "union")
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (collect-union-variants env arena resolved type-expr))
                              ((none) (do))))
                          ((is-range-type-expr type-expr)
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (let ((base-type (get-range-base-type env arena type-expr)))
                                  (resolved-type-set-inner resolved base-type)))
                              ((none) (do))))
                          ((is-form type-expr "Map")
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (let ((key-type (get-field-type env arena (get-type-arg type-expr 1)))
                                      (val-type (get-field-type env arena (get-type-arg type-expr 2))))
                                  (resolved-type-set-inner resolved key-type)
                                  (resolved-type-set-inner2 resolved val-type)))
                              ((none) (do))))
                          ((is-form type-expr "Set")
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (let ((elem-type (get-field-type env arena (get-type-arg type-expr 1))))
                                  (resolved-type-set-inner resolved elem-type)))
                              ((none) (do))))
                          ((is-form type-expr "List")
                            (match (env-lookup-type-direct env type-name)
                              ((some resolved)
                                (let ((elem-type (get-field-type env arena (get-type-arg type-expr 1))))
                                  (resolved-type-set-inner resolved elem-type)))
                              ((none) (do))))
                          (else
                            (let ((alias-name (sexpr-get-symbol-name type-expr)))
                              (when (not (string-eq alias-name ""))
                                (match (env-lookup-type-direct env type-name)
                                  ((some resolved)
                                    (let ((base-type (get-field-type env arena type-expr)))
                                      (resolved-type-set-inner resolved base-type)))
                                  ((none) (do))))))))
                      ((none) (do)))))
                (_ (do))))
            ((none) (do)))))
      (_ (do))))

  (fn collect-record-fields ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (record-expr (Ptr SExpr)))
    (@intent "Extract field definitions from a record and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= record-expr nil))
    (match (deref record-expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "record" keyword), iterate fields from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some field-form)
                ;; Each field is (field-name Type)
                (match (deref field-form)
                  ((lst field-lst)
                    (let ((field-items (. field-lst items)))
                      ;; Get field name at index 0
                      (match (list-get field-items 0)
                        ((some name-expr)
                          (match (deref name-expr)
                            ((sym name-sym)
                              ;; Get field type at index 1
                              (match (list-get field-items 1)
                                ((some type-expr)
                                  (let ((field-name (. name-sym name))
                                        (field-type (get-field-type env arena type-expr))
                                        (field (resolved-field-new arena field-name field-type (- i 1))))
                                    ;; Push directly to resolved's fields list
                                    (do (list-push (. (deref resolved) fields) (deref field)))))
                                ((none) (do))))
                            (_ (do))))
                        ((none) (do)))))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  (fn get-type-arg ((type-expr (Ptr SExpr)) (idx Int))
    (@intent "Get type argument at given index from a type expression like (Map K V)")
    (@spec (((Ptr SExpr) Int) -> (Ptr SExpr)))
    (@pre (!= type-expr nil))
    (match (deref type-expr)
      ((lst lst)
        (match (list-get (. lst items) idx)
          ((some arg) arg)
          ((none) type-expr)))  ;; Fallback to expr itself
      (_ type-expr)))

  (fn get-field-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a field type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((sym sym)
        (let ((type-name (. sym name)))
          ;; During collection, use direct lookup (no import enforcement)
          ;; since imports aren't resolved yet. Import visibility is enforced
          ;; during inference phase.
          (match (env-lookup-type-direct env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder (errors during inference)
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ((lst lst)
        ;; Complex type expression like (Option Int), (Ptr T), (List T)
        (let ((items (. lst items)))
          (match (list-get items 0)
            ((some head-expr)
              (let ((head-name (sexpr-get-symbol-name head-expr)))
                (cond
                  ;; Option type: (Option InnerType)
                  ((string-eq head-name "Option")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (env-make-option-type env inner-type)))
                  ;; Ptr type: (Ptr PointeeType)
                  ((string-eq head-name "Ptr")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      ;; Use Ptr_<inner> naming to match env-make-ptr-type
                      (let ((inner-name (. (deref inner-type) name))
                            (ptr-name (string-concat arena "Ptr_" inner-name))
                            (ptr-type (resolved-type-new arena 'rk-ptr ptr-name (none) "void*")))
                        (resolved-type-set-inner ptr-type inner-type)
                        ptr-type)))
                  ;; List type: (List ElemType)
                  ((string-eq head-name "List")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                        (resolved-type-set-inner list-type inner-type)
                        list-type)))
                  ;; Set type: (Set ElemType)
                  ((string-eq head-name "Set")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((set-type (resolved-type-new arena 'rk-primitive "Set" (none) "slop_map*")))
                        (resolved-type-set-inner set-type inner-type)
                        set-type)))
                  ;; Map type: (Map KeyType ValueType)
                  ((string-eq head-name "Map")
                    (let ((key-type (if (>= (list-len items) 2)
                                      (match (list-get items 1)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-int-type env)))
                                      (env-get-int-type env)))
                          (val-type (if (>= (list-len items) 3)
                                      (match (list-get items 2)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-int-type env)))
                                      (env-get-int-type env))))
                      (let ((map-type (resolved-type-new arena 'rk-map "Map" (none) "slop_map*")))
                        (resolved-type-set-inner map-type key-type)
                        (resolved-type-set-inner2 map-type val-type)
                        map-type)))
                  ;; Result type: (Result OkType ErrType)
                  ((string-eq head-name "Result")
                    (let ((ok-type (if (>= (list-len items) 2)
                                      (match (list-get items 1)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-unit-type env)))
                                      (env-get-unit-type env)))
                          (err-type (if (>= (list-len items) 3)
                                      (match (list-get items 2)
                                        ((some inner-expr) (get-field-type env arena inner-expr))
                                        ((none) (env-get-unit-type env)))
                                      (env-get-unit-type env)))
                          (ok-name (. (deref ok-type) name))
                          (err-name (. (deref err-type) name))
                          (result-name (string-concat arena "Result_"
                                         (string-concat arena ok-name
                                           (string-concat arena "_" err-name))))
                          (result-type (resolved-type-new arena 'rk-result result-name (none) "Result")))
                      (resolved-type-set-inner result-type ok-type)
                      (resolved-type-set-inner2 result-type err-type)
                      result-type))
                  ;; Unknown complex type
                  (else (resolved-type-new arena 'rk-primitive head-name (none) head-name)))))
            ((none) (env-get-unit-type env)))))
      ;; Other expression types
      (_ (env-get-unit-type env))))

  ;; ============================================================
  ;; Generic Type Parameter Support
  ;; ============================================================

  (fn is-type-param ((name String) (type-params (List String)))
    (@intent "Check if a type name is a declared type parameter")
    (@spec ((String (List String)) -> Bool))
    (@pure)
    (let ((len (list-len type-params))
          (mut found false))
      (for (i 0 len)
        (match (list-get type-params i)
          ((some tp) (when (string-eq name tp) (set! found true)))
          ((none) (do))))
      found))

  (fn get-field-type-generic ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)) (type-params (List String)))
    (@intent "Get resolved type for a type expression, with type parameter awareness")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr) (List String)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((sym sym)
        (let ((type-name (. sym name)))
          ;; Check type params first
          (if (is-type-param type-name type-params)
            (resolved-type-new arena 'rk-typevar type-name (none) type-name)
            ;; Fall through to normal resolution
            (match (env-lookup-type-direct env type-name)
              ((some t) t)
              ((none)
                (cond
                  ((string-eq type-name "Int") (env-get-int-type env))
                  ((string-eq type-name "Bool") (env-get-bool-type env))
                  ((string-eq type-name "String") (env-get-string-type env))
                  ((string-eq type-name "Unit") (env-get-unit-type env))
                  (else (resolved-type-new arena 'rk-primitive type-name (none) type-name))))))))
      ((lst lst)
        (let ((items (. lst items)))
          (match (list-get items 0)
            ((some head-expr)
              (let ((head-name (sexpr-get-symbol-name head-expr)))
                (cond
                  ((string-eq head-name "Option")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (env-make-option-type env inner-type)))
                  ((string-eq head-name "Ptr")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((inner-name (. (deref inner-type) name))
                            (ptr-name (string-concat arena "Ptr_" inner-name))
                            (ptr-type (resolved-type-new arena 'rk-ptr ptr-name (none) "void*")))
                        (resolved-type-set-inner ptr-type inner-type)
                        ptr-type)))
                  ((string-eq head-name "List")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((list-type (resolved-type-new arena 'rk-list "List" (none) "slop_list_t*")))
                        (resolved-type-set-inner list-type inner-type)
                        list-type)))
                  ((string-eq head-name "Chan")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((chan-type (resolved-type-new arena 'rk-chan "Chan" (none) "slop_chan_int*")))
                        (resolved-type-set-inner chan-type inner-type)
                        chan-type)))
                  ((string-eq head-name "Thread")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (let ((thread-type (resolved-type-new arena 'rk-thread "Thread" (none) "slop_thread_int*")))
                        (resolved-type-set-inner thread-type inner-type)
                        thread-type)))
                  ((string-eq head-name "Result")
                    (let ((ok-type (if (>= (list-len items) 2)
                                      (match (list-get items 1)
                                        ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                        ((none) (env-get-unit-type env)))
                                      (env-get-unit-type env)))
                          (err-type (if (>= (list-len items) 3)
                                      (match (list-get items 2)
                                        ((some inner-expr) (get-field-type-generic env arena inner-expr type-params))
                                        ((none) (env-get-unit-type env)))
                                      (env-get-unit-type env)))
                          (ok-name (. (deref ok-type) name))
                          (err-name (. (deref err-type) name))
                          (result-name (string-concat arena "Result_"
                                         (string-concat arena ok-name
                                           (string-concat arena "_" err-name))))
                          (result-type (resolved-type-new arena 'rk-result result-name (none) "Result")))
                      (resolved-type-set-inner result-type ok-type)
                      (resolved-type-set-inner2 result-type err-type)
                      result-type))
                  ((string-eq head-name "Fn")
                    (resolved-type-new arena 'rk-function "Fn" (none) "void*"))
                  (else (resolved-type-new arena 'rk-primitive head-name (none) head-name)))))
            ((none) (env-get-unit-type env)))))
      (_ (env-get-unit-type env))))

  (fn find-fn-type-params ((arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Extract type parameter names from @generic annotation in function body")
    (@spec ((Arena (Ptr SExpr)) -> (List String)))
    (@pre (!= fn-form nil))
    (let ((type-params (list-new arena String))
          (len (sexpr-list-len fn-form)))
      ;; Search body forms for (@generic (T U ...))
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@generic")
              ;; (@generic (T U ...)) - get the list at position 1
              (match (sexpr-list-get item 1)
                ((some params-expr)
                  (when (sexpr-is-list params-expr)
                    (let ((num-params (sexpr-list-len params-expr)))
                      (for (j 0 num-params)
                        (match (sexpr-list-get params-expr j)
                          ((some param-expr)
                            (let ((param-name (sexpr-get-symbol-name param-expr)))
                              (when (not (string-eq param-name ""))
                                (list-push type-params param-name))))
                          ((none) (do)))))))
                ((none) (do)))))
          ((none) (do))))
      type-params))

  (fn find-fn-return-type-generic ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)) (type-params (List String)))
    (@intent "Find return type from @spec, with type parameter awareness")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) (List String)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((len (sexpr-list-len fn-form))
          (mut found Bool false)
          (mut found-type (Ptr ResolvedType) (env-get-unit-type env)))
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@spec")
              (when (not found)
                (set! found-type (extract-spec-return-type-generic env item type-params))
                (set! found true))))
          ((none) (do))))
      found-type))

  (fn extract-spec-return-type-generic ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr)) (type-params (List String)))
    (@intent "Extract return type from @spec form with type parameter awareness")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) (List String)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (let ((arena (env-arena env)))
      (match (sexpr-list-get spec-form 1)
        ((some spec-body)
          (if (sexpr-is-list spec-body)
            (let ((len (sexpr-list-len spec-body)))
              (match (sexpr-list-get spec-body (- len 1))
                ((some ret-expr)
                  (get-field-type-generic env arena ret-expr type-params))
                ((none) (env-get-unit-type env))))
            (env-get-unit-type env)))
        ((none) (env-get-unit-type env)))))

  (fn collect-fn-spec-params ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)) (type-params (List String)))
    (@intent "Collect parameter types from @spec annotation for generic type unification")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr) (List String)) -> (List (Ptr ResolvedType))))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((spec-params (list-new arena (Ptr ResolvedType)))
          (len (sexpr-list-len fn-form)))
      ;; Find @spec form
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@spec")
              ;; (@spec ((ParamTypes...) -> RetType))
              (match (sexpr-list-get item 1)
                ((some spec-body)
                  (when (sexpr-is-list spec-body)
                    ;; First element is the param type list
                    (match (sexpr-list-get spec-body 0)
                      ((some param-types-expr)
                        (when (sexpr-is-list param-types-expr)
                          (let ((num-ptypes (sexpr-list-len param-types-expr)))
                            (for (j 0 num-ptypes)
                              (match (sexpr-list-get param-types-expr j)
                                ((some ptype-expr)
                                  (let ((pt (get-field-type-generic env arena ptype-expr type-params)))
                                    (list-push spec-params pt)))
                                ((none) (do)))))))
                      ((none) (do)))))
                ((none) (do)))))
          ((none) (do))))
      spec-params))

  (fn set-module-name-from-form ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Extract and set module name from a module form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (match (sexpr-list-get module-form 1)
      ((some name-expr)
        (let ((mod-name (sexpr-get-symbol-name name-expr)))
          (when (not (string-eq mod-name ""))
            (env-set-module env (some mod-name)))))
      ((none) (do))))

  (fn register-module-type-names ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Pass 1: Register type names from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (set-module-name-from-form env module-form)
        (let ((len (sexpr-list-len module-form)))
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "type")
                  (register-type-name env arena item)))
              ((none) (do))))))))

  (fn resolve-module-type-bodies ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Pass 2: Resolve type bodies from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (set-module-name-from-form env module-form)
        (let ((len (sexpr-list-len module-form)))
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "type")
                  (resolve-type-body env arena item)))
              ((none) (do))))))))

  (fn lookup-payload-type ((env (Ptr TypeEnv)) (type-name String))
    (@intent "Look up a type by name for union payload")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (if (string-eq type-name "")
      (none)
      ;; Use direct lookup during collection (imports not resolved yet)
      (match (env-lookup-type-direct env type-name)
        ((some t) (some t))
        ((none)
          (cond
            ((string-eq type-name "Int") (some (env-get-int-type env)))
            ((string-eq type-name "Bool") (some (env-get-bool-type env)))
            ((string-eq type-name "String") (some (env-get-string-type env)))
            (else (none)))))))

  (fn is-range-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if expression is a range type like (Int 0 .. 127)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pure)
    ;; Range type is a list like (Int 0 .. 127) or (Int 0 127)
    ;; First element is the base type (a symbol like Int)
    (if (not (sexpr-is-list type-expr))
      false
      (if (< (sexpr-list-len type-expr) 2)
        false
        (match (sexpr-list-get type-expr 0)
          ((some first-elem)
            (let ((base-name (sexpr-get-symbol-name first-elem)))
              ;; Check if it's a known base type for ranges
              (or (string-eq base-name "Int")
                  (string-eq base-name "Float"))))
          ((none) false)))))

  (fn get-range-base-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get the base type from a range expression like (Int 0 .. 127)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (sexpr-list-get type-expr 0)
      ((some first-elem)
        (let ((base-name (sexpr-get-symbol-name first-elem)))
          (cond
            ((string-eq base-name "Int") (env-get-int-type env))
            ((string-eq base-name "Float")
              (match (env-lookup-type-direct env "Float")
                ((some t) t)
                ((none) (env-get-int-type env))))
            (else (env-get-int-type env)))))
      ((none) (env-get-int-type env))))

  (fn get-type-name-from-expr ((expr (Ptr SExpr)))
    (@intent "Extract type name from an expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    (match (deref expr)
      ((sym sym) (. sym name))
      (_ "")))

  ;; ============================================================
  ;; Reserved Variant Names Check
  ;; ============================================================

  (fn is-reserved-variant-name ((name String))
    (@intent "Check if a variant name shadows a built-in form")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "list")
        (string-eq name "ok")
        (string-eq name "error")
        (string-eq name "some")
        (string-eq name "none")))

  ;; ============================================================
  ;; Union Variant Collection
  ;; ============================================================

  (fn collect-union-variants ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (union-expr (Ptr SExpr)))
    (@intent "Extract variant definitions from a union and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= union-expr nil))
    (when (sexpr-is-list union-expr)
      (let ((len (sexpr-list-len union-expr))
            (mut variant-idx 0))
        ;; Skip index 0 (the "union" keyword), iterate variants from index 1
        (for (i 1 len)
          (match (sexpr-list-get union-expr i)
            ((some variant-form)
              (do (collect-single-union-variant env arena resolved variant-form variant-idx)
                  (set! variant-idx (+ variant-idx 1))))
            ((none) (do)))))))

  (fn get-variant-payload-type ((env (Ptr TypeEnv)) (variant-form (Ptr SExpr)))
    (@intent "Get the payload type from a variant form if present")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Option (Ptr ResolvedType))))
    (@pure)
    ;; Use sexpr-list-get to avoid cross-module type issues
    (if (<= (sexpr-list-len variant-form) 1)
      (none)
      (match (sexpr-list-get variant-form 1)
        ((some type-expr)
          (lookup-payload-type env (sexpr-get-symbol-name type-expr)))
        ((none) (none)))))

  (fn checker-get-variant-name ((variant-form (Ptr SExpr)))
    (@intent "Get the variant name from a variant form")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    ;; Use parser helpers to avoid cross-module issues
    (if (sexpr-is-list variant-form)
      (if (== (sexpr-list-len variant-form) 0)
        ""
        (match (sexpr-list-get variant-form 0)
          ((some name-expr) (sexpr-get-symbol-name name-expr))
          ((none) "")))
      (match (deref variant-form)
        ((sym sym) (. sym name))
        (_ ""))))

  (fn collect-single-union-variant ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType))
                                     (variant-form (Ptr SExpr)) (variant-idx Int))
    (@intent "Process a single union variant")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr) Int) -> Unit))
    (let ((vname (checker-get-variant-name variant-form))
          (type-name (. (deref resolved) name))
          (arena (env-arena env)))
      (when (not (string-eq vname ""))
        ;; Check for reserved names that shadow built-in forms
        (when (is-reserved-variant-name vname)
          (let ((msg (string-concat arena "union variant '"
                       (string-concat arena vname
                         (string-concat arena "' in type '"
                           (string-concat arena type-name "' shadows built-in form"))))))
            (env-add-warning env msg (sexpr-line variant-form) (sexpr-col variant-form))))
        (let ((payload-type (get-variant-payload-type env variant-form))
              (v (resolved-variant-new arena vname variant-idx vname payload-type)))
          (list-push (. (deref resolved) variants) (deref v))
          ;; Register variant for collision detection (same as enum variants)
          (env-register-variant env vname type-name)))))

  (fn collect-enum-variants ((env (Ptr TypeEnv)) (enum-name String) (enum-expr (Ptr SExpr)))
    (@intent "Extract variant names from an enum definition and register them")
    (@spec (((Ptr TypeEnv) String (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= enum-expr nil))
    (match (deref enum-expr)
      ((lst lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "enum" keyword), iterate variants from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some variant-expr)
                (match (deref variant-expr)
                  ((sym sym)
                    (do (env-register-variant env (. sym name) enum-name)))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  ;; ============================================================
  ;; Constant Collection
  ;; ============================================================

  (fn collect-constants ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for constant definitions and register them")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "const")
                (collect-single-constant env arena expr))
              ((is-form expr "module")
                (collect-module-constants env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-constants ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect constant definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "const")
                  (collect-single-constant env arena item)))
              ((none) (do))))))))

  (fn collect-single-constant ((env (Ptr TypeEnv)) (arena Arena) (const-form (Ptr SExpr)))
    (@intent "Collect a single constant definition: (const NAME Type value)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= const-form nil))
    (when (sexpr-is-list const-form)
      (when (>= (sexpr-list-len const-form) 3)
        ;; Get name at position 1
        (match (sexpr-list-get const-form 1)
          ((some name-expr)
            (let ((const-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq const-name ""))
                ;; Get type at position 2
                (match (sexpr-list-get const-form 2)
                  ((some type-expr)
                    (let ((const-type (get-const-type env arena type-expr)))
                      (env-register-constant env const-name const-type)))
                  ((none) (do))))))
          ((none) (do))))))

  (fn get-const-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a constant type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((sym sym)
        (let ((type-name (. sym name)))
          ;; Use direct lookup during collection (imports not resolved yet)
          (match (env-lookup-type-direct env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ;; Complex type or other - use Int as default
      (_ (env-get-int-type env))))

  ;; ============================================================
  ;; Function Collection
  ;; ============================================================

  (fn collect-functions ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for function definitions and register signatures")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "fn")
                (collect-single-function env arena expr))
              ((is-form expr "module")
                (collect-module-functions env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-functions ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect function definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        ;; Extract and set module name from position 1
        (match (sexpr-list-get module-form 1)
          ((some name-expr)
            (let ((mod-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq mod-name ""))
                (env-set-module env (some mod-name)))))
          ((none) (do)))
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (cond
                  ((is-form item "fn")
                    (collect-single-function env arena item))
                  ((is-form item "ffi")
                    (collect-ffi-functions env arena item))
                  (else (do))))
              ((none) (do))))))))

  (fn collect-ffi-functions ((env (Ptr TypeEnv)) (arena Arena) (ffi-form (Ptr SExpr)))
    (@intent "Collect function signatures from an FFI declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= ffi-form nil))
    ;; ffi-form is (ffi "header.h" (func-name ((param Type)...) RetType) ...)
    (when (sexpr-is-list ffi-form)
      (let ((len (sexpr-list-len ffi-form)))
        ;; Skip index 0 (ffi) and index 1 (header), start at index 2
        (for (i 2 len)
          (match (sexpr-list-get ffi-form i)
            ((some func-decl)
              (collect-ffi-function env arena func-decl))
            ((none) (do)))))))

  (fn collect-ffi-function ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Collect a single FFI function or constant declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= func-decl nil))
    ;; func-decl is either:
    ;;   (func-name ((param Type)...) RetType) - function with 3 elements
    ;;   (CONST_NAME Type) - constant with 2 elements
    (when (sexpr-is-list func-decl)
      (let ((decl-len (sexpr-list-len func-decl)))
        (cond
          ;; Function declaration: 3+ elements
          ((>= decl-len 3)
            (match (sexpr-list-get func-decl 0)
              ((some name-expr)
                (let ((fn-name (sexpr-get-symbol-name name-expr)))
                  (when (not (string-eq fn-name ""))
                    ;; Build qualified name with current module
                    (let ((mod-opt (env-get-module env))
                          (qualified-name (if (. mod-opt has-value)
                                            (string-concat arena (. mod-opt value)
                                              (string-concat arena ":" fn-name))
                                            fn-name))
                          ;; Parse parameters from index 1
                          (params (collect-ffi-params env arena func-decl))
                          ;; Parse return type from index 2
                          (ret-type (get-ffi-return-type env arena func-decl))
                          (sig (fn-signature-new arena qualified-name fn-name params ret-type)))
                      ;; Set module-name for visibility checking
                      (set! (. (deref sig) module-name) mod-opt)
                      (env-register-function env sig)))))
              ((none) (do))))
          ;; Constant declaration: 2 elements (name Type)
          ((== decl-len 2)
            (match (sexpr-list-get func-decl 0)
              ((some name-expr)
                (let ((const-name (sexpr-get-symbol-name name-expr)))
                  (when (not (string-eq const-name ""))
                    (match (sexpr-list-get func-decl 1)
                      ((some type-expr)
                        (let ((const-type (get-field-type env arena type-expr)))
                          (env-register-constant env const-name const-type)))
                      ((none) (do))))))
              ((none) (do))))
          (else (do))))))

  (fn collect-ffi-params ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Collect parameters from FFI function declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (let ((params (list-new arena ParamInfo)))
      (match (sexpr-list-get func-decl 1)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (j 0 num-params)
                (match (sexpr-list-get params-expr j)
                  ((some param-form)
                    ;; param-form is (name Type)
                    (when (sexpr-is-list param-form)
                      (when (>= (sexpr-list-len param-form) 2)
                        (match (sexpr-list-get param-form 0)
                          ((some pname-expr)
                            (let ((param-name (sexpr-get-symbol-name pname-expr)))
                              (when (not (string-eq param-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some ptype-expr)
                                    (let ((param-type (get-field-type env arena ptype-expr))
                                          (info (param-info-new arena param-name param-type)))
                                      (list-push params (deref info))))
                                  ((none) (do))))))
                          ((none) (do))))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn get-ffi-return-type ((env (Ptr TypeEnv)) (arena Arena) (func-decl (Ptr SExpr)))
    (@intent "Get return type from FFI function declaration")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (sexpr-list-get func-decl 2)
      ((some ret-expr)
        (get-field-type env arena ret-expr))
      ((none) (env-get-unit-type env))))

  (fn collect-single-function ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect signature for a single function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; fn-form is (fn NAME ((param Type)...) @contracts... body)
    (when (sexpr-is-list fn-form)
      (when (>= (sexpr-list-len fn-form) 3)
        (match (sexpr-list-get fn-form 1)
          ((some name-expr)
            (let ((fn-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq fn-name ""))
                ;; Build qualified name: module:fn-name
                (let ((mod-opt (env-get-module env))
                      (qualified-name (if (. mod-opt has-value)
                                        (string-concat arena (. mod-opt value)
                                          (string-concat arena ":" fn-name))
                                        fn-name))
                      (type-params (find-fn-type-params arena fn-form))
                      (has-generics (> (list-len type-params) 0))
                      (concrete-params (collect-fn-params env arena fn-form))
                      (params (if has-generics
                                (collect-fn-params-generic env arena fn-form type-params)
                                concrete-params))
                      (ret-type (if has-generics
                                  (find-fn-return-type-generic env fn-form type-params)
                                  (find-fn-return-type env fn-form)))
                      (sig (fn-signature-new arena qualified-name fn-name params ret-type)))
                  ;; Set module-name on the signature for visibility checking
                  (set! (. (deref sig) module-name) mod-opt)
                  ;; Set type parameters for generic functions
                  (when has-generics
                    (set! (. (deref sig) type-params) type-params))
                  ;; Validate main function parameters
                  (when (string-eq fn-name "main")
                    (validate-main-params env fn-form concrete-params))
                  (env-register-function env sig)))))
          ((none) (do))))))

  (fn is-integer-type-name ((name String))
    (@intent "Check if type name is an integer type suitable for argc")
    (@spec ((String) -> Bool))
    (@pure)
    (or (string-eq name "Int")
        (string-eq name "I8")
        (string-eq name "I16")
        (string-eq name "I32")
        (string-eq name "I64")
        (string-eq name "U8")
        (string-eq name "U16")
        (string-eq name "U32")
        (string-eq name "U64")))

  (fn validate-main-params ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)) (params (List ParamInfo)))
    (@intent "Validate that main function has valid C entry point parameters")
    (@spec (((Ptr TypeEnv) (Ptr SExpr) (List ParamInfo)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; Valid main signatures:
    ;; - () - no parameters
    ;; - ((argc Int) (argv (Ptr (Ptr U8)))) - standard C main
    ;; Invalid: any other parameter count or types like Arena
    (let ((num-params (list-len params))
          (line (sexpr-line fn-form))
          (col (sexpr-col fn-form)))
      (cond
        ;; No params is fine
        ((== num-params 0) (do))
        ;; Two params is the standard argc/argv pattern
        ((== num-params 2)
          ;; First param should be integer-like (Int, I32, etc.)
          (match (list-get params 0)
            ((some p0)
              (let ((t0 (. p0 param-type)))
                (when (!= t0 nil)
                  (let ((name0 (. (deref t0) name)))
                    ;; Check for integer type names specifically
                    (when (not (is-integer-type-name name0))
                      (env-add-error env
                        "main's first parameter must be an integer type (e.g., Int for argc)"
                        line col))))))
            ((none) (do)))
          ;; Second param should be pointer-like (Ptr (Ptr U8) or similar)
          (match (list-get params 1)
            ((some p1)
              (let ((t1 (. p1 param-type)))
                (when (!= t1 nil)
                  (when (not (resolved-type-is-pointer t1))
                    (env-add-error env
                      "main's second parameter must be a pointer type (e.g., (Ptr (Ptr U8)) for argv)"
                      line col)))))
            ((none) (do))))
        ;; Any other count is invalid
        (else
          (env-add-error env
            "main function must have either no parameters or exactly two parameters (argc: Int, argv: (Ptr (Ptr U8)))"
            line col)))))

  (fn collect-fn-params ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect parameter types from a function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((params (list-new arena ParamInfo)))
      ;; Get params-expr at position 2
      (match (sexpr-list-get fn-form 2)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (i 0 num-params)
                (match (sexpr-list-get params-expr i)
                  ((some param-form)
                    ;; param-form is (param-name Type) or (mode param-name Type)
                    (when (and (sexpr-is-list param-form) (>= (sexpr-list-len param-form) 2))
                      (match (sexpr-list-get param-form 0)
                        ((some first-expr)
                          (let ((first-name (sexpr-get-symbol-name first-expr)))
                            ;; Check if first element is a mode annotation (in, out, mut)
                            (if (or (string-eq first-name "in")
                                    (string-eq first-name "out")
                                    (string-eq first-name "mut"))
                              ;; Mode form: (mode name Type) - need at least 3 elements
                              (when (>= (sexpr-list-len param-form) 3)
                                (match (sexpr-list-get param-form 1)
                                  ((some name-expr)
                                    (let ((param-name (sexpr-get-symbol-name name-expr)))
                                      (when (not (string-eq param-name ""))
                                        (match (sexpr-list-get param-form 2)
                                          ((some type-expr)
                                            (let ((param-type (get-field-type env arena type-expr))
                                                  (info (param-info-new arena param-name param-type)))
                                              (do (list-push params (deref info)))))
                                          ((none) (do))))))
                                  ((none) (do))))
                              ;; Regular form: (name Type) - first element is name
                              (when (not (string-eq first-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some type-expr)
                                    (let ((param-type (get-field-type env arena type-expr))
                                          (info (param-info-new arena first-name param-type)))
                                      (do (list-push params (deref info)))))
                                  ((none) (do)))))))
                        ((none) (do)))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn collect-fn-params-generic ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)) (type-params (List String)))
    (@intent "Collect parameter types from a function definition with type parameter awareness")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr) (List String)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((params (list-new arena ParamInfo)))
      (match (sexpr-list-get fn-form 2)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (i 0 num-params)
                (match (sexpr-list-get params-expr i)
                  ((some param-form)
                    (when (and (sexpr-is-list param-form) (>= (sexpr-list-len param-form) 2))
                      (match (sexpr-list-get param-form 0)
                        ((some first-expr)
                          (let ((first-name (sexpr-get-symbol-name first-expr)))
                            (if (or (string-eq first-name "in")
                                    (string-eq first-name "out")
                                    (string-eq first-name "mut"))
                              (when (>= (sexpr-list-len param-form) 3)
                                (match (sexpr-list-get param-form 1)
                                  ((some name-expr)
                                    (let ((param-name (sexpr-get-symbol-name name-expr)))
                                      (when (not (string-eq param-name ""))
                                        (match (sexpr-list-get param-form 2)
                                          ((some type-expr)
                                            (let ((param-type (get-field-type-generic env arena type-expr type-params))
                                                  (info (param-info-new arena param-name param-type)))
                                              (do (list-push params (deref info)))))
                                          ((none) (do))))))
                                  ((none) (do))))
                              (when (not (string-eq first-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some type-expr)
                                    (let ((param-type (get-field-type-generic env arena type-expr type-params))
                                          (info (param-info-new arena first-name param-type)))
                                      (do (list-push params (deref info)))))
                                  ((none) (do)))))))
                        ((none) (do)))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn find-fn-return-type ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)))
    (@intent "Find return type from @spec in function definition")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; Search through function body for @spec
    (let ((len (sexpr-list-len fn-form))
          (mut found Bool false)
          (mut found-type (Ptr ResolvedType) (env-get-unit-type env)))
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@spec")
              (when (not found)
                (set! found-type (checker-extract-spec-return-type env item))
                (set! found true))))
          ((none) (do))))
      found-type))

  (fn checker-extract-spec-return-type ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr)))
    (@intent "Extract return type from @spec form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    ;; (@spec ((Types) -> RetType))
    (let ((arena (env-arena env)))
      (match (sexpr-list-get spec-form 1)
        ((some spec-body)
          ;; spec-body is ((Types) -> RetType)
          (if (sexpr-is-list spec-body)
            (let ((len (sexpr-list-len spec-body)))
              ;; Last element is return type
              (match (sexpr-list-get spec-body (- len 1))
                ((some ret-expr)
                  (get-field-type env arena ret-expr))
                ((none) (env-get-unit-type env))))
            (env-get-unit-type env)))
        ((none) (env-get-unit-type env)))))
)
