;; ============================================================
;; Type Collection Pass
;;
;; Scans AST for type and function definitions, building
;; the type environment with resolved type information.
;; ============================================================

(module collect
  (export
    ;; Main collection functions
    collect-types collect-functions collect-constants collect-module)

  (import parser (SExpr SExprList SExprSymbol is-form
                  sexpr-line sexpr-col
                  sexpr-list-len sexpr-list-get sexpr-is-list sexpr-get-symbol-name))
  (import types (ResolvedType ResolvedTypeKind ResolvedVariant ResolvedField
                 FnSignature ParamInfo
                 resolved-type-new resolved-variant-new resolved-field-new
                 resolved-type-set-inner
                 fn-signature-new param-info-new))
  (import env (TypeEnv env-arena env-register-type env-lookup-type
               env-register-function env-register-constant env-set-module env-get-module
               env-get-int-type env-get-bool-type env-get-string-type
               env-get-unit-type env-register-variant env-check-variant-collisions
               env-make-option-type))

  ;; ============================================================
  ;; Main Collection Functions
  ;; ============================================================

  (fn collect-module ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Collect all types, constants, and functions from a module AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    ;; First pass: collect all type definitions
    (collect-types env ast)
    ;; Check for ambiguous enum variants (same name in different enums)
    (env-check-variant-collisions env)
    ;; Second pass: collect constant definitions
    (collect-constants env ast)
    ;; Third pass: collect function signatures
    (collect-functions env ast))

  (fn collect-types ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for type definitions and register them")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ;; Direct type definition
              ((is-form expr "type")
                (collect-type-def env arena expr))
              ;; Module - scan inside for types
              ((is-form expr "module")
                (collect-module-types env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-type-def ((env (Ptr TypeEnv)) (arena Arena) (expr (Ptr SExpr)))
    (@intent "Collect a single type definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (match (deref expr)
      ((list lst)
        (let ((items (. lst items)))
          ;; Extract type name from position 1: (type NAME TYPE-EXPR)
          (match (list-get items 1)
            ((some name-expr)
              (match (deref name-expr)
                ((symbol sym)
                  (let ((type-name (. sym name)))
                    ;; Check type-expr to determine kind
                    (match (list-get items 2)
                      ((some type-expr)
                        (cond
                          ;; Enum: (type Name (enum v1 v2 ...))
                          ((is-form type-expr "enum")
                            (let ((resolved (resolved-type-new arena 'rk-enum type-name (none) type-name)))
                              (env-register-type env resolved)
                              (collect-enum-variants env type-name type-expr)))
                          ;; Record: (type Name (record (field Type) ...))
                          ((is-form type-expr "record")
                            (let ((resolved (resolved-type-new arena 'rk-record type-name (none) type-name)))
                              (env-register-type env resolved)
                              (collect-record-fields env arena resolved type-expr)))
                          ;; Union: (type Name (union (variant-name Type) ...))
                          ((is-form type-expr "union")
                            (let ((resolved (resolved-type-new arena 'rk-union type-name (none) type-name)))
                              (env-register-type env resolved)
                              (collect-union-variants env arena resolved type-expr)))
                          ;; Range: (type Name (BaseType min .. max))
                          ((is-range-type-expr type-expr)
                            (let ((base-type (get-range-base-type env arena type-expr))
                                  (resolved (resolved-type-new arena 'rk-range type-name (none) type-name)))
                              (resolved-type-set-inner resolved base-type)
                              (env-register-type env resolved)))
                          ;; Other - use placeholder
                          (else
                            (let ((resolved (resolved-type-new arena 'rk-primitive type-name (none) type-name)))
                              (env-register-type env resolved)))))
                      ((none)
                        ;; No type expr - use placeholder
                        (let ((resolved (resolved-type-new arena 'rk-primitive type-name (none) type-name)))
                          (env-register-type env resolved))))))
                (_ (do))))
            ((none) (do)))))
      (_ (do))))

  (fn collect-record-fields ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (record-expr (Ptr SExpr)))
    (@intent "Extract field definitions from a record and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= record-expr nil))
    (match (deref record-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "record" keyword), iterate fields from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some field-form)
                ;; Each field is (field-name Type)
                (match (deref field-form)
                  ((list field-lst)
                    (let ((field-items (. field-lst items)))
                      ;; Get field name at index 0
                      (match (list-get field-items 0)
                        ((some name-expr)
                          (match (deref name-expr)
                            ((symbol name-sym)
                              ;; Get field type at index 1
                              (match (list-get field-items 1)
                                ((some type-expr)
                                  (let ((field-name (. name-sym name))
                                        (field-type (get-field-type env arena type-expr))
                                        (field (resolved-field-new arena field-name field-type (- i 1))))
                                    ;; Push directly to resolved's fields list
                                    (do (list-push (. (deref resolved) fields) (deref field)))))
                                ((none) (do))))
                            (_ (do))))
                        ((none) (do)))))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  (fn get-field-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a field type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((symbol sym)
        (let ((type-name (. sym name)))
          ;; Try to look up type, fall back to creating placeholder
          (match (env-lookup-type env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ((list lst)
        ;; Complex type expression like (Option Int), (Ptr T), (List T)
        (let ((items (. lst items)))
          (match (list-get items 0)
            ((some head-expr)
              (let ((head-name (sexpr-get-symbol-name head-expr)))
                (cond
                  ;; Option type: (Option InnerType)
                  ((string-eq head-name "Option")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env))))
                      (env-make-option-type env inner-type)))
                  ;; Ptr type: (Ptr PointeeType)
                  ((string-eq head-name "Ptr")
                    (let ((inner-type (if (>= (list-len items) 2)
                                        (match (list-get items 1)
                                          ((some inner-expr) (get-field-type env arena inner-expr))
                                          ((none) (env-get-int-type env)))
                                        (env-get-int-type env)))
                          (ptr-type (resolved-type-new arena 'rk-ptr "Ptr" (none) "void*")))
                      (resolved-type-set-inner ptr-type inner-type)
                      ptr-type))
                  ;; List type: (List ElemType) - return placeholder
                  ((string-eq head-name "List")
                    (resolved-type-new arena 'rk-primitive "List" (none) "slop_list_t*"))
                  ;; Unknown complex type
                  (else (resolved-type-new arena 'rk-primitive head-name (none) head-name)))))
            ((none) (env-get-unit-type env)))))
      ;; Other expression types
      (_ (env-get-unit-type env))))

  (fn collect-module-types ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect type definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (match (deref module-form)
        ((list lst)
          (let ((items (. lst items))
                (len (list-len items)))
            ;; Skip module name and export, start at index 2
            (for (i 2 len)
              (match (list-get items i)
                ((some item)
                  (when (is-form item "type")
                    (collect-type-def env arena item)))
                ((none) (do))))))
        (_ (do)))))

  (fn lookup-payload-type ((env (Ptr TypeEnv)) (type-name String))
    (@intent "Look up a type by name for union payload")
    (@spec (((Ptr TypeEnv) String) -> (Option (Ptr ResolvedType))))
    (@pure)
    (if (string-eq type-name "")
      (none)
      (match (env-lookup-type env type-name)
        ((some t) (some t))
        ((none)
          (cond
            ((string-eq type-name "Int") (some (env-get-int-type env)))
            ((string-eq type-name "Bool") (some (env-get-bool-type env)))
            ((string-eq type-name "String") (some (env-get-string-type env)))
            (else (none)))))))

  (fn is-range-type-expr ((type-expr (Ptr SExpr)))
    (@intent "Check if expression is a range type like (Int 0 .. 127)")
    (@spec (((Ptr SExpr)) -> Bool))
    (@pure)
    ;; Range type is a list like (Int 0 .. 127) or (Int 0 127)
    ;; First element is the base type (a symbol like Int)
    (if (not (sexpr-is-list type-expr))
      false
      (if (< (sexpr-list-len type-expr) 2)
        false
        (match (sexpr-list-get type-expr 0)
          ((some first-elem)
            (let ((base-name (sexpr-get-symbol-name first-elem)))
              ;; Check if it's a known base type for ranges
              (or (string-eq base-name "Int")
                  (string-eq base-name "Float"))))
          ((none) false)))))

  (fn get-range-base-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get the base type from a range expression like (Int 0 .. 127)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (sexpr-list-get type-expr 0)
      ((some first-elem)
        (let ((base-name (sexpr-get-symbol-name first-elem)))
          (cond
            ((string-eq base-name "Int") (env-get-int-type env))
            ((string-eq base-name "Float")
              (match (env-lookup-type env "Float")
                ((some t) t)
                ((none) (env-get-int-type env))))
            (else (env-get-int-type env)))))
      ((none) (env-get-int-type env))))

  (fn get-type-name-from-expr ((expr (Ptr SExpr)))
    (@intent "Extract type name from an expression")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    (match (deref expr)
      ((symbol sym) (. sym name))
      (_ "")))

  (fn collect-union-variants ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType)) (union-expr (Ptr SExpr)))
    (@intent "Extract variant definitions from a union and add them to the resolved type")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= resolved nil))
    (@pre (!= union-expr nil))
    (match (deref union-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items))
              (mut variant-idx 0))
          ;; Skip index 0 (the "union" keyword), iterate variants from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some variant-form)
                (collect-single-union-variant env arena resolved variant-form variant-idx)
                (set! variant-idx (+ variant-idx 1)))
              ((none) (do))))))
      (_ (do))))

  (fn get-variant-payload-type ((env (Ptr TypeEnv)) (variant-form (Ptr SExpr)))
    (@intent "Get the payload type from a variant form if present")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Option (Ptr ResolvedType))))
    (@pure)
    ;; Use sexpr-list-get to avoid cross-module type issues
    (if (<= (sexpr-list-len variant-form) 1)
      (none)
      (match (sexpr-list-get variant-form 1)
        ((some type-expr)
          (lookup-payload-type env (sexpr-get-symbol-name type-expr)))
        ((none) (none)))))

  (fn get-variant-name ((variant-form (Ptr SExpr)))
    (@intent "Get the variant name from a variant form")
    (@spec (((Ptr SExpr)) -> String))
    (@pure)
    ;; Use parser helpers to avoid cross-module issues
    (if (sexpr-is-list variant-form)
      (if (== (sexpr-list-len variant-form) 0)
        ""
        (match (sexpr-list-get variant-form 0)
          ((some name-expr) (sexpr-get-symbol-name name-expr))
          ((none) "")))
      (match (deref variant-form)
        ((symbol sym) (. sym name))
        (_ ""))))

  (fn collect-single-union-variant ((env (Ptr TypeEnv)) (arena Arena) (resolved (Ptr ResolvedType))
                                     (variant-form (Ptr SExpr)) (variant-idx Int))
    (@intent "Process a single union variant")
    (@spec (((Ptr TypeEnv) Arena (Ptr ResolvedType) (Ptr SExpr) Int) -> Unit))
    (let ((variant-name (get-variant-name variant-form)))
      (when (not (string-eq variant-name ""))
        (let ((payload-type (get-variant-payload-type env variant-form))
              (variant (resolved-variant-new arena variant-name variant-idx variant-name payload-type)))
          (list-push (. (deref resolved) variants) (deref variant))))))

  (fn collect-enum-variants ((env (Ptr TypeEnv)) (enum-name String) (enum-expr (Ptr SExpr)))
    (@intent "Extract variant names from an enum definition and register them")
    (@spec (((Ptr TypeEnv) String (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= enum-expr nil))
    (match (deref enum-expr)
      ((list lst)
        (let ((items (. lst items))
              (len (list-len items)))
          ;; Skip index 0 (the "enum" keyword), iterate variants from index 1
          (for (i 1 len)
            (match (list-get items i)
              ((some variant-expr)
                (match (deref variant-expr)
                  ((symbol sym)
                    (do (env-register-variant env (. sym name) enum-name)))
                  (_ (do))))
              ((none) (do))))))
      (_ (do))))

  ;; ============================================================
  ;; Constant Collection
  ;; ============================================================

  (fn collect-constants ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for constant definitions and register them")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "const")
                (collect-single-constant env arena expr))
              ((is-form expr "module")
                (collect-module-constants env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-constants ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect constant definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "const")
                  (collect-single-constant env arena item)))
              ((none) (do))))))))

  (fn collect-single-constant ((env (Ptr TypeEnv)) (arena Arena) (const-form (Ptr SExpr)))
    (@intent "Collect a single constant definition: (const NAME Type value)")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= const-form nil))
    (when (sexpr-is-list const-form)
      (when (>= (sexpr-list-len const-form) 3)
        ;; Get name at position 1
        (match (sexpr-list-get const-form 1)
          ((some name-expr)
            (let ((const-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq const-name ""))
                ;; Get type at position 2
                (match (sexpr-list-get const-form 2)
                  ((some type-expr)
                    (let ((const-type (get-const-type env arena type-expr)))
                      (env-register-constant env const-name const-type)))
                  ((none) (do))))))
          ((none) (do))))))

  (fn get-const-type ((env (Ptr TypeEnv)) (arena Arena) (type-expr (Ptr SExpr)))
    (@intent "Get resolved type for a constant type expression")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (deref type-expr)
      ((symbol sym)
        (let ((type-name (. sym name)))
          ;; Try to look up type, fall back to primitive
          (match (env-lookup-type env type-name)
            ((some t) t)
            ((none)
              ;; Check for built-in types
              (cond
                ((string-eq type-name "Int") (env-get-int-type env))
                ((string-eq type-name "Bool") (env-get-bool-type env))
                ((string-eq type-name "String") (env-get-string-type env))
                ((string-eq type-name "Unit") (env-get-unit-type env))
                ;; Unknown type - create placeholder
                (else (resolved-type-new arena 'rk-primitive type-name (none) type-name)))))))
      ;; Complex type or other - use Int as default
      (_ (env-get-int-type env))))

  ;; ============================================================
  ;; Function Collection
  ;; ============================================================

  (fn collect-functions ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Scan AST for function definitions and register signatures")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((arena (env-arena env))
          (len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "fn")
                (collect-single-function env arena expr))
              ((is-form expr "module")
                (collect-module-functions env expr))
              (else (do))))
          ((none) (do))))))

  (fn collect-module-functions ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Collect function definitions from inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (let ((arena (env-arena env)))
      (when (sexpr-is-list module-form)
        (let ((len (sexpr-list-len module-form)))
          ;; Skip module name and export, start at index 2
          (for (i 2 len)
            (match (sexpr-list-get module-form i)
              ((some item)
                (when (is-form item "fn")
                  (collect-single-function env arena item)))
              ((none) (do))))))))

  (fn collect-single-function ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect signature for a single function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; fn-form is (fn NAME ((param Type)...) @contracts... body)
    (when (sexpr-is-list fn-form)
      (when (>= (sexpr-list-len fn-form) 3)
        (match (sexpr-list-get fn-form 1)
          ((some name-expr)
            (let ((fn-name (sexpr-get-symbol-name name-expr)))
              (when (not (string-eq fn-name ""))
                (let ((params (collect-fn-params env arena fn-form))
                      (ret-type (find-fn-return-type env fn-form))
                      (sig (fn-signature-new arena fn-name fn-name params ret-type)))
                  (env-register-function env sig)))))
          ((none) (do))))))

  (fn collect-fn-params ((env (Ptr TypeEnv)) (arena Arena) (fn-form (Ptr SExpr)))
    (@intent "Collect parameter types from a function definition")
    (@spec (((Ptr TypeEnv) Arena (Ptr SExpr)) -> (List ParamInfo)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    (let ((params (list-new arena ParamInfo)))
      ;; Get params-expr at position 2
      (match (sexpr-list-get fn-form 2)
        ((some params-expr)
          (when (sexpr-is-list params-expr)
            (let ((num-params (sexpr-list-len params-expr)))
              (for (i 0 num-params)
                (match (sexpr-list-get params-expr i)
                  ((some param-form)
                    ;; param-form is (param-name Type) or (mode param-name Type)
                    (when (and (sexpr-is-list param-form) (>= (sexpr-list-len param-form) 2))
                      (match (sexpr-list-get param-form 0)
                        ((some first-expr)
                          (let ((first-name (sexpr-get-symbol-name first-expr)))
                            ;; Check if first element is a mode annotation (in, out, mut)
                            (if (or (string-eq first-name "in")
                                    (string-eq first-name "out")
                                    (string-eq first-name "mut"))
                              ;; Mode form: (mode name Type) - need at least 3 elements
                              (when (>= (sexpr-list-len param-form) 3)
                                (match (sexpr-list-get param-form 1)
                                  ((some name-expr)
                                    (let ((param-name (sexpr-get-symbol-name name-expr)))
                                      (when (not (string-eq param-name ""))
                                        (match (sexpr-list-get param-form 2)
                                          ((some type-expr)
                                            (let ((param-type (get-field-type env arena type-expr))
                                                  (info (param-info-new arena param-name param-type)))
                                              (do (list-push params (deref info)))))
                                          ((none) (do))))))
                                  ((none) (do))))
                              ;; Regular form: (name Type) - first element is name
                              (when (not (string-eq first-name ""))
                                (match (sexpr-list-get param-form 1)
                                  ((some type-expr)
                                    (let ((param-type (get-field-type env arena type-expr))
                                          (info (param-info-new arena first-name param-type)))
                                      (do (list-push params (deref info)))))
                                  ((none) (do)))))))
                        ((none) (do)))))
                  ((none) (do)))))))
        ((none) (do)))
      params))

  (fn find-fn-return-type ((env (Ptr TypeEnv)) (fn-form (Ptr SExpr)))
    (@intent "Find return type from @spec in function definition")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (@pre (!= fn-form nil))
    ;; Search through function body for @spec
    (let ((len (sexpr-list-len fn-form))
          (mut found Bool false)
          (mut found-type (Ptr ResolvedType) (env-get-unit-type env)))
      (for (i 3 len)
        (match (sexpr-list-get fn-form i)
          ((some item)
            (when (is-form item "@spec")
              (when (not found)
                (set! found-type (extract-spec-return-type env item))
                (set! found true))))
          ((none) (do))))
      found-type))

  (fn extract-spec-return-type ((env (Ptr TypeEnv)) (spec-form (Ptr SExpr)))
    (@intent "Extract return type from @spec form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    ;; (@spec ((Types) -> RetType))
    (let ((arena (env-arena env)))
      (match (sexpr-list-get spec-form 1)
        ((some spec-body)
          ;; spec-body is ((Types) -> RetType)
          (if (sexpr-is-list spec-body)
            (let ((len (sexpr-list-len spec-body)))
              ;; Last element is return type
              (match (sexpr-list-get spec-body (- len 1))
                ((some ret-expr)
                  (get-field-type env arena ret-expr))
                ((none) (env-get-unit-type env))))
            (env-get-unit-type env)))
        ((none) (env-get-unit-type env)))))
)
