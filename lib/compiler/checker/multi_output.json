{"types":{"header":"#ifndef SLOP_types_H\n#define SLOP_types_H\n\n#include \"slop_runtime.h\"\n#include <stdint.h>\n#include <stdbool.h>\n\ntypedef struct types_SExprSymbol types_SExprSymbol;\ntypedef struct types_SExprString types_SExprString;\ntypedef struct types_SExprNumber types_SExprNumber;\ntypedef struct types_SExprList types_SExprList;\ntypedef struct types_SExpr types_SExpr;\ntypedef struct types_RangeBounds types_RangeBounds;\ntypedef struct types_FieldDef types_FieldDef;\ntypedef struct types_VariantDef types_VariantDef;\ntypedef struct types_TypeDef types_TypeDef;\ntypedef struct types_ResolvedVariant types_ResolvedVariant;\ntypedef struct types_ResolvedField types_ResolvedField;\ntypedef struct types_ResolvedType types_ResolvedType;\ntypedef struct types_ParamInfo types_ParamInfo;\ntypedef struct types_FnSignature types_FnSignature;\ntypedef struct types_TypeError types_TypeError;\ntypedef struct types_Diagnostic types_Diagnostic;\n\ntypedef enum {\n    types_TypeKind_kind_primitive,\n    types_TypeKind_kind_range,\n    types_TypeKind_kind_record,\n    types_TypeKind_kind_enum,\n    types_TypeKind_kind_union,\n    types_TypeKind_kind_alias,\n    types_TypeKind_kind_option,\n    types_TypeKind_kind_result,\n    types_TypeKind_kind_list,\n    types_TypeKind_kind_map,\n    types_TypeKind_kind_ptr,\n    types_TypeKind_kind_array,\n    types_TypeKind_kind_function,\n    types_TypeKind_kind_ffi\n} types_TypeKind;\n\ntypedef enum {\n    types_ResolvedTypeKind_rk_primitive,\n    types_ResolvedTypeKind_rk_range,\n    types_ResolvedTypeKind_rk_record,\n    types_ResolvedTypeKind_rk_union,\n    types_ResolvedTypeKind_rk_enum,\n    types_ResolvedTypeKind_rk_list,\n    types_ResolvedTypeKind_rk_ptr,\n    types_ResolvedTypeKind_rk_option,\n    types_ResolvedTypeKind_rk_result,\n    types_ResolvedTypeKind_rk_function,\n    types_ResolvedTypeKind_rk_array,\n    types_ResolvedTypeKind_rk_map,\n    types_ResolvedTypeKind_rk_set,\n    types_ResolvedTypeKind_rk_chan,\n    types_ResolvedTypeKind_rk_thread,\n    types_ResolvedTypeKind_rk_typevar\n} types_ResolvedTypeKind;\n\ntypedef enum {\n    types_TypeErrorKind_te_undefined_type,\n    types_TypeErrorKind_te_undefined_var,\n    types_TypeErrorKind_te_undefined_fn,\n    types_TypeErrorKind_te_type_mismatch,\n    types_TypeErrorKind_te_arity_mismatch,\n    types_TypeErrorKind_te_not_a_function,\n    types_TypeErrorKind_te_not_a_record,\n    types_TypeErrorKind_te_unknown_field,\n    types_TypeErrorKind_te_not_a_union,\n    types_TypeErrorKind_te_unknown_variant,\n    types_TypeErrorKind_te_non_exhaustive,\n    types_TypeErrorKind_te_import_error\n} types_TypeErrorKind;\n\ntypedef enum {\n    types_DiagnosticLevel_diag_warning,\n    types_DiagnosticLevel_diag_error\n} types_DiagnosticLevel;\n\n#ifndef SLOP_LIST_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_LIST_TYPES_SEXPR_PTR_DEFINED\nSLOP_LIST_DEFINE(types_SExpr*, slop_list_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr*, slop_option_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_OPTION_LIST_STRING_DEFINED\n#define SLOP_OPTION_LIST_STRING_DEFINED\nSLOP_OPTION_DEFINE(slop_list_string, slop_option_list_string)\n#endif\n\nstruct types_SExprSymbol {\n    slop_string name;\n    int64_t line;\n    int64_t col;\n    slop_option_types_ResolvedType_ptr resolved_type;\n};\ntypedef struct types_SExprSymbol types_SExprSymbol;\n\n#ifndef SLOP_OPTION_TYPES_SEXPRSYMBOL_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRSYMBOL_DEFINED\nSLOP_OPTION_DEFINE(types_SExprSymbol, slop_option_types_SExprSymbol)\n#endif\n\nstruct types_SExprString {\n    slop_string value;\n    int64_t line;\n    int64_t col;\n    slop_option_types_ResolvedType_ptr resolved_type;\n};\ntypedef struct types_SExprString types_SExprString;\n\n#ifndef SLOP_OPTION_TYPES_SEXPRSTRING_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRSTRING_DEFINED\nSLOP_OPTION_DEFINE(types_SExprString, slop_option_types_SExprString)\n#endif\n\nstruct types_SExprNumber {\n    int64_t int_value;\n    double float_value;\n    uint8_t is_float;\n    slop_string raw;\n    int64_t line;\n    int64_t col;\n    slop_option_types_ResolvedType_ptr resolved_type;\n};\ntypedef struct types_SExprNumber types_SExprNumber;\n\n#ifndef SLOP_OPTION_TYPES_SEXPRNUMBER_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRNUMBER_DEFINED\nSLOP_OPTION_DEFINE(types_SExprNumber, slop_option_types_SExprNumber)\n#endif\n\nstruct types_SExprList {\n    slop_list_types_SExpr_ptr items;\n    int64_t line;\n    int64_t col;\n    slop_option_types_ResolvedType_ptr resolved_type;\n};\ntypedef struct types_SExprList types_SExprList;\n\n#ifndef SLOP_OPTION_TYPES_SEXPRLIST_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRLIST_DEFINED\nSLOP_OPTION_DEFINE(types_SExprList, slop_option_types_SExprList)\n#endif\n\ntypedef enum {\n    types_SExpr_sym,\n    types_SExpr_str,\n    types_SExpr_num,\n    types_SExpr_lst\n} types_SExpr_tag;\n\nstruct types_SExpr {\n    types_SExpr_tag tag;\n    union {\n        types_SExprSymbol sym;\n        types_SExprString str;\n        types_SExprNumber num;\n        types_SExprList lst;\n    } data;\n};\ntypedef struct types_SExpr types_SExpr;\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr, slop_option_types_SExpr)\n#endif\n\nstruct types_RangeBounds {\n    uint8_t has_min;\n    uint8_t has_max;\n    int64_t min_val;\n    int64_t max_val;\n};\ntypedef struct types_RangeBounds types_RangeBounds;\n\n#ifndef SLOP_OPTION_TYPES_RANGEBOUNDS_DEFINED\n#define SLOP_OPTION_TYPES_RANGEBOUNDS_DEFINED\nSLOP_OPTION_DEFINE(types_RangeBounds, slop_option_types_RangeBounds)\n#endif\n\nstruct types_FieldDef {\n    slop_string name;\n    types_SExpr* type_expr;\n};\ntypedef struct types_FieldDef types_FieldDef;\n\n#ifndef SLOP_OPTION_TYPES_FIELDDEF_DEFINED\n#define SLOP_OPTION_TYPES_FIELDDEF_DEFINED\nSLOP_OPTION_DEFINE(types_FieldDef, slop_option_types_FieldDef)\n#endif\n\n#ifndef SLOP_LIST_TYPES_FIELDDEF_DEFINED\n#define SLOP_LIST_TYPES_FIELDDEF_DEFINED\nSLOP_LIST_DEFINE(types_FieldDef, slop_list_types_FieldDef)\n#endif\n\n#ifndef SLOP_OPTION_LIST_TYPES_FIELDDEF_DEFINED\n#define SLOP_OPTION_LIST_TYPES_FIELDDEF_DEFINED\nSLOP_OPTION_DEFINE(slop_list_types_FieldDef, slop_option_list_types_FieldDef)\n#endif\n\nstruct types_VariantDef {\n    slop_string tag;\n    slop_option_types_SExpr_ptr payload;\n};\ntypedef struct types_VariantDef types_VariantDef;\n\n#ifndef SLOP_OPTION_TYPES_VARIANTDEF_DEFINED\n#define SLOP_OPTION_TYPES_VARIANTDEF_DEFINED\nSLOP_OPTION_DEFINE(types_VariantDef, slop_option_types_VariantDef)\n#endif\n\n#ifndef SLOP_LIST_TYPES_VARIANTDEF_DEFINED\n#define SLOP_LIST_TYPES_VARIANTDEF_DEFINED\nSLOP_LIST_DEFINE(types_VariantDef, slop_list_types_VariantDef)\n#endif\n\n#ifndef SLOP_OPTION_LIST_TYPES_VARIANTDEF_DEFINED\n#define SLOP_OPTION_LIST_TYPES_VARIANTDEF_DEFINED\nSLOP_OPTION_DEFINE(slop_list_types_VariantDef, slop_option_list_types_VariantDef)\n#endif\n\nstruct types_TypeDef {\n    slop_string name;\n    types_TypeKind kind;\n    types_SExpr* source_expr;\n    slop_option_types_RangeBounds range;\n    slop_option_list_types_FieldDef fields;\n    slop_option_list_types_VariantDef variants;\n    slop_option_list_string type_params;\n};\ntypedef struct types_TypeDef types_TypeDef;\n\n#ifndef SLOP_OPTION_TYPES_TYPEDEF_DEFINED\n#define SLOP_OPTION_TYPES_TYPEDEF_DEFINED\nSLOP_OPTION_DEFINE(types_TypeDef, slop_option_types_TypeDef)\n#endif\n\nstruct types_ResolvedVariant {\n    slop_string name;\n    int64_t index;\n    slop_string tag_constant;\n    slop_option_types_ResolvedType_ptr payload_type;\n};\ntypedef struct types_ResolvedVariant types_ResolvedVariant;\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDVARIANT_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDVARIANT_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedVariant, slop_option_types_ResolvedVariant)\n#endif\n\n#ifndef SLOP_LIST_TYPES_RESOLVEDVARIANT_DEFINED\n#define SLOP_LIST_TYPES_RESOLVEDVARIANT_DEFINED\nSLOP_LIST_DEFINE(types_ResolvedVariant, slop_list_types_ResolvedVariant)\n#endif\n\nstruct types_ResolvedField {\n    slop_string name;\n    types_ResolvedType* field_type;\n    int64_t offset;\n};\ntypedef struct types_ResolvedField types_ResolvedField;\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDFIELD_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDFIELD_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedField, slop_option_types_ResolvedField)\n#endif\n\n#ifndef SLOP_LIST_TYPES_RESOLVEDFIELD_DEFINED\n#define SLOP_LIST_TYPES_RESOLVEDFIELD_DEFINED\nSLOP_LIST_DEFINE(types_ResolvedField, slop_list_types_ResolvedField)\n#endif\n\nstruct types_ResolvedType {\n    types_ResolvedTypeKind kind;\n    slop_string name;\n    slop_option_string module_name;\n    slop_string c_name;\n    slop_list_types_ResolvedVariant variants;\n    slop_list_types_ResolvedField fields;\n    slop_option_types_ResolvedType_ptr inner_type;\n    slop_option_types_ResolvedType_ptr inner_type2;\n    slop_option_types_RangeBounds range;\n    int64_t source_line;\n    int64_t source_col;\n};\ntypedef struct types_ResolvedType types_ResolvedType;\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType, slop_option_types_ResolvedType)\n#endif\n\nstruct types_ParamInfo {\n    slop_string name;\n    types_ResolvedType* param_type;\n};\ntypedef struct types_ParamInfo types_ParamInfo;\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n#ifndef SLOP_LIST_TYPES_PARAMINFO_DEFINED\n#define SLOP_LIST_TYPES_PARAMINFO_DEFINED\nSLOP_LIST_DEFINE(types_ParamInfo, slop_list_types_ParamInfo)\n#endif\n\nstruct types_FnSignature {\n    slop_string name;\n    slop_string c_name;\n    slop_list_types_ParamInfo params;\n    types_ResolvedType* return_type;\n    uint8_t is_pure;\n    uint8_t allocates;\n    slop_option_string module_name;\n    slop_list_string type_params;\n};\ntypedef struct types_FnSignature types_FnSignature;\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature, slop_option_types_FnSignature)\n#endif\n\nstruct types_TypeError {\n    types_TypeErrorKind kind;\n    slop_string message;\n    int64_t line;\n    int64_t col;\n};\ntypedef struct types_TypeError types_TypeError;\n\n#ifndef SLOP_OPTION_TYPES_TYPEERROR_DEFINED\n#define SLOP_OPTION_TYPES_TYPEERROR_DEFINED\nSLOP_OPTION_DEFINE(types_TypeError, slop_option_types_TypeError)\n#endif\n\nstruct types_Diagnostic {\n    types_DiagnosticLevel level;\n    slop_string message;\n    int64_t line;\n    int64_t col;\n};\ntypedef struct types_Diagnostic types_Diagnostic;\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\ntypes_RangeBounds types_range_bounds_new(uint8_t has_min, int64_t min_val, uint8_t has_max, int64_t max_val);\ntypes_RangeBounds types_range_bounds_unbounded(void);\nuint8_t types_range_contains(types_RangeBounds bounds, int64_t value);\nint64_t types_min(int64_t a, int64_t b);\nint64_t types_max(int64_t a, int64_t b);\ntypes_RangeBounds types_range_intersect(types_RangeBounds a, types_RangeBounds b);\ntypes_RangeBounds types_range_union(types_RangeBounds a, types_RangeBounds b);\ntypes_ResolvedVariant* types_resolved_variant_new(slop_arena* arena, slop_string name, int64_t index, slop_string tag_constant, slop_option_types_ResolvedType_ptr payload);\ntypes_ResolvedField* types_resolved_field_new(slop_arena* arena, slop_string name, types_ResolvedType* field_type, int64_t offset);\ntypes_ResolvedType* types_resolved_type_new(slop_arena* arena, types_ResolvedTypeKind kind, slop_string name, slop_option_string module_name, slop_string c_name);\nvoid types_resolved_type_set_inner(types_ResolvedType* t, types_ResolvedType* inner);\nvoid types_resolved_type_set_inner2(types_ResolvedType* t, types_ResolvedType* inner);\ntypes_ParamInfo* types_param_info_new(slop_arena* arena, slop_string name, types_ResolvedType* param_type);\ntypes_FnSignature* types_fn_signature_new(slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* return_type);\ntypes_TypeError types_type_error_new(types_TypeErrorKind kind, slop_string message, int64_t line, int64_t col);\ntypes_Diagnostic types_diagnostic_new(types_DiagnosticLevel level, slop_string message, int64_t line, int64_t col);\nuint8_t types_is_primitive_kind(types_ResolvedTypeKind kind);\nuint8_t types_is_container_kind(types_ResolvedTypeKind kind);\nuint8_t types_resolved_type_is_pointer(types_ResolvedType* t);\nuint8_t types_resolved_type_is_union(types_ResolvedType* t);\nuint8_t types_resolved_type_is_record(types_ResolvedType* t);\nuint8_t types_resolved_type_is_function(types_ResolvedType* t);\nslop_option_int types_resolved_type_get_variant_index(types_ResolvedType* t, slop_string name);\nslop_option_types_ResolvedType_ptr types_resolved_type_get_variant_payload(types_ResolvedType* t, slop_string name);\nuint8_t types_resolved_type_has_field(types_ResolvedType* t, slop_string name);\nslop_option_types_ResolvedType_ptr types_resolved_type_get_field_type(types_ResolvedType* t, slop_string name);\nslop_string types_resolved_type_to_slop_string(slop_arena* arena, types_ResolvedType* t);\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPRSYMBOL_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRSYMBOL_DEFINED\nSLOP_OPTION_DEFINE(types_SExprSymbol, slop_option_types_SExprSymbol)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPRSTRING_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRSTRING_DEFINED\nSLOP_OPTION_DEFINE(types_SExprString, slop_option_types_SExprString)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPRNUMBER_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRNUMBER_DEFINED\nSLOP_OPTION_DEFINE(types_SExprNumber, slop_option_types_SExprNumber)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr*, slop_option_types_SExpr_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPRLIST_DEFINED\n#define SLOP_OPTION_TYPES_SEXPRLIST_DEFINED\nSLOP_OPTION_DEFINE(types_SExprList, slop_option_types_SExprList)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_SEXPR_DEFINED\n#define SLOP_OPTION_TYPES_SEXPR_DEFINED\nSLOP_OPTION_DEFINE(types_SExpr, slop_option_types_SExpr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RANGEBOUNDS_DEFINED\n#define SLOP_OPTION_TYPES_RANGEBOUNDS_DEFINED\nSLOP_OPTION_DEFINE(types_RangeBounds, slop_option_types_RangeBounds)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FIELDDEF_DEFINED\n#define SLOP_OPTION_TYPES_FIELDDEF_DEFINED\nSLOP_OPTION_DEFINE(types_FieldDef, slop_option_types_FieldDef)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_VARIANTDEF_DEFINED\n#define SLOP_OPTION_TYPES_VARIANTDEF_DEFINED\nSLOP_OPTION_DEFINE(types_VariantDef, slop_option_types_VariantDef)\n#endif\n\n#ifndef SLOP_OPTION_LIST_TYPES_FIELDDEF_DEFINED\n#define SLOP_OPTION_LIST_TYPES_FIELDDEF_DEFINED\nSLOP_OPTION_DEFINE(slop_list_types_FieldDef, slop_option_list_types_FieldDef)\n#endif\n\n#ifndef SLOP_OPTION_LIST_TYPES_VARIANTDEF_DEFINED\n#define SLOP_OPTION_LIST_TYPES_VARIANTDEF_DEFINED\nSLOP_OPTION_DEFINE(slop_list_types_VariantDef, slop_option_list_types_VariantDef)\n#endif\n\n#ifndef SLOP_OPTION_LIST_STRING_DEFINED\n#define SLOP_OPTION_LIST_STRING_DEFINED\nSLOP_OPTION_DEFINE(slop_list_string, slop_option_list_string)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_TYPEDEF_DEFINED\n#define SLOP_OPTION_TYPES_TYPEDEF_DEFINED\nSLOP_OPTION_DEFINE(types_TypeDef, slop_option_types_TypeDef)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDVARIANT_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDVARIANT_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedVariant, slop_option_types_ResolvedVariant)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDFIELD_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDFIELD_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedField, slop_option_types_ResolvedField)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType, slop_option_types_ResolvedType)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature, slop_option_types_FnSignature)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_TYPEERROR_DEFINED\n#define SLOP_OPTION_TYPES_TYPEERROR_DEFINED\nSLOP_OPTION_DEFINE(types_TypeError, slop_option_types_TypeError)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n\n#endif\n","impl":"types_RangeBounds types_range_bounds_new(uint8_t has_min, int64_t min_val, uint8_t has_max, int64_t max_val);\ntypes_RangeBounds types_range_bounds_unbounded(void);\nuint8_t types_range_contains(types_RangeBounds bounds, int64_t value);\nint64_t types_min(int64_t a, int64_t b);\nint64_t types_max(int64_t a, int64_t b);\ntypes_RangeBounds types_range_intersect(types_RangeBounds a, types_RangeBounds b);\ntypes_RangeBounds types_range_union(types_RangeBounds a, types_RangeBounds b);\ntypes_ResolvedVariant* types_resolved_variant_new(slop_arena* arena, slop_string name, int64_t index, slop_string tag_constant, slop_option_types_ResolvedType_ptr payload);\ntypes_ResolvedField* types_resolved_field_new(slop_arena* arena, slop_string name, types_ResolvedType* field_type, int64_t offset);\ntypes_ResolvedType* types_resolved_type_new(slop_arena* arena, types_ResolvedTypeKind kind, slop_string name, slop_option_string module_name, slop_string c_name);\nvoid types_resolved_type_set_inner(types_ResolvedType* t, types_ResolvedType* inner);\nvoid types_resolved_type_set_inner2(types_ResolvedType* t, types_ResolvedType* inner);\ntypes_ParamInfo* types_param_info_new(slop_arena* arena, slop_string name, types_ResolvedType* param_type);\ntypes_FnSignature* types_fn_signature_new(slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* return_type);\ntypes_TypeError types_type_error_new(types_TypeErrorKind kind, slop_string message, int64_t line, int64_t col);\ntypes_Diagnostic types_diagnostic_new(types_DiagnosticLevel level, slop_string message, int64_t line, int64_t col);\nuint8_t types_is_primitive_kind(types_ResolvedTypeKind kind);\nuint8_t types_is_container_kind(types_ResolvedTypeKind kind);\nuint8_t types_resolved_type_is_pointer(types_ResolvedType* t);\nuint8_t types_resolved_type_is_union(types_ResolvedType* t);\nuint8_t types_resolved_type_is_record(types_ResolvedType* t);\nuint8_t types_resolved_type_is_function(types_ResolvedType* t);\nslop_option_int types_resolved_type_get_variant_index(types_ResolvedType* t, slop_string name);\nslop_option_types_ResolvedType_ptr types_resolved_type_get_variant_payload(types_ResolvedType* t, slop_string name);\nuint8_t types_resolved_type_has_field(types_ResolvedType* t, slop_string name);\nslop_option_types_ResolvedType_ptr types_resolved_type_get_field_type(types_ResolvedType* t, slop_string name);\nslop_string types_resolved_type_to_slop_string(slop_arena* arena, types_ResolvedType* t);\n\ntypes_RangeBounds types_range_bounds_new(uint8_t has_min, int64_t min_val, uint8_t has_max, int64_t max_val) {\n    return (types_RangeBounds){has_min, has_max, min_val, max_val};\n}\n\ntypes_RangeBounds types_range_bounds_unbounded(void) {\n    return (types_RangeBounds){0, 0, 0, 0};\n}\n\nuint8_t types_range_contains(types_RangeBounds bounds, int64_t value) {\n    return ((!(bounds.has_min) || (value >= bounds.min_val)) && (!(bounds.has_max) || (value <= bounds.max_val)));\n}\n\nint64_t types_min(int64_t a, int64_t b) {\n    if ((a < b)) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint64_t types_max(int64_t a, int64_t b) {\n    if ((a > b)) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\ntypes_RangeBounds types_range_intersect(types_RangeBounds a, types_RangeBounds b) {\n    {\n        __auto_type new_has_min = (a.has_min || b.has_min);\n        __auto_type new_has_max = (a.has_max || b.has_max);\n        __auto_type new_min_val = ((a.has_min) ? ((b.has_min) ? ((a.min_val) > (b.min_val) ? (a.min_val) : (b.min_val)) : a.min_val) : b.min_val);\n        __auto_type new_max_val = ((a.has_max) ? ((b.has_max) ? ((a.max_val) < (b.max_val) ? (a.max_val) : (b.max_val)) : a.max_val) : b.max_val);\n        return (types_RangeBounds){new_has_min, new_has_max, new_min_val, new_max_val};\n    }\n}\n\ntypes_RangeBounds types_range_union(types_RangeBounds a, types_RangeBounds b) {\n    {\n        __auto_type new_has_min = (a.has_min && b.has_min);\n        __auto_type new_has_max = (a.has_max && b.has_max);\n        __auto_type new_min_val = (((a.has_min && b.has_min)) ? ((a.min_val) < (b.min_val) ? (a.min_val) : (b.min_val)) : a.min_val);\n        __auto_type new_max_val = (((a.has_max && b.has_max)) ? ((a.max_val) > (b.max_val) ? (a.max_val) : (b.max_val)) : a.max_val);\n        return (types_RangeBounds){new_has_min, new_has_max, new_min_val, new_max_val};\n    }\n}\n\ntypes_ResolvedVariant* types_resolved_variant_new(slop_arena* arena, slop_string name, int64_t index, slop_string tag_constant, slop_option_types_ResolvedType_ptr payload) {\n    {\n        __auto_type v = ((types_ResolvedVariant*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 64); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*v) = (types_ResolvedVariant){name, index, tag_constant, payload};\n        return v;\n    }\n}\n\ntypes_ResolvedField* types_resolved_field_new(slop_arena* arena, slop_string name, types_ResolvedType* field_type, int64_t offset) {\n    SLOP_PRE(((field_type != NULL)), \"(!= field-type nil)\");\n    {\n        __auto_type f = ((types_ResolvedField*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 48); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*f) = (types_ResolvedField){name, field_type, offset};\n        return f;\n    }\n}\n\ntypes_ResolvedType* types_resolved_type_new(slop_arena* arena, types_ResolvedTypeKind kind, slop_string name, slop_option_string module_name, slop_string c_name) {\n    {\n        __auto_type t = ((types_ResolvedType*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 128); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*t) = (types_ResolvedType){kind, name, module_name, c_name, ((slop_list_types_ResolvedVariant){ .data = (types_ResolvedVariant*)slop_arena_alloc(arena, 16 * sizeof(types_ResolvedVariant)), .len = 0, .cap = 16 }), ((slop_list_types_ResolvedField){ .data = (types_ResolvedField*)slop_arena_alloc(arena, 16 * sizeof(types_ResolvedField)), .len = 0, .cap = 16 }), ((slop_option_types_ResolvedType_ptr){.has_value = false}), ((slop_option_types_ResolvedType_ptr){.has_value = false}), ((slop_option_types_RangeBounds){.has_value = false}), 0, 0};\n        return t;\n    }\n}\n\nvoid types_resolved_type_set_inner(types_ResolvedType* t, types_ResolvedType* inner) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    {\n        slop_option_types_ResolvedType_ptr inner_opt = (((inner != NULL)) ? (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = inner} : (slop_option_types_ResolvedType_ptr){.has_value = false});\n        (*t).inner_type = inner_opt;\n    }\n}\n\nvoid types_resolved_type_set_inner2(types_ResolvedType* t, types_ResolvedType* inner) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    {\n        slop_option_types_ResolvedType_ptr inner_opt = (((inner != NULL)) ? (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = inner} : (slop_option_types_ResolvedType_ptr){.has_value = false});\n        (*t).inner_type2 = inner_opt;\n    }\n}\n\ntypes_ParamInfo* types_param_info_new(slop_arena* arena, slop_string name, types_ResolvedType* param_type) {\n    SLOP_PRE(((param_type != NULL)), \"(!= param-type nil)\");\n    {\n        __auto_type p = ((types_ParamInfo*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 24); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*p) = (types_ParamInfo){name, param_type};\n        return p;\n    }\n}\n\ntypes_FnSignature* types_fn_signature_new(slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* return_type) {\n    SLOP_PRE(((return_type != NULL)), \"(!= return-type nil)\");\n    {\n        __auto_type sig = ((types_FnSignature*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 112); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*sig) = (types_FnSignature){name, c_name, params, return_type, 0, 0, ((slop_option_string){.has_value = false}), ((slop_list_string){ .data = (slop_string*)slop_arena_alloc(arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 })};\n        return sig;\n    }\n}\n\ntypes_TypeError types_type_error_new(types_TypeErrorKind kind, slop_string message, int64_t line, int64_t col) {\n    return (types_TypeError){kind, message, line, col};\n}\n\ntypes_Diagnostic types_diagnostic_new(types_DiagnosticLevel level, slop_string message, int64_t line, int64_t col) {\n    return (types_Diagnostic){level, message, line, col};\n}\n\nuint8_t types_is_primitive_kind(types_ResolvedTypeKind kind) {\n    uint8_t _retval;\n    return (kind == types_ResolvedTypeKind_rk_primitive);\n    SLOP_POST(((_retval == (kind == types_ResolvedTypeKind_rk_primitive))), \"(== $result (== kind (quote rk-primitive)))\");\n    return _retval;\n}\n\nuint8_t types_is_container_kind(types_ResolvedTypeKind kind) {\n    uint8_t _retval;\n    return (((kind == types_ResolvedTypeKind_rk_list)) || ((kind == types_ResolvedTypeKind_rk_ptr)) || ((kind == types_ResolvedTypeKind_rk_option)) || ((kind == types_ResolvedTypeKind_rk_result)) || ((kind == types_ResolvedTypeKind_rk_map)) || ((kind == types_ResolvedTypeKind_rk_array)));\n    SLOP_POST(((_retval == (((kind == types_ResolvedTypeKind_rk_list)) || ((kind == types_ResolvedTypeKind_rk_ptr)) || ((kind == types_ResolvedTypeKind_rk_option)) || ((kind == types_ResolvedTypeKind_rk_result)) || ((kind == types_ResolvedTypeKind_rk_map)) || ((kind == types_ResolvedTypeKind_rk_array))))), \"(== $result (or (== kind (quote rk-list)) (== kind (quote rk-ptr)) (== kind (quote rk-option)) (== kind (quote rk-result)) (== kind (quote rk-map)) (== kind (quote rk-array))))\");\n    return _retval;\n}\n\nuint8_t types_resolved_type_is_pointer(types_ResolvedType* t) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    uint8_t _retval;\n    return ((*t).kind == types_ResolvedTypeKind_rk_ptr);\n    SLOP_POST(((_retval == ((*t).kind == types_ResolvedTypeKind_rk_ptr))), \"(== $result (== (. (deref t) kind) (quote rk-ptr)))\");\n    return _retval;\n}\n\nuint8_t types_resolved_type_is_union(types_ResolvedType* t) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    uint8_t _retval;\n    return ((*t).kind == types_ResolvedTypeKind_rk_union);\n    SLOP_POST(((_retval == ((*t).kind == types_ResolvedTypeKind_rk_union))), \"(== $result (== (. (deref t) kind) (quote rk-union)))\");\n    return _retval;\n}\n\nuint8_t types_resolved_type_is_record(types_ResolvedType* t) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    uint8_t _retval;\n    return ((*t).kind == types_ResolvedTypeKind_rk_record);\n    SLOP_POST(((_retval == ((*t).kind == types_ResolvedTypeKind_rk_record))), \"(== $result (== (. (deref t) kind) (quote rk-record)))\");\n    return _retval;\n}\n\nuint8_t types_resolved_type_is_function(types_ResolvedType* t) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    uint8_t _retval;\n    return ((*t).kind == types_ResolvedTypeKind_rk_function);\n    SLOP_POST(((_retval == ((*t).kind == types_ResolvedTypeKind_rk_function))), \"(== $result (== (. (deref t) kind) (quote rk-function)))\");\n    return _retval;\n}\n\nslop_option_int types_resolved_type_get_variant_index(types_ResolvedType* t, slop_string name) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    SLOP_PRE((((*t).kind == types_ResolvedTypeKind_rk_union)), \"(== (. (deref t) kind) (quote rk-union))\");\n    {\n        __auto_type variants = (*t).variants;\n        __auto_type len = ((int64_t)((variants).len));\n        __auto_type i = 0;\n        __auto_type done = 0;\n        slop_option_int found = (slop_option_int){.has_value = false};\n        while (((i < len) && !(done))) {\n            __auto_type _mv_0 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_types_ResolvedVariant _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_0.has_value) {\n                __auto_type v = _mv_0.value;\n                if (string_eq(v.name, name)) {\n                    done = 1;\n                    found = (slop_option_int){.has_value = 1, .value = v.index};\n                }\n            } else if (!_mv_0.has_value) {\n            }\n            i = (i + 1);\n        }\n        return found;\n    }\n}\n\nslop_option_types_ResolvedType_ptr types_resolved_type_get_variant_payload(types_ResolvedType* t, slop_string name) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    if (((*t).kind == types_ResolvedTypeKind_rk_union)) {\n        {\n            __auto_type variants = (*t).variants;\n            __auto_type len = ((int64_t)((variants).len));\n            __auto_type i = 0;\n            __auto_type done = 0;\n            slop_option_types_ResolvedType_ptr found = (slop_option_types_ResolvedType_ptr){.has_value = false};\n            while (((i < len) && !(done))) {\n                __auto_type _mv_1 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_types_ResolvedVariant _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                if (_mv_1.has_value) {\n                    __auto_type v = _mv_1.value;\n                    if (string_eq(v.name, name)) {\n                        done = 1;\n                        found = v.payload_type;\n                    }\n                } else if (!_mv_1.has_value) {\n                }\n                i = (i + 1);\n            }\n            return found;\n        }\n    } else {\n        return (slop_option_types_ResolvedType_ptr){.has_value = false};\n    }\n}\n\nuint8_t types_resolved_type_has_field(types_ResolvedType* t, slop_string name) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    SLOP_PRE((((*t).kind == types_ResolvedTypeKind_rk_record)), \"(== (. (deref t) kind) (quote rk-record))\");\n    {\n        __auto_type fields = (*t).fields;\n        __auto_type len = ((int64_t)((fields).len));\n        __auto_type i = 0;\n        __auto_type found = 0;\n        while (((i < len) && !(found))) {\n            __auto_type _mv_2 = ({ __auto_type _lst = fields; size_t _idx = (size_t)i; slop_option_types_ResolvedField _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_2.has_value) {\n                __auto_type f = _mv_2.value;\n                if (string_eq(f.name, name)) {\n                    found = 1;\n                }\n            } else if (!_mv_2.has_value) {\n            }\n            i = (i + 1);\n        }\n        return found;\n    }\n}\n\nslop_option_types_ResolvedType_ptr types_resolved_type_get_field_type(types_ResolvedType* t, slop_string name) {\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    {\n        __auto_type fields = (*t).fields;\n        __auto_type len = ((int64_t)((fields).len));\n        __auto_type i = 0;\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        while (((i < len) && !(found))) {\n            __auto_type _mv_3 = ({ __auto_type _lst = fields; size_t _idx = (size_t)i; slop_option_types_ResolvedField _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_3.has_value) {\n                __auto_type f = _mv_3.value;\n                if (string_eq(f.name, name)) {\n                    found = 1;\n                    result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = f.field_type};\n                }\n            } else if (!_mv_3.has_value) {\n            }\n            i = (i + 1);\n        }\n        return result;\n    }\n}\n\nslop_string types_resolved_type_to_slop_string(slop_arena* arena, types_ResolvedType* t) {\n    if ((t == NULL)) {\n        return SLOP_STR(\"Unknown\");\n    } else {\n        {\n            __auto_type kind = (*t).kind;\n            __auto_type name = (*t).name;\n            __auto_type _mv_4 = kind;\n            if (_mv_4 == types_ResolvedTypeKind_rk_primitive) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_record) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_enum) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_union) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_function) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_range) {\n                return name;\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_option) {\n                __auto_type _mv_5 = (*t).inner_type;\n                if (_mv_5.has_value) {\n                    __auto_type inner = _mv_5.value;\n                    return string_concat(arena, SLOP_STR(\"(Option \"), string_concat(arena, types_resolved_type_to_slop_string(arena, inner), SLOP_STR(\")\")));\n                } else if (!_mv_5.has_value) {\n                    return SLOP_STR(\"Option\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_ptr) {\n                __auto_type _mv_6 = (*t).inner_type;\n                if (_mv_6.has_value) {\n                    __auto_type inner = _mv_6.value;\n                    return string_concat(arena, SLOP_STR(\"(Ptr \"), string_concat(arena, types_resolved_type_to_slop_string(arena, inner), SLOP_STR(\")\")));\n                } else if (!_mv_6.has_value) {\n                    return SLOP_STR(\"Ptr\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_list) {\n                __auto_type _mv_7 = (*t).inner_type;\n                if (_mv_7.has_value) {\n                    __auto_type inner = _mv_7.value;\n                    return string_concat(arena, SLOP_STR(\"(List \"), string_concat(arena, types_resolved_type_to_slop_string(arena, inner), SLOP_STR(\")\")));\n                } else if (!_mv_7.has_value) {\n                    return SLOP_STR(\"List\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_map) {\n                __auto_type _mv_8 = (*t).inner_type;\n                if (_mv_8.has_value) {\n                    __auto_type key_type = _mv_8.value;\n                    __auto_type _mv_9 = (*t).inner_type2;\n                    if (_mv_9.has_value) {\n                        __auto_type val_type = _mv_9.value;\n                        return string_concat(arena, SLOP_STR(\"(Map \"), string_concat(arena, types_resolved_type_to_slop_string(arena, key_type), string_concat(arena, SLOP_STR(\" \"), string_concat(arena, types_resolved_type_to_slop_string(arena, val_type), SLOP_STR(\")\")))));\n                    } else if (!_mv_9.has_value) {\n                        return string_concat(arena, SLOP_STR(\"(Map \"), string_concat(arena, types_resolved_type_to_slop_string(arena, key_type), SLOP_STR(\")\")));\n                    }\n                } else if (!_mv_8.has_value) {\n                    return SLOP_STR(\"Map\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_result) {\n                __auto_type _mv_10 = (*t).inner_type;\n                if (_mv_10.has_value) {\n                    __auto_type ok_type = _mv_10.value;\n                    __auto_type _mv_11 = (*t).inner_type2;\n                    if (_mv_11.has_value) {\n                        __auto_type err_type = _mv_11.value;\n                        return string_concat(arena, SLOP_STR(\"(Result \"), string_concat(arena, types_resolved_type_to_slop_string(arena, ok_type), string_concat(arena, SLOP_STR(\" \"), string_concat(arena, types_resolved_type_to_slop_string(arena, err_type), SLOP_STR(\")\")))));\n                    } else if (!_mv_11.has_value) {\n                        return string_concat(arena, SLOP_STR(\"(Result \"), string_concat(arena, types_resolved_type_to_slop_string(arena, ok_type), SLOP_STR(\")\")));\n                    }\n                } else if (!_mv_10.has_value) {\n                    return SLOP_STR(\"Result\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_array) {\n                __auto_type _mv_12 = (*t).inner_type;\n                if (_mv_12.has_value) {\n                    __auto_type inner = _mv_12.value;\n                    return string_concat(arena, SLOP_STR(\"(Array \"), string_concat(arena, types_resolved_type_to_slop_string(arena, inner), SLOP_STR(\")\")));\n                } else if (!_mv_12.has_value) {\n                    return SLOP_STR(\"Array\");\n                }\n            } else if (_mv_4 == types_ResolvedTypeKind_rk_typevar) {\n                return name;\n            } else {\n                return name;\n            }\n        }\n    }\n}\n\n"}Error: Could not open file: ../common/strlib.slop
,"env":{"header":"#ifndef SLOP_env_H\n#define SLOP_env_H\n\n#include \"slop_runtime.h\"\n#include <stdint.h>\n#include <stdbool.h>\n#include \"slop_types.h\"\n\ntypedef struct env_VarBinding env_VarBinding;\ntypedef struct env_ConstBinding env_ConstBinding;\ntypedef struct env_ImportEntry env_ImportEntry;\ntypedef struct env_CheckerScope env_CheckerScope;\ntypedef struct env_VariantMapping env_VariantMapping;\ntypedef struct env_BindingAnnotation env_BindingAnnotation;\ntypedef struct env_TypeEnv env_TypeEnv;\n\n#ifndef SLOP_LIST_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_LIST_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_LIST_DEFINE(types_ResolvedType*, slop_list_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_LIST_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_LIST_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_LIST_DEFINE(types_FnSignature*, slop_list_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_LIST_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_LIST_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_LIST_DEFINE(env_CheckerScope*, slop_list_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature*, slop_option_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope*, slop_option_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_LIST_TYPES_PARAMINFO_DEFINED\n#define SLOP_LIST_TYPES_PARAMINFO_DEFINED\nSLOP_LIST_DEFINE(types_ParamInfo, slop_list_types_ParamInfo)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n#ifndef SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_LIST_TYPES_DIAGNOSTIC_DEFINED\nSLOP_LIST_DEFINE(types_Diagnostic, slop_list_types_Diagnostic)\n#endif\n\n#ifndef SLOP_LIST_TYPES_PARAMINFO_DEFINED\n#define SLOP_LIST_TYPES_PARAMINFO_DEFINED\nSLOP_LIST_DEFINE(types_ParamInfo, slop_list_types_ParamInfo)\n#endif\n\nstruct env_VarBinding {\n    slop_string name;\n    types_ResolvedType* var_type;\n};\ntypedef struct env_VarBinding env_VarBinding;\n\n#ifndef SLOP_OPTION_ENV_VARBINDING_DEFINED\n#define SLOP_OPTION_ENV_VARBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_VarBinding, slop_option_env_VarBinding)\n#endif\n\n#ifndef SLOP_LIST_ENV_VARBINDING_DEFINED\n#define SLOP_LIST_ENV_VARBINDING_DEFINED\nSLOP_LIST_DEFINE(env_VarBinding, slop_list_env_VarBinding)\n#endif\n\nstruct env_ConstBinding {\n    slop_string name;\n    types_ResolvedType* const_type;\n    slop_option_string module_name;\n};\ntypedef struct env_ConstBinding env_ConstBinding;\n\n#ifndef SLOP_OPTION_ENV_CONSTBINDING_DEFINED\n#define SLOP_OPTION_ENV_CONSTBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_ConstBinding, slop_option_env_ConstBinding)\n#endif\n\n#ifndef SLOP_LIST_ENV_CONSTBINDING_DEFINED\n#define SLOP_LIST_ENV_CONSTBINDING_DEFINED\nSLOP_LIST_DEFINE(env_ConstBinding, slop_list_env_ConstBinding)\n#endif\n\nstruct env_ImportEntry {\n    slop_string local;\n    slop_string qualified;\n};\ntypedef struct env_ImportEntry env_ImportEntry;\n\n#ifndef SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\n#define SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\nSLOP_OPTION_DEFINE(env_ImportEntry, slop_option_env_ImportEntry)\n#endif\n\n#ifndef SLOP_LIST_ENV_IMPORTENTRY_DEFINED\n#define SLOP_LIST_ENV_IMPORTENTRY_DEFINED\nSLOP_LIST_DEFINE(env_ImportEntry, slop_list_env_ImportEntry)\n#endif\n\nstruct env_CheckerScope {\n    slop_list_env_VarBinding bindings;\n};\ntypedef struct env_CheckerScope env_CheckerScope;\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope, slop_option_env_CheckerScope)\n#endif\n\nstruct env_VariantMapping {\n    slop_string variant_name;\n    slop_string enum_name;\n    slop_option_string module_name;\n};\ntypedef struct env_VariantMapping env_VariantMapping;\n\n#ifndef SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\nSLOP_OPTION_DEFINE(env_VariantMapping, slop_option_env_VariantMapping)\n#endif\n\n#ifndef SLOP_LIST_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_LIST_ENV_VARIANTMAPPING_DEFINED\nSLOP_LIST_DEFINE(env_VariantMapping, slop_list_env_VariantMapping)\n#endif\n\nstruct env_BindingAnnotation {\n    slop_string name;\n    int64_t line;\n    int64_t col;\n    slop_string slop_type;\n};\ntypedef struct env_BindingAnnotation env_BindingAnnotation;\n\n#ifndef SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\nSLOP_OPTION_DEFINE(env_BindingAnnotation, slop_option_env_BindingAnnotation)\n#endif\n\n#ifndef SLOP_LIST_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_LIST_ENV_BINDINGANNOTATION_DEFINED\nSLOP_LIST_DEFINE(env_BindingAnnotation, slop_list_env_BindingAnnotation)\n#endif\n\nstruct env_TypeEnv {\n    slop_arena* arena;\n    slop_list_types_ResolvedType_ptr types;\n    slop_list_types_FnSignature_ptr functions;\n    slop_list_env_ConstBinding constants;\n    slop_list_env_ImportEntry imports;\n    slop_list_env_VariantMapping enum_variants;\n    slop_list_env_CheckerScope_ptr scopes;\n    slop_option_string current_module;\n    types_ResolvedType* int_type;\n    types_ResolvedType* bool_type;\n    types_ResolvedType* string_type;\n    types_ResolvedType* unit_type;\n    types_ResolvedType* arena_type;\n    types_ResolvedType* unknown_type;\n    slop_list_types_Diagnostic diagnostics;\n    slop_list_env_BindingAnnotation binding_annotations;\n    slop_option_string current_file;\n    slop_list_string loaded_modules;\n    slop_list_string fn_type_params;\n};\ntypedef struct env_TypeEnv env_TypeEnv;\n\n#ifndef SLOP_OPTION_ENV_TYPEENV_DEFINED\n#define SLOP_OPTION_ENV_TYPEENV_DEFINED\nSLOP_OPTION_DEFINE(env_TypeEnv, slop_option_env_TypeEnv)\n#endif\n\nenv_TypeEnv* env_env_new(slop_arena* arena);\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type);\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t);\nslop_arena* env_env_arena(env_TypeEnv* env);\nvoid env_env_push_scope(env_TypeEnv* env);\nvoid env_env_pop_scope(env_TypeEnv* env);\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type);\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name);\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type);\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name);\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding);\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name);\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name);\nint64_t env_find_colon_pos(slop_string name);\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name);\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t);\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig);\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name);\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name);\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name);\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name);\nvoid env_env_clear_imports(env_TypeEnv* env);\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name);\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name);\nuint8_t env_env_variant_is_builtin(env_VariantMapping v);\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name);\nvoid env_env_check_variant_collisions(env_TypeEnv* env);\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b);\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name);\nslop_option_string env_env_get_module(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env);\nvoid env_env_clear_diagnostics(env_TypeEnv* env);\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type);\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env);\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path);\nslop_option_string env_env_get_current_file(env_TypeEnv* env);\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path);\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path);\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params);\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env);\nvoid env_env_clear_fn_type_params(env_TypeEnv* env);\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name);\n\n#ifndef SLOP_OPTION_ENV_VARBINDING_DEFINED\n#define SLOP_OPTION_ENV_VARBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_VarBinding, slop_option_env_VarBinding)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CONSTBINDING_DEFINED\n#define SLOP_OPTION_ENV_CONSTBINDING_DEFINED\nSLOP_OPTION_DEFINE(env_ConstBinding, slop_option_env_ConstBinding)\n#endif\n\n#ifndef SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\n#define SLOP_OPTION_ENV_IMPORTENTRY_DEFINED\nSLOP_OPTION_DEFINE(env_ImportEntry, slop_option_env_ImportEntry)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope, slop_option_env_CheckerScope)\n#endif\n\n#ifndef SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\n#define SLOP_OPTION_ENV_VARIANTMAPPING_DEFINED\nSLOP_OPTION_DEFINE(env_VariantMapping, slop_option_env_VariantMapping)\n#endif\n\n#ifndef SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\n#define SLOP_OPTION_ENV_BINDINGANNOTATION_DEFINED\nSLOP_OPTION_DEFINE(env_BindingAnnotation, slop_option_env_BindingAnnotation)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_RESOLVEDTYPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_ResolvedType*, slop_option_types_ResolvedType_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\n#define SLOP_OPTION_TYPES_FNSIGNATURE_PTR_DEFINED\nSLOP_OPTION_DEFINE(types_FnSignature*, slop_option_types_FnSignature_ptr)\n#endif\n\n#ifndef SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\n#define SLOP_OPTION_ENV_CHECKERSCOPE_PTR_DEFINED\nSLOP_OPTION_DEFINE(env_CheckerScope*, slop_option_env_CheckerScope_ptr)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\n#define SLOP_OPTION_TYPES_DIAGNOSTIC_DEFINED\nSLOP_OPTION_DEFINE(types_Diagnostic, slop_option_types_Diagnostic)\n#endif\n\n#ifndef SLOP_OPTION_ENV_TYPEENV_DEFINED\n#define SLOP_OPTION_ENV_TYPEENV_DEFINED\nSLOP_OPTION_DEFINE(env_TypeEnv, slop_option_env_TypeEnv)\n#endif\n\n#ifndef SLOP_OPTION_TYPES_PARAMINFO_DEFINED\n#define SLOP_OPTION_TYPES_PARAMINFO_DEFINED\nSLOP_OPTION_DEFINE(types_ParamInfo, slop_option_types_ParamInfo)\n#endif\n\n\n#endif\n","impl":"env_TypeEnv* env_env_new(slop_arena* arena);\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type);\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t);\nslop_arena* env_env_arena(env_TypeEnv* env);\nvoid env_env_push_scope(env_TypeEnv* env);\nvoid env_env_pop_scope(env_TypeEnv* env);\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type);\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name);\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type);\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name);\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding);\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name);\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name);\nint64_t env_find_colon_pos(slop_string name);\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name);\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name);\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t);\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig);\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name);\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name);\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name);\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name);\nvoid env_env_clear_imports(env_TypeEnv* env);\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name);\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name);\nuint8_t env_env_variant_is_builtin(env_VariantMapping v);\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name);\nvoid env_env_check_variant_collisions(env_TypeEnv* env);\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b);\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name);\nslop_option_string env_env_get_module(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type);\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env);\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig);\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col);\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env);\nvoid env_env_clear_diagnostics(env_TypeEnv* env);\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type);\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env);\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path);\nslop_option_string env_env_get_current_file(env_TypeEnv* env);\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path);\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path);\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params);\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env);\nvoid env_env_clear_fn_type_params(env_TypeEnv* env);\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name);\n\nenv_TypeEnv* env_env_new(slop_arena* arena) {\n    {\n        __auto_type int_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"Int\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"int64_t\"));\n        __auto_type bool_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"Bool\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"bool\"));\n        __auto_type string_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"String\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"slop_string_t\"));\n        __auto_type unit_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"Unit\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"void\"));\n        __auto_type arena_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"Arena\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"slop_arena_t*\"));\n        __auto_type unknown_t = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"Unknown\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"void\"));\n        __auto_type env = ((env_TypeEnv*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 320); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*env) = (env_TypeEnv){arena, ((slop_list_types_ResolvedType_ptr){ .data = (types_ResolvedType**)slop_arena_alloc(arena, 16 * sizeof(types_ResolvedType*)), .len = 0, .cap = 16 }), ((slop_list_types_FnSignature_ptr){ .data = (types_FnSignature**)slop_arena_alloc(arena, 16 * sizeof(types_FnSignature*)), .len = 0, .cap = 16 }), ((slop_list_env_ConstBinding){ .data = (env_ConstBinding*)slop_arena_alloc(arena, 16 * sizeof(env_ConstBinding)), .len = 0, .cap = 16 }), ((slop_list_env_ImportEntry){ .data = (env_ImportEntry*)slop_arena_alloc(arena, 16 * sizeof(env_ImportEntry)), .len = 0, .cap = 16 }), ((slop_list_env_VariantMapping){ .data = (env_VariantMapping*)slop_arena_alloc(arena, 16 * sizeof(env_VariantMapping)), .len = 0, .cap = 16 }), ((slop_list_env_CheckerScope_ptr){ .data = (env_CheckerScope**)slop_arena_alloc(arena, 16 * sizeof(env_CheckerScope*)), .len = 0, .cap = 16 }), ((slop_option_string){.has_value = false}), int_t, bool_t, string_t, unit_t, arena_t, unknown_t, ((slop_list_types_Diagnostic){ .data = (types_Diagnostic*)slop_arena_alloc(arena, 16 * sizeof(types_Diagnostic)), .len = 0, .cap = 16 }), ((slop_list_env_BindingAnnotation){ .data = (env_BindingAnnotation*)slop_arena_alloc(arena, 16 * sizeof(env_BindingAnnotation)), .len = 0, .cap = 16 }), ((slop_option_string){.has_value = false}), ((slop_list_string){ .data = (slop_string*)slop_arena_alloc(arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 }), ((slop_list_string){ .data = (slop_string*)slop_arena_alloc(arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 })};\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (int_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (bool_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (string_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (unit_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (arena_t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        {\n            __auto_type i8 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"I8\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"int8_t\"));\n            __auto_type i16 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"I16\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"int16_t\"));\n            __auto_type i32 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"I32\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"int32_t\"));\n            __auto_type i64 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"I64\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"int64_t\"));\n            __auto_type u8 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"U8\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"uint8_t\"));\n            __auto_type u16 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"U16\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"uint16_t\"));\n            __auto_type u32 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"U32\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"uint32_t\"));\n            __auto_type u64 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"U64\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"uint64_t\"));\n            __auto_type f32 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"F32\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"float\"));\n            __auto_type f64 = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"F64\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"double\"));\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i8); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i16); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (i64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u8); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u16); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (u64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (f32); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (f64); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            env_register_builtin_functions(env, arena, int_t, bool_t, string_t, arena_t, u8);\n        }\n        return env;\n    }\n}\n\nvoid env_env_register_builtin_fn(env_TypeEnv* env, slop_arena* arena, slop_string name, slop_string c_name, slop_list_types_ParamInfo params, types_ResolvedType* ret_type) {\n    {\n        __auto_type sig = types_fn_signature_new(arena, name, c_name, params, ret_type);\n        env_env_register_function(env, sig);\n    }\n}\n\nvoid env_register_builtin_functions(env_TypeEnv* env, slop_arena* arena, types_ResolvedType* int_t, types_ResolvedType* bool_t, types_ResolvedType* string_t, types_ResolvedType* arena_t, types_ResolvedType* u8_t) {\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"a\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"b\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-eq\"), SLOP_STR(\"string_eq\"), p, bool_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"a\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"b\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-concat\"), SLOP_STR(\"string_concat\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-len\"), SLOP_STR(\"string_len\"), p, int_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-copy\"), SLOP_STR(\"string_copy\"), p, string_t);\n    }\n    {\n        __auto_type ptr_u8_t = env_env_make_ptr_type(env, u8_t);\n        {\n            __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n            ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"cstr\"), ptr_u8_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n            env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-new\"), SLOP_STR(\"string_new\"), p, string_t);\n        }\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"start\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"end\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-slice\"), SLOP_STR(\"string_slice\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"n\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"int-to-string\"), SLOP_STR(\"int_to_string\"), p, string_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"idx\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"char-at\"), SLOP_STR(\"char_at\"), p, int_t);\n    }\n    {\n        __auto_type p = ((slop_list_types_ParamInfo){ .data = (types_ParamInfo*)slop_arena_alloc(arena, 16 * sizeof(types_ParamInfo)), .len = 0, .cap = 16 });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"arena\"), arena_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"s\"), string_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        ({ __auto_type _lst_p = &(p); __auto_type _item = ((*types_param_info_new(arena, SLOP_STR(\"c\"), int_t))); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        env_env_register_builtin_fn(env, arena, SLOP_STR(\"string-push-char\"), SLOP_STR(\"slop_string_push_char\"), p, string_t);\n    }\n}\n\nslop_arena* env_env_arena(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).arena;\n}\n\nvoid env_env_push_scope(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type scope_ptr = ((env_CheckerScope*)(({ __auto_type _alloc = (uint8_t*)slop_arena_alloc(arena, 64); if (_alloc == NULL) { fprintf(stderr, \"SLOP: arena alloc failed at %s:%d\\n\", __FILE__, __LINE__); abort(); } _alloc; })));\n        (*scope_ptr) = (env_CheckerScope){((slop_list_env_VarBinding){ .data = (env_VarBinding*)slop_arena_alloc(arena, 16 * sizeof(env_VarBinding)), .len = 0, .cap = 16 })};\n        ({ __auto_type _lst_p = &((*env).scopes); __auto_type _item = (scope_ptr); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n    }\n}\n\nvoid env_env_pop_scope(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((((int64_t)(((*env).scopes).len)) > 0)), \"(> (list-len (. (deref env) scopes)) 0)\");\n    {\n        __auto_type _ = ({ __auto_type _lst_p = &((*env).scopes); slop_option_env_CheckerScope_ptr _r = {0}; if (_lst_p->len > 0) { _lst_p->len--; _r.has_value = true; _r.value = _lst_p->data[_lst_p->len]; } _r; });\n    }\n}\n\nvoid env_env_bind_var(env_TypeEnv* env, slop_string name, types_ResolvedType* var_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((var_type != NULL)), \"(!= var-type nil)\");\n    SLOP_PRE(((((int64_t)(((*env).scopes).len)) > 0)), \"(> (list-len (. (deref env) scopes)) 0)\");\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type scopes = (*env).scopes;\n        __auto_type top_idx = (((int64_t)((scopes).len)) - 1);\n        __auto_type _mv_13 = ({ __auto_type _lst = scopes; size_t _idx = (size_t)top_idx; slop_option_env_CheckerScope_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n        if (_mv_13.has_value) {\n            __auto_type scope_ptr = _mv_13.value;\n            ({ __auto_type _lst_p = &((*scope_ptr).bindings); __auto_type _item = ((env_VarBinding){name, var_type}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n        } else if (!_mv_13.has_value) {\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_scope_lookup_var(env_CheckerScope* scope_ptr, slop_string name) {\n    SLOP_PRE(((scope_ptr != NULL)), \"(!= scope-ptr nil)\");\n    {\n        __auto_type bindings = (*scope_ptr).bindings;\n        __auto_type num_bindings = ((int64_t)((bindings).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t j = 0; j < num_bindings; j++) {\n            __auto_type _mv_14 = ({ __auto_type _lst = bindings; size_t _idx = (size_t)j; slop_option_env_VarBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_14.has_value) {\n                __auto_type binding = _mv_14.value;\n                if ((!(found) && string_eq(binding.name, name))) {\n                    found = 1;\n                    result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = binding.var_type};\n                }\n            } else if (!_mv_14.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_var(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type scopes = (*env).scopes;\n        __auto_type num_scopes = ((int64_t)((scopes).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < num_scopes; i++) {\n            if (!(found)) {\n                {\n                    __auto_type scope_idx = ((num_scopes) - (1) - (i));\n                    __auto_type _mv_15 = ({ __auto_type _lst = scopes; size_t _idx = (size_t)scope_idx; slop_option_env_CheckerScope_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_15.has_value) {\n                        __auto_type scope_ptr = _mv_15.value;\n                        __auto_type _mv_16 = env_scope_lookup_var(scope_ptr, name);\n                        if (_mv_16.has_value) {\n                            __auto_type var_type = _mv_16.value;\n                            found = 1;\n                            result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = var_type};\n                        } else if (!_mv_16.has_value) {\n                        }\n                    } else if (!_mv_15.has_value) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n\nvoid env_env_register_constant(env_TypeEnv* env, slop_string name, types_ResolvedType* const_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((const_type != NULL)), \"(!= const-type nil)\");\n    ({ __auto_type _lst_p = &((*env).constants); __auto_type _item = ((env_ConstBinding){name, const_type, env_env_get_module(env)}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_constant_matches_module(env_ConstBinding binding, slop_string mod_name) {\n    __auto_type _mv_17 = binding.module_name;\n    if (_mv_17.has_value) {\n        __auto_type bmod = _mv_17.value;\n        return string_eq(bmod, mod_name);\n    } else if (!_mv_17.has_value) {\n        return 0;\n    }\n}\n\nuint8_t env_env_constant_is_builtin(env_ConstBinding binding) {\n    __auto_type _mv_18 = binding.module_name;\n    if (!_mv_18.has_value) {\n        return 1;\n    } else if (_mv_18.has_value) {\n        __auto_type _ = _mv_18.value;\n        return 0;\n    }\n}\n\nuint8_t env_env_lookup_constant_in_module(env_TypeEnv* env, slop_string mod_name, slop_string const_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type constants = (*env).constants;\n        __auto_type len = ((int64_t)((constants).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            if (!(found)) {\n                __auto_type _mv_19 = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                if (_mv_19.has_value) {\n                    __auto_type binding = _mv_19.value;\n                    if ((string_eq(binding.name, const_name) && env_env_constant_matches_module(binding, mod_name))) {\n                        found = 1;\n                    }\n                } else if (!_mv_19.has_value) {\n                }\n            }\n        }\n        return found;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_constant(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type constants = (*env).constants;\n        __auto_type len = ((int64_t)((constants).len));\n        __auto_type current_mod = env_env_get_module(env);\n        __auto_type found = 0;\n        types_ResolvedType* found_type = NULL;\n        __auto_type _mv_20 = current_mod;\n        if (_mv_20.has_value) {\n            __auto_type mod = _mv_20.value;\n            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type binding = _mv.value; (((string_eq(binding.name, name) && env_env_constant_matches_module(binding, mod))) ? ({ ({ found = 1; (void)0; }); ({ found_type = binding.const_type; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n        } else if (!_mv_20.has_value) {\n        }\n        if (!(found)) {\n            __auto_type _mv_21 = env_env_resolve_import(env, name);\n            if (_mv_21.has_value) {\n                __auto_type qualified_name = _mv_21.value;\n                {\n                    __auto_type colon_pos = env_find_colon_pos(qualified_name);\n                    if ((colon_pos != -1)) {\n                        {\n                            __auto_type mod_part = (slop_string){.len = ((uint64_t)(colon_pos)), .data = qualified_name.data};\n                            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type binding = _mv.value; (((string_eq(binding.name, name) && env_env_constant_matches_module(binding, mod_part))) ? ({ ({ found = 1; (void)0; }); ({ found_type = binding.const_type; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n                        }\n                    }\n                }\n            } else if (!_mv_21.has_value) {\n            }\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_22 = ({ __auto_type _lst = constants; size_t _idx = (size_t)i; slop_option_env_ConstBinding _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_22.has_value) {\n                        __auto_type binding = _mv_22.value;\n                        if ((string_eq(binding.name, name) && env_env_constant_is_builtin(binding))) {\n                            found = 1;\n                            found_type = binding.const_type;\n                        }\n                    } else if (!_mv_22.has_value) {\n                    }\n                }\n            }\n        }\n        if (found) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = found_type};\n        } else {\n            return (slop_option_types_ResolvedType_ptr){.has_value = false};\n        }\n    }\n}\n\nvoid env_env_register_type(env_TypeEnv* env, types_ResolvedType* t) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    ({ __auto_type _lst_p = &((*env).types); __auto_type _item = (t); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type_direct(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type types = (*env).types;\n        __auto_type len = ((int64_t)((types).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_23 = ({ __auto_type _lst = types; size_t _idx = (size_t)i; slop_option_types_ResolvedType_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_23.has_value) {\n                __auto_type t = _mv_23.value;\n                if ((!(found) && string_eq((*t).name, name))) {\n                    found = 1;\n                    result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n                }\n            } else if (!_mv_23.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nint64_t env_find_colon_pos(slop_string name) {\n    {\n        __auto_type len = string_len(name);\n        int64_t colon_pos = -1;\n        __auto_type i = 0;\n        while (((i < len) && (colon_pos == -1))) {\n            if ((name.data[i] == 58)) {\n                colon_pos = i;\n            }\n            i = (i + 1);\n        }\n        return colon_pos;\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_lookup_type_by_qualified_name(env_TypeEnv* env, slop_string qualified_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type colon_pos = env_find_colon_pos(qualified_name);\n        if ((colon_pos == -1)) {\n            return env_env_lookup_type_direct(env, qualified_name);\n        } else {\n            {\n                __auto_type mod_part = (slop_string){.len = ((uint64_t)(colon_pos)), .data = qualified_name.data};\n                __auto_type start_offset = (colon_pos + 1);\n                __auto_type type_len = (((int64_t)(qualified_name.len)) - start_offset);\n                __auto_type type_data = ((uint8_t*)((((int64_t)(qualified_name.data)) + start_offset)));\n                __auto_type type_part = (slop_string){.len = ((uint64_t)(type_len)), .data = type_data};\n                return env_env_lookup_type_qualified(env, mod_part, type_part);\n            }\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_24 = env_env_lookup_type_direct(env, name);\n    if (_mv_24.has_value) {\n        __auto_type t = _mv_24.value;\n        if (env_env_is_type_visible(env, t)) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n        } else {\n            __auto_type _mv_25 = env_env_resolve_import(env, name);\n            if (_mv_25.has_value) {\n                __auto_type qualified_name = _mv_25.value;\n                return env_lookup_type_by_qualified_name(env, qualified_name);\n            } else if (!_mv_25.has_value) {\n                return (slop_option_types_ResolvedType_ptr){.has_value = false};\n            }\n        }\n    } else if (!_mv_24.has_value) {\n        __auto_type _mv_26 = env_env_resolve_import(env, name);\n        if (_mv_26.has_value) {\n            __auto_type qualified_name = _mv_26.value;\n            return env_lookup_type_by_qualified_name(env, qualified_name);\n        } else if (!_mv_26.has_value) {\n            return (slop_option_types_ResolvedType_ptr){.has_value = false};\n        }\n    }\n}\n\nslop_option_types_ResolvedType_ptr env_env_lookup_type_qualified(env_TypeEnv* env, slop_string module_name, slop_string type_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type types = (*env).types;\n        __auto_type len = ((int64_t)((types).len));\n        __auto_type found = 0;\n        slop_option_types_ResolvedType_ptr result = (slop_option_types_ResolvedType_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_27 = ({ __auto_type _lst = types; size_t _idx = (size_t)i; slop_option_types_ResolvedType_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_27.has_value) {\n                __auto_type t = _mv_27.value;\n                if (!(found)) {\n                    __auto_type _mv_28 = (*t).module_name;\n                    if (_mv_28.has_value) {\n                        __auto_type mod = _mv_28.value;\n                        if ((string_eq(mod, module_name) && string_eq((*t).name, type_name))) {\n                            found = 1;\n                            result = (slop_option_types_ResolvedType_ptr){.has_value = 1, .value = t};\n                        }\n                    } else if (!_mv_28.has_value) {\n                    }\n                }\n            } else if (!_mv_27.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nuint8_t env_env_is_type_visible(env_TypeEnv* env, types_ResolvedType* t) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((t != NULL)), \"(!= t nil)\");\n    __auto_type _mv_29 = (*t).module_name;\n    if (!_mv_29.has_value) {\n        return 1;\n    } else if (_mv_29.has_value) {\n        __auto_type mod = _mv_29.value;\n        __auto_type _mv_30 = env_env_get_module(env);\n        if (_mv_30.has_value) {\n            __auto_type current = _mv_30.value;\n            return string_eq(mod, current);\n        } else if (!_mv_30.has_value) {\n            return 0;\n        }\n    }\n}\n\nuint8_t env_env_is_function_visible(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    __auto_type _mv_31 = (*sig).module_name;\n    if (!_mv_31.has_value) {\n        return 1;\n    } else if (_mv_31.has_value) {\n        __auto_type mod = _mv_31.value;\n        __auto_type _mv_32 = env_env_get_module(env);\n        if (_mv_32.has_value) {\n            __auto_type current = _mv_32.value;\n            return string_eq(mod, current);\n        } else if (!_mv_32.has_value) {\n            return 0;\n        }\n    }\n}\n\nvoid env_env_register_function(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    ({ __auto_type _lst_p = &((*env).functions); __auto_type _item = (sig); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_types_FnSignature_ptr env_env_lookup_function_direct(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type functions = (*env).functions;\n        __auto_type len = ((int64_t)((functions).len));\n        __auto_type found = 0;\n        slop_option_types_FnSignature_ptr result = (slop_option_types_FnSignature_ptr){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_33 = ({ __auto_type _lst = functions; size_t _idx = (size_t)i; slop_option_types_FnSignature_ptr _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_33.has_value) {\n                __auto_type sig = _mv_33.value;\n                if ((!(found) && (string_eq((*sig).name, name) || string_eq((*sig).c_name, name)))) {\n                    found = 1;\n                    result = (slop_option_types_FnSignature_ptr){.has_value = 1, .value = sig};\n                }\n            } else if (!_mv_33.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nslop_option_types_FnSignature_ptr env_env_lookup_function(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    __auto_type _mv_34 = env_env_lookup_function_direct(env, name);\n    if (_mv_34.has_value) {\n        __auto_type sig = _mv_34.value;\n        if (env_env_is_function_visible(env, sig)) {\n            return (slop_option_types_FnSignature_ptr){.has_value = 1, .value = sig};\n        } else {\n            __auto_type _mv_35 = env_env_resolve_import(env, name);\n            if (_mv_35.has_value) {\n                __auto_type import_qualified = _mv_35.value;\n                return env_env_lookup_function_direct(env, import_qualified);\n            } else if (!_mv_35.has_value) {\n                __auto_type _mv_36 = env_env_get_module(env);\n                if (_mv_36.has_value) {\n                    __auto_type mod = _mv_36.value;\n                    {\n                        __auto_type qualified = string_concat(env_env_arena(env), mod, string_concat(env_env_arena(env), SLOP_STR(\":\"), name));\n                        return env_env_lookup_function_direct(env, qualified);\n                    }\n                } else if (!_mv_36.has_value) {\n                    return (slop_option_types_FnSignature_ptr){.has_value = false};\n                }\n            }\n        }\n    } else if (!_mv_34.has_value) {\n        __auto_type _mv_37 = env_env_resolve_import(env, name);\n        if (_mv_37.has_value) {\n            __auto_type import_qualified = _mv_37.value;\n            return env_env_lookup_function_direct(env, import_qualified);\n        } else if (!_mv_37.has_value) {\n            __auto_type _mv_38 = env_env_get_module(env);\n            if (_mv_38.has_value) {\n                __auto_type mod = _mv_38.value;\n                {\n                    __auto_type qualified = string_concat(env_env_arena(env), mod, string_concat(env_env_arena(env), SLOP_STR(\":\"), name));\n                    return env_env_lookup_function_direct(env, qualified);\n                }\n            } else if (!_mv_38.has_value) {\n                return (slop_option_types_FnSignature_ptr){.has_value = false};\n            }\n        }\n    }\n}\n\nvoid env_env_add_import(env_TypeEnv* env, slop_string local_name, slop_string qualified_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).imports); __auto_type _item = ((env_ImportEntry){local_name, qualified_name}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_option_string env_env_resolve_import(env_TypeEnv* env, slop_string local_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type imports = (*env).imports;\n        __auto_type len = ((int64_t)((imports).len));\n        __auto_type found = 0;\n        slop_option_string result = (slop_option_string){.has_value = false};\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_39 = ({ __auto_type _lst = imports; size_t _idx = (size_t)i; slop_option_env_ImportEntry _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_39.has_value) {\n                __auto_type entry = _mv_39.value;\n                if ((!(found) && string_eq(entry.local, local_name))) {\n                    found = 1;\n                    result = (slop_option_string){.has_value = 1, .value = entry.qualified};\n                }\n            } else if (!_mv_39.has_value) {\n            }\n        }\n        return result;\n    }\n}\n\nvoid env_env_clear_imports(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        (*env).imports = ((slop_list_env_ImportEntry){ .data = (env_ImportEntry*)slop_arena_alloc(arena, 16 * sizeof(env_ImportEntry)), .len = 0, .cap = 16 });\n    }\n}\n\nvoid env_env_register_variant(env_TypeEnv* env, slop_string variant_name, slop_string enum_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).enum_variants); __auto_type _item = ((env_VariantMapping){variant_name, enum_name, env_env_get_module(env)}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_variant_matches_module(env_VariantMapping v, slop_string mod_name) {\n    __auto_type _mv_40 = v.module_name;\n    if (_mv_40.has_value) {\n        __auto_type vmod = _mv_40.value;\n        return string_eq(vmod, mod_name);\n    } else if (!_mv_40.has_value) {\n        return 0;\n    }\n}\n\nuint8_t env_env_variant_is_builtin(env_VariantMapping v) {\n    __auto_type _mv_41 = v.module_name;\n    if (!_mv_41.has_value) {\n        return 1;\n    } else if (_mv_41.has_value) {\n        __auto_type _ = _mv_41.value;\n        return 0;\n    }\n}\n\nslop_option_string env_env_lookup_variant(env_TypeEnv* env, slop_string variant_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type variants = (*env).enum_variants;\n        __auto_type len = ((int64_t)((variants).len));\n        __auto_type current_mod = env_env_get_module(env);\n        __auto_type found = 0;\n        slop_string found_name = SLOP_STR(\"\");\n        __auto_type _mv_42 = current_mod;\n        if (_mv_42.has_value) {\n            __auto_type mod = _mv_42.value;\n            ({ for (int64_t i = 0; i < len; i++) { ((!(found)) ? ({ ({ __auto_type _mv = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type v = _mv.value; (((string_eq(v.variant_name, variant_name) && env_env_variant_matches_module(v, mod))) ? ({ ({ found = 1; (void)0; }); ({ found_name = v.enum_name; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); 0; }) : ({ (void)0; })); } 0; });\n        } else if (!_mv_42.has_value) {\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_43 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_43.has_value) {\n                        __auto_type v = _mv_43.value;\n                        if ((string_eq(v.variant_name, variant_name) && env_env_variant_is_builtin(v))) {\n                            found = 1;\n                            found_name = v.enum_name;\n                        }\n                    } else if (!_mv_43.has_value) {\n                    }\n                }\n            }\n        }\n        if (!(found)) {\n            for (int64_t i = 0; i < len; i++) {\n                if (!(found)) {\n                    __auto_type _mv_44 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                    if (_mv_44.has_value) {\n                        __auto_type v = _mv_44.value;\n                        if (string_eq(v.variant_name, variant_name)) {\n                            __auto_type _mv_45 = v.module_name;\n                            if (_mv_45.has_value) {\n                                __auto_type vmod = _mv_45.value;\n                                __auto_type _mv_46 = env_env_resolve_import(env, v.enum_name);\n                                if (_mv_46.has_value) {\n                                    __auto_type _ = _mv_46.value;\n                                    found = 1;\n                                    found_name = v.enum_name;\n                                } else if (!_mv_46.has_value) {\n                                }\n                            } else if (!_mv_45.has_value) {\n                            }\n                        }\n                    } else if (!_mv_44.has_value) {\n                    }\n                }\n            }\n        }\n        if (found) {\n            return (slop_option_string){.has_value = 1, .value = found_name};\n        } else {\n            return (slop_option_string){.has_value = false};\n        }\n    }\n}\n\nvoid env_env_check_variant_collisions(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type variants = (*env).enum_variants;\n        __auto_type len = ((int64_t)((variants).len));\n        __auto_type arena = (*env).arena;\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_47 = ({ __auto_type _lst = variants; size_t _idx = (size_t)i; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_47.has_value) {\n                __auto_type v1 = _mv_47.value;\n                {\n                    __auto_type name1 = v1.variant_name;\n                    __auto_type enum1 = v1.enum_name;\n                    __auto_type mod1 = v1.module_name;\n                    __auto_type found_collision = 0;\n                    slop_string collision_enum = SLOP_STR(\"\");\n                    ({ for (int64_t j = (i + 1); j < len; j++) { ({ __auto_type _mv = ({ __auto_type _lst = variants; size_t _idx = (size_t)j; slop_option_env_VariantMapping _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; }); if (_mv.has_value) { __auto_type v2 = _mv.value; (((!(found_collision) && (string_eq(v2.variant_name, name1) && (!(string_eq(v2.enum_name, enum1)) && env_env_same_module_opt(mod1, v2.module_name))))) ? ({ ({ found_collision = 1; (void)0; }); ({ collision_enum = v2.enum_name; (void)0; }); 0; }) : ({ (void)0; })); } else { ({ (void)0; }); } (void)0; }); } 0; });\n                    if (found_collision) {\n                        {\n                            __auto_type msg = string_concat(arena, SLOP_STR(\"Ambiguous enum variant '\"), string_concat(arena, name1, string_concat(arena, SLOP_STR(\"' exists in multiple types: \"), string_concat(arena, enum1, string_concat(arena, SLOP_STR(\", \"), collision_enum)))));\n                            env_env_add_error(env, msg, 0, 0);\n                        }\n                    }\n                }\n            } else if (!_mv_47.has_value) {\n            }\n        }\n    }\n}\n\nuint8_t env_env_same_module_opt(slop_option_string a, slop_option_string b) {\n    __auto_type _mv_48 = a;\n    if (!_mv_48.has_value) {\n        __auto_type _mv_49 = b;\n        if (!_mv_49.has_value) {\n            return 1;\n        } else if (_mv_49.has_value) {\n            __auto_type _ = _mv_49.value;\n            return 0;\n        }\n    } else if (_mv_48.has_value) {\n        __auto_type amod = _mv_48.value;\n        __auto_type _mv_50 = b;\n        if (!_mv_50.has_value) {\n            return 0;\n        } else if (_mv_50.has_value) {\n            __auto_type bmod = _mv_50.value;\n            return string_eq(amod, bmod);\n        }\n    }\n}\n\nvoid env_env_set_module(env_TypeEnv* env, slop_option_string module_name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).current_module = module_name;\n}\n\nslop_option_string env_env_get_module(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).current_module;\n}\n\ntypes_ResolvedType* env_env_get_int_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).int_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_bool_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).bool_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_string_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).string_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_unit_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).unit_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_arena_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).arena_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_unknown_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    return (*env).unknown_type;\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_option_type(env_TypeEnv* env, types_ResolvedType* inner_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type inner_name = (((inner_type != NULL)) ? (*inner_type).name : SLOP_STR(\"T\"));\n        __auto_type opt_name = string_concat(arena, SLOP_STR(\"Option_\"), inner_name);\n        __auto_type opt_type = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_option, opt_name, ((slop_option_string){.has_value = false}), opt_name);\n        types_resolved_type_set_inner(opt_type, inner_type);\n        return opt_type;\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_ptr_type(env_TypeEnv* env, types_ResolvedType* inner_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type inner_name = (((inner_type != NULL)) ? (*inner_type).name : SLOP_STR(\"Void\"));\n        __auto_type ptr_name = string_concat(arena, SLOP_STR(\"Ptr_\"), inner_name);\n        __auto_type ptr_type = types_resolved_type_new(arena, types_ResolvedTypeKind_rk_ptr, ptr_name, ((slop_option_string){.has_value = false}), ptr_name);\n        types_resolved_type_set_inner(ptr_type, inner_type);\n        return ptr_type;\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_get_generic_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        return types_resolved_type_new(arena, types_ResolvedTypeKind_rk_primitive, SLOP_STR(\"T\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"void*\"));\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_result_type(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        return types_resolved_type_new(arena, types_ResolvedTypeKind_rk_result, SLOP_STR(\"Result\"), ((slop_option_string){.has_value = false}), SLOP_STR(\"Result\"));\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\ntypes_ResolvedType* env_env_make_fn_type(env_TypeEnv* env, types_FnSignature* sig) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    SLOP_PRE(((sig != NULL)), \"(!= sig nil)\");\n    types_ResolvedType* _retval;\n    {\n        __auto_type arena = (*env).arena;\n        __auto_type fn_name = string_concat(arena, SLOP_STR(\"Fn_\"), (*sig).name);\n        return types_resolved_type_new(arena, types_ResolvedTypeKind_rk_function, fn_name, ((slop_option_string){.has_value = false}), fn_name);\n    }\n    SLOP_POST(((_retval != NULL)), \"(!= $result nil)\");\n    return _retval;\n}\n\nvoid env_env_add_warning(env_TypeEnv* env, slop_string message, int64_t line, int64_t col) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).diagnostics); __auto_type _item = (types_diagnostic_new(types_DiagnosticLevel_diag_warning, message, line, col)); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nvoid env_env_add_error(env_TypeEnv* env, slop_string message, int64_t line, int64_t col) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).diagnostics); __auto_type _item = (types_diagnostic_new(types_DiagnosticLevel_diag_error, message, line, col)); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_list_types_Diagnostic env_env_get_diagnostics(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).diagnostics;\n}\n\nvoid env_env_clear_diagnostics(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type arena = (*env).arena;\n        (*env).diagnostics = ((slop_list_types_Diagnostic){ .data = (types_Diagnostic*)slop_arena_alloc(arena, 16 * sizeof(types_Diagnostic)), .len = 0, .cap = 16 });\n    }\n}\n\nvoid env_env_record_binding(env_TypeEnv* env, slop_string name, int64_t line, int64_t col, slop_string slop_type) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).binding_annotations); __auto_type _item = ((env_BindingAnnotation){name, line, col, slop_type}); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nslop_list_env_BindingAnnotation env_env_get_binding_annotations(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).binding_annotations;\n}\n\nvoid env_env_set_current_file(env_TypeEnv* env, slop_option_string file_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).current_file = file_path;\n}\n\nslop_option_string env_env_get_current_file(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).current_file;\n}\n\nvoid env_env_add_loaded_module(env_TypeEnv* env, slop_string module_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    ({ __auto_type _lst_p = &((*env).loaded_modules); __auto_type _item = (module_path); if (_lst_p->len >= _lst_p->cap) { size_t _new_cap = _lst_p->cap == 0 ? 16 : _lst_p->cap * 2; __typeof__(_lst_p->data) _new_data = (__typeof__(_lst_p->data))slop_arena_alloc(env->arena, _new_cap * sizeof(*_lst_p->data)); if (_lst_p->len > 0) memcpy(_new_data, _lst_p->data, _lst_p->len * sizeof(*_lst_p->data)); _lst_p->data = _new_data; _lst_p->cap = _new_cap; } _lst_p->data[_lst_p->len++] = _item; (void)0; });\n}\n\nuint8_t env_env_is_module_loaded(env_TypeEnv* env, slop_string module_path) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type modules = (*env).loaded_modules;\n        __auto_type len = ((int64_t)((modules).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            __auto_type _mv_51 = ({ __auto_type _lst = modules; size_t _idx = (size_t)i; slop_option_string _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n            if (_mv_51.has_value) {\n                __auto_type path = _mv_51.value;\n                if ((!(found) && string_eq(path, module_path))) {\n                    found = 1;\n                }\n            } else if (!_mv_51.has_value) {\n            }\n        }\n        return found;\n    }\n}\n\nvoid env_env_set_fn_type_params(env_TypeEnv* env, slop_list_string params) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).fn_type_params = params;\n}\n\nslop_list_string env_env_get_fn_type_params(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    return (*env).fn_type_params;\n}\n\nvoid env_env_clear_fn_type_params(env_TypeEnv* env) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    (*env).fn_type_params = ((slop_list_string){ .data = (slop_string*)slop_arena_alloc((*env).arena, 16 * sizeof(slop_string)), .len = 0, .cap = 16 });\n}\n\nuint8_t env_env_is_type_param(env_TypeEnv* env, slop_string name) {\n    SLOP_PRE(((env != NULL)), \"(!= env nil)\");\n    {\n        __auto_type params = (*env).fn_type_params;\n        __auto_type len = ((int64_t)((params).len));\n        __auto_type found = 0;\n        for (int64_t i = 0; i < len; i++) {\n            if (!(found)) {\n                __auto_type _mv_52 = ({ __auto_type _lst = params; size_t _idx = (size_t)i; slop_option_string _r; if (_idx < _lst.len) { _r.has_value = true; _r.value = _lst.data[_idx]; } else { _r.has_value = false; } _r; });\n                if (_mv_52.has_value) {\n                    __auto_type p = _mv_52.value;\n                    if (string_eq(p, name)) {\n                        found = 1;\n                    }\n                } else if (!_mv_52.has_value) {\n                }\n            }\n        }\n        return found;\n    }\n}\n\n"}}
