;; ============================================================
;; Import Resolution
;;
;; Resolves import statements, mapping local names to their
;; fully qualified types from other modules.
;; ============================================================

(module resolve
  (export
    resolve-imports resolve-import-stmt resolve-module-file)

  (import parser (SExpr SExprList SExprSymbol is-form
                  sexpr-is-list sexpr-list-len sexpr-list-get
                  sexpr-line sexpr-col))
  (import types (ResolvedType))
  (import env (TypeEnv env-arena env-add-import env-resolve-import
               env-lookup-type env-lookup-type-direct env-set-module env-get-current-file
               env-add-error env-lookup-function-direct))
  (import path (path-dirname path-join))
  (import file (file-exists))

  ;; ============================================================
  ;; Import Resolution
  ;; ============================================================

  (fn resolve-imports ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Process all import statements in the AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "import")
                (resolve-import-stmt env expr))
              ((is-form expr "module")
                (resolve-module-imports env expr))
              (else (do))))
          ((none) (do))))))

  (fn resolve-module-imports ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Process import statements inside a module form")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (when (sexpr-is-list module-form)
      (let ((len (sexpr-list-len module-form)))
        ;; Start from index 2 (after module keyword and name)
        (for (i 2 len)
          (match (sexpr-list-get module-form i)
            ((some item)
              (when (is-form item "import")
                (resolve-import-stmt env item)))
            ((none) (do)))))))

  (fn resolve-import-stmt ((env (Ptr TypeEnv)) (import-form (Ptr SExpr)))
    (@intent "Process a single import statement")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= import-form nil))
    (@pre (is-form import-form "import"))
    (let ((arena (env-arena env)))
      (match (deref import-form)
        ((lst lst)
          (let ((items (. lst items)))
            (match (list-get items 1)
              ((some mod-name-expr)
                (match (deref mod-name-expr)
                  ((sym mod-sym)
                    (match (list-get items 2)
                      ((some names-expr)
                        (match (deref names-expr)
                          ((lst names-lst)
                            (let ((name-items (. names-lst items))
                                  (name-len (list-len name-items)))
                              (for (j 0 name-len)
                                (match (list-get name-items j)
                                  ((some name-expr)
                                    (match (deref name-expr)
                                      ((sym name-sym)
                                        (let ((local-name (. name-sym name))
                                              ;; Look up the type to find its actual defining module
                                              ;; This handles re-exports: if parser exports SExpr from types,
                                              ;; we want "types:SExpr" not "parser:SExpr"
                                              (actual-module (match (env-lookup-type-direct env local-name)
                                                               ((some t)
                                                                 (match (. (deref t) module-name)
                                                                   ((some mod) mod)
                                                                   ;; Builtin - use specified module
                                                                   ((none) (. mod-sym name))))
                                                               ;; Type not found - might be a function, use specified module
                                                               ((none) (. mod-sym name))))
                                              (qualified-name (string-concat arena actual-module
                                                                (string-concat arena ":" local-name))))
                                          ;; Validate that the symbol exists in the target module
                                          (when (and (not (contains-slash (. mod-sym name)))
                                                     (match (env-lookup-type-direct env qualified-name)
                                                       ((some _) false)
                                                       ((none) true))
                                                     (match (env-lookup-function-direct env qualified-name)
                                                       ((some _) false)
                                                       ((none) true)))
                                            (env-add-error env
                                              (string-concat arena "module '"
                                                (string-concat arena (. mod-sym name)
                                                  (string-concat arena "' does not export '"
                                                    (string-concat arena local-name "'"))))
                                              (sexpr-line name-expr) (sexpr-col name-expr)))
                                          (env-add-import env local-name qualified-name)))
                                      (_ (do))))
                                  ((none) (do))))))
                          (_ (do))))
                      ((none) (do))))
                  (_ (do))))
              ((none) (do)))))
        (_ (do)))))

  ;; ============================================================
  ;; Module File Resolution
  ;; ============================================================

  (fn contains-slash ((s String))
    (@intent "Check if string contains a forward slash character")
    (@spec ((String) -> Bool))
    (@pure)
    (let ((len (cast Int (. s len)))
          (mut found false))
      (for (i 0 len)
        (when (and (not found) (== (cast Int (@ (. s data) i)) 47))
          (set! found true)))
      found))

  (fn resolve-module-file ((arena Arena) (module-name String) (from-file (Option String)))
    (@intent "Resolve module name to file path, returning the resolved path or none")
    (@spec ((Arena String (Option String)) -> (Option String)))
    (@pure)
    (@example (arena "utils/helper" (some "src/main.slop")) -> (some "src/utils/helper.slop"))
    (@example (arena "strlib" (some "src/main.slop")) -> none)
    ;; Only resolve path-style imports (containing '/')
    ;; Regular imports like 'strlib' are handled by build orchestration
    (if (not (contains-slash module-name))
      (none)
      (match from-file
        ((some current-path)
          (let ((dir (path-dirname arena current-path))
                (rel-path (string-concat arena module-name ".slop"))
                (full-path (path-join arena dir rel-path)))
            (if (file-exists full-path)
              (some full-path)
              (none))))
        ((none) (none)))))
)
