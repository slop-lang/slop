;; ============================================================
;; SLOP Compiler - Merged Checker + Transpiler
;;
;; Single binary with subcommands:
;;   slop-compiler check [--json] [--expr ...] FILES
;;   slop-compiler transpile FILES
;;
;; In transpile mode, the checker runs first to annotate AST
;; nodes with resolved types, then the transpiler reads those
;; annotations instead of doing string-based type guessing.
;; ============================================================

(module compiler
  (export (main 2))

  ;; --- Parser imports ---
  (import parser (SExpr parse is-form
                  sexpr-is-list sexpr-list-get sexpr-list-len sexpr-get-symbol-name
                  sexpr-line sexpr-col))
  ;; --- Type system imports ---
  (import types (TypeError TypeErrorKind type-error-new
                 Diagnostic DiagnosticLevel ResolvedType ResolvedTypeKind
                 SExprList SExprSymbol
                 resolved-type-to-slop-string))
  ;; --- Checker imports ---
  (import env (TypeEnv env-new env-get-diagnostics env-clear-diagnostics
               env-arena env-push-scope env-pop-scope env-bind-var
               env-lookup-type env-get-int-type env-get-bool-type
               env-get-string-type env-get-unit-type env-get-arena-type
               env-set-module env-add-error env-clear-imports))
  (import collect (collect-module))
  (import resolve (resolve-imports))
  (import infer (infer-fn-body infer-expr resolve-complex-type-expr resolve-simple-type))
  ;; --- C type bridge imports ---
  (import ctype (get-node-resolved-type))
  ;; --- Transpiler imports ---
  (import context (TranspileContext context-new ctx-reset-for-new-module
                   ctx-get-output ctx-get-header ctx-set-prefixing
                   ctx-set-file ctx-has-errors ctx-report-errors))
  (import transpiler (transpile-file))
  ;; --- I/O imports ---
  (import file (FileMode FileError File
                file-open file-close file-read-all))
  (import strlib (cstring-to-string))

  ;; FFI for stdio
  (ffi "stdio.h"
    (putchar ((c Int)) Int))

  (ffi "stdlib.h"
    (exit ((code Int)) Unit))

  (ffi "string.h"
    (strlen ((s (Ptr U8))) U64))

  ;; ============================================================
  ;; Subcommand Enum
  ;; ============================================================

  (type Subcommand (enum cmd-check cmd-transpile cmd-typed-ast cmd-help))

  ;; ============================================================
  ;; Output Format (for check mode)
  ;; ============================================================

  (type OutputFormat (enum fmt-text fmt-json))

  ;; ============================================================
  ;; Output Helpers
  ;; ============================================================

  (fn print-str ((s (Ptr U8)))
    (@intent "Print null-terminated C string to stdout")
    (@spec (((Ptr U8)) -> Unit))
    (@pre (!= s nil))
    (let ((mut i 0))
      (while (!= (@ s i) 0)
        (putchar (cast Int (@ s i)))
        (set! i (+ i 1))))
    (do))

  (fn print-string ((s String))
    (@intent "Print String to stdout")
    (@spec ((String) -> Unit))
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut i 0))
      (while (< i len)
        (putchar (cast Int (@ data i)))
        (set! i (+ i 1))))
    (do))

  (fn print-json-string ((arena Arena) (s String))
    (@intent "Print JSON-escaped string with quotes")
    (@spec ((Arena String) -> Unit))
    (putchar 34)
    (let ((len (cast Int (. s len)))
          (data (. s data))
          (mut i 0))
      (while (< i len)
        (let ((c (cast Int (@ data i))))
          (cond
            ((== c 34)  (putchar 92) (putchar 34))
            ((== c 92)  (putchar 92) (putchar 92))
            ((== c 10)  (putchar 92) (putchar 110))
            ((== c 13)  (putchar 92) (putchar 114))
            ((== c 9)   (putchar 92) (putchar 116))
            (else (putchar c))))
        (set! i (+ i 1))))
    (putchar 34)
    (do))

  (fn lines-to-string ((arena Arena) (lines (List String)))
    (@intent "Concatenate list of lines into single string with newlines")
    (@spec ((Arena (List String)) -> String))
    (let ((len (list-len lines)))
      (if (== len 0)
        ""
        (let ((mut total 0)
              (mut i 0))
          (while (< i len)
            (match (list-get lines i)
              ((some line)
                (set! total (+ total (+ (cast Int (. line len)) 1))))
              ((none) (do)))
            (set! i (+ i 1)))
          (let ((buf (arena-alloc arena (+ total 1)))
                (mut pos 0)
                (mut j 0))
            (while (< j len)
              (match (list-get lines j)
                ((some line)
                  (let ((line-len (cast Int (. line len)))
                        (line-data (. line data))
                        (mut k 0))
                    (while (< k line-len)
                      (set! (@ buf pos) (@ line-data k))
                      (set! pos (+ pos 1))
                      (set! k (+ k 1)))
                    (set! (@ buf pos) 10)
                    (set! pos (+ pos 1))))
                ((none) (do)))
              (set! j (+ j 1)))
            (set! (@ buf pos) 0)
            (String buf (cast U64 pos)))))))

  ;; ============================================================
  ;; Module Name Extraction
  ;; ============================================================

  (fn extract-module-name ((exprs (List (Ptr SExpr))))
    (@intent "Extract module name from parsed expressions")
    (@spec (((List (Ptr SExpr))) -> String))
    (if (< (list-len exprs) 1)
      "unknown"
      (match (list-get exprs 0)
        ((some first-expr)
          (match (deref first-expr)
            ((lst lst)
              (let ((items (. lst items)))
                (if (< (list-len items) 2)
                  "unknown"
                  (match (list-get items 0)
                    ((some head)
                      (match (deref head)
                        ((sym sym)
                          (if (string-eq (. sym name) "module")
                            (match (list-get items 1)
                              ((some name-expr)
                                (match (deref name-expr)
                                  ((sym name-sym) (. name-sym name))
                                  (_ "unknown")))
                              ((none) "unknown"))
                            "unknown"))
                        (_ "unknown")))
                    ((none) "unknown")))))
            (_ "unknown")))
        ((none) "unknown"))))

  ;; ============================================================
  ;; Argv Helper
  ;; ============================================================

  (fn argv-to-string ((argv (Ptr (Ptr U8))) (index Int))
    (@intent "Convert argv[index] to String")
    (@spec (((Ptr (Ptr U8)) Int) -> String))
    (let ((ptr (@ argv index)))
      (String ptr (strlen ptr))))

  ;; ============================================================
  ;; Type Check Pipeline
  ;; ============================================================

  (fn type-check-with-env ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Type check an AST using existing environment (for multi-module)")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (@pre (> (list-len ast) 0))
    (collect-module env ast)
    (resolve-imports env ast)
    (check-all-functions env ast))

  (fn check-all-functions ((env (Ptr TypeEnv)) (ast (List (Ptr SExpr))))
    (@intent "Type check all function bodies in the AST")
    (@spec (((Ptr TypeEnv) (List (Ptr SExpr))) -> Unit))
    (@pre (!= env nil))
    (let ((len (list-len ast)))
      (for (i 0 len)
        (match (list-get ast i)
          ((some expr)
            (cond
              ((is-form expr "fn")
                (let ((_ (infer-fn-body env expr)))
                  (do)))
              ((is-form expr "module")
                (check-module-functions env expr))
              (else (do))))
          ((none) (do))))))

  (fn is-annotation-form ((item (Ptr SExpr)))
    (@intent "Check if item starts with @ symbol")
    (@spec (((Ptr SExpr)) -> Bool))
    (if (sexpr-is-list item)
      (match (sexpr-list-get item 0)
        ((some head)
          (cast Bool (let ((name (sexpr-get-symbol-name head)))
                       (if (> (. name len) 0)
                         (= (@ (. name data) 0) 64)
                         false))))
        ((none) false))
      false))

  (fn is-valid-toplevel-form ((item (Ptr SExpr)))
    (@intent "Check if item is a valid top-level form")
    (@spec (((Ptr SExpr)) -> Bool))
    (cond
      ((is-form item "fn") true)
      ((is-form item "type") true)
      ((is-form item "const") true)
      ((is-form item "ffi") true)
      ((is-form item "ffi-struct") true)
      ((is-form item "import") true)
      ((is-form item "export") true)
      ((is-annotation-form item) true)
      (else false)))

  (fn get-form-name ((item (Ptr SExpr)))
    (@intent "Get the head symbol name of a form, or <unknown>")
    (@spec (((Ptr SExpr)) -> String))
    (if (sexpr-is-list item)
      (match (sexpr-list-get item 0)
        ((some head) (sexpr-get-symbol-name head))
        ((none) "<empty>"))
      "<non-list>"))

  (fn check-module-functions ((env (Ptr TypeEnv)) (module-form (Ptr SExpr)))
    (@intent "Type check all function bodies inside a module")
    (@spec (((Ptr TypeEnv) (Ptr SExpr)) -> Unit))
    (@pre (!= env nil))
    (@pre (!= module-form nil))
    (when (sexpr-is-list module-form)
      (match (sexpr-list-get module-form 1)
        ((some name-expr)
          (let ((mod-name (sexpr-get-symbol-name name-expr)))
            (when (not (string-eq mod-name ""))
              (env-set-module env (some mod-name)))))
        ((none) (do)))
      (let ((len (sexpr-list-len module-form)))
        (for (i 2 len)
          (match (sexpr-list-get module-form i)
            ((some item)
              (cond
                ((is-form item "fn")
                  (let ((_ (infer-fn-body env item)))
                    (do)))
                ((is-valid-toplevel-form item) (do))
                (else
                  (let ((arena (env-arena env))
                        (msg (string-concat arena "Unknown top-level form: " (get-form-name item))))
                    (env-add-error env msg (sexpr-line item) (sexpr-col item))))))
            ((none) (do)))))))

  ;; ============================================================
  ;; Diagnostics Output (for check mode)
  ;; ============================================================

  (fn count-errors ((diagnostics (List Diagnostic)))
    (@intent "Count number of error diagnostics")
    (@spec (((List Diagnostic)) -> Int))
    (let ((len (list-len diagnostics))
          (mut errors 0)
          (mut i 0))
      (while (< i len)
        (match (list-get diagnostics i)
          ((some diag)
            (match (. diag level)
              ('diag-error (set! errors (+ errors 1)))
              ('diag-warning (do))))
          ((none) (do)))
        (set! i (+ i 1)))
      errors))

  (fn print-diagnostic ((arena Arena) (filename String) (diag Diagnostic))
    (@intent "Print a diagnostic message with location info")
    (@spec ((Arena String Diagnostic) -> Unit))
    (print filename)
    (print ":")
    (print (. diag line))
    (print ":")
    (print (. diag col))
    (print ": ")
    (match (. diag level)
      ('diag-warning (print "warning: "))
      ('diag-error (print "error: ")))
    (println (. diag message)))

  (fn output-diagnostics-text ((arena Arena) (filename String) (diagnostics (List Diagnostic)))
    (@intent "Output diagnostics in human-readable text format")
    (@spec ((Arena String (List Diagnostic)) -> Unit))
    (let ((len (list-len diagnostics))
          (mut i 0))
      (while (< i len)
        (match (list-get diagnostics i)
          ((some diag) (print-diagnostic arena filename diag))
          ((none) (do)))
        (set! i (+ i 1))))
    (do))

  (fn output-diagnostics-json ((arena Arena) (diagnostics (List Diagnostic)))
    (@intent "Output diagnostics as JSON array")
    (@spec ((Arena (List Diagnostic)) -> Unit))
    (putchar 91)
    (let ((len (list-len diagnostics))
          (mut i 0))
      (while (< i len)
        (when (> i 0)
          (putchar 44))
        (match (list-get diagnostics i)
          ((some diag)
            (output-single-diagnostic-json arena diag))
          ((none) (do)))
        (set! i (+ i 1))))
    (putchar 93)
    (do))

  (fn output-single-diagnostic-json ((arena Arena) (diag Diagnostic))
    (@intent "Output a single diagnostic as JSON object")
    (@spec ((Arena Diagnostic) -> Unit))
    (putchar 123)
    (print-str (cast (Ptr U8) "\"level\":"))
    (match (. diag level)
      ('diag-warning (print-str (cast (Ptr U8) "\"warning\"")))
      ('diag-error (print-str (cast (Ptr U8) "\"error\""))))
    (putchar 44)
    (print-str (cast (Ptr U8) "\"line\":"))
    (print-string (int-to-string arena (. diag line)))
    (putchar 44)
    (print-str (cast (Ptr U8) "\"col\":"))
    (print-string (int-to-string arena (. diag col)))
    (putchar 44)
    (print-str (cast (Ptr U8) "\"message\":"))
    (print-json-string arena (. diag message))
    (putchar 125)
    (do))

  (fn output-check-module-json ((arena Arena) (mod-name String) (diagnostics (List Diagnostic)) (first Bool))
    (@intent "Output JSON for a single module's check diagnostics")
    (@spec ((Arena String (List Diagnostic) Bool) -> Unit))
    (when (not first)
      (putchar 44))
    (print-json-string arena mod-name)
    (putchar 58)
    (putchar 123)
    (print-str (cast (Ptr U8) "\"diagnostics\":"))
    (output-diagnostics-json arena diagnostics)
    (putchar 125)
    (do))

  ;; ============================================================
  ;; Check Mode: Single File Processing
  ;; ============================================================

  (fn check-single-file ((env (Ptr TypeEnv)) (arena Arena) (filename (Ptr U8)) (format OutputFormat) (first Bool))
    (@intent "Type check a single file using shared environment")
    (@spec (((Ptr TypeEnv) Arena (Ptr U8) OutputFormat Bool) -> Int))
    (@pre (!= env nil))
    (@pre (!= filename nil))
    (let ((filename-str (cstring-to-string filename)))
      (match (file-open filename-str 'read)
        ((error e)
          (do
            (print "Error: Could not open file: ")
            (println filename-str)
            1))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error e)
              (do
                (file-close (addr f))
                (print "Error: Could not read file: ")
                (println filename-str)
                1))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok ast)
                    (let ((mod-name (extract-module-name ast)))
                      (env-clear-imports env)
                      (env-clear-diagnostics env)
                      (type-check-with-env env ast)
                      (let ((diagnostics (env-get-diagnostics env)))
                        (when (== format 'fmt-json)
                          (output-check-module-json arena mod-name diagnostics first))
                        (when (== format 'fmt-text)
                          (output-diagnostics-text arena filename-str diagnostics))
                        (count-errors diagnostics))))
                  ((error parse-err)
                    (do
                      (print filename-str)
                      (print ":")
                      (print (. parse-err line))
                      (print ":")
                      (print (. parse-err col))
                      (print ": error: ")
                      (println (. parse-err message))
                      1))))))))))

  ;; ============================================================
  ;; Expression Mode Support (for hole filler)
  ;; ============================================================

  (fn resolve-type-string ((env (Ptr TypeEnv)) (arena Arena) (type-str String))
    (@intent "Parse a type string and resolve it to a ResolvedType")
    (@spec (((Ptr TypeEnv) Arena String) -> (Ptr ResolvedType)))
    (@pre (!= env nil))
    (match (parse arena type-str)
      ((ok type-ast)
        (if (== (list-len type-ast) 0)
          (env-get-int-type env)
          (match (list-get type-ast 0)
            ((some type-expr)
              (if (sexpr-is-list type-expr)
                (resolve-complex-type-expr env type-expr)
                (let ((name (sexpr-get-symbol-name type-expr)))
                  (if (string-eq name "")
                    (env-get-int-type env)
                    (resolve-simple-type env name)))))
            ((none) (env-get-int-type env)))))
      ((error _) (env-get-int-type env))))

  (fn parse-and-bind-params ((env (Ptr TypeEnv)) (arena Arena) (params-str String))
    (@intent "Parse a params string like '((a Int) (b String))' and bind to env")
    (@spec (((Ptr TypeEnv) Arena String) -> Unit))
    (@pre (!= env nil))
    (match (parse arena params-str)
      ((ok params-ast)
        (when (> (list-len params-ast) 0)
          (match (list-get params-ast 0)
            ((some params-list)
              (match (deref params-list)
                ((lst lst)
                  (let ((items (. lst items))
                        (len (list-len items)))
                    (for (i 0 len)
                      (match (list-get items i)
                        ((some param)
                          (match (deref param)
                            ((lst param-lst)
                              (let ((param-items (. param-lst items)))
                                (when (>= (list-len param-items) 2)
                                  (match (list-get param-items 0)
                                    ((some name-expr)
                                      (match (deref name-expr)
                                        ((sym name-sym)
                                          (let ((param-name (. name-sym name)))
                                            (match (list-get param-items 1)
                                              ((some type-expr)
                                                (match (deref type-expr)
                                                  ((sym type-sym)
                                                    (let ((param-type (resolve-type-string env arena (. type-sym name))))
                                                      (env-bind-var env param-name param-type)))
                                                  ((lst _)
                                                    (let ((param-type (resolve-complex-type-expr env type-expr)))
                                                      (env-bind-var env param-name param-type)))
                                                  (_ (env-bind-var env param-name (env-get-int-type env)))))
                                              ((none) (do)))))
                                        (_ (do))))
                                    ((none) (do))))))
                            (_ (do))))
                        ((none) (do))))))
                (_ (do))))
            ((none) (do)))))
      ((error _) (do))))

  (fn types-names-equal ((a (Ptr ResolvedType)) (b (Ptr ResolvedType)))
    (@intent "Check if two types are structurally equal")
    (@spec (((Ptr ResolvedType) (Ptr ResolvedType)) -> Bool))
    (@pure)
    (@pre (!= a nil))
    (@pre (!= b nil))
    (let ((a-name (. (deref a) name))
          (b-name (. (deref b) name))
          (a-kind (. (deref a) kind))
          (b-kind (. (deref b) kind)))
      (cond
        ((string-eq a-name b-name) true)
        ((or (string-eq a-name "T") (string-eq b-name "T")) true)
        ((or (string-eq a-name "Unknown") (string-eq b-name "Unknown")) true)
        ((and (== a-kind 'rk-option) (== b-kind 'rk-option))
          (match (. (deref a) inner-type)
            ((some a-inner)
              (match (. (deref b) inner-type)
                ((some b-inner) (types-names-equal a-inner b-inner))
                ((none) true)))
            ((none) true)))
        ((and (== a-kind 'rk-result) (== b-kind 'rk-result))
          (let ((ok-match (match (. (deref a) inner-type)
                            ((some a-inner)
                              (match (. (deref b) inner-type)
                                ((some b-inner) (types-names-equal a-inner b-inner))
                                ((none) true)))
                            ((none) true)))
                (err-match (match (. (deref a) inner-type2)
                             ((some a-inner2)
                               (match (. (deref b) inner-type2)
                                 ((some b-inner2) (types-names-equal a-inner2 b-inner2))
                                 ((none) true)))
                             ((none) true))))
            (and ok-match err-match)))
        ((and (== a-kind 'rk-ptr) (== b-kind 'rk-ptr))
          (match (. (deref a) inner-type)
            ((some a-inner)
              (match (. (deref b) inner-type)
                ((some b-inner) (types-names-equal a-inner b-inner))
                ((none) true)))
            ((none) true)))
        ((== a-kind 'rk-range)
          (match (. (deref a) inner-type)
            ((some base) (types-names-equal base b))
            ((none) false)))
        ((== b-kind 'rk-range)
          (match (. (deref b) inner-type)
            ((some base) (types-names-equal a base))
            ((none) false)))
        ((and (== a-kind 'rk-primitive) (== b-kind 'rk-primitive))
          (let ((a-match (match (. (deref a) inner-type)
                           ((some a-base) (types-names-equal a-base b))
                           ((none) false)))
                (b-match (match (. (deref b) inner-type)
                           ((some b-base) (types-names-equal a b-base))
                           ((none) false))))
            (or a-match b-match)))
        ((== a-kind 'rk-primitive)
          (match (. (deref a) inner-type)
            ((some a-base) (types-names-equal a-base b))
            ((none) false)))
        ((== b-kind 'rk-primitive)
          (match (. (deref b) inner-type)
            ((some b-base) (types-names-equal a b-base))
            ((none) false)))
        (else false))))

  (fn check-expr-mode ((arena Arena) (env (Ptr TypeEnv))
                        (expr-str String) (type-str String)
                        (context-file String) (params-str String))
    (@intent "Type check an expression against expected type with context")
    (@spec ((Arena (Ptr TypeEnv) String String String String) -> Int))
    (@pre (!= env nil))
    (when (> (string-len context-file) 0)
      (match (file-open context-file 'read)
        ((error _) (do))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error _) (file-close (addr f)))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok context-ast)
                    (do
                      (collect-module env context-ast)
                      (resolve-imports env context-ast)))
                  ((error _) (do)))))))))
    (env-push-scope env)
    (when (> (string-len params-str) 0)
      (parse-and-bind-params env arena params-str))
    (let ((result (match (parse arena expr-str)
                    ((error parse-err)
                      (do
                        (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":"))
                        (print-string (int-to-string arena (. parse-err line)))
                        (print-str (cast (Ptr U8) ",\"col\":"))
                        (print-string (int-to-string arena (. parse-err col)))
                        (print-str (cast (Ptr U8) ",\"message\":"))
                        (print-json-string arena (. parse-err message))
                        (print-str (cast (Ptr U8) "}]}\n"))
                        1))
                    ((ok expr-ast)
                      (if (== (list-len expr-ast) 0)
                        (do
                          (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":1,\"col\":1,\"message\":\"Empty expression\"}]}\n"))
                          1)
                        (match (list-get expr-ast 0)
                          ((none)
                            (do
                              (print-str (cast (Ptr U8) "{\"valid\":false,\"diagnostics\":[{\"level\":\"error\",\"line\":1,\"col\":1,\"message\":\"Empty expression\"}]}\n"))
                              1))
                          ((some expr)
                            (do
                              (let ((inferred-type (infer-expr env expr)))
                                (let ((expected-type (resolve-type-string env arena type-str))
                                      (diagnostics (env-get-diagnostics env))
                                      (num-errors (count-errors diagnostics)))
                                  (let ((type-match (types-names-equal inferred-type expected-type))
                                        (final-diagnostics (env-get-diagnostics env))
                                        (final-errors (count-errors final-diagnostics))
                                        (is-valid (and type-match (== final-errors 0))))
                                    (output-expr-result arena is-valid
                                      (. (deref inferred-type) name) type-str final-diagnostics)
                                    (if is-valid 0 1))))))))))))
      (env-pop-scope env)
      result))

  (fn output-expr-result ((arena Arena) (valid Bool)
                           (inferred-type String) (expected-type String)
                           (diagnostics (List Diagnostic)))
    (@intent "Output JSON result for expression mode")
    (@spec ((Arena Bool String String (List Diagnostic)) -> Unit))
    (print-str (cast (Ptr U8) "{\"valid\":"))
    (if valid
      (print-str (cast (Ptr U8) "true"))
      (print-str (cast (Ptr U8) "false")))
    (print-str (cast (Ptr U8) ",\"inferred_type\":"))
    (print-json-string arena inferred-type)
    (print-str (cast (Ptr U8) ",\"expected_type\":"))
    (print-json-string arena expected-type)
    (print-str (cast (Ptr U8) ",\"diagnostics\":"))
    (output-diagnostics-json arena diagnostics)
    (print-str (cast (Ptr U8) "}\n"))
    (do))

  ;; ============================================================
  ;; Transpile Mode: Single File Processing
  ;; ============================================================

  (fn transpile-single-file ((env (Ptr TypeEnv)) (ctx (Ptr TranspileContext))
                              (arena Arena) (filename (Ptr U8)) (first Bool))
    (@intent "Parse, type check, and transpile a single file")
    (@spec (((Ptr TypeEnv) (Ptr TranspileContext) Arena (Ptr U8) Bool) -> Int))
    (@pre (!= env nil))
    (@pre (!= ctx nil))
    (@pre (!= filename nil))
    (let ((filename-str (cstring-to-string filename)))
      (ctx-set-file ctx filename-str)
      (match (file-open filename-str 'read)
        ((error e)
          (do
            (print "Error: Could not open file: ")
            (println filename-str)
            1))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error e)
              (do
                (file-close (addr f))
                (print "Error: Could not read file: ")
                (println filename-str)
                1))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok ast)
                    (let ((mod-name (extract-module-name ast)))
                      ;; Phase 1: Type check (annotates AST nodes)
                      (env-clear-imports env)
                      (env-clear-diagnostics env)
                      (type-check-with-env env ast)
                      ;; Phase 2: Transpile
                      (ctx-reset-for-new-module ctx mod-name)
                      (transpile-file ctx ast)
                      ;; Check for transpiler errors
                      (when (ctx-has-errors ctx)
                        (ctx-report-errors ctx)
                        (exit 1))
                      ;; Output JSON for this module
                      (output-transpile-module-json arena ctx mod-name first)
                      0))
                  ((error parse-err)
                    (do
                      (print filename-str)
                      (print ":")
                      (print (. parse-err line))
                      (print ":")
                      (print (. parse-err col))
                      (print ": error: ")
                      (println (. parse-err message))
                      1))))))))))

  (fn output-transpile-module-json ((arena Arena) (ctx (Ptr TranspileContext)) (mod-name String) (first Bool))
    (@intent "Output JSON for a single transpiled module")
    (@spec ((Arena (Ptr TranspileContext) String Bool) -> Unit))
    (@pre (!= ctx nil))
    (when (not first)
      (putchar 44))
    (print-json-string arena mod-name)
    (putchar 58)
    (putchar 123)
    (print-str (cast (Ptr U8) "\"header\":"))
    (let ((header-lines (ctx-get-header ctx))
          (header-str (lines-to-string arena header-lines)))
      (print-json-string arena header-str))
    (putchar 44)
    (print-str (cast (Ptr U8) "\"impl\":"))
    (let ((impl-lines (ctx-get-output ctx))
          (impl-str (lines-to-string arena impl-lines)))
      (print-json-string arena impl-str))
    (putchar 125)
    (do))

  ;; ============================================================
  ;; Typed-AST Emission
  ;; ============================================================

  (fn emit-sexpr-inner ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Emit inner representation of an S-expression without type wrapper")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre {expr != nil})
    (@pure)
    (match (deref expr)
      ((sym sym) (. sym name))
      ((str str)
        (string-concat arena "\""
          (string-concat arena (. str value) "\"")))
      ((num num) (. num raw))
      ((lst lst) (emit-typed-list arena (. lst items)))))

  (fn emit-typed-sexpr ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Emit S-expression with type annotations from checker")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre (!= expr nil))
    (let ((type-opt (get-node-resolved-type expr))
          (inner (emit-sexpr-inner arena expr)))
      (match type-opt
        ((some rt)
          (let ((type-str (resolved-type-to-slop-string arena rt)))
            (string-concat arena "(typed "
              (string-concat arena type-str
                (string-concat arena " " (string-concat arena inner ")"))))))
        ((none) inner))))

  (fn emit-typed-list ((arena Arena) (items (List (Ptr SExpr))))
    (@intent "Emit list items with type annotations, joined with spaces")
    (@spec ((Arena (List (Ptr SExpr))) -> String))
    (let ((len (list-len items))
          (mut result "(")
          (mut i 0))
      (while (< i len)
        (match (list-get items i)
          ((some item)
            (let ((child-str (emit-typed-sexpr arena item)))
              (if (> i 0)
                (set! result (string-concat arena result (string-concat arena " " child-str)))
                (set! result (string-concat arena result child-str)))))
          ((none) (do)))
        (set! i (+ i 1)))
      (string-concat arena result ")")))

  (fn emit-typed-toplevel ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Emit top-level form with type annotations on function bodies")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre (!= expr nil))
    (cond
      ((is-form expr "fn")
        ;; For fn forms, recursively emit with types
        (emit-typed-sexpr arena expr))
      ((is-form expr "module")
        ;; For modules, recurse into body forms
        (emit-typed-module arena expr))
      (else
        ;; Other forms (type, const, ffi, import, export) pass through
        (emit-typed-sexpr arena expr))))

  (fn emit-typed-module ((arena Arena) (module-form (Ptr SExpr)))
    (@intent "Emit module with typed function bodies")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@pre (!= module-form nil))
    (if (sexpr-is-list module-form)
      (let ((len (sexpr-list-len module-form))
            (mut result "(")
            (mut i 0))
        (while (< i len)
          (match (sexpr-list-get module-form i)
            ((some item)
              (let ((child-str (if (is-form item "fn")
                                 (emit-typed-sexpr arena item)
                                 (emit-typed-sexpr arena item))))
                (if (> i 0)
                  (set! result (string-concat arena result (string-concat arena " " child-str)))
                  (set! result (string-concat arena result child-str)))))
            ((none) (do)))
          (set! i (+ i 1)))
        (string-concat arena result ")"))
      (emit-typed-sexpr arena module-form)))

  (fn emit-typed-ast ((arena Arena) (ast (List (Ptr SExpr))))
    (@intent "Emit full typed AST as S-expression string")
    (@spec ((Arena (List (Ptr SExpr))) -> String))
    (let ((len (list-len ast))
          (mut result "")
          (mut i 0))
      (while (< i len)
        (match (list-get ast i)
          ((some expr)
            (let ((form-str (emit-typed-toplevel arena expr)))
              (if (> i 0)
                (set! result (string-concat arena result (string-concat arena "\n" form-str)))
                (set! result form-str))))
          ((none) (do)))
        (set! i (+ i 1)))
      result))

  (fn typed-ast-single-file ((env (Ptr TypeEnv)) (arena Arena) (filename (Ptr U8)) (format OutputFormat) (first Bool))
    (@intent "Parse, type check, and emit typed AST for a single file")
    (@spec (((Ptr TypeEnv) Arena (Ptr U8) OutputFormat Bool) -> Int))
    (@pre (!= env nil))
    (@pre (!= filename nil))
    (let ((filename-str (cstring-to-string filename)))
      (match (file-open filename-str 'read)
        ((error e)
          (do
            (print "Error: Could not open file: ")
            (println filename-str)
            1))
        ((ok f)
          (match (file-read-all arena (addr f))
            ((error e)
              (do
                (file-close (addr f))
                (print "Error: Could not read file: ")
                (println filename-str)
                1))
            ((ok source)
              (do
                (file-close (addr f))
                (match (parse arena source)
                  ((ok ast)
                    (let ((mod-name (extract-module-name ast)))
                      ;; Type check to annotate AST nodes
                      (env-clear-imports env)
                      (env-clear-diagnostics env)
                      (type-check-with-env env ast)
                      ;; Emit typed AST
                      (let ((typed-str (emit-typed-ast arena ast)))
                        (if (== format 'fmt-json)
                          (do
                            (when (not first)
                              (putchar 44))
                            (print-json-string arena mod-name)
                            (putchar 58)
                            (putchar 123)
                            (print-str (cast (Ptr U8) "\"typed-ast\":"))
                            (print-json-string arena typed-str)
                            (putchar 125)
                            0)
                          (do
                            (when (not first)
                              (putchar 10))
                            (print-string typed-str)
                            0)))))
                  ((error parse-err)
                    (do
                      (print filename-str)
                      (print ":")
                      (print (. parse-err line))
                      (print ":")
                      (print (. parse-err col))
                      (print ": error: ")
                      (println (. parse-err message))
                      1))))))))))

  ;; ============================================================
  ;; Main - CLI Entry Point
  ;; ============================================================

  (fn main ((argc Int) (argv (Ptr (Ptr U8))))
    (@intent "Entry point for the merged compiler - dispatches check/transpile subcommands")
    (@spec ((Int (Ptr (Ptr U8))) -> Int))
    (if (< argc 2)
      (do
        (println "Usage: slop-compiler <command> [options] <files...>")
        (println "")
        (println "Commands:")
        (println "  check [--json] [--expr EXPR --type TYPE] <files...>")
        (println "  typed-ast [--json] <files...>")
        (println "  transpile <files...>")
        1)
      (let ((cmd (argv-to-string argv 1)))
        (cond
          ;; ---- CHECK MODE ----
          ((string-eq cmd "check")
            (if (< argc 3)
              (do
                (println "Usage: slop-compiler check [--json] <file.slop> [file2.slop ...]")
                (println "       slop-compiler check --expr EXPR --type TYPE [--context FILE] [--params PARAMS]")
                1)
              (with-arena 4194304
                (if (string-eq (argv-to-string argv 2) "--expr")
                  ;; Expression mode
                  (let ((env (env-new arena))
                        (mut expr-str String "")
                        (mut type-str String "Int")
                        (mut context-file String "")
                        (mut params-str String "")
                        (mut i 3))
                    (when (< i argc)
                      (set! expr-str (argv-to-string argv i))
                      (set! i (+ i 1)))
                    (while (< i argc)
                      (let ((arg (argv-to-string argv i)))
                        (cond
                          ((string-eq arg "--type")
                            (when (< (+ i 1) argc)
                              (set! type-str (argv-to-string argv (+ i 1)))
                              (set! i (+ i 2))))
                          ((string-eq arg "--context")
                            (when (< (+ i 1) argc)
                              (set! context-file (argv-to-string argv (+ i 1)))
                              (set! i (+ i 2))))
                          ((string-eq arg "--params")
                            (when (< (+ i 1) argc)
                              (set! params-str (argv-to-string argv (+ i 1)))
                              (set! i (+ i 2))))
                          (else
                            (set! i (+ i 1))))))
                    (if (== (string-len expr-str) 0)
                      (do
                        (println "Error: --expr requires an expression argument")
                        1)
                      (check-expr-mode arena env expr-str type-str context-file params-str)))
                  ;; File mode
                  (let ((env (env-new arena))
                        (mut total-errors 0)
                        (mut format 'fmt-text)
                        (mut file-start 2))
                    (when (string-eq (argv-to-string argv 2) "--json")
                      (set! format 'fmt-json)
                      (set! file-start 3))
                    (when (== format 'fmt-json)
                      (putchar 123))
                    (let ((mut i file-start)
                          (mut first true))
                      (while (< i argc)
                        (let ((filename (@ argv i))
                              (errors (check-single-file env arena filename format first)))
                          (set! total-errors (+ total-errors errors))
                          (set! first false))
                        (set! i (+ i 1))))
                    (when (== format 'fmt-json)
                      (putchar 125)
                      (putchar 10))
                    (if (> total-errors 0) 1 0))))))

          ;; ---- TRANSPILE MODE ----
          ((string-eq cmd "transpile")
            (if (< argc 3)
              (do
                (println "Usage: slop-compiler transpile <file.slop> [file2.slop ...]")
                1)
              (with-arena 16777216
                (let ((env (env-new arena))
                      (ctx (context-new arena)))
                  (ctx-set-prefixing ctx true)
                  (putchar 123)
                  (let ((mut i 2)
                        (mut first true))
                    (while (< i argc)
                      (let ((filename (@ argv i))
                            (result (transpile-single-file env ctx arena filename first)))
                        (set! first false))
                      (set! i (+ i 1))))
                  (putchar 125)
                  (putchar 10)
                  0))))

          ;; ---- TYPED-AST MODE ----
          ((string-eq cmd "typed-ast")
            (if (< argc 3)
              (do
                (println "Usage: slop-compiler typed-ast [--json] <file.slop> [file2.slop ...]")
                1)
              (with-arena 4194304
                (let ((env (env-new arena))
                      (mut format 'fmt-text)
                      (mut file-start 2)
                      (mut total-errors 0))
                  (when (string-eq (argv-to-string argv 2) "--json")
                    (set! format 'fmt-json)
                    (set! file-start 3))
                  (when (== format 'fmt-json)
                    (putchar 123))
                  (let ((mut i file-start)
                        (mut first true))
                    (while (< i argc)
                      (let ((filename (@ argv i))
                            (errors (typed-ast-single-file env arena filename format first)))
                        (set! total-errors (+ total-errors errors))
                        (set! first false))
                      (set! i (+ i 1))))
                  (when (== format 'fmt-json)
                    (putchar 125)
                    (putchar 10))
                  (if (> total-errors 0) 1 0)))))

          ;; ---- UNKNOWN COMMAND ----
          (else
            (do
              (print "Unknown command: ")
              (println cmd)
              (println "Usage: slop-compiler <check|typed-ast|transpile> [options] <files...>")
              1))))))
)
