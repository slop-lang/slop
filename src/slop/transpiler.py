"""
SLOP Transpiler - Generate C code from SLOP AST

Handles:
- Type definitions → C structs/typedefs
- Functions → C functions
- Range types → runtime checks
- Contracts → SLOP_PRE/SLOP_POST macros
"""

from dataclasses import dataclass
from typing import List, Dict, Optional, Set
from slop.parser import SExpr, SList, Symbol, String, Number, is_form, parse


@dataclass
class TypeInfo:
    """Information about a SLOP type"""
    name: str
    c_type: str
    is_range: bool = False
    min_val: Optional[int] = None
    max_val: Optional[int] = None


class Transpiler:
    """Transpile SLOP to C"""

    def __init__(self):
        self.types: Dict[str, TypeInfo] = {}
        self.enums: Dict[str, str] = {}  # value -> qualified name
        self.ffi_funcs: Dict[str, dict] = {}  # FFI function registry
        self.ffi_structs: Dict[str, dict] = {}  # FFI struct registry
        self.ffi_struct_fields: Dict[str, Dict[str, dict]] = {}  # struct → field → type info
        self.ffi_includes: List[str] = []  # FFI headers to include
        self.output: List[str] = []
        self.indent = 0

        # Built-in type mappings
        self.builtin_types = {
            'Int': 'int64_t',
            'I8': 'int8_t',
            'I16': 'int16_t',
            'I32': 'int32_t',
            'I64': 'int64_t',
            'U8': 'uint8_t',
            'U16': 'uint16_t',
            'U32': 'uint32_t',
            'U64': 'uint64_t',
            'Float': 'double',
            'F32': 'float',
            'Bool': 'uint8_t',
            'String': 'slop_string',
            'Bytes': 'slop_bytes',
            'Unit': 'void',
            'Void': 'void',
            'Arena': 'slop_arena*',
            'Milliseconds': 'int64_t',
        }

    def emit(self, line: str = ""):
        """Emit a line of C code"""
        if line:
            self.output.append("    " * self.indent + line)
        else:
            self.output.append("")

    def transpile(self, ast: List[SExpr]) -> str:
        """Transpile SLOP AST to C code"""
        self.output = []
        self.ffi_funcs = {}
        self.ffi_structs = {}
        self.ffi_struct_fields = {}
        self.ffi_includes = []

        # First pass: collect FFI declarations from all modules
        for form in ast:
            if is_form(form, 'module'):
                self._collect_ffi(form)
            elif is_form(form, 'ffi'):
                self._register_ffi(form)
            elif is_form(form, 'ffi-struct'):
                self._register_ffi_struct(form)

        # Header
        self.emit("/* Generated by SLOP transpiler */")

        # Emit FFI includes first (before runtime)
        for header in self.ffi_includes:
            self.emit(f"#include <{header}>")
        if self.ffi_includes:
            self.emit("")

        self.emit("#include \"slop_runtime.h\"")
        self.emit("#include <stdint.h>")
        self.emit("#include <stdbool.h>")
        self.emit("")

        # Process all forms
        for form in ast:
            if is_form(form, 'module'):
                self.transpile_module(form)
            elif is_form(form, 'type'):
                self.transpile_type(form)
            elif is_form(form, 'fn'):
                self.transpile_function(form)

        return '\n'.join(self.output)

    def _collect_ffi(self, form: SList):
        """Collect FFI declarations from module"""
        for item in form.items[2:]:
            if is_form(item, 'ffi'):
                self._register_ffi(item)
            elif is_form(item, 'ffi-struct'):
                self._register_ffi_struct(item)

    def _register_ffi(self, form: SList):
        """Register FFI function declarations: (ffi "header.h" (func ...) ...)"""
        if len(form) < 2:
            return

        header = form[1].value if isinstance(form[1], String) else None
        if header and header not in self.ffi_includes:
            self.ffi_includes.append(header)

        # Register each declared function
        for decl in form.items[2:]:
            if isinstance(decl, SList) and len(decl) >= 2:
                func_name = decl[0].name
                params = decl[1] if len(decl) > 1 else SList([])
                return_type = decl[2] if len(decl) > 2 else Symbol('Void')
                self.ffi_funcs[func_name] = {
                    'c_name': func_name.replace('-', '_'),
                    'params': params,
                    'return_type': return_type
                }

    def _register_ffi_struct(self, form: SList, inline: bool = False):
        """Register FFI struct: (ffi-struct "header.h" name (field type) ...)"""
        if len(form) < 2:
            return

        # Determine if first arg is header or name
        if isinstance(form[1], String):
            header = form[1].value
            name = form[2].name if len(form) > 2 else None
            fields_start = 3
        else:
            header = None
            name = form[1].name
            fields_start = 2

        if header and header not in self.ffi_includes:
            self.ffi_includes.append(header)

        if name:
            fields = []
            self.ffi_struct_fields[name] = {}

            for f in form.items[fields_start:]:
                if isinstance(f, SList) and len(f) >= 2:
                    field_name = f[0].name
                    field_type = f[1]
                    fields.append((field_name, field_type))

                    # Build field type info for nested access
                    if isinstance(field_type, SList) and len(field_type) >= 1:
                        type_head = field_type[0].name if isinstance(field_type[0], Symbol) else None
                        if type_head == 'ffi-struct':
                            # Inline nested struct - register recursively
                            nested_name = field_type[1].name
                            self._register_ffi_struct(field_type, inline=True)
                            self.ffi_struct_fields[name][field_name] = {
                                'type': nested_name,
                                'is_pointer': False,
                                'is_struct': True
                            }
                        elif type_head == 'Ptr':
                            # Pointer field
                            inner = field_type[1].name if len(field_type) > 1 and isinstance(field_type[1], Symbol) else 'void'
                            self.ffi_struct_fields[name][field_name] = {
                                'type': inner,
                                'is_pointer': True,
                                'is_struct': False  # Will update later if needed
                            }
                        else:
                            # Other complex type (Array, etc)
                            self.ffi_struct_fields[name][field_name] = {
                                'type': str(field_type),
                                'is_pointer': False,
                                'is_struct': False
                            }
                    elif isinstance(field_type, Symbol):
                        # Simple type (U16, U32, etc)
                        self.ffi_struct_fields[name][field_name] = {
                            'type': field_type.name,
                            'is_pointer': False,
                            'is_struct': field_type.name in self.ffi_structs
                        }

            self.ffi_structs[name] = {
                'c_name': f"struct {name}",
                'fields': fields
            }
            # Register as known type
            self.types[name] = TypeInfo(name, f"struct {name}")

    def transpile_module(self, form: SList):
        """Transpile module definition"""
        module_name = form[1].name if len(form) > 1 else "main"
        self.emit(f"/* Module: {module_name} */")
        self.emit("")

        # Collect types and functions
        types = []
        functions = []
        for item in form.items[2:]:
            if is_form(item, 'export'):
                continue  # Skip exports, handled at link time
            elif is_form(item, 'ffi') or is_form(item, 'ffi-struct'):
                continue  # Already processed in first pass
            elif is_form(item, 'type'):
                types.append(item)
            elif is_form(item, 'fn'):
                functions.append(item)

        # First pass: emit types
        for t in types:
            self.transpile_type(t)

        # Second pass: emit forward declarations for functions
        if functions:
            self.emit("/* Forward declarations */")
            for fn in functions:
                self.emit_forward_declaration(fn)
            self.emit("")

        # Third pass: emit function bodies
        for fn in functions:
            self.transpile_function(fn)

    def emit_forward_declaration(self, form: SList):
        """Emit function forward declaration"""
        name = self.to_c_name(form[1].name)
        params = form[2] if len(form) > 2 else SList([])
        return_type = self._get_return_type(form)

        param_strs = []
        for p in params:
            if isinstance(p, SList) and len(p) >= 2:
                pname = self.to_c_name(p[0].name)
                ptype = self.to_c_type(p[1])
                param_strs.append(f"{ptype} {pname}")

        self.emit(f"{return_type} {name}({', '.join(param_strs) or 'void'});")

    def _get_return_type(self, form: SList) -> str:
        """Extract return type from function form"""
        for item in form.items[3:]:
            if is_form(item, '@spec'):
                spec = item[1] if len(item) > 1 else None
                if spec and isinstance(spec, SList) and len(spec) >= 3:
                    return self.to_c_type(spec[-1])
        return 'void'

    def transpile_type(self, form: SList):
        """Transpile type definition"""
        name = form[1].name
        type_expr = form[2]

        if is_form(type_expr, 'record'):
            self.transpile_record(name, type_expr)
        elif is_form(type_expr, 'enum'):
            self.transpile_enum(name, type_expr)
        elif is_form(type_expr, 'union'):
            self.transpile_union(name, type_expr)
        else:
            # Range type or alias
            self.transpile_range_type(name, type_expr)

    def transpile_record(self, name: str, form: SList):
        """Transpile record to C struct"""
        self.emit(f"typedef struct {{")
        self.indent += 1

        for field in form.items[1:]:
            if isinstance(field, SList) and len(field) >= 2:
                field_name = self.to_c_name(field[0].name)
                field_type = self.to_c_type(field[1])
                self.emit(f"{field_type} {field_name};")

        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")

        self.types[name] = TypeInfo(name, name)

    def transpile_enum(self, name: str, form: SList):
        """Transpile enum"""
        self.emit(f"typedef enum {{")
        self.indent += 1

        for i, val in enumerate(form.items[1:]):
            val_c_name = self.to_c_name(val.name)
            qualified_name = f"{name}_{val_c_name}"
            comma = "," if i < len(form.items) - 2 else ""
            self.emit(f"{qualified_name}{comma}")
            # Store enum value for lookup
            self.enums[val.name] = qualified_name
            self.enums[val_c_name] = qualified_name

        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")

        self.types[name] = TypeInfo(name, name)

    def transpile_union(self, name: str, form: SList):
        """Transpile tagged union"""
        self.emit(f"typedef struct {{")
        self.indent += 1
        self.emit("uint8_t tag;")
        self.emit("union {")
        self.indent += 1

        for i, variant in enumerate(form.items[1:]):
            if isinstance(variant, SList) and len(variant) >= 1:
                tag = variant[0].name
                if len(variant) >= 2:
                    var_type = self.to_c_type(variant[1])
                    self.emit(f"{var_type} {tag};")
                # else: empty variant, no field needed

        self.indent -= 1
        self.emit("} data;")
        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")

        # Generate tag constants
        for i, variant in enumerate(form.items[1:]):
            if isinstance(variant, SList):
                tag = variant[0].name
                self.emit(f"#define {name}_{tag}_TAG {i}")
        self.emit("")

        self.types[name] = TypeInfo(name, name)

    def transpile_range_type(self, name: str, type_expr: SExpr):
        """Transpile range type to typedef + constructor"""
        min_val, max_val = None, None
        base_type = 'int64_t'

        if isinstance(type_expr, SList):
            # Parse (Int min .. max) or similar
            if len(type_expr) >= 1:
                base = type_expr[0].name
                base_type = self.builtin_types.get(base, 'int64_t')

            # Find range bounds
            for i, item in enumerate(type_expr.items[1:]):
                if isinstance(item, Number):
                    if min_val is None:
                        min_val = int(item.value)
                    else:
                        max_val = int(item.value)
                elif isinstance(item, Symbol) and item.name == '..':
                    continue
        elif isinstance(type_expr, Symbol):
            # Simple alias
            base_type = self.builtin_types.get(type_expr.name, type_expr.name)

        # Choose smallest C type that fits
        if min_val is not None and max_val is not None:
            if min_val >= 0 and max_val <= 255:
                base_type = 'uint8_t'
            elif min_val >= 0 and max_val <= 65535:
                base_type = 'uint16_t'
            elif min_val >= -128 and max_val <= 127:
                base_type = 'int8_t'
            elif min_val >= -32768 and max_val <= 32767:
                base_type = 'int16_t'

        # Emit typedef (simple typedef, not wrapped struct)
        self.emit(f"typedef {base_type} {name};")
        self.emit("")

        # Emit constructor with range check
        self.emit(f"static inline {name} {name}_new(int64_t v) {{")
        self.indent += 1

        if min_val is not None and max_val is not None:
            self.emit(f'SLOP_PRE(v >= {min_val} && v <= {max_val}, "{name} in range {min_val}..{max_val}");')
        elif min_val is not None:
            self.emit(f'SLOP_PRE(v >= {min_val}, "{name} >= {min_val}");')
        elif max_val is not None:
            self.emit(f'SLOP_PRE(v <= {max_val}, "{name} <= {max_val}");')

        self.emit(f"return ({name})v;")
        self.indent -= 1
        self.emit("}")
        self.emit("")

        self.types[name] = TypeInfo(name, name, True, min_val, max_val)

    def transpile_function(self, form: SList):
        """Transpile function definition"""
        name = self.to_c_name(form[1].name)
        params = form[2] if len(form) > 2 else SList([])

        # Extract annotations and body
        annotations = {}
        body_exprs = []

        for item in form.items[3:]:
            if is_form(item, '@intent'):
                annotations['intent'] = item[1].value if len(item) > 1 else ""
            elif is_form(item, '@spec'):
                annotations['spec'] = item[1] if len(item) > 1 else None
            elif is_form(item, '@pre'):
                annotations.setdefault('pre', []).append(item[1] if len(item) > 1 else None)
            elif is_form(item, '@post'):
                annotations.setdefault('post', []).append(item[1] if len(item) > 1 else None)
            elif is_form(item, '@alloc'):
                annotations['alloc'] = item[1].name if len(item) > 1 else None
            else:
                body_exprs.append(item)

        # Determine return type from @spec
        return_type = 'void'
        if 'spec' in annotations and annotations['spec']:
            spec = annotations['spec']
            # spec is ((ParamTypes) -> ReturnType)
            if isinstance(spec, SList) and len(spec) >= 3:
                return_type = self.to_c_type(spec[-1])

        # Emit function comment
        if 'intent' in annotations:
            self.emit(f"/* {annotations['intent']} */")

        # Emit function signature
        param_strs = []
        for p in params:
            if isinstance(p, SList) and len(p) >= 2:
                pname = self.to_c_name(p[0].name)
                ptype = self.to_c_type(p[1])
                param_strs.append(f"{ptype} {pname}")

        self.emit(f"{return_type} {name}({', '.join(param_strs) or 'void'}) {{")
        self.indent += 1

        # Emit preconditions
        for pre in annotations.get('pre', []):
            if pre:
                cond = self.transpile_expr(pre)
                self.emit(f'SLOP_PRE({cond}, "{self.expr_to_str(pre)}");')

        # Emit body
        if body_exprs:
            # If multiple expressions, wrap in block
            for i, expr in enumerate(body_exprs):
                is_last = (i == len(body_exprs) - 1)
                self.transpile_statement(expr, is_last and return_type != 'void')

        self.indent -= 1
        self.emit("}")
        self.emit("")

    def transpile_statement(self, expr: SExpr, is_return: bool = False):
        """Transpile a statement"""
        if is_form(expr, 'let'):
            self.transpile_let(expr, is_return)
        elif is_form(expr, 'let*'):
            self.transpile_let(expr, is_return)  # Same as let in C
        elif is_form(expr, 'if'):
            self.transpile_if(expr, is_return)
        elif is_form(expr, 'when'):
            self.transpile_when(expr)
        elif is_form(expr, 'set!'):
            self.transpile_set(expr)
        elif is_form(expr, 'do'):
            for item in expr.items[1:]:
                is_last = (item == expr.items[-1])
                self.transpile_statement(item, is_return and is_last)
        elif is_form(expr, 'while'):
            self.transpile_while(expr)
        elif is_form(expr, 'for'):
            self.transpile_for(expr)
        elif is_form(expr, 'for-each'):
            self.transpile_for_each(expr)
        elif is_form(expr, 'match'):
            self.transpile_match(expr, is_return)
        elif is_form(expr, 'cond'):
            self.transpile_cond(expr, is_return)
        elif is_form(expr, 'return'):
            val = self.transpile_expr(expr[1]) if len(expr) > 1 else ""
            self.emit(f"return {val};" if val else "return;")
        elif is_form(expr, 'break'):
            self.emit("break;")
        elif is_form(expr, 'continue'):
            self.emit("continue;")
        elif is_form(expr, 'try'):
            self.transpile_try(expr, is_return)
        elif is_form(expr, 'with-arena'):
            self.transpile_with_arena(expr, is_return)
        else:
            code = self.transpile_expr(expr)
            if is_return:
                self.emit(f"return {code};")
            else:
                self.emit(f"{code};")

    def transpile_let(self, expr: SList, is_return: bool):
        """Transpile let binding"""
        bindings = expr[1]
        body = expr.items[2:]

        # Emit bindings
        for binding in bindings:
            var_name = self.to_c_name(binding[0].name)
            var_expr = self.transpile_expr(binding[1])
            # Type inference would go here; for now use auto
            self.emit(f"__auto_type {var_name} = {var_expr};")

        # Emit body
        for i, item in enumerate(body):
            is_last = (i == len(body) - 1)
            self.transpile_statement(item, is_return and is_last)

    def transpile_if(self, expr: SList, is_return: bool):
        """Transpile if expression"""
        cond = self.transpile_expr(expr[1])
        then_branch = expr[2]
        else_branch = expr[3] if len(expr) > 3 else None

        # Check if branches are simple expressions (can use ternary)
        def is_simple(e):
            if isinstance(e, (Number, String, Symbol)):
                return True
            if isinstance(e, SList) and len(e) > 0:
                head = e[0]
                if isinstance(head, Symbol):
                    # These are complex statements, not expressions
                    if head.name in ('do', 'let', 'let*', 'if', 'when', 'while',
                                     'for', 'for-each', 'match', 'cond', 'set!'):
                        return False
                return True
            return False

        if is_return and is_simple(then_branch) and (else_branch is None or is_simple(else_branch)):
            # Use ternary for simple returns
            then_expr = self.transpile_expr(then_branch)
            else_expr = self.transpile_expr(else_branch) if else_branch else "0"
            self.emit(f"return ({cond}) ? {then_expr} : {else_expr};")
        else:
            self.emit(f"if ({cond}) {{")
            self.indent += 1
            self.transpile_statement(then_branch, is_return)
            self.indent -= 1
            if else_branch:
                self.emit("} else {")
                self.indent += 1
                self.transpile_statement(else_branch, is_return)
                self.indent -= 1
            self.emit("}")

    def transpile_when(self, expr: SList):
        """Transpile when (if without else)"""
        cond = self.transpile_expr(expr[1])
        self.emit(f"if ({cond}) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_set(self, expr: SList):
        """Transpile set! mutation

        Forms:
        - (set! target field value) - field mutation: target->field = value
        - (set! var value) - simple assignment: *var = value or var = value
        """
        if len(expr) == 4:
            # (set! target field value) - field access
            target = expr[1]
            field = expr[2].name
            value = self.transpile_expr(expr[3])
            target_code = self.transpile_expr(target)
            self.emit(f"{target_code}->{self.to_c_name(field)} = {value};")
        elif len(expr) == 3:
            # (set! var value) - simple assignment
            target = expr[1]
            value = self.transpile_expr(expr[2])

            # Check if target is a symbol with dot notation (e.g., addr.sin_addr.s_addr)
            if isinstance(target, Symbol) and '.' in target.name:
                parts = target.name.split('.')
                resolved = self._resolve_field_chain(parts)
                self.emit(f"{resolved} = {value};")
            else:
                target_code = self.transpile_expr(target)
                # Dereference if it's a pointer variable
                self.emit(f"*{target_code} = {value};")

    def transpile_while(self, expr: SList):
        """Transpile while loop"""
        cond = self.transpile_expr(expr[1])
        self.emit(f"while ({cond}) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_for(self, expr: SList):
        """Transpile for loop: (for (i start end) body)"""
        binding = expr[1]
        var_name = self.to_c_name(binding[0].name)
        start = self.transpile_expr(binding[1])
        end = self.transpile_expr(binding[2])
        self.emit(f"for (int64_t {var_name} = {start}; {var_name} < {end}; {var_name}++) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_for_each(self, expr: SList):
        """Transpile for-each loop: (for-each (item collection) body)"""
        binding = expr[1]
        var_name = self.to_c_name(binding[0].name)
        collection = self.transpile_expr(binding[1])
        self.emit(f"for (size_t _i = 0; _i < {collection}.len; _i++) {{")
        self.indent += 1
        self.emit(f"__auto_type {var_name} = {collection}.data[_i];")
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_match(self, expr: SList, is_return: bool):
        """Transpile match expression"""
        scrutinee = self.transpile_expr(expr[1])
        self.emit(f"switch ({scrutinee}.tag) {{")
        self.indent += 1

        for i, clause in enumerate(expr.items[2:]):
            if isinstance(clause, SList) and len(clause) >= 2:
                pattern = clause[0]
                body = clause.items[1:]

                if isinstance(pattern, SList) and len(pattern) >= 1:
                    tag = pattern[0].name
                    var_name = self.to_c_name(pattern[1].name) if len(pattern) > 1 else None

                    self.emit(f"case {i}: {{")
                    self.indent += 1
                    if var_name:
                        self.emit(f"__auto_type {var_name} = {scrutinee}.data.{tag};")
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    if not is_return:
                        self.emit("break;")
                    self.indent -= 1
                    self.emit("}")
                elif isinstance(pattern, Symbol) and pattern.name == '_':
                    # Wildcard/default case
                    self.emit("default: {")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    if not is_return:
                        self.emit("break;")
                    self.indent -= 1
                    self.emit("}")

        self.indent -= 1
        self.emit("}")

    def transpile_cond(self, expr: SList, is_return: bool):
        """Transpile cond expression"""
        first = True
        for clause in expr.items[1:]:
            if isinstance(clause, SList) and len(clause) >= 2:
                test = clause[0]
                body = clause.items[1:]

                if isinstance(test, Symbol) and test.name == 'else':
                    self.emit("} else {")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    self.indent -= 1
                else:
                    cond = self.transpile_expr(test)
                    if first:
                        self.emit(f"if ({cond}) {{")
                        first = False
                    else:
                        self.emit(f"}} else if ({cond}) {{")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    self.indent -= 1
        self.emit("}")

    def transpile_try(self, expr: SList, is_return: bool):
        """Transpile try/catch: (try expr (catch pattern body))"""
        try_expr = self.transpile_expr(expr[1])
        self.emit("{")
        self.indent += 1
        self.emit(f"__auto_type _result = {try_expr};")
        self.emit("if (_result.tag != 0) {")
        self.indent += 1

        # Handle catch clause
        if len(expr) > 2 and is_form(expr[2], 'catch'):
            catch_clause = expr[2]
            pattern = catch_clause[1] if len(catch_clause) > 1 else None
            catch_body = catch_clause.items[2:]

            if pattern and isinstance(pattern, Symbol):
                var_name = self.to_c_name(pattern.name)
                self.emit(f"__auto_type {var_name} = _result.data.err;")

            for j, item in enumerate(catch_body):
                is_last = (j == len(catch_body) - 1)
                self.transpile_statement(item, is_return and is_last)

        self.indent -= 1
        self.emit("}")
        self.indent -= 1
        self.emit("}")

    def transpile_with_arena(self, expr: SList, is_return: bool):
        """Transpile with-arena: (with-arena size body)"""
        size = self.transpile_expr(expr[1])
        self.emit("{")
        self.indent += 1
        self.emit(f"slop_arena _arena = slop_arena_new({size});")
        self.emit(f"slop_arena* arena = &_arena;")

        for j, item in enumerate(expr.items[2:]):
            is_last = (j == len(expr.items) - 3)
            self.transpile_statement(item, is_return and is_last)

        self.emit("slop_arena_free(arena);")
        self.indent -= 1
        self.emit("}")

    def transpile_expr(self, expr: SExpr) -> str:
        """Transpile expression to C"""
        if isinstance(expr, Number):
            return str(expr.value)

        if isinstance(expr, String):
            # Escape the string for C output
            escaped = expr.value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
            return f'SLOP_STR("{escaped}")'

        if isinstance(expr, Symbol):
            name = expr.name
            if name == 'nil':
                return 'NULL'
            if name == 'true':
                return '1'
            if name == 'false':
                return '0'
            if name.startswith("'"):
                # Enum value - look up qualified name
                enum_val = name[1:]
                if enum_val in self.enums:
                    return self.enums[enum_val]
                return self.to_c_name(enum_val)
            # Check if it's an enum value without quote
            if name in self.enums:
                return self.enums[name]
            # Handle dot notation for field access (e.g., resp.data, addr.sin_addr.s_addr)
            if '.' in name:
                parts = name.split('.')
                return self._resolve_field_chain(parts)
            return self.to_c_name(name)

        if isinstance(expr, SList):
            if len(expr) == 0:
                return "NULL"

            head = expr[0]
            if isinstance(head, Symbol):
                op = head.name

                # Arithmetic/comparison operators
                if op in ['+', '-', '*', '/', '%', '&', '|', '^', '<<', '>>']:
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} {op} {b})"

                if op == '==':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} == {b})"

                if op == '!=':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} != {b})"

                if op in ['<', '<=', '>', '>=']:
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} {op} {b})"

                if op == 'and':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} && {b})"

                if op == 'or':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} || {b})"

                if op == 'not':
                    a = self.transpile_expr(expr[1])
                    return f"(!{a})"

                # If as expression (ternary)
                if op == 'if':
                    cond = self.transpile_expr(expr[1])
                    then_expr = self.transpile_expr(expr[2])
                    else_expr = self.transpile_expr(expr[3]) if len(expr) > 3 else "0"
                    return f"(({cond}) ? ({then_expr}) : ({else_expr}))"

                # Field access (value type with .)
                if op == '.':
                    obj = self.transpile_expr(expr[1])
                    field = self.to_c_name(expr[2].name)
                    return f"({obj}).{field}"

                # Index access
                if op == '@':
                    arr = self.transpile_expr(expr[1])
                    idx = self.transpile_expr(expr[2])
                    return f"{arr}[{idx}]"

                # Built-in functions
                if op == 'arena-alloc':
                    arena = self.transpile_expr(expr[1])
                    size_expr = expr[2]
                    # Extract type from sizeof(Type) to cast the result
                    if is_form(size_expr, 'sizeof'):
                        type_name = size_expr[1].name
                        # Map to C type
                        c_type = self.builtin_types.get(type_name, type_name)
                        if type_name in self.ffi_structs:
                            c_type = self.ffi_structs[type_name]['c_name']
                        return f"({c_type}*)slop_arena_alloc({arena}, sizeof({c_type}))"
                    else:
                        size = self.transpile_expr(size_expr)
                        return f"slop_arena_alloc({arena}, {size})"

                if op == 'sizeof':
                    type_name = expr[1].name
                    # Map SLOP types to C types for sizeof
                    c_type = self.builtin_types.get(type_name, type_name)
                    # Handle FFI structs
                    if type_name in self.ffi_structs:
                        c_type = self.ffi_structs[type_name]['c_name']
                    return f"sizeof({c_type})"

                if op == 'now-ms':
                    return "slop_now_ms()"

                if op == 'min':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"(({a}) < ({b}) ? ({a}) : ({b}))"

                if op == 'max':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"(({a}) > ({b}) ? ({a}) : ({b}))"

                # Error handling
                if op == 'ok':
                    val = self.transpile_expr(expr[1])
                    return f"((typeof(_result)){{ .tag = 0, .data.ok = {val} }})"

                if op == 'error':
                    val = self.transpile_expr(expr[1])
                    return f"((typeof(_result)){{ .tag = 1, .data.err = {val} }})"

                if op == '?':
                    # Early return on error
                    val = self.transpile_expr(expr[1])
                    return f"({{ __auto_type _tmp = {val}; if (_tmp.tag != 0) return _tmp; _tmp.data.ok; }})"

                if op == 'is-ok':
                    val = self.transpile_expr(expr[1])
                    return f"({val}.tag == 0)"

                if op == 'unwrap':
                    val = self.transpile_expr(expr[1])
                    return f"({val}.data.ok)"

                # Memory management
                if op == 'arena-new':
                    size = self.transpile_expr(expr[1])
                    return f"slop_arena_new({size})"

                if op == 'arena-free':
                    arena = self.transpile_expr(expr[1])
                    return f"slop_arena_free({arena})"

                # I/O
                if op == 'println':
                    arg = self.transpile_expr(expr[1])
                    return f'printf("%s\\n", ({arg}).data)'

                if op == 'print':
                    arg = self.transpile_expr(expr[1])
                    return f'printf("%s", ({arg}).data)'

                # Data construction
                if op == 'list':
                    elements = [self.transpile_expr(e) for e in expr.items[1:]]
                    n = len(elements)
                    if n == 0:
                        return "(slop_list){ .data = NULL, .len = 0, .cap = 0 }"
                    elems_str = ", ".join(elements)
                    return f"(slop_list){{ .data = (void*[]){{{elems_str}}}, .len = {n}, .cap = {n} }}"

                if op == 'array':
                    elements = [self.transpile_expr(e) for e in expr.items[1:]]
                    elems_str = ", ".join(elements)
                    return f"{{{elems_str}}}"

                if op == 'put':
                    # Functional update: (put expr field value)
                    obj = self.transpile_expr(expr[1])
                    field = self.to_c_name(expr[2].name)
                    value = self.transpile_expr(expr[3])
                    return f"({{ __auto_type _tmp = {obj}; _tmp.{field} = {value}; _tmp; }})"

                # Quote (enum value)
                if op == 'quote':
                    inner = expr[1]
                    if isinstance(inner, Symbol):
                        if inner.name in self.enums:
                            return self.enums[inner.name]
                        return self.to_c_name(inner.name)
                    return self.transpile_expr(inner)

                # C inline escape hatch
                if op == 'c-inline':
                    return expr[1].value

                # Type cast
                if op == 'cast':
                    target_type = self.to_c_type(expr[1])
                    value = self.transpile_expr(expr[2])
                    return f"(({target_type})({value}))"

                # Sizeof
                if op == 'sizeof':
                    type_name = expr[1]
                    if isinstance(type_name, Symbol) and type_name.name in self.ffi_structs:
                        # FFI struct - use the C name which includes "struct " prefix
                        c_type = self.ffi_structs[type_name.name]['c_name']
                    else:
                        # Regular SLOP type
                        c_type = self.to_c_type(type_name)
                    return f"sizeof({c_type})"

                # FFI function call
                if op in self.ffi_funcs:
                    ffi = self.ffi_funcs[op]
                    params = ffi['params']
                    raw_args = expr.items[1:]
                    args = []

                    for i, arg in enumerate(raw_args):
                        # Get expected parameter type if available
                        param_type = None
                        if isinstance(params, SList) and i < len(params):
                            param_spec = params[i]
                            if isinstance(param_spec, SList) and len(param_spec) >= 2:
                                param_type = param_spec[1]  # Type is second element

                        # Check if param expects a C string (pointer type)
                        expects_c_string = self._is_c_string_param(param_type)

                        if expects_c_string and isinstance(arg, String):
                            # String literal → bare C string
                            escaped = arg.value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
                            args.append(f'"{escaped}"')
                        else:
                            # Non-string or non-C-string param → transpile normally
                            args.append(self.transpile_expr(arg))

                    return f"{ffi['c_name']}({', '.join(args)})"

                # Function call
                fn_name = self.to_c_name(op)
                args = [self.transpile_expr(a) for a in expr.items[1:]]
                return f"{fn_name}({', '.join(args)})"

        return "/* unknown */"

    def _is_c_string_param(self, param_type) -> bool:
        """Check if parameter type expects a C string (pointer to bytes)"""
        if param_type is None:
            return False
        if isinstance(param_type, SList) and len(param_type) >= 2:
            if param_type[0].name == 'Ptr':
                inner = param_type[1]
                if isinstance(inner, Symbol):
                    # Ptr to U8, I8, Void all accept C strings
                    return inner.name in ('U8', 'I8', 'Void')
        return False

    def _resolve_field_chain(self, parts: list, base_is_pointer: bool = True) -> str:
        """Resolve a.b.c to correct C syntax like a->b.c

        For nested struct access:
        - First access from pointer uses ->
        - Subsequent accesses into embedded struct fields use .
        - If a field is itself a pointer, use -> again
        """
        if len(parts) == 1:
            return self.to_c_name(parts[0])

        result = self.to_c_name(parts[0])
        current_struct = None  # We don't know the base var's struct type

        for i, field in enumerate(parts[1:]):
            c_field = self.to_c_name(field)

            if i == 0:
                # First field access - base is assumed to be a pointer
                op = '->' if base_is_pointer else '.'
                # Try to find struct type from field registries
                for struct_name, fields in self.ffi_struct_fields.items():
                    if field in fields:
                        current_struct = struct_name
                        field_info = fields[field]
                        if field_info['is_struct']:
                            current_struct = field_info['type']
                        break
            else:
                # Subsequent accesses - check if previous field was a pointer
                if current_struct and current_struct in self.ffi_struct_fields:
                    field_info = self.ffi_struct_fields[current_struct].get(field)
                    if field_info:
                        if field_info['is_pointer']:
                            op = '->'
                        else:
                            op = '.'
                        # Update current_struct for next iteration
                        if field_info['is_struct']:
                            current_struct = field_info['type']
                        else:
                            current_struct = None
                    else:
                        op = '.'  # Default for unknown fields
                else:
                    op = '.'  # Default: embedded struct fields use .

            result += f"{op}{c_field}"

        return result

    def to_c_type(self, type_expr: SExpr) -> str:
        """Convert SLOP type to C type"""
        if isinstance(type_expr, Symbol):
            name = type_expr.name
            if name in self.builtin_types:
                return self.builtin_types[name]
            if name in self.types:
                return self.types[name].c_type
            if name in self.ffi_structs:
                return self.ffi_structs[name]['c_name']
            return name

        if isinstance(type_expr, SList) and len(type_expr) >= 1:
            head = type_expr[0].name

            if head == 'Ptr':
                inner = self.to_c_type(type_expr[1])
                return f"{inner}*"

            if head == 'Option':
                inner = self.to_c_type(type_expr[1])
                return f"slop_option_{inner}"

            if head == 'Result':
                ok_type = self.to_c_type(type_expr[1])
                err_type = self.to_c_type(type_expr[2]) if len(type_expr) > 2 else 'slop_error'
                return f"slop_result_{ok_type}_{err_type}"

            if head == 'List':
                inner = self.to_c_type(type_expr[1])
                return f"slop_list_{inner}"

            if head in self.builtin_types:
                return self.builtin_types[head]

            # Range type reference
            if head in self.types:
                return self.types[head].c_type

        return "void*"

    def to_c_name(self, name: str) -> str:
        """Convert SLOP identifier to valid C name"""
        return name.replace('-', '_').replace('?', '_p').replace('!', '_x')

    def expr_to_str(self, expr: SExpr) -> str:
        """Convert expression to string for error messages"""
        return str(expr).replace('"', '\\"')


def transpile(source: str) -> str:
    """Transpile SLOP source to C"""
    ast = parse(source)
    return Transpiler().transpile(ast)


def transpile_file(input_path: str, output_path: str = None):
    """Transpile SLOP file to C file"""
    with open(input_path) as f:
        source = f.read()

    c_code = transpile(source)

    if output_path:
        with open(output_path, 'w') as f:
            f.write(c_code)
    else:
        print(c_code)


if __name__ == '__main__':
    import sys
    if len(sys.argv) > 1:
        transpile_file(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else None)
    else:
        # Test
        test = '''
        (type Age (Int 0 .. 150))
        (type User (record (name String) (age Age)))
        (type Status (enum active inactive))

        (fn greet ((name String))
          (@intent "Say hello")
          (@spec ((String) -> String))
          (@pre (!= name nil))
          (concat "Hello, " name))
        '''
        print(transpile(test))
