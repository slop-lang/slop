"""
SLOP Transpiler - Generate C code from SLOP AST

Handles:
- Type definitions → C structs/typedefs
- Functions → C functions
- Range types → runtime checks
- Contracts → SLOP_PRE/SLOP_POST macros
"""

from dataclasses import dataclass
from typing import List, Dict, Optional, Set
from parser import SExpr, SList, Symbol, String, Number, is_form, parse


@dataclass
class TypeInfo:
    """Information about a SLOP type"""
    name: str
    c_type: str
    is_range: bool = False
    min_val: Optional[int] = None
    max_val: Optional[int] = None


class Transpiler:
    """Transpile SLOP to C"""
    
    def __init__(self):
        self.types: Dict[str, TypeInfo] = {}
        self.enums: Dict[str, str] = {}  # value -> qualified name
        self.output: List[str] = []
        self.indent = 0

        # Built-in type mappings
        self.builtin_types = {
            'Int': 'int64_t',
            'I8': 'int8_t',
            'I16': 'int16_t', 
            'I32': 'int32_t',
            'I64': 'int64_t',
            'U8': 'uint8_t',
            'U16': 'uint16_t',
            'U32': 'uint32_t',
            'U64': 'uint64_t',
            'Float': 'double',
            'F32': 'float',
            'Bool': 'uint8_t',
            'String': 'slop_string',
            'Bytes': 'slop_bytes',
            'Unit': 'void',
            'Arena': 'slop_arena*',
            'Milliseconds': 'int64_t',
        }
    
    def emit(self, line: str = ""):
        """Emit a line of C code"""
        if line:
            self.output.append("    " * self.indent + line)
        else:
            self.output.append("")
    
    def transpile(self, ast: List[SExpr]) -> str:
        """Transpile SLOP AST to C code"""
        self.output = []
        
        # Header
        self.emit("/* Generated by SLOP transpiler */")
        self.emit("#include \"slop_runtime.h\"")
        self.emit("#include <stdint.h>")
        self.emit("#include <stdbool.h>")
        self.emit("")
        
        # Process all forms
        for form in ast:
            if is_form(form, 'module'):
                self.transpile_module(form)
            elif is_form(form, 'type'):
                self.transpile_type(form)
            elif is_form(form, 'fn'):
                self.transpile_function(form)
        
        return '\n'.join(self.output)
    
    def transpile_module(self, form: SList):
        """Transpile module definition"""
        module_name = form[1].name if len(form) > 1 else "main"
        self.emit(f"/* Module: {module_name} */")
        self.emit("")
        
        # Process module contents
        for item in form.items[2:]:
            if is_form(item, 'export'):
                continue  # Skip exports, handled at link time
            elif is_form(item, 'type'):
                self.transpile_type(item)
            elif is_form(item, 'fn'):
                self.transpile_function(item)
    
    def transpile_type(self, form: SList):
        """Transpile type definition"""
        name = form[1].name
        type_expr = form[2]
        
        if is_form(type_expr, 'record'):
            self.transpile_record(name, type_expr)
        elif is_form(type_expr, 'enum'):
            self.transpile_enum(name, type_expr)
        elif is_form(type_expr, 'union'):
            self.transpile_union(name, type_expr)
        else:
            # Range type or alias
            self.transpile_range_type(name, type_expr)
    
    def transpile_record(self, name: str, form: SList):
        """Transpile record to C struct"""
        self.emit(f"typedef struct {{")
        self.indent += 1
        
        for field in form.items[1:]:
            if isinstance(field, SList) and len(field) >= 2:
                field_name = self.to_c_name(field[0].name)
                field_type = self.to_c_type(field[1])
                self.emit(f"{field_type} {field_name};")
        
        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")
        
        self.types[name] = TypeInfo(name, name)
    
    def transpile_enum(self, name: str, form: SList):
        """Transpile enum"""
        self.emit(f"typedef enum {{")
        self.indent += 1

        for i, val in enumerate(form.items[1:]):
            val_c_name = self.to_c_name(val.name)
            qualified_name = f"{name}_{val_c_name}"
            comma = "," if i < len(form.items) - 2 else ""
            self.emit(f"{qualified_name}{comma}")
            # Store enum value for lookup
            self.enums[val.name] = qualified_name
            self.enums[val_c_name] = qualified_name

        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")

        self.types[name] = TypeInfo(name, name)
    
    def transpile_union(self, name: str, form: SList):
        """Transpile tagged union"""
        self.emit(f"typedef struct {{")
        self.indent += 1
        self.emit("uint8_t tag;")
        self.emit("union {")
        self.indent += 1
        
        for i, variant in enumerate(form.items[1:]):
            if isinstance(variant, SList) and len(variant) >= 1:
                tag = variant[0].name
                if len(variant) >= 2:
                    var_type = self.to_c_type(variant[1])
                    self.emit(f"{var_type} {tag};")
                # else: empty variant, no field needed
        
        self.indent -= 1
        self.emit("} data;")
        self.indent -= 1
        self.emit(f"}} {name};")
        self.emit("")
        
        # Generate tag constants
        for i, variant in enumerate(form.items[1:]):
            if isinstance(variant, SList):
                tag = variant[0].name
                self.emit(f"#define {name}_{tag}_TAG {i}")
        self.emit("")
        
        self.types[name] = TypeInfo(name, name)
    
    def transpile_range_type(self, name: str, type_expr: SExpr):
        """Transpile range type to typedef + constructor"""
        min_val, max_val = None, None
        base_type = 'int64_t'
        
        if isinstance(type_expr, SList):
            # Parse (Int min .. max) or similar
            if len(type_expr) >= 1:
                base = type_expr[0].name
                base_type = self.builtin_types.get(base, 'int64_t')
            
            # Find range bounds
            for i, item in enumerate(type_expr.items[1:]):
                if isinstance(item, Number):
                    if min_val is None:
                        min_val = int(item.value)
                    else:
                        max_val = int(item.value)
                elif isinstance(item, Symbol) and item.name == '..':
                    continue
        elif isinstance(type_expr, Symbol):
            # Simple alias
            base_type = self.builtin_types.get(type_expr.name, type_expr.name)
        
        # Choose smallest C type that fits
        if min_val is not None and max_val is not None:
            if min_val >= 0 and max_val <= 255:
                base_type = 'uint8_t'
            elif min_val >= 0 and max_val <= 65535:
                base_type = 'uint16_t'
            elif min_val >= -128 and max_val <= 127:
                base_type = 'int8_t'
            elif min_val >= -32768 and max_val <= 32767:
                base_type = 'int16_t'
        
        # Emit typedef
        self.emit(f"typedef struct {{ {base_type} value; }} {name};")
        self.emit("")
        
        # Emit constructor with range check
        self.emit(f"static inline {name} {name}_new(int64_t v) {{")
        self.indent += 1
        
        if min_val is not None and max_val is not None:
            self.emit(f'SLOP_PRE(v >= {min_val} && v <= {max_val}, "{name} in range {min_val}..{max_val}");')
        elif min_val is not None:
            self.emit(f'SLOP_PRE(v >= {min_val}, "{name} >= {min_val}");')
        elif max_val is not None:
            self.emit(f'SLOP_PRE(v <= {max_val}, "{name} <= {max_val}");')
        
        self.emit(f"return ({name}){{({base_type})v}};")
        self.indent -= 1
        self.emit("}")
        self.emit("")
        
        self.types[name] = TypeInfo(name, name, True, min_val, max_val)
    
    def transpile_function(self, form: SList):
        """Transpile function definition"""
        name = self.to_c_name(form[1].name)
        params = form[2] if len(form) > 2 else SList([])
        
        # Extract annotations and body
        annotations = {}
        body_exprs = []
        
        for item in form.items[3:]:
            if is_form(item, '@intent'):
                annotations['intent'] = item[1].value if len(item) > 1 else ""
            elif is_form(item, '@spec'):
                annotations['spec'] = item[1] if len(item) > 1 else None
            elif is_form(item, '@pre'):
                annotations.setdefault('pre', []).append(item[1] if len(item) > 1 else None)
            elif is_form(item, '@post'):
                annotations.setdefault('post', []).append(item[1] if len(item) > 1 else None)
            elif is_form(item, '@alloc'):
                annotations['alloc'] = item[1].name if len(item) > 1 else None
            else:
                body_exprs.append(item)
        
        # Determine return type from @spec
        return_type = 'void'
        if 'spec' in annotations and annotations['spec']:
            spec = annotations['spec']
            # spec is ((ParamTypes) -> ReturnType)
            if isinstance(spec, SList) and len(spec) >= 3:
                return_type = self.to_c_type(spec[-1])
        
        # Emit function comment
        if 'intent' in annotations:
            self.emit(f"/* {annotations['intent']} */")
        
        # Emit function signature
        param_strs = []
        for p in params:
            if isinstance(p, SList) and len(p) >= 2:
                pname = self.to_c_name(p[0].name)
                ptype = self.to_c_type(p[1])
                param_strs.append(f"{ptype} {pname}")
        
        self.emit(f"{return_type} {name}({', '.join(param_strs) or 'void'}) {{")
        self.indent += 1
        
        # Emit preconditions
        for pre in annotations.get('pre', []):
            if pre:
                cond = self.transpile_expr(pre)
                self.emit(f'SLOP_PRE({cond}, "{self.expr_to_str(pre)}");')
        
        # Emit body
        if body_exprs:
            # If multiple expressions, wrap in block
            for i, expr in enumerate(body_exprs):
                is_last = (i == len(body_exprs) - 1)
                self.transpile_statement(expr, is_last and return_type != 'void')
        
        self.indent -= 1
        self.emit("}")
        self.emit("")
    
    def transpile_statement(self, expr: SExpr, is_return: bool = False):
        """Transpile a statement"""
        if is_form(expr, 'let'):
            self.transpile_let(expr, is_return)
        elif is_form(expr, 'let*'):
            self.transpile_let(expr, is_return)  # Same as let in C
        elif is_form(expr, 'if'):
            self.transpile_if(expr, is_return)
        elif is_form(expr, 'when'):
            self.transpile_when(expr)
        elif is_form(expr, 'set!'):
            self.transpile_set(expr)
        elif is_form(expr, 'do'):
            for item in expr.items[1:]:
                is_last = (item == expr.items[-1])
                self.transpile_statement(item, is_return and is_last)
        elif is_form(expr, 'while'):
            self.transpile_while(expr)
        elif is_form(expr, 'for'):
            self.transpile_for(expr)
        elif is_form(expr, 'for-each'):
            self.transpile_for_each(expr)
        elif is_form(expr, 'match'):
            self.transpile_match(expr, is_return)
        elif is_form(expr, 'cond'):
            self.transpile_cond(expr, is_return)
        elif is_form(expr, 'return'):
            val = self.transpile_expr(expr[1]) if len(expr) > 1 else ""
            self.emit(f"return {val};" if val else "return;")
        elif is_form(expr, 'break'):
            self.emit("break;")
        elif is_form(expr, 'continue'):
            self.emit("continue;")
        elif is_form(expr, 'try'):
            self.transpile_try(expr, is_return)
        elif is_form(expr, 'with-arena'):
            self.transpile_with_arena(expr, is_return)
        else:
            code = self.transpile_expr(expr)
            if is_return:
                self.emit(f"return {code};")
            else:
                self.emit(f"{code};")
    
    def transpile_let(self, expr: SList, is_return: bool):
        """Transpile let binding"""
        bindings = expr[1]
        body = expr.items[2:]
        
        # Emit bindings
        for binding in bindings:
            var_name = self.to_c_name(binding[0].name)
            var_expr = self.transpile_expr(binding[1])
            # Type inference would go here; for now use auto
            self.emit(f"__auto_type {var_name} = {var_expr};")
        
        # Emit body
        for i, item in enumerate(body):
            is_last = (i == len(body) - 1)
            self.transpile_statement(item, is_return and is_last)
    
    def transpile_if(self, expr: SList, is_return: bool):
        """Transpile if expression"""
        cond = self.transpile_expr(expr[1])
        then_branch = expr[2]
        else_branch = expr[3] if len(expr) > 3 else None

        # Check if branches are simple expressions (can use ternary)
        def is_simple(e):
            if isinstance(e, (Number, String, Symbol)):
                return True
            if isinstance(e, SList) and len(e) > 0:
                head = e[0]
                if isinstance(head, Symbol):
                    # These are complex statements, not expressions
                    if head.name in ('do', 'let', 'let*', 'if', 'when', 'while',
                                     'for', 'for-each', 'match', 'cond', 'set!'):
                        return False
                return True
            return False

        if is_return and is_simple(then_branch) and (else_branch is None or is_simple(else_branch)):
            # Use ternary for simple returns
            then_expr = self.transpile_expr(then_branch)
            else_expr = self.transpile_expr(else_branch) if else_branch else "0"
            self.emit(f"return ({cond}) ? {then_expr} : {else_expr};")
        else:
            self.emit(f"if ({cond}) {{")
            self.indent += 1
            self.transpile_statement(then_branch, is_return)
            self.indent -= 1
            if else_branch:
                self.emit("} else {")
                self.indent += 1
                self.transpile_statement(else_branch, is_return)
                self.indent -= 1
            self.emit("}")
    
    def transpile_when(self, expr: SList):
        """Transpile when (if without else)"""
        cond = self.transpile_expr(expr[1])
        self.emit(f"if ({cond}) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")
    
    def transpile_set(self, expr: SList):
        """Transpile set! mutation"""
        target = expr[1]
        field = expr[2].name
        value = self.transpile_expr(expr[3])
        target_code = self.transpile_expr(target)
        self.emit(f"{target_code}->{self.to_c_name(field)} = {value};")

    def transpile_while(self, expr: SList):
        """Transpile while loop"""
        cond = self.transpile_expr(expr[1])
        self.emit(f"while ({cond}) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_for(self, expr: SList):
        """Transpile for loop: (for (i start end) body)"""
        binding = expr[1]
        var_name = self.to_c_name(binding[0].name)
        start = self.transpile_expr(binding[1])
        end = self.transpile_expr(binding[2])
        self.emit(f"for (int64_t {var_name} = {start}; {var_name} < {end}; {var_name}++) {{")
        self.indent += 1
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_for_each(self, expr: SList):
        """Transpile for-each loop: (for-each (item collection) body)"""
        binding = expr[1]
        var_name = self.to_c_name(binding[0].name)
        collection = self.transpile_expr(binding[1])
        self.emit(f"for (size_t _i = 0; _i < {collection}.len; _i++) {{")
        self.indent += 1
        self.emit(f"__auto_type {var_name} = {collection}.data[_i];")
        for item in expr.items[2:]:
            self.transpile_statement(item, False)
        self.indent -= 1
        self.emit("}")

    def transpile_match(self, expr: SList, is_return: bool):
        """Transpile match expression"""
        scrutinee = self.transpile_expr(expr[1])
        self.emit(f"switch ({scrutinee}.tag) {{")
        self.indent += 1

        for i, clause in enumerate(expr.items[2:]):
            if isinstance(clause, SList) and len(clause) >= 2:
                pattern = clause[0]
                body = clause.items[1:]

                if isinstance(pattern, SList) and len(pattern) >= 1:
                    tag = pattern[0].name
                    var_name = self.to_c_name(pattern[1].name) if len(pattern) > 1 else None

                    self.emit(f"case {i}: {{")
                    self.indent += 1
                    if var_name:
                        self.emit(f"__auto_type {var_name} = {scrutinee}.data.{tag};")
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    if not is_return:
                        self.emit("break;")
                    self.indent -= 1
                    self.emit("}")
                elif isinstance(pattern, Symbol) and pattern.name == '_':
                    # Wildcard/default case
                    self.emit("default: {")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    if not is_return:
                        self.emit("break;")
                    self.indent -= 1
                    self.emit("}")

        self.indent -= 1
        self.emit("}")

    def transpile_cond(self, expr: SList, is_return: bool):
        """Transpile cond expression"""
        first = True
        for clause in expr.items[1:]:
            if isinstance(clause, SList) and len(clause) >= 2:
                test = clause[0]
                body = clause.items[1:]

                if isinstance(test, Symbol) and test.name == 'else':
                    self.emit("} else {")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    self.indent -= 1
                else:
                    cond = self.transpile_expr(test)
                    if first:
                        self.emit(f"if ({cond}) {{")
                        first = False
                    else:
                        self.emit(f"}} else if ({cond}) {{")
                    self.indent += 1
                    for j, item in enumerate(body):
                        is_last = (j == len(body) - 1)
                        self.transpile_statement(item, is_return and is_last)
                    self.indent -= 1
        self.emit("}")

    def transpile_try(self, expr: SList, is_return: bool):
        """Transpile try/catch: (try expr (catch pattern body))"""
        try_expr = self.transpile_expr(expr[1])
        self.emit("{")
        self.indent += 1
        self.emit(f"__auto_type _result = {try_expr};")
        self.emit("if (_result.tag != 0) {")
        self.indent += 1

        # Handle catch clause
        if len(expr) > 2 and is_form(expr[2], 'catch'):
            catch_clause = expr[2]
            pattern = catch_clause[1] if len(catch_clause) > 1 else None
            catch_body = catch_clause.items[2:]

            if pattern and isinstance(pattern, Symbol):
                var_name = self.to_c_name(pattern.name)
                self.emit(f"__auto_type {var_name} = _result.data.err;")

            for j, item in enumerate(catch_body):
                is_last = (j == len(catch_body) - 1)
                self.transpile_statement(item, is_return and is_last)

        self.indent -= 1
        self.emit("}")
        self.indent -= 1
        self.emit("}")

    def transpile_with_arena(self, expr: SList, is_return: bool):
        """Transpile with-arena: (with-arena size body)"""
        size = self.transpile_expr(expr[1])
        self.emit("{")
        self.indent += 1
        self.emit(f"slop_arena* arena = slop_arena_new({size});")

        for j, item in enumerate(expr.items[2:]):
            is_last = (j == len(expr.items) - 3)
            self.transpile_statement(item, is_return and is_last)

        self.emit("slop_arena_free(arena);")
        self.indent -= 1
        self.emit("}")

    def transpile_expr(self, expr: SExpr) -> str:
        """Transpile expression to C"""
        if isinstance(expr, Number):
            return str(expr.value)
        
        if isinstance(expr, String):
            return f'SLOP_STR("{expr.value}")'
        
        if isinstance(expr, Symbol):
            name = expr.name
            if name == 'nil':
                return 'NULL'
            if name == 'true':
                return '1'
            if name == 'false':
                return '0'
            if name.startswith("'"):
                # Enum value - look up qualified name
                enum_val = name[1:]
                if enum_val in self.enums:
                    return self.enums[enum_val]
                return self.to_c_name(enum_val)
            # Check if it's an enum value without quote
            if name in self.enums:
                return self.enums[name]
            return self.to_c_name(name)
        
        if isinstance(expr, SList):
            if len(expr) == 0:
                return "NULL"
            
            head = expr[0]
            if isinstance(head, Symbol):
                op = head.name
                
                # Arithmetic/comparison operators
                if op in ['+', '-', '*', '/', '%', '&', '|', '^', '<<', '>>']:
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} {op} {b})"
                
                if op == '==':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} == {b})"
                
                if op == '!=':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} != {b})"
                
                if op in ['<', '<=', '>', '>=']:
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} {op} {b})"
                
                if op == 'and':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} && {b})"
                
                if op == 'or':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"({a} || {b})"
                
                if op == 'not':
                    a = self.transpile_expr(expr[1])
                    return f"(!{a})"
                
                # Field access
                if op == '.':
                    obj = self.transpile_expr(expr[1])
                    field = self.to_c_name(expr[2].name)
                    return f"{obj}->{field}"
                
                # Index access
                if op == '@':
                    arr = self.transpile_expr(expr[1])
                    idx = self.transpile_expr(expr[2])
                    return f"{arr}[{idx}]"
                
                # Built-in functions
                if op == 'arena-alloc':
                    arena = self.transpile_expr(expr[1])
                    size = self.transpile_expr(expr[2])
                    return f"slop_arena_alloc({arena}, {size})"
                
                if op == 'sizeof':
                    type_name = expr[1].name
                    return f"sizeof({type_name})"
                
                if op == 'now-ms':
                    return "slop_now_ms()"
                
                if op == 'min':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"(({a}) < ({b}) ? ({a}) : ({b}))"
                
                if op == 'max':
                    a = self.transpile_expr(expr[1])
                    b = self.transpile_expr(expr[2])
                    return f"(({a}) > ({b}) ? ({a}) : ({b}))"

                # Error handling
                if op == 'ok':
                    val = self.transpile_expr(expr[1])
                    return f"((typeof(_result)){{ .tag = 0, .data.ok = {val} }})"

                if op == 'error':
                    val = self.transpile_expr(expr[1])
                    return f"((typeof(_result)){{ .tag = 1, .data.err = {val} }})"

                if op == '?':
                    # Early return on error
                    val = self.transpile_expr(expr[1])
                    return f"({{ __auto_type _tmp = {val}; if (_tmp.tag != 0) return _tmp; _tmp.data.ok; }})"

                if op == 'is-ok':
                    val = self.transpile_expr(expr[1])
                    return f"({val}.tag == 0)"

                if op == 'unwrap':
                    val = self.transpile_expr(expr[1])
                    return f"({val}.data.ok)"

                # Memory management
                if op == 'arena-new':
                    size = self.transpile_expr(expr[1])
                    return f"slop_arena_new({size})"

                if op == 'arena-free':
                    arena = self.transpile_expr(expr[1])
                    return f"slop_arena_free({arena})"

                # I/O
                if op == 'println':
                    arg = self.transpile_expr(expr[1])
                    return f'printf("%s\\n", ({arg}).data)'

                if op == 'print':
                    arg = self.transpile_expr(expr[1])
                    return f'printf("%s", ({arg}).data)'

                # Data construction
                if op == 'list':
                    elements = [self.transpile_expr(e) for e in expr.items[1:]]
                    n = len(elements)
                    if n == 0:
                        return "(slop_list){ .data = NULL, .len = 0, .cap = 0 }"
                    elems_str = ", ".join(elements)
                    return f"(slop_list){{ .data = (void*[]){{{elems_str}}}, .len = {n}, .cap = {n} }}"

                if op == 'array':
                    elements = [self.transpile_expr(e) for e in expr.items[1:]]
                    elems_str = ", ".join(elements)
                    return f"{{{elems_str}}}"

                if op == 'put':
                    # Functional update: (put expr field value)
                    obj = self.transpile_expr(expr[1])
                    field = self.to_c_name(expr[2].name)
                    value = self.transpile_expr(expr[3])
                    return f"({{ __auto_type _tmp = {obj}; _tmp.{field} = {value}; _tmp; }})"

                # Quote (enum value)
                if op == 'quote':
                    inner = expr[1]
                    if isinstance(inner, Symbol):
                        if inner.name in self.enums:
                            return self.enums[inner.name]
                        return self.to_c_name(inner.name)
                    return self.transpile_expr(inner)

                # Function call
                fn_name = self.to_c_name(op)
                args = [self.transpile_expr(a) for a in expr.items[1:]]
                return f"{fn_name}({', '.join(args)})"
        
        return "/* unknown */"
    
    def to_c_type(self, type_expr: SExpr) -> str:
        """Convert SLOP type to C type"""
        if isinstance(type_expr, Symbol):
            name = type_expr.name
            if name in self.builtin_types:
                return self.builtin_types[name]
            if name in self.types:
                return self.types[name].c_type
            return name
        
        if isinstance(type_expr, SList) and len(type_expr) >= 1:
            head = type_expr[0].name
            
            if head == 'Ptr':
                inner = self.to_c_type(type_expr[1])
                return f"{inner}*"
            
            if head == 'Option':
                inner = self.to_c_type(type_expr[1])
                return f"slop_option_{inner}"
            
            if head == 'Result':
                ok_type = self.to_c_type(type_expr[1])
                err_type = self.to_c_type(type_expr[2]) if len(type_expr) > 2 else 'slop_error'
                return f"slop_result_{ok_type}_{err_type}"
            
            if head == 'List':
                inner = self.to_c_type(type_expr[1])
                return f"slop_list_{inner}"
            
            if head in self.builtin_types:
                return self.builtin_types[head]
            
            # Range type reference
            if head in self.types:
                return self.types[head].c_type
        
        return "void*"
    
    def to_c_name(self, name: str) -> str:
        """Convert SLOP identifier to valid C name"""
        return name.replace('-', '_').replace('?', '_p').replace('!', '_x')
    
    def expr_to_str(self, expr: SExpr) -> str:
        """Convert expression to string for error messages"""
        return str(expr).replace('"', '\\"')


def transpile(source: str) -> str:
    """Transpile SLOP source to C"""
    ast = parse(source)
    return Transpiler().transpile(ast)


def transpile_file(input_path: str, output_path: str = None):
    """Transpile SLOP file to C file"""
    with open(input_path) as f:
        source = f.read()
    
    c_code = transpile(source)
    
    if output_path:
        with open(output_path, 'w') as f:
            f.write(c_code)
    else:
        print(c_code)


if __name__ == '__main__':
    import sys
    if len(sys.argv) > 1:
        transpile_file(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else None)
    else:
        # Test
        test = '''
        (type Age (Int 0 .. 150))
        (type User (record (name String) (age Age)))
        (type Status (enum active inactive))
        
        (fn greet ((name String))
          (@intent "Say hello")
          (@spec ((String) -> String))
          (@pre (!= name nil))
          (concat "Hello, " name))
        '''
        print(transpile(test))
